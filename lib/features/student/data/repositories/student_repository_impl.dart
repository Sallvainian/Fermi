/// Concrete implementation of the student repository.
/// 
/// This module implements the StudentRepository interface using
/// Firebase Firestore as the data source. It provides comprehensive
/// student management functionality with enrollment tracking
/// and performance analytics.
library;

import 'package:cloud_firestore/cloud_firestore.dart';
import '../../domain/models/student.dart';
import '../../../grades/domain/models/grade.dart';
import '../../../../shared/services/firestore_service.dart';
import '../../../../shared/services/logger_service.dart';
import '../../domain/repositories/student_repository.dart';
import '../../../../shared/repositories/firestore_repository.dart';

/// Firestore-based implementation of StudentRepository.
/// 
/// This class extends FirestoreRepository to leverage common
/// CRUD operations while implementing student-specific features:
/// - Multi-class enrollment management
/// - Grade level organization and filtering
/// - Parent-student relationship tracking
/// - Academic performance statistics
/// - Batch operations for bulk enrollment
/// - Full-text search across student profiles
/// 
/// All operations include comprehensive logging and automatic
/// timestamp management for audit trails.
class StudentRepositoryImpl extends FirestoreRepository<Student> implements StudentRepository {
  /// Logger tag for this repository.
  static const String _tag = 'StudentRepository';
  
  /// Firestore instance for direct database operations.
  final FirebaseFirestore _firestore;

  /// Creates a student repository with Firestore backend.
  /// 
  /// Initializes the parent FirestoreRepository with student-specific
  /// configuration including collection path and serialization functions.
  /// 
  /// @param _firestore Firestore database instance
  StudentRepositoryImpl(this._firestore)
      : super(
          firestore: _firestore,
          collectionPath: 'students',
          fromFirestore: (doc) => Student.fromFirestore(doc),
          toFirestore: (student) => student.toFirestore(),
          logTag: _tag,
        );

  /// Creates a new student profile with timestamps.
  /// 
  /// Automatically sets creation and update timestamps.
  /// The student ID is generated by Firestore for uniqueness.
  /// 
  /// @param student Student model with profile data
  /// @return Generated unique student ID
  /// @throws Exception if creation fails
  @override
  Future<String> createStudent(Student student) async {
    try {
      // Update timestamp
      final studentToCreate = student.copyWith(
        createdAt: DateTime.now(),
        updatedAt: DateTime.now(),
      );
      return await create(studentToCreate);
    } catch (e) {
      LoggerService.error('Failed to create student', tag: _tag, error: e);
      rethrow;
    }
  }

  /// Retrieves a student by their unique identifier.
  /// 
  /// Delegates to parent repository for consistent error handling.
  /// 
  /// @param id Unique student identifier
  /// @return Student instance or null if not found
  @override
  Future<Student?> getStudent(String id) => read(id);

  /// Retrieves a student by their authentication user ID.
  /// 
  /// Maps from Firebase Auth user ID to student profile.
  /// Uses limit 1 for efficiency since userId should be unique.
  /// Useful for post-login profile loading.
  /// 
  /// @param userId Authentication user identifier
  /// @return Student instance or null if not found
  /// @throws Exception if retrieval fails
  @override
  Future<Student?> getStudentByUserId(String userId) async {
    try {
      final students = await list(
        conditions: [
          QueryCondition(field: 'userId', isEqualTo: userId),
        ],
        limit: 1,
      );
      return students.isEmpty ? null : students.first;
    } catch (e) {
      LoggerService.error('Failed to get student by user ID', tag: _tag, error: e);
      rethrow;
    }
  }

  /// Updates an existing student profile.
  /// 
  /// Automatically updates the modification timestamp.
  /// Preserves immutable fields like creation date.
  /// 
  /// @param id Student ID to update
  /// @param student Updated student information
  /// @throws Exception if update fails
  @override
  Future<void> updateStudent(String id, Student student) async {
    try {
      // Update timestamp
      final studentToUpdate = student.copyWith(
        updatedAt: DateTime.now(),
      );
      await update(id, studentToUpdate);
    } catch (e) {
      LoggerService.error('Failed to update student', tag: _tag, error: e);
      rethrow;
    }
  }

  /// Permanently deletes a student profile.
  /// 
  /// This operation cannot be undone. Consider soft deletion
  /// by setting isActive to false for recoverable removal.
  /// 
  /// @param id Student ID to delete
  /// @throws Exception if deletion fails
  @override
  Future<void> deleteStudent(String id) => delete(id);

  /// Enrolls a student in a specific class.
  /// 
  /// Uses Firestore's arrayUnion to safely add the class ID
  /// without duplicates. Updates modification timestamp using
  /// server time for consistency.
  /// 
  /// Note: Should also update the class's student roster for
  /// bidirectional relationship.
  /// 
  /// @param studentId Student to enroll
  /// @param classId Target class identifier
  /// @throws Exception if enrollment fails
  @override
  Future<void> enrollInClass(String studentId, String classId) async {
    try {
      await _firestore.collection('students').doc(studentId).update({
        'classIds': FieldValue.arrayUnion([classId]),
        'updatedAt': FieldValue.serverTimestamp(),
      });
      LoggerService.info('Student $studentId enrolled in class $classId', tag: _tag);
    } catch (e) {
      LoggerService.error('Failed to enroll student in class', tag: _tag, error: e);
      rethrow;
    }
  }

  /// Removes a student from a class enrollment.
  /// 
  /// Uses Firestore's arrayRemove to safely remove the class ID.
  /// Updates modification timestamp for audit trail.
  /// 
  /// Note: Should also update the class's student roster.
  /// 
  /// @param studentId Student to unenroll
  /// @param classId Class to remove from
  /// @throws Exception if unenrollment fails
  @override
  Future<void> unenrollFromClass(String studentId, String classId) async {
    try {
      await _firestore.collection('students').doc(studentId).update({
        'classIds': FieldValue.arrayRemove([classId]),
        'updatedAt': FieldValue.serverTimestamp(),
      });
      LoggerService.info('Student $studentId unenrolled from class $classId', tag: _tag);
    } catch (e) {
      LoggerService.error('Failed to unenroll student from class', tag: _tag, error: e);
      rethrow;
    }
  }

  /// Enrolls a student in multiple classes at once.
  /// 
  /// Efficient batch enrollment for term registration.
  /// Uses arrayUnion to add all class IDs without duplicates
  /// in a single operation.
  /// 
  /// Note: Consider updating each class's roster in batch.
  /// 
  /// @param studentId Student to enroll
  /// @param classIds List of class identifiers
  /// @throws Exception if batch enrollment fails
  @override
  Future<void> enrollInMultipleClasses(String studentId, List<String> classIds) async {
    try {
      await _firestore.collection('students').doc(studentId).update({
        'classIds': FieldValue.arrayUnion(classIds),
        'updatedAt': FieldValue.serverTimestamp(),
      });
      LoggerService.info('Student $studentId enrolled in ${classIds.length} classes', tag: _tag);
    } catch (e) {
      LoggerService.error('Failed to enroll student in multiple classes', tag: _tag, error: e);
      rethrow;
    }
  }

  /// Streams all active students enrolled in a specific class.
  /// 
  /// Filters by class enrollment and active status, ordered
  /// alphabetically by last name then first name for consistent
  /// display in class rosters.
  /// 
  /// @param classId Class to get students from
  /// @return Stream of enrolled student lists
  @override
  Stream<List<Student>> getClassStudents(String classId) {
    return stream(
      conditions: [
        QueryCondition(field: 'classIds', arrayContains: classId),
        QueryCondition(field: 'isActive', isEqualTo: true),
      ],
      orderBy: [OrderBy(field: 'lastName'), OrderBy(field: 'firstName')],
    );
  }

  /// Streams all active students in the system.
  /// 
  /// Returns only students with active enrollment status,
  /// excluding graduated, suspended, or inactive students.
  /// Ordered alphabetically for easy browsing.
  /// 
  /// @return Stream of active student lists
  @override
  Stream<List<Student>> getActiveStudents() {
    return stream(
      conditions: [
        QueryCondition(field: 'isActive', isEqualTo: true),
      ],
      orderBy: [OrderBy(field: 'lastName'), OrderBy(field: 'firstName')],
    );
  }

  /// Streams active students by their grade level.
  /// 
  /// Useful for grade-specific activities, communications,
  /// and curriculum planning. Only includes active students.
  /// 
  /// @param gradeLevel Grade level to filter by (e.g., 9 for 9th grade)
  /// @return Stream of students in that grade
  @override
  Stream<List<Student>> getStudentsByGradeLevel(int gradeLevel) {
    return stream(
      conditions: [
        QueryCondition(field: 'gradeLevel', isEqualTo: gradeLevel),
        QueryCondition(field: 'isActive', isEqualTo: true),
      ],
      orderBy: [OrderBy(field: 'lastName'), OrderBy(field: 'firstName')],
    );
  }

  /// Searches for students by name or email.
  /// 
  /// Performs client-side text search across multiple fields:
  /// - First name
  /// - Last name
  /// - Email address
  /// - Display name
  /// 
  /// This is a basic implementation that loads all active students.
  /// For production with large datasets, consider:
  /// - Server-side search with Firestore composite indexes
  /// - External search services (Algolia, Elasticsearch)
  /// - Pagination for large result sets
  /// 
  /// @param query Search terms (case-insensitive)
  /// @return List of matching students
  /// @throws Exception if search fails
  @override
  Future<List<Student>> searchStudents(String query) async {
    try {
      final lowercaseQuery = query.toLowerCase();
      
      // This is a simple implementation. For better search, consider using
      // a search service like Algolia or implementing full-text search
      final allStudents = await list(
        conditions: [
          QueryCondition(field: 'isActive', isEqualTo: true),
        ],
      );
      
      return allStudents.where((student) {
        return student.firstName.toLowerCase().contains(lowercaseQuery) ||
               student.lastName.toLowerCase().contains(lowercaseQuery) ||
               (student.email?.toLowerCase().contains(lowercaseQuery) ?? false) ||
               student.displayName.toLowerCase().contains(lowercaseQuery);
      }).toList();
    } catch (e) {
      LoggerService.error('Failed to search students', tag: _tag, error: e);
      rethrow;
    }
  }

  /// Calculates overall academic statistics for a student.
  /// 
  /// Aggregates all graded and returned grades across all classes:
  /// - Overall average/GPA
  /// - Total assignments completed
  /// - Grade distribution
  /// - Performance trends
  /// 
  /// Only includes finalized grades (graded or returned status).
  /// Returns null if no grades found.
  /// 
  /// @param studentId Student to analyze
  /// @return Overall grade statistics or null
  /// @throws Exception if calculation fails
  @override
  Future<GradeStatistics?> getStudentOverallStatistics(String studentId) async {
    try {
      final gradesSnapshot = await _firestore
          .collection('grades')
          .where('studentId', isEqualTo: studentId)
          .where('status', whereIn: [
            GradeStatus.graded.name,
            GradeStatus.returned.name,
          ])
          .get();
      
      if (gradesSnapshot.docs.isEmpty) return null;
      
      final grades = gradesSnapshot.docs
          .map((doc) => Grade.fromFirestore(doc))
          .toList();
      
      return GradeStatistics.fromGrades(grades);
    } catch (e) {
      LoggerService.error('Failed to get student overall statistics', tag: _tag, error: e);
      rethrow;
    }
  }

  /// Gets grade statistics broken down by class.
  /// 
  /// Process:
  /// 1. Fetches all finalized grades for the student
  /// 2. Groups grades by class ID
  /// 3. Calculates statistics for each class separately
  /// 
  /// Useful for:
  /// - Identifying strong/weak subjects
  /// - Class-specific progress reports
  /// - Parent-teacher conferences
  /// 
  /// @param studentId Student to analyze
  /// @return Map of class ID to grade statistics
  /// @throws Exception if calculation fails
  @override
  Future<Map<String, GradeStatistics>> getStudentStatisticsByClass(String studentId) async {
    try {
      final gradesSnapshot = await _firestore
          .collection('grades')
          .where('studentId', isEqualTo: studentId)
          .where('status', whereIn: [
            GradeStatus.graded.name,
            GradeStatus.returned.name,
          ])
          .get();
      
      if (gradesSnapshot.docs.isEmpty) return {};
      
      final grades = gradesSnapshot.docs
          .map((doc) => Grade.fromFirestore(doc))
          .toList();
      
      // Group grades by class
      final gradesByClass = <String, List<Grade>>{};
      for (final grade in grades) {
        gradesByClass.putIfAbsent(grade.classId, () => []).add(grade);
      }
      
      // Calculate statistics for each class
      final statisticsByClass = <String, GradeStatistics>{};
      gradesByClass.forEach((classId, classGrades) {
        statisticsByClass[classId] = GradeStatistics.fromGrades(classGrades);
      });
      
      return statisticsByClass;
    } catch (e) {
      LoggerService.error('Failed to get student statistics by class', tag: _tag, error: e);
      rethrow;
    }
  }

  /// Streams all active students associated with a parent email.
  /// 
  /// Returns children linked to a parent account for family
  /// portal access. Only includes active students.
  /// 
  /// @param parentEmail Parent's email address
  /// @return Stream of associated student lists
  @override
  Stream<List<Student>> getStudentsByParentEmail(String parentEmail) {
    return stream(
      conditions: [
        QueryCondition(field: 'parentEmail', isEqualTo: parentEmail),
        QueryCondition(field: 'isActive', isEqualTo: true),
      ],
      orderBy: [OrderBy(field: 'lastName'), OrderBy(field: 'firstName')],
    );
  }

  /// Creates multiple student profiles in one atomic operation.
  /// 
  /// Efficient bulk import for:
  /// - New academic year enrollment
  /// - School transfers
  /// - System migration
  /// 
  /// Process:
  /// 1. Generates unique IDs for each student
  /// 2. Sets consistent timestamps
  /// 3. Commits all creates atomically
  /// 
  /// All creates succeed or fail together.
  /// 
  /// @param students List of student profiles to create
  /// @throws Exception if batch creation fails
  @override
  Future<void> batchCreateStudents(List<Student> students) async {
    try {
      final batch = _firestore.batch();
      final now = DateTime.now();
      
      for (final student in students) {
        final ref = _firestore.collection('students').doc();
        final studentToCreate = student.copyWith(
          id: ref.id,
          createdAt: now,
          updatedAt: now,
        );
        batch.set(ref, studentToCreate.toFirestore());
      }
      
      await batch.commit();
      LoggerService.info('Batch created ${students.length} students', tag: _tag);
    } catch (e) {
      LoggerService.error('Failed to batch create students', tag: _tag, error: e);
      rethrow;
    }
  }

  /// Updates multiple student profiles in one atomic operation.
  /// 
  /// Efficient bulk update for:
  /// - Grade level promotion
  /// - Mass status changes
  /// - Bulk data corrections
  /// 
  /// All updates use the same timestamp for consistency.
  /// Operations are atomic - all succeed or fail together.
  /// 
  /// @param students Map of student IDs to updated profiles
  /// @throws Exception if batch update fails
  @override
  Future<void> batchUpdateStudents(Map<String, Student> students) async {
    try {
      final batch = _firestore.batch();
      final now = DateTime.now();
      
      students.forEach((studentId, student) {
        final ref = _firestore.collection('students').doc(studentId);
        final studentToUpdate = student.copyWith(
          updatedAt: now,
        );
        batch.update(ref, studentToUpdate.toFirestore());
      });
      
      await batch.commit();
      LoggerService.info('Batch updated ${students.length} students', tag: _tag);
    } catch (e) {
      LoggerService.error('Failed to batch update students', tag: _tag, error: e);
      rethrow;
    }
  }

  /// Checks if an email address is available for registration.
  /// 
  /// Queries for existing students with the same email.
  /// Returns true only if no matches found.
  /// 
  /// Used during student registration to prevent duplicates.
  /// 
  /// @param email Email address to check
  /// @return true if available, false if taken
  /// @throws Exception if check fails
  @override
  Future<bool> isEmailAvailable(String email) async {
    try {
      final existing = await list(
        conditions: [
          QueryCondition(field: 'email', isEqualTo: email),
        ],
        limit: 1,
      );
      return existing.isEmpty;
    } catch (e) {
      LoggerService.error('Failed to check email availability', tag: _tag, error: e);
      rethrow;
    }
  }

  /// Verifies if a student is enrolled in a specific class.
  /// 
  /// Efficient enrollment check by loading the student profile
  /// and checking the classIds array. Returns false if student
  /// doesn't exist.
  /// 
  /// @param studentId Student to check
  /// @param classId Class to verify enrollment in
  /// @return true if enrolled, false otherwise
  /// @throws Exception if verification fails
  @override
  Future<bool> isStudentEnrolledInClass(String studentId, String classId) async {
    try {
      final student = await read(studentId);
      return student?.classIds.contains(classId) ?? false;
    } catch (e) {
      LoggerService.error('Failed to check student enrollment', tag: _tag, error: e);
      rethrow;
    }
  }
}