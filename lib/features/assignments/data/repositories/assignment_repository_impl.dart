/// Concrete implementation of the assignment repository.
///
/// This module implements the AssignmentRepository interface using
/// Firebase Firestore as the data source. It provides comprehensive
/// assignment management functionality with status workflows
/// and statistical analysis.
library;

import 'package:cloud_firestore/cloud_firestore.dart';
import '../../domain/models/assignment.dart';
import '../../../../shared/services/firestore_service.dart';
import '../../../../shared/services/logger_service.dart';
import '../../domain/repositories/assignment_repository.dart';
import '../../../../shared/repositories/firestore_repository.dart';

/// Firestore-based implementation of AssignmentRepository.
///
/// This class extends FirestoreRepository to leverage common
/// CRUD operations while implementing assignment-specific features:
/// - Status workflow management (draft, active, completed, archived)
/// - Publishing and unpublishing controls
/// - Due date tracking and overdue detection
/// - Multi-class assignment streaming
/// - Statistical analysis for dashboards
/// - Automatic timestamp management
///
/// All operations include comprehensive logging for debugging
/// and audit trail purposes.
class AssignmentRepositoryImpl extends FirestoreRepository<Assignment>
    implements AssignmentRepository {
  /// Creates an assignment repository with Firestore backend.
  ///
  /// Initializes the parent FirestoreRepository with assignment-specific
  /// configuration including collection path and serialization functions.
  ///
  /// @param firestore Firestore database instance
  AssignmentRepositoryImpl(FirebaseFirestore firestore)
      : super(
          firestore: firestore,
          collectionPath: 'assignments',
          fromFirestore: (doc) => Assignment.fromFirestore(doc),
          toFirestore: (assignment) => assignment.toFirestore(),
          logTag: 'AssignmentRepository',
        );

  /// Creates a new assignment with automatic timestamps.
  ///
  /// Sets both creation and update timestamps to current time.
  /// The assignment ID is generated by Firestore for uniqueness.
  /// New assignments start in draft status by default.
  ///
  /// @param assignment Assignment model with content and settings
  /// @return Generated unique assignment ID
  /// @throws Exception if creation fails
  @override
  Future<String> createAssignment(Assignment assignment) async {
    try {
      final assignmentWithTimestamp = assignment.copyWith(
        createdAt: DateTime.now(),
        updatedAt: DateTime.now(),
      );
      return await create(assignmentWithTimestamp);
    } catch (e) {
      LoggerService.error('Failed to create assignment', tag: tag, error: e);
      rethrow;
    }
  }

  /// Retrieves an assignment by its unique identifier.
  ///
  /// Delegates to parent repository for consistent error handling.
  ///
  /// @param assignmentId Unique assignment identifier
  /// @return Assignment instance or null if not found
  @override
  Future<Assignment?> getAssignment(String assignmentId) => read(assignmentId);

  /// Updates an existing assignment with new timestamp.
  ///
  /// Automatically updates the modification timestamp while
  /// preserving the assignment ID and creation date.
  ///
  /// @param assignmentId ID of assignment to update
  /// @param assignment Updated assignment information
  /// @throws Exception if update fails
  @override
  Future<void> updateAssignment(
      String assignmentId, Assignment assignment) async {
    try {
      final updatedAssignment = assignment.copyWith(
        id: assignmentId,
        updatedAt: DateTime.now(),
      );
      await update(assignmentId, updatedAssignment);
    } catch (e) {
      LoggerService.error('Failed to update assignment', tag: tag, error: e);
      rethrow;
    }
  }

  /// Permanently deletes an assignment.
  ///
  /// This operation cannot be undone. Consider archiving
  /// for recoverable removal.
  ///
  /// @param assignmentId ID of assignment to delete
  /// @throws Exception if deletion fails
  @override
  Future<void> deleteAssignment(String assignmentId) => delete(assignmentId);

  /// Streams all assignments for a specific class.
  ///
  /// Returns real-time updates ordered by creation date,
  /// most recent first. Includes all assignment statuses.
  ///
  /// @param classId Class to get assignments from
  /// @return Stream of assignment lists
  @override
  Stream<List<Assignment>> getClassAssignments(String classId) {
    LoggerService.info('Querying assignments for classId: $classId', tag: tag);
    return stream(
      conditions: [
        QueryCondition(field: 'classId', isEqualTo: classId),
      ],
      orderBy: [
        OrderBy(field: 'createdAt', descending: true),
      ],
    );
  }

  /// Streams all assignments created by a teacher.
  ///
  /// Returns comprehensive assignment list across all classes
  /// taught by the teacher, ordered by most recent first.
  ///
  /// @param teacherId Teacher's unique identifier
  /// @return Stream of teacher's assignments
  @override
  Stream<List<Assignment>> getTeacherAssignments(String teacherId) {
    LoggerService.info('Querying assignments for teacherId: $teacherId', tag: tag);
    return stream(
      conditions: [
        QueryCondition(field: 'teacherId', isEqualTo: teacherId),
      ],
      orderBy: [
        OrderBy(field: 'createdAt', descending: true),
      ],
    );
  }

  /// Streams assignments for multiple classes.
  ///
  /// Efficient query for students enrolled in multiple classes.
  /// Returns assignments ordered by due date (earliest first)
  /// to help prioritize work.
  ///
  /// @param classIds List of class identifiers
  /// @return Stream of assignments from all specified classes
  @override
  Stream<List<Assignment>> getClassAssignmentsForMultipleClasses(
      List<String> classIds) {
    if (classIds.isEmpty) {
      return Stream.value([]);
    }

    return stream(
      conditions: [
        QueryCondition(field: 'classId', whereIn: classIds),
      ],
      orderBy: [
        OrderBy(field: 'dueDate', descending: false),
      ],
    );
  }

  /// Gets upcoming assignments for a class.
  ///
  /// Filters to show only:
  /// - Published assignments
  /// - Active status
  /// - Due date in the future
  ///
  /// Ordered by due date (soonest first) for priority display.
  ///
  /// @param classId Class to query
  /// @param limit Maximum assignments to return (default: 5)
  /// @return List of upcoming assignments
  /// @throws Exception if query fails
  @override
  Future<List<Assignment>> getUpcomingAssignments(String classId,
      {int limit = 5}) async {
    final now = DateTime.now();
    return await list(
      conditions: [
        QueryCondition(field: 'classId', isEqualTo: classId),
        QueryCondition(
            field: 'dueDate', isGreaterThan: Timestamp.fromDate(now)),
        QueryCondition(field: 'isPublished', isEqualTo: true),
        QueryCondition(field: 'status', isEqualTo: 'active'),
      ],
      orderBy: [
        OrderBy(field: 'dueDate', descending: false),
      ],
      limit: limit,
    );
  }

  /// Gets overdue assignments for a class.
  ///
  /// Filters to show only:
  /// - Published assignments
  /// - Active status
  /// - Due date in the past
  ///
  /// Ordered by due date (most recent first) to show
  /// assignments that just became overdue.
  ///
  /// @param classId Class to query
  /// @return List of overdue assignments
  /// @throws Exception if query fails
  @override
  Future<List<Assignment>> getOverdueAssignments(String classId) async {
    final now = DateTime.now();
    return await list(
      conditions: [
        QueryCondition(field: 'classId', isEqualTo: classId),
        QueryCondition(field: 'dueDate', isLessThan: Timestamp.fromDate(now)),
        QueryCondition(field: 'isPublished', isEqualTo: true),
        QueryCondition(field: 'status', isEqualTo: 'active'),
      ],
      orderBy: [
        OrderBy(field: 'dueDate', descending: true),
      ],
    );
  }

  /// Publishes an assignment to make it visible to students.
  ///
  /// Updates:
  /// - isPublished flag to true
  /// - Status to 'active'
  /// - Update timestamp
  ///
  /// Published assignments appear in student dashboards
  /// and accept submissions.
  ///
  /// @param assignmentId Assignment to publish
  /// @throws Exception if publishing fails
  @override
  Future<void> publishAssignment(String assignmentId) async {
    try {
      final assignment = await getAssignment(assignmentId);
      if (assignment != null) {
        final published = assignment.copyWith(
          isPublished: true,
          status: AssignmentStatus.active,
          updatedAt: DateTime.now(),
        );
        await update(assignmentId, published);
      }
    } catch (e) {
      LoggerService.error('Failed to publish assignment', tag: tag, error: e);
      rethrow;
    }
  }

  /// Archives an assignment to hide it from active lists.
  ///
  /// Archived assignments:
  /// - No longer accept submissions
  /// - Hidden from student views
  /// - Preserved for historical records
  /// - Can be restored later
  ///
  /// @param assignmentId Assignment to archive
  /// @throws Exception if archiving fails
  @override
  Future<void> archiveAssignment(String assignmentId) async {
    try {
      final assignment = await getAssignment(assignmentId);
      if (assignment != null) {
        final archived = assignment.copyWith(
          status: AssignmentStatus.archived,
          updatedAt: DateTime.now(),
        );
        await update(assignmentId, archived);
      }
    } catch (e) {
      LoggerService.error('Failed to archive assignment', tag: tag, error: e);
      rethrow;
    }
  }

  /// Unpublishes an assignment to hide it from students.
  ///
  /// Updates:
  /// - isPublished flag to false
  /// - Status back to 'draft'
  /// - Update timestamp
  ///
  /// Useful for corrections before re-publishing.
  ///
  /// @param assignmentId Assignment to unpublish
  /// @throws Exception if unpublishing fails
  @override
  Future<void> unpublishAssignment(String assignmentId) async {
    try {
      final assignment = await getAssignment(assignmentId);
      if (assignment != null) {
        final unpublished = assignment.copyWith(
          isPublished: false,
          status: AssignmentStatus.draft,
          updatedAt: DateTime.now(),
        );
        await update(assignmentId, unpublished);
      }
    } catch (e) {
      LoggerService.error('Failed to unpublish assignment', tag: tag, error: e);
      rethrow;
    }
  }

  /// Restores an archived assignment to draft status.
  ///
  /// Allows reactivation of archived assignments for:
  /// - Reuse in new terms
  /// - Template creation
  /// - Error correction
  ///
  /// Restored assignments must be republished to
  /// become visible to students again.
  ///
  /// @param assignmentId Assignment to restore
  /// @throws Exception if restoration fails
  @override
  Future<void> restoreAssignment(String assignmentId) async {
    try {
      final assignment = await getAssignment(assignmentId);
      if (assignment != null) {
        final restored = assignment.copyWith(
          status: AssignmentStatus.draft,
          updatedAt: DateTime.now(),
        );
        await update(assignmentId, restored);
      }
    } catch (e) {
      LoggerService.error('Failed to restore assignment', tag: tag, error: e);
      rethrow;
    }
  }

  /// Calculates comprehensive statistics for a class's assignments.
  ///
  /// Aggregates assignment data to provide insights:
  /// - Total assignment count
  /// - Active assignments
  /// - Overdue assignments
  /// - Upcoming assignments
  /// - Completed assignments
  /// - Archived assignments
  ///
  /// Useful for teacher dashboards and progress tracking.
  ///
  /// @param classId Class to analyze
  /// @return Map of statistical data
  /// @throws Exception if calculation fails
  @override
  Future<Map<String, dynamic>> getAssignmentStats(String classId) async {
    try {
      final assignments = await list(
        conditions: [
          QueryCondition(field: 'classId', isEqualTo: classId),
        ],
      );

      final now = DateTime.now();
      final total = assignments.length;
      final active =
          assignments.where((a) => a.status == AssignmentStatus.active).length;
      final overdue = assignments
          .where((a) =>
              a.status == AssignmentStatus.active && a.dueDate.isBefore(now))
          .length;
      final upcoming = assignments
          .where((a) =>
              a.status == AssignmentStatus.active && a.dueDate.isAfter(now))
          .length;

      return {
        'total': total,
        'active': active,
        'overdue': overdue,
        'upcoming': upcoming,
        'completed': assignments
            .where((a) => a.status == AssignmentStatus.completed)
            .length,
        'archived': assignments
            .where((a) => a.status == AssignmentStatus.archived)
            .length,
      };
    } catch (e) {
      LoggerService.error('Failed to get assignment stats', tag: tag, error: e);
      rethrow;
    }
  }
}
