/// Concrete implementation of the submission repository.
///
/// This module implements the SubmissionRepository interface using
/// Firebase Firestore as the data source. It provides comprehensive
/// submission management functionality with automatic timestamps
/// and status tracking.
library;

import 'package:cloud_firestore/cloud_firestore.dart';
import '../../domain/models/submission.dart';
import '../../../../shared/services/firestore_service.dart';
import '../../../../shared/services/logger_service.dart';
import '../../domain/repositories/submission_repository.dart';
import '../../../../shared/repositories/firestore_repository.dart';

/// Firestore-based implementation of SubmissionRepository.
///
/// This class extends FirestoreRepository to leverage common
/// CRUD operations while implementing submission-specific features:
/// - Automatic duplicate detection and updates
/// - Text and file submission handling
/// - Status workflow management
/// - Real-time submission streaming
/// - Statistical analysis for completion tracking
/// - Batch operations for bulk updates
///
/// All operations include comprehensive logging and automatic
/// timestamp management for audit trails.
class SubmissionRepositoryImpl extends FirestoreRepository<Submission>
    implements SubmissionRepository {
  /// Logger tag for this repository.
  static const String _tag = 'SubmissionRepository';

  /// Firestore instance for direct database operations.
  final FirebaseFirestore _firestore;

  /// Creates a submission repository with Firestore backend.
  ///
  /// Initializes the parent FirestoreRepository with submission-specific
  /// configuration including collection path and serialization functions.
  ///
  /// @param _firestore Firestore database instance
  SubmissionRepositoryImpl(this._firestore)
      : super(
          firestore: _firestore,
          collectionPath: 'submissions',
          fromFirestore: (doc) => Submission.fromFirestore(doc),
          toFirestore: (submission) => submission.toFirestore(),
          logTag: _tag,
        );

  /// Creates a new submission with automatic timestamps.
  ///
  /// Sets both submission and update timestamps to current time.
  /// The submission ID is generated by Firestore for uniqueness.
  ///
  /// @param submission Submission model with content and metadata
  /// @return Generated unique submission ID
  /// @throws Exception if creation fails
  @override
  Future<String> createSubmission(Submission submission) async {
    try {
      // Update timestamp
      final submissionToCreate = submission.copyWith(
        submittedAt: DateTime.now(),
        updatedAt: DateTime.now(),
      );
      return await create(submissionToCreate);
    } catch (e) {
      LoggerService.error('Failed to create submission', tag: _tag, error: e);
      rethrow;
    }
  }

  /// Retrieves a submission by its unique identifier.
  ///
  /// Delegates to parent repository for consistent error handling.
  ///
  /// @param id Unique submission identifier
  /// @return Submission instance or null if not found
  @override
  Future<Submission?> getSubmission(String id) => read(id);

  /// Retrieves a student's submission for a specific assignment.
  ///
  /// Queries for the unique submission matching both student and
  /// assignment IDs. Uses limit 1 for efficiency since only one
  /// submission should exist per student-assignment pair.
  ///
  /// @param assignmentId Assignment identifier
  /// @param studentId Student identifier
  /// @return Submission instance or null if not submitted
  /// @throws Exception if retrieval fails
  @override
  Future<Submission?> getStudentSubmission(
      String assignmentId, String studentId) async {
    try {
      final submissions = await list(
        conditions: [
          QueryCondition(field: 'assignmentId', isEqualTo: assignmentId),
          QueryCondition(field: 'studentId', isEqualTo: studentId),
        ],
        limit: 1,
      );
      return submissions.isEmpty ? null : submissions.first;
    } catch (e) {
      LoggerService.error('Failed to get student submission',
          tag: _tag, error: e);
      rethrow;
    }
  }

  /// Updates an existing submission with new timestamp.
  ///
  /// Automatically updates the modification timestamp while
  /// preserving other metadata like submission date.
  ///
  /// @param id Submission ID to update
  /// @param submission Updated submission information
  /// @throws Exception if update fails
  @override
  Future<void> updateSubmission(String id, Submission submission) async {
    try {
      // Update timestamp
      final submissionToUpdate = submission.copyWith(
        updatedAt: DateTime.now(),
      );
      await update(id, submissionToUpdate);
    } catch (e) {
      LoggerService.error('Failed to update submission', tag: _tag, error: e);
      rethrow;
    }
  }

  /// Permanently deletes a submission.
  ///
  /// This operation cannot be undone. Consider using status
  /// changes for recoverable operations.
  ///
  /// @param id Submission ID to delete
  /// @throws Exception if deletion fails
  @override
  Future<void> deleteSubmission(String id) => delete(id);

  /// Creates or updates a text-based submission.
  ///
  /// Intelligent submission handling:
  /// - Checks for existing submission to prevent duplicates
  /// - Updates existing submission if found
  /// - Creates new submission if none exists
  ///
  /// This ensures students can resubmit without creating
  /// multiple submission records.
  ///
  /// @param assignmentId Target assignment
  /// @param studentId Submitting student
  /// @param studentName Student's display name
  /// @param textContent Written response content
  /// @return Created or updated submission
  /// @throws Exception if submission fails
  @override
  Future<Submission> submitTextContent({
    required String assignmentId,
    required String studentId,
    required String studentName,
    required String textContent,
  }) async {
    try {
      // Check if submission already exists
      final existing = await getStudentSubmission(assignmentId, studentId);

      if (existing != null) {
        // Update existing submission
        final updated = existing.copyWith(
          textContent: textContent,
          status: SubmissionStatus.submitted,
          submittedAt: DateTime.now(),
          updatedAt: DateTime.now(),
        );
        await updateSubmission(existing.id, updated);
        return updated;
      } else {
        // Create new submission
        final submission = Submission(
          id: '',
          assignmentId: assignmentId,
          studentId: studentId,
          studentName: studentName,
          textContent: textContent,
          status: SubmissionStatus.submitted,
          submittedAt: DateTime.now(),
          updatedAt: DateTime.now(),
        );
        final id = await createSubmission(submission);
        return submission.copyWith(id: id);
      }
    } catch (e) {
      LoggerService.error('Failed to submit text content', tag: _tag, error: e);
      rethrow;
    }
  }

  /// Creates or updates a file-based submission.
  ///
  /// Intelligent submission handling:
  /// - Checks for existing submission to prevent duplicates
  /// - Updates existing submission with new file if found
  /// - Creates new submission if none exists
  ///
  /// File URL should point to pre-uploaded content in
  /// Firebase Storage or other file hosting service.
  ///
  /// @param assignmentId Target assignment
  /// @param studentId Submitting student
  /// @param studentName Student's display name
  /// @param fileUrl URL of uploaded file
  /// @param fileName Original file name for display
  /// @return Created or updated submission
  /// @throws Exception if submission fails
  @override
  Future<Submission> submitFile({
    required String assignmentId,
    required String studentId,
    required String studentName,
    required String fileUrl,
    required String fileName,
  }) async {
    try {
      // Check if submission already exists
      final existing = await getStudentSubmission(assignmentId, studentId);

      if (existing != null) {
        // Update existing submission
        final updated = existing.copyWith(
          fileUrl: fileUrl,
          fileName: fileName,
          status: SubmissionStatus.submitted,
          submittedAt: DateTime.now(),
          updatedAt: DateTime.now(),
        );
        await updateSubmission(existing.id, updated);
        return updated;
      } else {
        // Create new submission
        final submission = Submission(
          id: '',
          assignmentId: assignmentId,
          studentId: studentId,
          studentName: studentName,
          fileUrl: fileUrl,
          fileName: fileName,
          status: SubmissionStatus.submitted,
          submittedAt: DateTime.now(),
          updatedAt: DateTime.now(),
        );
        final id = await createSubmission(submission);
        return submission.copyWith(id: id);
      }
    } catch (e) {
      LoggerService.error('Failed to submit file', tag: _tag, error: e);
      rethrow;
    }
  }

  /// Updates the status of a submission.
  ///
  /// Uses server timestamp for consistency across clients.
  /// Status changes may trigger notifications or other
  /// workflow actions.
  ///
  /// @param id Submission to update
  /// @param status New submission status
  /// @throws Exception if status update fails
  @override
  Future<void> updateSubmissionStatus(
      String id, SubmissionStatus status) async {
    try {
      await _firestore.collection('submissions').doc(id).update({
        'status': status.name,
        'updatedAt': FieldValue.serverTimestamp(),
      });
      LoggerService.info('Updated submission status to ${status.name}',
          tag: _tag);
    } catch (e) {
      LoggerService.error('Failed to update submission status',
          tag: _tag, error: e);
      rethrow;
    }
  }

  /// Streams all submissions for an assignment.
  ///
  /// Returns real-time updates ordered by submission time,
  /// with most recent first. Useful for grading dashboards.
  ///
  /// @param assignmentId Assignment to monitor
  /// @return Stream of submission lists
  @override
  Stream<List<Submission>> getAssignmentSubmissions(String assignmentId) {
    return stream(
      conditions: [
        QueryCondition(field: 'assignmentId', isEqualTo: assignmentId),
      ],
      orderBy: [OrderBy(field: 'submittedAt', descending: true)],
    );
  }

  /// Streams all submissions by a specific student.
  ///
  /// Returns comprehensive submission history ordered by
  /// submission time, most recent first.
  ///
  /// @param studentId Student to monitor
  /// @return Stream of submission lists
  @override
  Stream<List<Submission>> getStudentSubmissions(String studentId) {
    return stream(
      conditions: [
        QueryCondition(field: 'studentId', isEqualTo: studentId),
      ],
      orderBy: [OrderBy(field: 'submittedAt', descending: true)],
    );
  }

  /// Streams submissions for a student in a specific class.
  ///
  /// Note: This implementation currently returns all student
  /// submissions. Filtering by class requires joining with
  /// assignments collection, which should be done in the
  /// provider layer for better performance.
  ///
  /// @param studentId Student to monitor
  /// @param classId Class context (not currently used)
  /// @return Stream of student submissions
  @override
  Stream<List<Submission>> getStudentClassSubmissions(
      String studentId, String classId) {
    // Note: This requires joining with assignments to filter by classId
    // For now, returning student submissions and filtering will be done in the provider
    return getStudentSubmissions(studentId);
  }

  /// Calculates submission statistics for an assignment.
  ///
  /// Aggregates submission data to provide insights:
  /// - Total submissions (currently based on actual submissions)
  /// - Number submitted vs pending
  /// - Number graded
  /// - Submission rate percentage
  /// - Latest submission timestamp
  ///
  /// Note: Total count should ideally come from enrolled
  /// students in the class, requiring a join with classes.
  ///
  /// @param assignmentId Assignment to analyze
  /// @return Statistical summary of submissions
  /// @throws Exception if calculation fails
  @override
  Future<SubmissionStatistics> getAssignmentSubmissionStatistics(
      String assignmentId) async {
    try {
      // Get all submissions for the assignment
      final submissions = await list(
        conditions: [
          QueryCondition(field: 'assignmentId', isEqualTo: assignmentId),
        ],
      );

      // Get total students count from assignment's class
      // This would require joining with assignments and classes
      // For now, we'll use submissions count as total
      final total = submissions.length;
      final submitted = submissions
          .where((s) =>
              s.status == SubmissionStatus.submitted ||
              s.status == SubmissionStatus.graded)
          .length;
      final graded =
          submissions.where((s) => s.status == SubmissionStatus.graded).length;
      final pending = total - submitted;

      DateTime? lastSubmissionAt;
      if (submissions.isNotEmpty) {
        submissions.sort((a, b) => b.submittedAt.compareTo(a.submittedAt));
        lastSubmissionAt = submissions.first.submittedAt;
      }

      return SubmissionStatistics(
        total: total,
        submitted: submitted,
        graded: graded,
        pending: pending,
        submissionRate: total > 0 ? (submitted / total) : 0,
        lastSubmissionAt: lastSubmissionAt,
      );
    } catch (e) {
      LoggerService.error('Failed to get submission statistics',
          tag: _tag, error: e);
      rethrow;
    }
  }

  /// Marks a submission as graded.
  ///
  /// Convenience method that updates status to 'graded'.
  /// Should be called after grade has been recorded.
  ///
  /// @param id Submission to mark as graded
  /// @throws Exception if marking fails
  @override
  Future<void> markAsGraded(String id) async {
    try {
      await updateSubmissionStatus(id, SubmissionStatus.graded);
    } catch (e) {
      LoggerService.error('Failed to mark submission as graded',
          tag: _tag, error: e);
      rethrow;
    }
  }

  /// Adds teacher feedback to a submission.
  ///
  /// Updates the feedback field and modification timestamp.
  /// Feedback is preserved even if submission is resubmitted.
  ///
  /// @param id Submission to add feedback to
  /// @param feedback Teacher's comments and suggestions
  /// @throws Exception if feedback addition fails
  @override
  Future<void> addFeedback(String id, String feedback) async {
    try {
      await _firestore.collection('submissions').doc(id).update({
        'feedback': feedback,
        'updatedAt': FieldValue.serverTimestamp(),
      });
      LoggerService.info('Added feedback to submission', tag: _tag);
    } catch (e) {
      LoggerService.error('Failed to add feedback', tag: _tag, error: e);
      rethrow;
    }
  }

  /// Creates multiple submissions in one atomic operation.
  ///
  /// Efficient bulk creation for:
  /// - Programmatic submission generation
  /// - Data migration
  /// - Testing purposes
  ///
  /// All submissions get the same timestamp for consistency.
  /// Uses batch operations to ensure atomicity.
  ///
  /// @param submissions List of submissions to create
  /// @throws Exception if batch creation fails
  @override
  Future<void> batchCreateSubmissions(List<Submission> submissions) async {
    try {
      final batch = _firestore.batch();
      final now = DateTime.now();

      for (final submission in submissions) {
        final ref = _firestore.collection('submissions').doc();
        final submissionToCreate = submission.copyWith(
          id: ref.id,
          submittedAt: now,
          updatedAt: now,
        );
        batch.set(ref, submissionToCreate.toFirestore());
      }

      await batch.commit();
      LoggerService.info('Batch created ${submissions.length} submissions',
          tag: _tag);
    } catch (e) {
      LoggerService.error('Failed to batch create submissions',
          tag: _tag, error: e);
      rethrow;
    }
  }

  /// Updates multiple submissions in one atomic operation.
  ///
  /// Efficient bulk update for:
  /// - Batch status changes
  /// - Mass feedback updates
  /// - Bulk grading operations
  ///
  /// All updates use the same timestamp for consistency.
  /// Operations are atomic - all succeed or fail together.
  ///
  /// @param submissions Map of submission IDs to updated data
  /// @throws Exception if batch update fails
  @override
  Future<void> batchUpdateSubmissions(
      Map<String, Submission> submissions) async {
    try {
      final batch = _firestore.batch();
      final now = DateTime.now();

      submissions.forEach((submissionId, submission) {
        final ref = _firestore.collection('submissions').doc(submissionId);
        final submissionToUpdate = submission.copyWith(
          updatedAt: now,
        );
        batch.update(ref, submissionToUpdate.toFirestore());
      });

      await batch.commit();
      LoggerService.info('Batch updated ${submissions.length} submissions',
          tag: _tag);
    } catch (e) {
      LoggerService.error('Failed to batch update submissions',
          tag: _tag, error: e);
      rethrow;
    }
  }
}
