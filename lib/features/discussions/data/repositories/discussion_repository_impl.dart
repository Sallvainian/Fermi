/// Concrete implementation of the discussion repository.
///
/// This module implements the DiscussionRepository interface using
/// Firebase Firestore as the data source. It provides full forum
/// functionality with threaded discussions and real-time updates.
library;

import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:firebase_auth/firebase_auth.dart';
import '../../domain/models/discussion_board.dart';
import '../../../../shared/services/logger_service.dart';
import '../../../../shared/services/firestore_service.dart';
import '../../domain/repositories/discussion_repository.dart';
import '../../../../shared/repositories/firestore_repository.dart';

/// Firestore-based implementation of DiscussionRepository.
///
/// This class extends FirestoreRepository to leverage common
/// CRUD operations while implementing forum-specific features:
/// - Hierarchical data structure (boards -> threads -> replies)
/// - Like/unlike functionality with user tracking
/// - Pin and lock features for moderation
/// - Real-time streaming of discussions
/// - Full-text search across threads
/// - Automatic metadata management
///
/// Uses Firebase Auth for user identification and role detection.
class DiscussionRepositoryImpl extends FirestoreRepository<DiscussionBoard>
    implements DiscussionRepository {
  /// Logger tag for this repository.
  static const String _tag = 'DiscussionRepository';

  /// Firestore instance for direct database operations.
  final FirebaseFirestore _firestore;

  /// Firebase Auth for user identification.
  final FirebaseAuth _auth;

  /// Creates a discussion repository with Firestore backend.
  ///
  /// Initializes the parent FirestoreRepository with board-specific
  /// configuration and sets up authentication integration.
  ///
  /// @param _firestore Firestore database instance
  /// @param _auth Firebase Auth instance
  DiscussionRepositoryImpl(this._firestore, this._auth)
      : super(
          firestore: _firestore,
          collectionPath: 'discussion_boards',
          fromFirestore: (doc) => DiscussionBoard.fromFirestore(doc),
          toFirestore: (board) => board.toFirestore(),
          logTag: _tag,
        );

  /// Gets the current user's ID from Firebase Auth.
  String get _currentUserId => _auth.currentUser?.uid ?? '';

  /// Gets the current user's display name.
  String get _currentUserName => _auth.currentUser?.displayName ?? 'User';

  /// Determines user role based on email domain.
  ///
  /// Simple role detection: teachers have @teacher.edu emails,
  /// all others are considered students. This is a placeholder
  /// implementation that should be replaced with proper role lookup.
  String get _currentUserRole =>
      _auth.currentUser?.email?.endsWith('@teacher.edu') == true
          ? 'teacher'
          : 'student';

  /// Creates a new discussion board with automatic metadata.
  ///
  /// Sets creation timestamp, creator information, and ensures
  /// the creator is included in participants. Board ID is
  /// generated by Firestore.
  ///
  /// @param board Board configuration with title and settings
  /// @return Generated unique board ID
  /// @throws Exception if board creation fails
  @override
  Future<String> createBoard(DiscussionBoard board) async {
    try {
      final boardToCreate = board.copyWith(
        createdAt: DateTime.now(),
        updatedAt: DateTime.now(),
        createdBy: _currentUserId,
        createdByName: _currentUserName,
        participantIds: board.participantIds.isEmpty
            ? [_currentUserId]
            : board.participantIds,
      );

      final boardId = await create(boardToCreate);
      LoggerService.info('Created discussion board: $boardId', tag: _tag);
      return boardId;
    } catch (e) {
      LoggerService.error('Failed to create discussion board',
          tag: _tag, error: e);
      rethrow;
    }
  }

  /// Retrieves a discussion board by ID.
  ///
  /// Delegates to parent repository for consistent error handling.
  ///
  /// @param boardId Unique board identifier
  /// @return Board instance or null if not found
  @override
  Future<DiscussionBoard?> getBoard(String boardId) => read(boardId);

  /// Retrieves all discussion boards sorted by priority.
  ///
  /// Orders boards with pinned items first, then by most
  /// recently updated. This ensures important and active
  /// discussions are prominently displayed.
  ///
  /// @return List of discussion boards
  /// @throws Exception if retrieval fails
  @override
  Future<List<DiscussionBoard>> getBoards() async {
    try {
      return await list(
        orderBy: [
          OrderBy(field: 'isPinned', descending: true),
          OrderBy(field: 'updatedAt', descending: true),
        ],
      );
    } catch (e) {
      LoggerService.error('Failed to get boards', tag: _tag, error: e);
      rethrow;
    }
  }

  /// Updates board information with automatic timestamp.
  ///
  /// Modifies board details while preserving immutable fields
  /// like creator and creation date. Updates modification time.
  ///
  /// @param boardId Board to update
  /// @param board Updated board information
  /// @throws Exception if update fails
  @override
  Future<void> updateBoard(String boardId, DiscussionBoard board) async {
    try {
      final boardToUpdate = board.copyWith(
        updatedAt: DateTime.now(),
      );
      await update(boardId, boardToUpdate);
    } catch (e) {
      LoggerService.error('Failed to update board', tag: _tag, error: e);
      rethrow;
    }
  }

  /// Pins or unpins a discussion board.
  ///
  /// Pinned boards appear at the top of board lists.
  /// Uses server timestamp for consistency across clients.
  ///
  /// @param boardId Board to pin/unpin
  /// @param isPinned Whether to pin the board
  /// @throws Exception if operation fails
  @override
  Future<void> pinBoard(String boardId, bool isPinned) async {
    try {
      await _firestore.collection('discussion_boards').doc(boardId).update({
        'isPinned': isPinned,
        'updatedAt': FieldValue.serverTimestamp(),
      });
    } catch (e) {
      LoggerService.error('Failed to pin/unpin board', tag: _tag, error: e);
      rethrow;
    }
  }

  /// Creates a new discussion thread in a board.
  ///
  /// Automatically sets author information from current user,
  /// timestamps, and increments the board's thread count.
  /// Thread is stored as a subcollection under the board.
  ///
  /// @param boardId Target board for the thread
  /// @param thread Thread content and configuration
  /// @return Generated unique thread ID
  /// @throws Exception if thread creation fails
  @override
  Future<String> createThread(String boardId, DiscussionThread thread) async {
    try {
      final threadToCreate = thread.copyWith(
        boardId: boardId,
        authorId: _currentUserId,
        authorName: _currentUserName,
        authorRole: _currentUserRole,
        createdAt: DateTime.now(),
        updatedAt: DateTime.now(),
      );

      final ref = _firestore
          .collection('discussion_boards')
          .doc(boardId)
          .collection('threads')
          .doc();

      await ref.set(threadToCreate.toFirestore());

      // Update thread count
      await _firestore.collection('discussion_boards').doc(boardId).update({
        'threadCount': FieldValue.increment(1),
        'updatedAt': FieldValue.serverTimestamp(),
      });

      LoggerService.info('Created thread in board $boardId', tag: _tag);
      return ref.id;
    } catch (e) {
      LoggerService.error('Failed to create thread', tag: _tag, error: e);
      rethrow;
    }
  }

  /// Retrieves a specific discussion thread.
  ///
  /// Fetches thread from the board's subcollection.
  /// Returns null if thread doesn't exist or on error.
  ///
  /// @param boardId Board containing the thread
  /// @param threadId Unique thread identifier
  /// @return Thread instance or null
  @override
  Future<DiscussionThread?> getThread(String boardId, String threadId) async {
    try {
      final doc = await _firestore
          .collection('discussion_boards')
          .doc(boardId)
          .collection('threads')
          .doc(threadId)
          .get();

      if (doc.exists) {
        return DiscussionThread.fromFirestore(doc);
      }
      return null;
    } catch (e) {
      LoggerService.error('Failed to get thread', tag: _tag, error: e);
      return null;
    }
  }

  /// Retrieves all threads in a discussion board.
  ///
  /// Orders threads with pinned items first, then by
  /// most recent activity. This ensures important and
  /// active discussions are prominently displayed.
  ///
  /// @param boardId Board to get threads from
  /// @return List of discussion threads
  @override
  Future<List<DiscussionThread>> getBoardThreads(String boardId) async {
    try {
      final snapshot = await _firestore
          .collection('discussion_boards')
          .doc(boardId)
          .collection('threads')
          .orderBy('isPinned', descending: true)
          .orderBy('updatedAt', descending: true)
          .get();

      return snapshot.docs
          .map((doc) => DiscussionThread.fromFirestore(doc))
          .toList();
    } catch (e) {
      LoggerService.error('Failed to get board threads', tag: _tag, error: e);
      return [];
    }
  }

  @override
  Future<void> updateThread(
      String boardId, String threadId, DiscussionThread thread) async {
    try {
      await _firestore
          .collection('discussion_boards')
          .doc(boardId)
          .collection('threads')
          .doc(threadId)
          .update({
        ...thread.toFirestore(),
        'updatedAt': FieldValue.serverTimestamp(),
      });
    } catch (e) {
      LoggerService.error('Failed to update thread', tag: _tag, error: e);
      rethrow;
    }
  }

  /// Deletes a thread and all associated replies.
  ///
  /// Uses batch operations to ensure atomic deletion:
  /// 1. Deletes all replies in the thread
  /// 2. Deletes the thread document
  /// 3. Updates board's thread count
  ///
  /// This ensures data consistency even if partial failure occurs.
  ///
  /// @param boardId Board containing the thread
  /// @param threadId Thread to delete
  /// @throws Exception if deletion fails
  @override
  Future<void> deleteThread(String boardId, String threadId) async {
    try {
      // Delete all replies first
      final repliesSnapshot = await _firestore
          .collection('discussion_boards')
          .doc(boardId)
          .collection('threads')
          .doc(threadId)
          .collection('replies')
          .get();

      final batch = _firestore.batch();
      for (final doc in repliesSnapshot.docs) {
        batch.delete(doc.reference);
      }

      // Delete the thread
      batch.delete(_firestore
          .collection('discussion_boards')
          .doc(boardId)
          .collection('threads')
          .doc(threadId));

      await batch.commit();

      // Update thread count
      await _firestore.collection('discussion_boards').doc(boardId).update({
        'threadCount': FieldValue.increment(-1),
        'updatedAt': FieldValue.serverTimestamp(),
      });

      LoggerService.info('Deleted thread $threadId from board $boardId',
          tag: _tag);
    } catch (e) {
      LoggerService.error('Failed to delete thread', tag: _tag, error: e);
      rethrow;
    }
  }

  /// Adds a like to a discussion thread.
  ///
  /// Uses arrayUnion to prevent duplicate likes from the
  /// same user. Increments the like count for display.
  ///
  /// @param boardId Board containing the thread
  /// @param threadId Thread to like
  /// @param userId User performing the like
  /// @throws Exception if like operation fails
  @override
  Future<void> likeThread(
      String boardId, String threadId, String userId) async {
    try {
      await _firestore
          .collection('discussion_boards')
          .doc(boardId)
          .collection('threads')
          .doc(threadId)
          .update({
        'likedBy': FieldValue.arrayUnion([userId]),
        'likeCount': FieldValue.increment(1),
      });
    } catch (e) {
      LoggerService.error('Failed to like thread', tag: _tag, error: e);
      rethrow;
    }
  }

  /// Removes a like from a discussion thread.
  ///
  /// Uses arrayRemove to remove the user's like and
  /// decrements the like count accordingly.
  ///
  /// @param boardId Board containing the thread
  /// @param threadId Thread to unlike
  /// @param userId User removing the like
  /// @throws Exception if unlike operation fails
  @override
  Future<void> unlikeThread(
      String boardId, String threadId, String userId) async {
    try {
      await _firestore
          .collection('discussion_boards')
          .doc(boardId)
          .collection('threads')
          .doc(threadId)
          .update({
        'likedBy': FieldValue.arrayRemove([userId]),
        'likeCount': FieldValue.increment(-1),
      });
    } catch (e) {
      LoggerService.error('Failed to unlike thread', tag: _tag, error: e);
      rethrow;
    }
  }

  /// Pins or unpins a thread within a board.
  ///
  /// Pinned threads appear at the top of thread lists.
  /// Typically restricted to moderators or thread authors.
  ///
  /// @param boardId Board containing the thread
  /// @param threadId Thread to pin/unpin
  /// @param isPinned Whether to pin the thread
  /// @throws Exception if operation fails
  @override
  Future<void> pinThread(String boardId, String threadId, bool isPinned) async {
    try {
      await _firestore
          .collection('discussion_boards')
          .doc(boardId)
          .collection('threads')
          .doc(threadId)
          .update({
        'isPinned': isPinned,
        'updatedAt': FieldValue.serverTimestamp(),
      });
    } catch (e) {
      LoggerService.error('Failed to pin/unpin thread', tag: _tag, error: e);
      rethrow;
    }
  }

  /// Locks or unlocks a thread for replies.
  ///
  /// Locked threads prevent new replies but remain visible.
  /// Used for closing resolved discussions or preventing
  /// further debate on sensitive topics.
  ///
  /// @param boardId Board containing the thread
  /// @param threadId Thread to lock/unlock
  /// @param isLocked Whether to lock the thread
  /// @throws Exception if operation fails
  @override
  Future<void> lockThread(
      String boardId, String threadId, bool isLocked) async {
    try {
      await _firestore
          .collection('discussion_boards')
          .doc(boardId)
          .collection('threads')
          .doc(threadId)
          .update({
        'isLocked': isLocked,
        'updatedAt': FieldValue.serverTimestamp(),
      });
    } catch (e) {
      LoggerService.error('Failed to lock/unlock thread', tag: _tag, error: e);
      rethrow;
    }
  }

  /// Creates a reply to a discussion thread.
  ///
  /// Automatically sets author information and timestamps.
  /// Updates both thread and board metadata to reflect new
  /// activity. Reply is stored as a subcollection under thread.
  ///
  /// Updates cascade:
  /// 1. Creates reply document
  /// 2. Increments thread reply count
  /// 3. Updates thread activity timestamp
  /// 4. Updates board activity timestamp
  ///
  /// @param boardId Board containing the thread
  /// @param threadId Thread to reply to
  /// @param reply Reply content and metadata
  /// @return Generated unique reply ID
  /// @throws Exception if reply creation fails
  @override
  Future<String> createReply(
      String boardId, String threadId, ThreadReply reply) async {
    try {
      final replyToCreate = reply.copyWith(
        threadId: threadId,
        authorId: _currentUserId,
        authorName: _currentUserName,
        authorRole: _currentUserRole,
        createdAt: DateTime.now(),
      );

      final ref = _firestore
          .collection('discussion_boards')
          .doc(boardId)
          .collection('threads')
          .doc(threadId)
          .collection('replies')
          .doc();

      await ref.set(replyToCreate.toFirestore());

      // Update reply count and thread updated time
      await _firestore
          .collection('discussion_boards')
          .doc(boardId)
          .collection('threads')
          .doc(threadId)
          .update({
        'replyCount': FieldValue.increment(1),
        'updatedAt': FieldValue.serverTimestamp(),
      });

      // Update board updated time
      await _firestore.collection('discussion_boards').doc(boardId).update({
        'updatedAt': FieldValue.serverTimestamp(),
      });

      LoggerService.info('Created reply in thread $threadId', tag: _tag);
      return ref.id;
    } catch (e) {
      LoggerService.error('Failed to create reply', tag: _tag, error: e);
      rethrow;
    }
  }

  /// Retrieves all replies for a thread.
  ///
  /// Fetches replies in chronological order to maintain
  /// conversation flow. Returns empty list on error.
  ///
  /// @param boardId Board containing the thread
  /// @param threadId Thread to get replies for
  /// @return List of thread replies in order
  @override
  Future<List<ThreadReply>> getThreadReplies(
      String boardId, String threadId) async {
    try {
      final snapshot = await _firestore
          .collection('discussion_boards')
          .doc(boardId)
          .collection('threads')
          .doc(threadId)
          .collection('replies')
          .orderBy('createdAt')
          .get();

      return snapshot.docs
          .map((doc) => ThreadReply.fromFirestore(doc))
          .toList();
    } catch (e) {
      LoggerService.error('Failed to get thread replies', tag: _tag, error: e);
      return [];
    }
  }

  /// Updates reply content with edit tracking.
  ///
  /// Only updates the content field and marks the reply
  /// as edited with timestamp. Preserves original author
  /// and creation information.
  ///
  /// @param boardId Board containing the thread
  /// @param threadId Thread containing the reply
  /// @param replyId Reply to update
  /// @param reply Updated reply with new content
  /// @throws Exception if update fails
  @override
  Future<void> updateReply(String boardId, String threadId, String replyId,
      ThreadReply reply) async {
    try {
      await _firestore
          .collection('discussion_boards')
          .doc(boardId)
          .collection('threads')
          .doc(threadId)
          .collection('replies')
          .doc(replyId)
          .update({
        'content': reply.content,
        'isEdited': true,
        'editedAt': FieldValue.serverTimestamp(),
      });
    } catch (e) {
      LoggerService.error('Failed to update reply', tag: _tag, error: e);
      rethrow;
    }
  }

  /// Deletes a reply from a thread.
  ///
  /// Permanently removes the reply and decrements the
  /// thread's reply count. Updates thread timestamp to
  /// reflect the change.
  ///
  /// @param boardId Board containing the thread
  /// @param threadId Thread containing the reply
  /// @param replyId Reply to delete
  /// @throws Exception if deletion fails
  @override
  Future<void> deleteReply(
      String boardId, String threadId, String replyId) async {
    try {
      await _firestore
          .collection('discussion_boards')
          .doc(boardId)
          .collection('threads')
          .doc(threadId)
          .collection('replies')
          .doc(replyId)
          .delete();

      // Update reply count
      await _firestore
          .collection('discussion_boards')
          .doc(boardId)
          .collection('threads')
          .doc(threadId)
          .update({
        'replyCount': FieldValue.increment(-1),
        'updatedAt': FieldValue.serverTimestamp(),
      });

      LoggerService.info('Deleted reply $replyId from thread $threadId',
          tag: _tag);
    } catch (e) {
      LoggerService.error('Failed to delete reply', tag: _tag, error: e);
      rethrow;
    }
  }

  /// Adds a like to a reply.
  ///
  /// Uses arrayUnion to prevent duplicate likes from the
  /// same user. Increments the like count for display.
  ///
  /// @param boardId Board containing the thread
  /// @param threadId Thread containing the reply
  /// @param replyId Reply to like
  /// @param userId User performing the like
  /// @throws Exception if like operation fails
  @override
  Future<void> likeReply(
      String boardId, String threadId, String replyId, String userId) async {
    try {
      await _firestore
          .collection('discussion_boards')
          .doc(boardId)
          .collection('threads')
          .doc(threadId)
          .collection('replies')
          .doc(replyId)
          .update({
        'likedBy': FieldValue.arrayUnion([userId]),
        'likeCount': FieldValue.increment(1),
      });
    } catch (e) {
      LoggerService.error('Failed to like reply', tag: _tag, error: e);
      rethrow;
    }
  }

  /// Removes a like from a reply.
  ///
  /// Uses arrayRemove to remove the user's like and
  /// decrements the like count accordingly.
  ///
  /// @param boardId Board containing the thread
  /// @param threadId Thread containing the reply
  /// @param replyId Reply to unlike
  /// @param userId User removing the like
  /// @throws Exception if unlike operation fails
  @override
  Future<void> unlikeReply(
      String boardId, String threadId, String replyId, String userId) async {
    try {
      await _firestore
          .collection('discussion_boards')
          .doc(boardId)
          .collection('threads')
          .doc(threadId)
          .collection('replies')
          .doc(replyId)
          .update({
        'likedBy': FieldValue.arrayRemove([userId]),
        'likeCount': FieldValue.increment(-1),
      });
    } catch (e) {
      LoggerService.error('Failed to unlike reply', tag: _tag, error: e);
      rethrow;
    }
  }

  /// Streams all discussion boards in real-time.
  ///
  /// Returns live updates ordered by pin status and activity.
  /// Leverages parent repository's stream method with
  /// appropriate ordering.
  ///
  /// @return Stream of discussion board lists
  @override
  Stream<List<DiscussionBoard>> streamBoards() {
    return stream(
      orderBy: [
        OrderBy(field: 'isPinned', descending: true),
        OrderBy(field: 'updatedAt', descending: true),
      ],
    );
  }

  /// Streams threads for a specific board in real-time.
  ///
  /// Returns live updates of threads with pinned items
  /// first, then by most recent activity. Automatically
  /// updates when threads are added, modified, or deleted.
  ///
  /// @param boardId Board to monitor
  /// @return Stream of thread lists
  @override
  Stream<List<DiscussionThread>> streamBoardThreads(String boardId) {
    return _firestore
        .collection('discussion_boards')
        .doc(boardId)
        .collection('threads')
        .orderBy('isPinned', descending: true)
        .orderBy('updatedAt', descending: true)
        .snapshots()
        .map((snapshot) => snapshot.docs
            .map((doc) => DiscussionThread.fromFirestore(doc))
            .toList());
  }

  /// Streams replies for a specific thread in real-time.
  ///
  /// Returns live updates of replies in chronological order.
  /// Automatically updates when replies are added, edited,
  /// or deleted.
  ///
  /// @param boardId Board containing the thread
  /// @param threadId Thread to monitor
  /// @return Stream of reply lists
  @override
  Stream<List<ThreadReply>> streamThreadReplies(
      String boardId, String threadId) {
    return _firestore
        .collection('discussion_boards')
        .doc(boardId)
        .collection('threads')
        .doc(threadId)
        .collection('replies')
        .orderBy('createdAt')
        .snapshots()
        .map((snapshot) => snapshot.docs
            .map((doc) => ThreadReply.fromFirestore(doc))
            .toList());
  }

  /// Searches for threads across all boards.
  ///
  /// Performs client-side text search on thread titles
  /// and content. This is a basic implementation that
  /// loads all threads into memory.
  ///
  /// Note: For production use with large datasets,
  /// consider implementing server-side search with
  /// Firestore composite indexes or external search
  /// services like Algolia or Elasticsearch.
  ///
  /// @param query Search terms (case-insensitive)
  /// @return List of matching threads
  @override
  Future<List<DiscussionThread>> searchThreads(String query) async {
    try {
      // This is a simple implementation. For better search,
      // consider using a search service like Algolia
      final boards = await getBoards();
      final allThreads = <DiscussionThread>[];

      for (final board in boards) {
        final threads = await getBoardThreads(board.id);
        allThreads.addAll(threads);
      }

      final lowercaseQuery = query.toLowerCase();
      return allThreads
          .where((thread) =>
              thread.title.toLowerCase().contains(lowercaseQuery) ||
              thread.content.toLowerCase().contains(lowercaseQuery))
          .toList();
    } catch (e) {
      LoggerService.error('Failed to search threads', tag: _tag, error: e);
      return [];
    }
  }

  /// Searches for threads within a specific board.
  ///
  /// Performs client-side text search limited to a single
  /// board. More efficient than global search when scope
  /// is known.
  ///
  /// @param boardId Board to search within
  /// @param query Search terms (case-insensitive)
  /// @return List of matching threads from the board
  @override
  Future<List<DiscussionThread>> searchBoardThreads(
      String boardId, String query) async {
    try {
      final threads = await getBoardThreads(boardId);
      final lowercaseQuery = query.toLowerCase();

      return threads
          .where((thread) =>
              thread.title.toLowerCase().contains(lowercaseQuery) ||
              thread.content.toLowerCase().contains(lowercaseQuery))
          .toList();
    } catch (e) {
      LoggerService.error('Failed to search board threads',
          tag: _tag, error: e);
      return [];
    }
  }
}
