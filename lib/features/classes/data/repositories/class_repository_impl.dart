/// Concrete implementation of the class repository.
/// 
/// This module implements the ClassRepository interface using
/// Firebase Firestore as the data source. It provides full
/// CRUD operations and specialized queries for academic
/// class management.
library;

import 'dart:math';
import 'package:cloud_firestore/cloud_firestore.dart';
import '../../domain/models/class_model.dart';
import '../../../../shared/models/user_model.dart';
import '../../../../shared/services/firestore_service.dart';
import '../../../../shared/services/logger_service.dart';
import '../../domain/repositories/class_repository.dart';
import '../../../../shared/repositories/firestore_repository.dart';

/// Firestore-based implementation of ClassRepository.
/// 
/// This class extends FirestoreRepository to leverage common
/// CRUD operations while implementing class-specific features:
/// - Student enrollment management with batch operations
/// - Teacher-class associations and filtering
/// - Active/archive state management
/// - Statistical analysis of class data
/// - Capacity tracking and enrollment limits
/// - Academic year organization
/// 
/// All operations include comprehensive logging for debugging
/// and audit trails.
class ClassRepositoryImpl extends FirestoreRepository<ClassModel> 
    implements ClassRepository {
  /// Firestore instance for direct database operations.
  final FirebaseFirestore _firestore;
  
  /// Creates a class repository with Firestore backend.
  /// 
  /// Initializes the parent FirestoreRepository with class-specific
  /// configuration including collection path and serialization.
  /// 
  /// @param _firestore Firestore database instance
  ClassRepositoryImpl(this._firestore)
      : super(
          firestore: _firestore,
          collectionPath: 'classes',
          fromFirestore: (doc) => ClassModel.fromFirestore(doc),
          toFirestore: (classModel) => classModel.toFirestore(),
          logTag: 'ClassRepository',
        );
  
  /// Creates a new academic class with initial metadata.
  /// 
  /// Automatically sets creation/update timestamps and initializes
  /// an empty student list. The class ID is generated by Firestore.
  /// 
  /// @param classModel Class details including name, teacher, schedule
  /// @return Generated unique class ID
  /// @throws Exception if class creation fails
  @override
  Future<String> createClass(ClassModel classModel) async {
    try {
      // Generate unique enrollment code
      String? enrollmentCode;
      if (classModel.enrollmentCode == null) {
        enrollmentCode = await _generateUniqueEnrollmentCode();
      }
      
      final classWithTimestamp = classModel.copyWith(
        createdAt: DateTime.now(),
        updatedAt: DateTime.now(),
        studentIds: [],
        enrollmentCode: enrollmentCode ?? classModel.enrollmentCode,
      );
      return await create(classWithTimestamp);
    } catch (e) {
      LoggerService.error('Failed to create class', tag: tag, error: e);
      rethrow;
    }
  }
  
  /// Generates a unique enrollment code for a new class.
  /// 
  /// Internal helper method that creates codes without
  /// updating existing classes.
  /// 
  /// @return A unique 6-character enrollment code
  /// @throws Exception if unable to generate unique code
  Future<String> _generateUniqueEnrollmentCode() async {
    const chars = 'ABCDEFGHJKLMNPQRSTUVWXYZ23456789';
    const codeLength = 6;
    const maxAttempts = 100;
    
    for (int attempt = 0; attempt < maxAttempts; attempt++) {
      final random = Random();
      final code = String.fromCharCodes(
        Iterable.generate(
          codeLength,
          (_) => chars.codeUnitAt(random.nextInt(chars.length)),
        ),
      );
      
      // Check if code already exists
      final existing = await getClassByEnrollmentCode(code);
      if (existing == null) {
        return code;
      }
    }
    
    throw Exception('Unable to generate unique enrollment code');
  }  
  /// Retrieves a class by its unique identifier.
  /// 
  /// Delegates to the parent repository's read method for
  /// consistent error handling and logging.
  /// 
  /// @param classId Unique class identifier
  /// @return Class instance or null if not found
  @override
  Future<ClassModel?> getClass(String classId) => read(classId);
  
  /// Updates class information with automatic timestamp.
  /// 
  /// Ensures the class ID remains consistent and updates
  /// the modification timestamp. Only modifiable fields
  /// are updated; immutable fields like teacherId are preserved.
  /// 
  /// @param classId ID of the class to update
  /// @param classModel Updated class information
  /// @throws Exception if update fails or class not found
  @override
  Future<void> updateClass(String classId, ClassModel classModel) async {
    try {
      final updatedClass = classModel.copyWith(
        id: classId,
        updatedAt: DateTime.now(),
      );
      await update(classId, updatedClass);
    } catch (e) {
      LoggerService.error('Failed to update class', tag: tag, error: e);
      rethrow;
    }
  }
  
  /// Permanently deletes a class and all associated data.
  /// 
  /// This is a destructive operation that cannot be undone.
  /// Consider using archiveClass for recoverable removal.
  /// 
  /// @param classId ID of the class to delete
  /// @throws Exception if deletion fails
  @override
  Future<void> deleteClass(String classId) => delete(classId);
  
  /// Streams all classes taught by a specific teacher.
  /// 
  /// Returns real-time updates of classes where the teacher
  /// is the instructor, sorted alphabetically by name.
  /// Includes both active and archived classes.
  /// 
  /// @param teacherId Teacher's unique identifier
  /// @return Stream of teacher's class list
  @override
  Stream<List<ClassModel>> getTeacherClasses(String teacherId) {
    return stream(
      conditions: [
        QueryCondition(field: 'teacherId', isEqualTo: teacherId),
      ],
      orderBy: [
        OrderBy(field: 'name', descending: false),
      ],
    );
  }  
  /// Streams active classes a student is enrolled in.
  /// 
  /// Filters to only active classes where the student ID
  /// appears in the studentIds array. Updates in real-time
  /// as enrollment changes.
  /// 
  /// @param studentId Student's unique identifier
  /// @return Stream of student's enrolled classes
  @override
  Stream<List<ClassModel>> getStudentClasses(String studentId) {
    return stream(
      conditions: [
        QueryCondition(field: 'studentIds', arrayContains: studentId),
        QueryCondition(field: 'isActive', isEqualTo: true),
      ],
      orderBy: [
        OrderBy(field: 'name', descending: false),
      ],
    );
  }
  
  /// Adds a student to a class roster.
  /// 
  /// Uses Firestore's arrayUnion to safely add the student ID
  /// without duplicates. Updates the modification timestamp
  /// using server time for consistency.
  /// 
  /// @param classId Target class identifier
  /// @param studentId Student to enroll
  /// @throws Exception if enrollment fails
  @override
  Future<void> addStudent(String classId, String studentId) async {
    try {
      // Use a batch to update both class and student documents atomically
      final batch = _firestore.batch();
      
      // Update class document
      final classRef = _firestore.collection('classes').doc(classId);
      batch.update(classRef, {
        'studentIds': FieldValue.arrayUnion([studentId]),
        'studentCount': FieldValue.increment(1),
        'updatedAt': FieldValue.serverTimestamp(),
      });
      
      // Update student document to add this class to their classIds
      final studentRef = _firestore.collection('students').doc(studentId);
      batch.update(studentRef, {
        'classIds': FieldValue.arrayUnion([classId]),
        'updatedAt': FieldValue.serverTimestamp(),
      });
      
      // Commit the batch
      await batch.commit();
      
      LoggerService.info('Added student $studentId to class $classId', tag: tag);
    } catch (e) {
      LoggerService.error('Failed to add student to class', tag: tag, error: e);
      rethrow;
    }
  }  
  /// Removes a student from a class roster.
  /// 
  /// Uses Firestore's arrayRemove to safely remove the student ID.
  /// Updates the modification timestamp for audit trail.
  /// 
  /// @param classId Target class identifier
  /// @param studentId Student to unenroll
  /// @throws Exception if removal fails
  @override
  Future<void> removeStudent(String classId, String studentId) async {
    try {
      // Use a batch to update both class and student documents atomically
      final batch = _firestore.batch();
      
      // Update class document
      final classRef = _firestore.collection('classes').doc(classId);
      batch.update(classRef, {
        'studentIds': FieldValue.arrayRemove([studentId]),
        'studentCount': FieldValue.increment(-1),
        'updatedAt': FieldValue.serverTimestamp(),
      });
      
      // Update student document to remove this class from their classIds
      final studentRef = _firestore.collection('students').doc(studentId);
      batch.update(studentRef, {
        'classIds': FieldValue.arrayRemove([classId]),
        'updatedAt': FieldValue.serverTimestamp(),
      });
      
      // Commit the batch
      await batch.commit();
      
      LoggerService.info('Removed student $studentId from class $classId', tag: tag);
    } catch (e) {
      LoggerService.error('Failed to remove student from class', tag: tag, error: e);
      rethrow;
    }
  }
  
  /// Retrieves complete profiles for all enrolled students.
  /// 
  /// Performs a two-step query:
  /// 1. Fetches the class to get student IDs
  /// 2. Batch fetches user profiles for all students
  /// 
  /// Filters results to ensure only student role users are
  /// returned, providing an additional safety check.
  /// 
  /// @param classId Class to get students for
  /// @return List of student user profiles
  /// @throws Exception if retrieval fails
  @override
  Future<List<UserModel>> getClassStudents(String classId) async {
    try {
      final classModel = await getClass(classId);
      if (classModel == null || classModel.studentIds.isEmpty) {
        return [];
      }
      
      final studentDocs = await _firestore
          .collection('users')
          .where(FieldPath.documentId, whereIn: classModel.studentIds)
          .get();
      
      return studentDocs.docs
          .map((doc) => UserModel.fromFirestore(doc))
          .where((user) => user.role == UserRole.student)
          .toList();
    } catch (e) {
      LoggerService.error('Failed to get class students', tag: tag, error: e);
      rethrow;
    }
  }  
  /// Checks if a student is enrolled in a specific class.
  /// 
  /// Efficient enrollment verification without loading all
  /// student profiles. Returns false if class doesn't exist.
  /// 
  /// @param classId Class to check
  /// @param studentId Student to verify
  /// @return true if enrolled, false otherwise
  /// @throws Exception if check fails
  @override
  Future<bool> isStudentEnrolled(String classId, String studentId) async {
    try {
      final classModel = await getClass(classId);
      return classModel?.studentIds.contains(studentId) ?? false;
    } catch (e) {
      LoggerService.error('Failed to check student enrollment', tag: tag, error: e);
      rethrow;
    }
  }
  
  /// Calculates comprehensive statistics for a class.
  /// 
  /// Aggregates data from multiple sources:
  /// - Student enrollment metrics from class document
  /// - Assignment count from assignments collection
  /// - Capacity and active status
  /// 
  /// Note: This is a basic implementation. Can be extended
  /// to include grades, attendance, and submission rates.
  /// 
  /// @param classId Class to analyze
  /// @return Map containing statistical data
  /// @throws Exception if calculation fails
  @override
  Future<Map<String, dynamic>> getClassStats(String classId) async {
    try {
      final classModel = await getClass(classId);
      if (classModel == null) {
        return {};
      }
      
      // Get assignment count
      final assignmentCount = await _firestore
          .collection('assignments')
          .where('classId', isEqualTo: classId)
          .count()
          .get();
      
      // Get average grade (if grades are available)
      // This is a simplified version - you might want to implement more complex logic
      
      return {
        'studentCount': classModel.studentCount,
        'assignmentCount': assignmentCount.count,
        'isActive': classModel.isActive,
        'isFull': classModel.isFull,
        'capacity': classModel.maxStudents ?? 'Unlimited',
      };
    } catch (e) {
      LoggerService.error('Failed to get class stats', tag: tag, error: e);
      rethrow;
    }
  }  
  /// Archives a class at the end of term or year.
  /// 
  /// Sets the isActive flag to false, hiding the class from
  /// active lists while preserving all data. The class can
  /// be restored later if needed.
  /// 
  /// @param classId ID of class to archive
  /// @throws Exception if archiving fails
  @override
  Future<void> archiveClass(String classId) async {
    try {
      await _firestore.collection('classes').doc(classId).update({
        'isActive': false,
        'updatedAt': FieldValue.serverTimestamp(),
      });
      LoggerService.info('Archived class $classId', tag: tag);
    } catch (e) {
      LoggerService.error('Failed to archive class', tag: tag, error: e);
      rethrow;
    }
  }
  
  /// Retrieves active classes for a specific academic year.
  /// 
  /// Filters classes by teacher, academic year, and active status.
  /// Useful for term-based views and academic year transitions.
  /// Results are sorted alphabetically by class name.
  /// 
  /// @param teacherId Teacher's unique identifier
  /// @param academicYear Year string (e.g., "2023-2024")
  /// @return List of active classes for the year
  /// @throws Exception if retrieval fails
  @override
  Future<List<ClassModel>> getActiveClasses(String teacherId, String academicYear) async {
    return await list(
      conditions: [
        QueryCondition(field: 'teacherId', isEqualTo: teacherId),
        QueryCondition(field: 'academicYear', isEqualTo: academicYear),
        QueryCondition(field: 'isActive', isEqualTo: true),
      ],
      orderBy: [
        OrderBy(field: 'name', descending: false),
      ],
    );
  }
  
  /// Restores an archived class to active status.
  /// 
  /// Reverses the archiving process by setting isActive to true.
  /// The class becomes visible in active lists again.
  /// 
  /// @param classId ID of class to restore
  /// @throws Exception if restoration fails
  @override
  Future<void> restoreClass(String classId) async {
    try {
      await _firestore.collection('classes').doc(classId).update({
        'isActive': true,
        'updatedAt': FieldValue.serverTimestamp(),
      });
      LoggerService.info('Restored class $classId', tag: tag);
    } catch (e) {
      LoggerService.error('Failed to restore class', tag: tag, error: e);
      rethrow;
    }
  }
  
  /// Enrolls a student in a class (alias for addStudent).
  /// 
  /// Provides semantic clarity for enrollment operations.
  /// Delegates to addStudent for actual implementation.
  /// 
  /// @param classId Target class identifier  
  /// @param studentId Student to enroll
  /// @throws Exception if enrollment fails
  @override
  Future<void> enrollStudent(String classId, String studentId) async {
    try {
      await addStudent(classId, studentId);
    } catch (e) {
      LoggerService.error('Failed to enroll student', tag: tag, error: e);
      rethrow;
    }
  }
  
  /// Unenrolls a student from a class (alias for removeStudent).
  /// 
  /// Provides semantic clarity for unenrollment operations.
  /// Delegates to removeStudent for actual implementation.
  /// 
  /// @param classId Target class identifier
  /// @param studentId Student to unenroll
  /// @throws Exception if unenrollment fails
  @override
  Future<void> unenrollStudent(String classId, String studentId) async {
    try {
      await removeStudent(classId, studentId);
    } catch (e) {
      LoggerService.error('Failed to unenroll student', tag: tag, error: e);
      rethrow;
    }
  }
  
  /// Enrolls multiple students in a single batch operation.
  /// 
  /// Uses Firestore batch writes for atomicity - all enrollments
  /// succeed or fail together. Updates both the class roster
  /// and each student's enrolled classes list.
  /// 
  /// This is more efficient than individual enrollments and
  /// ensures data consistency across documents.
  /// 
  /// @param classId Target class identifier
  /// @param studentIds List of students to enroll
  /// @throws Exception if batch enrollment fails
  @override
  Future<void> enrollMultipleStudents(String classId, List<String> studentIds) async {
    try {
      final batch = _firestore.batch();
      
      // Update class document
      final classRef = _firestore.collection('classes').doc(classId);
      batch.update(classRef, {
        'studentIds': FieldValue.arrayUnion(studentIds),
        'studentCount': FieldValue.increment(studentIds.length),
        'updatedAt': FieldValue.serverTimestamp(),
      });
      
      // Update each student document
      for (final studentId in studentIds) {
        final studentRef = _firestore.collection('students').doc(studentId);
        batch.update(studentRef, {
          'classIds': FieldValue.arrayUnion([classId]),
          'updatedAt': FieldValue.serverTimestamp(),
        });
      }
      
      await batch.commit();
      LoggerService.info('Enrolled ${studentIds.length} students in class $classId', tag: tag);
    } catch (e) {
      LoggerService.error('Failed to enroll multiple students', tag: tag, error: e);
      rethrow;
    }
  }
  
  /// Finds a class by its enrollment code.
  /// 
  /// Searches for active classes with the specified enrollment code.
  /// Enrollment codes are unique across all active classes.
  /// 
  /// @param enrollmentCode The enrollment code to search for
  /// @return Class instance or null if not found
  /// @throws Exception if search fails
  @override
  Future<ClassModel?> getClassByEnrollmentCode(String enrollmentCode) async {
    try {
      final querySnapshot = await _firestore
          .collection('classes')
          .where('enrollmentCode', isEqualTo: enrollmentCode)
          .where('isActive', isEqualTo: true)
          .limit(1)
          .get();
      
      if (querySnapshot.docs.isEmpty) {
        return null;
      }
      
      return ClassModel.fromFirestore(querySnapshot.docs.first);
    } catch (e) {
      LoggerService.error('Failed to get class by enrollment code', tag: tag, error: e);
      rethrow;
    }
  }
  
  /// Enrolls a student using an enrollment code.
  /// 
  /// Validates the enrollment code, checks class capacity,
  /// and adds the student to the class if allowed.
  /// 
  /// @param studentId Student to enroll
  /// @param enrollmentCode Class enrollment code
  /// @return The enrolled class model
  /// @throws Exception if enrollment fails
  @override
  Future<ClassModel> enrollWithCode(String studentId, String enrollmentCode) async {
    try {
      // Find class by enrollment code
      final classModel = await getClassByEnrollmentCode(enrollmentCode);
      
      if (classModel == null) {
        throw Exception('Invalid enrollment code');
      }
      
      // Check if student is already enrolled
      if (classModel.studentIds.contains(studentId)) {
        throw Exception('Student is already enrolled in this class');
      }
      
      // Check if class is full
      if (classModel.isFull) {
        throw Exception('Class is at maximum capacity');
      }
      
      // Enroll the student
      await addStudent(classModel.id, studentId);
      
      // Return updated class model
      final updatedClass = await getClass(classModel.id);
      if (updatedClass == null) {
        throw Exception('Failed to retrieve updated class');
      }
      
      LoggerService.info('Enrolled student $studentId in class ${classModel.name} via code', tag: tag);
      return updatedClass;
      
    } catch (e) {
      LoggerService.error('Failed to enroll with code', tag: tag, error: e);
      rethrow;
    }
  }
  
  /// Generates a new enrollment code for a class.
  /// 
  /// Creates a unique 6-character alphanumeric code
  /// and updates the class record. Ensures uniqueness
  /// by checking against existing codes.
  /// 
  /// @param classId Class to generate code for
  /// @return The new enrollment code
  /// @throws Exception if generation fails
  @override
  Future<String> regenerateEnrollmentCode(String classId) async {
    try {
      const chars = 'ABCDEFGHJKLMNPQRSTUVWXYZ23456789'; // Exclude ambiguous characters
      const codeLength = 6;
      const maxAttempts = 100;
      
      String? newCode;
      bool isUnique = false;
      
      // Generate unique code
      for (int attempt = 0; attempt < maxAttempts && !isUnique; attempt++) {
        // Generate random code
        final random = Random();
        newCode = String.fromCharCodes(
          Iterable.generate(
            codeLength,
            (_) => chars.codeUnitAt(random.nextInt(chars.length)),
          ),
        );
        
        // Check if code already exists
        final existing = await getClassByEnrollmentCode(newCode);
        isUnique = existing == null;
      }
      
      if (!isUnique || newCode == null) {
        throw Exception('Unable to generate unique enrollment code');
      }
      
      // Update class with new code
      await _firestore.collection('classes').doc(classId).update({
        'enrollmentCode': newCode,
        'updatedAt': FieldValue.serverTimestamp(),
      });
      
      LoggerService.info('Generated new enrollment code for class $classId', tag: tag);
      return newCode;
      
    } catch (e) {
      LoggerService.error('Failed to regenerate enrollment code', tag: tag, error: e);
      rethrow;
    }
  }
}