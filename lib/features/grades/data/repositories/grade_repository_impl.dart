/// Concrete implementation of the grade repository.
///
/// This module implements the GradeRepository interface using
/// Firebase Firestore as the data source. It provides comprehensive
/// grade management functionality with automatic calculations
/// and batch operations.
library;

import 'package:cloud_firestore/cloud_firestore.dart';
import '../../domain/models/grade.dart';
import '../../../../shared/services/firestore_service.dart';
import '../../../../shared/services/logger_service.dart';
import '../../domain/repositories/grade_repository.dart';
import '../../../../shared/repositories/firestore_repository.dart';

/// Firestore-based implementation of GradeRepository.
///
/// This class extends FirestoreRepository to leverage common
/// CRUD operations while implementing grade-specific features:
/// - Automatic grade calculation (percentage and letter grades)
/// - Batch grading operations for efficiency
/// - Grade status management (submitted, graded, returned)
/// - Statistical analysis at multiple levels
/// - Automatic grade initialization for new assignments
/// - Real-time grade streaming
///
/// All operations include comprehensive logging and automatic
/// timestamp management for audit trails.
class GradeRepositoryImpl extends FirestoreRepository<Grade>
    implements GradeRepository {
  /// Firestore instance for direct database operations.
  final FirebaseFirestore _firestore;

  /// Creates a grade repository with Firestore backend.
  ///
  /// Initializes the parent FirestoreRepository with grade-specific
  /// configuration including collection path and serialization functions.
  ///
  /// @param _firestore Firestore database instance
  GradeRepositoryImpl(this._firestore)
      : super(
          firestore: _firestore,
          collectionPath: 'grades',
          fromFirestore: (doc) => Grade.fromFirestore(doc),
          toFirestore: (grade) => grade.toFirestore(),
          logTag: 'GradeRepository',
        );

  /// Creates a new grade entry with automatic calculations.
  ///
  /// Automatically computes:
  /// - Percentage based on points earned vs possible
  /// - Letter grade based on percentage (if not provided)
  /// - Creation and update timestamps
  ///
  /// The grade ID is generated by Firestore for uniqueness.
  ///
  /// @param grade Grade model with score and feedback
  /// @return Generated unique grade ID
  /// @throws Exception if grade creation fails
  @override
  Future<String> createGrade(Grade grade) async {
    try {
      final gradeWithTimestamp = grade.copyWith(
        createdAt: DateTime.now(),
        updatedAt: DateTime.now(),
        percentage:
            Grade.calculatePercentage(grade.pointsEarned, grade.pointsPossible),
        letterGrade: grade.letterGrade ??
            Grade.calculateLetterGrade(Grade.calculatePercentage(
                grade.pointsEarned, grade.pointsPossible)),
      );
      return await create(gradeWithTimestamp);
    } catch (e) {
      LoggerService.error('Failed to create grade', tag: tag, error: e);
      rethrow;
    }
  }

  /// Retrieves a grade by its unique identifier.
  ///
  /// Delegates to parent repository for consistent error handling.
  ///
  /// @param gradeId Unique grade identifier
  /// @return Grade instance or null if not found
  @override
  Future<Grade?> getGrade(String gradeId) => read(gradeId);

  /// Updates an existing grade with recalculation.
  ///
  /// Automatically recalculates:
  /// - Percentage based on new scores
  /// - Letter grade if not explicitly provided
  /// - Update timestamp for audit trail
  ///
  /// Preserves the original grade ID and creation time.
  ///
  /// @param gradeId ID of grade to update
  /// @param grade Updated grade information
  /// @throws Exception if update fails
  @override
  Future<void> updateGrade(String gradeId, Grade grade) async {
    try {
      final updatedGrade = grade.copyWith(
        id: gradeId,
        updatedAt: DateTime.now(),
        percentage:
            Grade.calculatePercentage(grade.pointsEarned, grade.pointsPossible),
        letterGrade: grade.letterGrade ??
            Grade.calculateLetterGrade(Grade.calculatePercentage(
                grade.pointsEarned, grade.pointsPossible)),
      );
      await update(gradeId, updatedGrade);
    } catch (e) {
      LoggerService.error('Failed to update grade', tag: tag, error: e);
      rethrow;
    }
  }

  /// Permanently deletes a grade record.
  ///
  /// This operation cannot be undone. Consider soft deletion
  /// or status changes for recoverable operations.
  ///
  /// @param gradeId ID of grade to delete
  /// @throws Exception if deletion fails
  @override
  Future<void> deleteGrade(String gradeId) => delete(gradeId);

  /// Retrieves the grade for a specific student-assignment pair.
  ///
  /// Queries for the unique grade entry matching both the student
  /// and assignment IDs. Returns null if not yet graded.
  /// Uses limit 1 for efficiency since only one grade should exist
  /// per student-assignment combination.
  ///
  /// @param studentId Student's unique identifier
  /// @param assignmentId Assignment's unique identifier
  /// @return Grade instance or null if not graded
  /// @throws Exception if retrieval fails
  @override
  Future<Grade?> getStudentAssignmentGrade(
      String studentId, String assignmentId) async {
    try {
      final grades = await list(
        conditions: [
          QueryCondition(field: 'studentId', isEqualTo: studentId),
          QueryCondition(field: 'assignmentId', isEqualTo: assignmentId),
        ],
        limit: 1,
      );
      return grades.isNotEmpty ? grades.first : null;
    } catch (e) {
      LoggerService.error('Failed to get student assignment grade',
          tag: tag, error: e);
      rethrow;
    }
  }

  /// Streams all grades for a specific assignment.
  ///
  /// Returns real-time updates of all student grades for an
  /// assignment, ordered by student ID for consistent display.
  /// Useful for grading dashboards and batch operations.
  ///
  /// @param assignmentId Assignment to get grades for
  /// @return Stream of grade lists
  @override
  Stream<List<Grade>> getAssignmentGrades(String assignmentId) {
    return stream(
      conditions: [
        QueryCondition(field: 'assignmentId', isEqualTo: assignmentId),
      ],
      orderBy: [
        OrderBy(field: 'studentId', descending: false),
      ],
    );
  }

  /// Streams all grades for a student in a specific class.
  ///
  /// Returns real-time updates of a student's grades across
  /// all assignments in a class, ordered by most recent first.
  /// Useful for student progress tracking and report cards.
  ///
  /// @param studentId Student's unique identifier
  /// @param classId Class identifier
  /// @return Stream of student's grades in the class
  @override
  Stream<List<Grade>> getStudentClassGrades(String studentId, String classId) {
    return stream(
      conditions: [
        QueryCondition(field: 'studentId', isEqualTo: studentId),
        QueryCondition(field: 'classId', isEqualTo: classId),
      ],
      orderBy: [
        OrderBy(field: 'createdAt', descending: true),
      ],
    );
  }

  /// Streams all grades for a student across all classes.
  ///
  /// Returns comprehensive grade history for a student,
  /// ordered by most recent first. Useful for transcripts
  /// and overall academic progress tracking.
  ///
  /// @param studentId Student's unique identifier
  /// @return Stream of all student grades
  @override
  Stream<List<Grade>> getStudentGrades(String studentId) {
    return stream(
      conditions: [
        QueryCondition(field: 'studentId', isEqualTo: studentId),
      ],
      orderBy: [
        OrderBy(field: 'createdAt', descending: true),
      ],
    );
  }

  /// Submits a grade for an assignment.
  ///
  /// Handles both new grade creation and existing grade updates:
  /// - If grade.id is empty, creates a new grade entry
  /// - If grade.id exists, updates the existing grade
  ///
  /// Automatically sets:
  /// - Status to 'graded'
  /// - Graded timestamp
  /// - Update timestamp
  ///
  /// @param grade Grade to submit with score and feedback
  /// @throws Exception if submission fails
  @override
  Future<void> submitGrade(Grade grade) async {
    try {
      final submittedGrade = grade.copyWith(
        status: GradeStatus.graded,
        gradedAt: DateTime.now(),
        updatedAt: DateTime.now(),
      );
      if (grade.id.isEmpty) {
        await createGrade(submittedGrade);
      } else {
        await updateGrade(grade.id, submittedGrade);
      }
    } catch (e) {
      LoggerService.error('Failed to submit grade', tag: tag, error: e);
      rethrow;
    }
  }

  /// Returns multiple grades to students in batch.
  ///
  /// Uses Firestore batch operations for efficiency and atomicity.
  /// All grades are returned with the same timestamp, ensuring
  /// consistent release time. Updates:
  /// - Status to 'returned'
  /// - Return timestamp
  /// - Update timestamp
  ///
  /// This may trigger notifications to students about grade availability.
  ///
  /// @param gradeIds List of grade IDs to return
  /// @throws Exception if batch return fails
  @override
  Future<void> returnGrades(List<String> gradeIds) async {
    try {
      final batch = _firestore.batch();
      final now = DateTime.now();

      for (final gradeId in gradeIds) {
        final gradeRef = _firestore.collection('grades').doc(gradeId);
        batch.update(gradeRef, {
          'status': GradeStatus.returned.name,
          'returnedAt': Timestamp.fromDate(now),
          'updatedAt': Timestamp.fromDate(now),
        });
      }

      await batch.commit();
      LoggerService.info('Returned ${gradeIds.length} grades', tag: tag);
    } catch (e) {
      LoggerService.error('Failed to return grades', tag: tag, error: e);
      rethrow;
    }
  }

  /// Returns a single grade to a student.
  ///
  /// Makes the grade visible to the student by updating:
  /// - Status to 'returned'
  /// - Return timestamp for tracking
  /// - Update timestamp for audit trail
  ///
  /// Individual return useful for immediate feedback scenarios.
  ///
  /// @param gradeId Grade ID to return
  /// @throws Exception if return fails
  @override
  Future<void> returnGrade(String gradeId) async {
    try {
      final now = DateTime.now();
      await _firestore.collection('grades').doc(gradeId).update({
        'status': GradeStatus.returned.name,
        'returnedAt': Timestamp.fromDate(now),
        'updatedAt': Timestamp.fromDate(now),
      });
      LoggerService.info('Returned grade $gradeId', tag: tag);
    } catch (e) {
      LoggerService.error('Failed to return grade', tag: tag, error: e);
      rethrow;
    }
  }

  /// Streams all grades for an entire class.
  ///
  /// Returns real-time updates of all grades across all
  /// assignments and students in a class. Ordered by
  /// most recent first for activity monitoring.
  ///
  /// @param classId Class identifier
  /// @return Stream of all grades in the class
  @override
  Stream<List<Grade>> getClassGrades(String classId) {
    return stream(
      conditions: [
        QueryCondition(field: 'classId', isEqualTo: classId),
      ],
      orderBy: [
        OrderBy(field: 'createdAt', descending: true),
      ],
    );
  }

  /// Calculates comprehensive statistics for an assignment.
  ///
  /// Aggregates data from all graded and returned grades to compute:
  /// - Average, median, and mode scores
  /// - Grade distribution (A-F breakdown)
  /// - Completion rates
  /// - Standard deviation
  /// - High/low scores
  ///
  /// Only includes grades with status 'graded' or 'returned',
  /// excluding incomplete submissions.
  ///
  /// @param assignmentId Assignment to analyze
  /// @return Statistical summary of grades
  /// @throws Exception if calculation fails
  @override
  Future<GradeStatistics> getAssignmentStatistics(String assignmentId) async {
    try {
      final grades = await list(
        conditions: [
          QueryCondition(field: 'assignmentId', isEqualTo: assignmentId),
          QueryCondition(field: 'status', whereIn: [
            GradeStatus.graded.name,
            GradeStatus.returned.name,
          ]),
        ],
      );
      return GradeStatistics.fromGrades(grades);
    } catch (e) {
      LoggerService.error('Failed to get assignment statistics',
          tag: tag, error: e);
      rethrow;
    }
  }

  /// Calculates grade statistics for a student in a class.
  ///
  /// Generates student-specific performance metrics including:
  /// - Overall average across assignments
  /// - Assignment completion rate
  /// - Grade trends over time
  /// - Performance relative to class average
  /// - Strengths and areas for improvement
  ///
  /// Only includes completed grades (graded or returned status).
  ///
  /// @param studentId Student to analyze
  /// @param classId Class context
  /// @return Student's statistical summary
  /// @throws Exception if calculation fails
  @override
  Future<GradeStatistics> getStudentClassStatistics(
      String studentId, String classId) async {
    try {
      final grades = await list(
        conditions: [
          QueryCondition(field: 'studentId', isEqualTo: studentId),
          QueryCondition(field: 'classId', isEqualTo: classId),
          QueryCondition(field: 'status', whereIn: [
            GradeStatus.graded.name,
            GradeStatus.returned.name,
          ]),
        ],
      );
      return GradeStatistics.fromGrades(grades);
    } catch (e) {
      LoggerService.error('Failed to get student class statistics',
          tag: tag, error: e);
      rethrow;
    }
  }

  /// Calculates overall statistics for an entire class.
  ///
  /// Aggregates performance data across all students and assignments:
  /// - Class average and grade distribution
  /// - Assignment difficulty indicators
  /// - Student performance rankings
  /// - Completion rates by assignment
  /// - Trends over academic period
  ///
  /// Useful for identifying class-wide patterns and adjusting
  /// teaching strategies.
  ///
  /// @param classId Class to analyze
  /// @return Class statistical summary
  /// @throws Exception if calculation fails
  @override
  Future<GradeStatistics> getClassStatistics(String classId) async {
    try {
      final grades = await list(
        conditions: [
          QueryCondition(field: 'classId', isEqualTo: classId),
          QueryCondition(field: 'status', whereIn: [
            GradeStatus.graded.name,
            GradeStatus.returned.name,
          ]),
        ],
      );
      return GradeStatistics.fromGrades(grades);
    } catch (e) {
      LoggerService.error('Failed to get class statistics', tag: tag, error: e);
      rethrow;
    }
  }

  /// Updates multiple grades in a single atomic operation.
  ///
  /// Efficient batch update for grading multiple submissions at once.
  /// All updates succeed or fail together, ensuring consistency.
  ///
  /// For each grade:
  /// - Recalculates percentage and letter grade
  /// - Updates modification timestamp
  /// - Preserves other grade properties
  ///
  /// Particularly useful for:
  /// - Grading all submissions for an assignment
  /// - Applying curve adjustments
  /// - Bulk feedback updates
  ///
  /// @param grades Map of grade IDs to updated grade objects
  /// @throws Exception if batch update fails
  @override
  Future<void> batchUpdateGrades(Map<String, Grade> grades) async {
    try {
      final batch = _firestore.batch();
      final now = DateTime.now();

      grades.forEach((gradeId, grade) {
        final gradeRef = _firestore.collection('grades').doc(gradeId);
        final updatedGrade = grade.copyWith(
          updatedAt: now,
          percentage: Grade.calculatePercentage(
              grade.pointsEarned, grade.pointsPossible),
          letterGrade: grade.letterGrade ??
              Grade.calculateLetterGrade(Grade.calculatePercentage(
                  grade.pointsEarned, grade.pointsPossible)),
        );
        batch.update(gradeRef, updatedGrade.toFirestore());
      });

      await batch.commit();
      LoggerService.info('Batch updated ${grades.length} grades', tag: tag);
    } catch (e) {
      LoggerService.error('Failed to batch update grades', tag: tag, error: e);
      rethrow;
    }
  }

  /// Initializes grade records for all students in a class.
  ///
  /// Creates placeholder grade entries when a new assignment is created,
  /// allowing teachers to track:
  /// - Which students haven't submitted
  /// - Overall completion rates
  /// - Missing work patterns
  ///
  /// Process:
  /// 1. Queries all students enrolled in the class
  /// 2. Creates a grade entry for each student with:
  ///    - Zero points earned initially
  ///    - Status set to 'notSubmitted'
  ///    - Student name cached for display
  /// 3. Uses batch operations for efficiency
  ///
  /// This enables proactive grade management rather than
  /// reactive entry after submission.
  ///
  /// @param assignmentId New assignment identifier
  /// @param classId Class with enrolled students
  /// @param teacherId Teacher creating the assignment
  /// @param totalPoints Maximum possible score
  /// @throws Exception if initialization fails
  @override
  Future<void> initializeGradesForAssignment(
    String assignmentId,
    String classId,
    String teacherId,
    double totalPoints,
  ) async {
    try {
      // Get all students in the class
      final studentQuery = await _firestore
          .collection('students')
          .where('classIds', arrayContains: classId)
          .get();

      final batch = _firestore.batch();
      final now = DateTime.now();

      for (final studentDoc in studentQuery.docs) {
        final studentId = studentDoc.id;
        final studentData = studentDoc.data();
        final studentName = studentData['displayName'] ?? 'Unknown Student';

        // Create a new grade for each student
        final gradeRef = _firestore.collection('grades').doc();
        final grade = Grade(
          id: gradeRef.id,
          studentId: studentId,
          studentName: studentName,
          assignmentId: assignmentId,
          teacherId: teacherId,
          classId: classId,
          pointsEarned: 0,
          pointsPossible: totalPoints,
          percentage: 0,
          letterGrade: 'F',
          feedback: '',
          status: GradeStatus.notSubmitted,
          createdAt: now,
          updatedAt: now,
        );

        batch.set(gradeRef, grade.toFirestore());
      }

      await batch.commit();
      LoggerService.info(
        'Initialized grades for ${studentQuery.docs.length} students in assignment $assignmentId',
        tag: tag,
      );
    } catch (e) {
      LoggerService.error('Failed to initialize grades for assignment',
          tag: tag, error: e);
      rethrow;
    }
  }
}
