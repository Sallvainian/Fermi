/// Concrete implementation of the chat repository.
/// 
/// This module implements the ChatRepository interface using
/// Firebase Firestore as the data source. It provides comprehensive
/// chat functionality with real-time messaging and status tracking.
library;

import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:firebase_auth/firebase_auth.dart';
import '../models/message.dart';
import '../models/chat_room.dart';
import '../services/firestore_service.dart';
import '../services/logger_service.dart';
import 'chat_repository.dart';
import 'firestore_repository.dart';

/// Firestore-based implementation of ChatRepository.
/// 
/// This class extends FirestoreRepository to leverage common
/// CRUD operations while implementing chat-specific features:
/// - Direct and group chat creation with participant management
/// - Real-time messaging with delivery/read status tracking
/// - Message editing and deletion with audit trails
/// - Typing indicators and unread message counts
/// - Message search and chat room discovery
/// - Batch operations for performance optimization
/// 
/// Uses Firebase Auth for user identification and role detection.
/// Messages are stored as a subcollection under each chat room.
class ChatRepositoryImpl extends FirestoreRepository<ChatRoom> implements ChatRepository {
  /// Logger tag for this repository.
  static const String _tag = 'ChatRepository';
  
  /// Firestore instance for direct database operations.
  final FirebaseFirestore _firestore;
  
  /// Firebase Auth for user identification.
  final FirebaseAuth _auth;

  /// Creates a chat repository with Firestore and Auth integration.
  /// 
  /// Initializes the parent FirestoreRepository with chat-specific
  /// configuration and sets up authentication integration.
  /// 
  /// @param _firestore Firestore database instance
  /// @param _auth Firebase Auth instance
  ChatRepositoryImpl(this._firestore, this._auth)
      : super(
          firestore: _firestore,
          collectionPath: 'chat_rooms',
          fromFirestore: (doc) => ChatRoom.fromFirestore(doc),
          toFirestore: (chatRoom) => chatRoom.toFirestore(),
          logTag: _tag,
        );

  /// Gets the current user's ID from Firebase Auth.
  /// 
  /// Returns empty string if no user is authenticated.
  String get _currentUserId => _auth.currentUser?.uid ?? '';

  /// Creates a new chat room with automatic timestamps.
  /// 
  /// Sets creation and update timestamps to current time.
  /// The chat room ID is generated by Firestore for uniqueness.
  /// 
  /// @param chatRoom Chat room configuration with participants
  /// @return Generated unique chat room ID
  /// @throws Exception if creation fails
  @override
  Future<String> createChatRoom(ChatRoom chatRoom) async {
    try {
      final chatRoomToCreate = chatRoom.copyWith(
        createdAt: DateTime.now(),
        updatedAt: DateTime.now(),
      );
      return await create(chatRoomToCreate);
    } catch (e) {
      LoggerService.error('Failed to create chat room', tag: _tag, error: e);
      rethrow;
    }
  }

  /// Retrieves a chat room by its unique identifier.
  /// 
  /// Delegates to parent repository for consistent error handling.
  /// 
  /// @param id Unique chat room identifier
  /// @return Chat room instance or null if not found
  @override
  Future<ChatRoom?> getChatRoom(String id) => read(id);

  /// Updates an existing chat room with new timestamp.
  /// 
  /// Automatically updates the modification timestamp while
  /// preserving other metadata like creation date.
  /// 
  /// @param id Chat room ID to update
  /// @param chatRoom Updated chat room information
  /// @throws Exception if update fails
  @override
  Future<void> updateChatRoom(String id, ChatRoom chatRoom) async {
    try {
      final chatRoomToUpdate = chatRoom.copyWith(
        updatedAt: DateTime.now(),
      );
      await update(id, chatRoomToUpdate);
    } catch (e) {
      LoggerService.error('Failed to update chat room', tag: _tag, error: e);
      rethrow;
    }
  }

  /// Permanently deletes a chat room and all messages.
  /// 
  /// This operation cannot be undone. Consider archiving
  /// for recoverable operations.
  /// 
  /// @param id Chat room ID to delete
  /// @throws Exception if deletion fails
  @override
  Future<void> deleteChatRoom(String id) => delete(id);

  /// Creates or retrieves an existing direct chat.
  /// 
  /// Intelligent chat handling:
  /// - Checks for existing direct chat between users
  /// - Returns existing chat if found
  /// - Creates new direct chat if none exists
  /// 
  /// This ensures users don't create duplicate direct chats.
  /// Direct chats are named after the other participant.
  /// 
  /// @param otherUserId ID of the other participant
  /// @param otherUserName Display name of other participant
  /// @param otherUserRole Role of other participant
  /// @return Created or existing chat room
  /// @throws Exception if operation fails
  @override
  Future<ChatRoom> createOrGetDirectChat(
    String otherUserId,
    String otherUserName,
    String otherUserRole,
  ) async {
    try {
      // Check if direct chat already exists
      final existing = await findDirectChat(_currentUserId, otherUserId);
      if (existing != null) {
        return existing;
      }

      // Create new direct chat
      final participants = [
        ParticipantInfo(
          id: _currentUserId,
          name: _auth.currentUser?.displayName ?? 'User',
          role: 'user', // This should be fetched from user profile
        ),
        ParticipantInfo(
          id: otherUserId,
          name: otherUserName,
          role: otherUserRole,
        ),
      ];

      final chatRoom = ChatRoom(
        id: '',
        name: otherUserName,
        type: 'direct',
        participantIds: [_currentUserId, otherUserId],
        participants: participants,
        createdBy: _currentUserId,
        createdAt: DateTime.now(),
        updatedAt: DateTime.now(),
      );

      final id = await createChatRoom(chatRoom);
      return chatRoom.copyWith(id: id);
    } catch (e) {
      LoggerService.error('Failed to create or get direct chat', tag: _tag, error: e);
      rethrow;
    }
  }

  /// Creates a new group chat room.
  /// 
  /// Supports different group types:
  /// - 'group': General purpose groups
  /// - 'class': Class-specific discussions
  /// - 'announcement': Broadcast channels
  /// 
  /// Automatically adds the creator as a participant.
  /// 
  /// @param name Display name for the group
  /// @param type Group type identifier
  /// @param participantIds List of participant user IDs
  /// @param participants List of participant info objects
  /// @param classId Optional class association
  /// @return Created group chat room
  /// @throws Exception if creation fails
  @override
  Future<ChatRoom> createGroupChat({
    required String name,
    required String type,
    required List<String> participantIds,
    required List<ParticipantInfo> participants,
    String? classId,
  }) async {
    try {
      final chatRoom = ChatRoom(
        id: '',
        name: name,
        type: type,
        participantIds: participantIds,
        participants: participants,
        classId: classId,
        createdBy: _currentUserId,
        createdAt: DateTime.now(),
        updatedAt: DateTime.now(),
      );

      final id = await createChatRoom(chatRoom);
      return chatRoom.copyWith(id: id);
    } catch (e) {
      LoggerService.error('Failed to create group chat', tag: _tag, error: e);
      rethrow;
    }
  }

  /// Sends a message to a chat room.
  /// 
  /// Process:
  /// 1. Creates message with sender info and timestamp
  /// 2. Adds to messages subcollection
  /// 3. Updates chat room's last message info
  /// 4. Increments unread counts for other participants
  /// 
  /// Supports text messages and attachments.
  /// 
  /// @param chatRoomId Target chat room
  /// @param content Message text content
  /// @param attachmentUrl Optional file attachment URL
  /// @param attachmentType Optional attachment MIME type
  /// @return Generated message ID
  /// @throws Exception if sending fails
  @override
  Future<String> sendMessage({
    required String chatRoomId,
    required String content,
    String? attachmentUrl,
    String? attachmentType,
  }) async {
    try {
      final message = Message(
        id: '',
        senderId: _currentUserId,
        senderName: _auth.currentUser?.displayName ?? 'User',
        senderRole: _auth.currentUser?.email?.endsWith('@teacher.edu') == true ? 'teacher' : 'student',
        content: content,
        attachmentUrl: attachmentUrl,
        attachmentType: attachmentType,
        timestamp: DateTime.now(),
      );

      // Add message to subcollection
      final ref = _firestore
          .collection('chat_rooms')
          .doc(chatRoomId)
          .collection('messages')
          .doc();
      
      final messageWithId = message.copyWith(id: ref.id);
      await ref.set(messageWithId.toFirestore());

      // Update last message in chat room
      await updateLastMessage(chatRoomId, messageWithId);

      LoggerService.info('Message sent to chat room $chatRoomId', tag: _tag);
      return ref.id;
    } catch (e) {
      LoggerService.error('Failed to send message', tag: _tag, error: e);
      rethrow;
    }
  }

  /// Deletes a message from a chat room.
  /// 
  /// Permanently removes the message. Consider soft deletion
  /// by updating message content for audit trails.
  /// 
  /// @param chatRoomId Chat room containing the message
  /// @param messageId Message to delete
  /// @throws Exception if deletion fails
  @override
  Future<void> deleteMessage(String chatRoomId, String messageId) async {
    try {
      await _firestore
          .collection('chat_rooms')
          .doc(chatRoomId)
          .collection('messages')
          .doc(messageId)
          .delete();
      
      LoggerService.info('Message $messageId deleted from chat room $chatRoomId', tag: _tag);
    } catch (e) {
      LoggerService.error('Failed to delete message', tag: _tag, error: e);
      rethrow;
    }
  }

  /// Edits an existing message content.
  /// 
  /// Updates the message content and marks it as edited
  /// with an edit timestamp for transparency.
  /// 
  /// @param chatRoomId Chat room containing the message
  /// @param messageId Message to edit
  /// @param newContent Updated message content
  /// @throws Exception if edit fails
  @override
  Future<void> editMessage(String chatRoomId, String messageId, String newContent) async {
    try {
      await _firestore
          .collection('chat_rooms')
          .doc(chatRoomId)
          .collection('messages')
          .doc(messageId)
          .update({
            'content': newContent,
            'isEdited': true,
            'editedAt': FieldValue.serverTimestamp(),
          });
      
      LoggerService.info('Message $messageId edited in chat room $chatRoomId', tag: _tag);
    } catch (e) {
      LoggerService.error('Failed to edit message', tag: _tag, error: e);
      rethrow;
    }
  }

  /// Streams all chat rooms for the current user.
  /// 
  /// Returns real-time updates of chat rooms where the user
  /// is a participant, ordered by most recent activity.
  /// 
  /// @return Stream of user's chat room lists
  @override
  Stream<List<ChatRoom>> getUserChatRooms() {
    return stream(
      conditions: [
        QueryCondition(field: 'participantIds', arrayContains: _currentUserId),
      ],
      orderBy: [OrderBy(field: 'updatedAt', descending: true)],
    );
  }

  /// Streams messages for a specific chat room.
  /// 
  /// Returns real-time updates of the latest 100 messages,
  /// ordered by most recent first for chat UI display.
  /// 
  /// @param chatRoomId Chat room to monitor
  /// @return Stream of message lists
  @override
  Stream<List<Message>> getChatMessages(String chatRoomId) {
    return _firestore
        .collection('chat_rooms')
        .doc(chatRoomId)
        .collection('messages')
        .orderBy('timestamp', descending: true)
        .limit(100)
        .snapshots()
        .map((snapshot) => snapshot.docs
            .map((doc) => Message.fromFirestore(doc))
            .toList());
  }

  /// Adds a participant to a chat room.
  /// 
  /// Updates both the participant ID list and participant
  /// info array. Uses arrayUnion to prevent duplicates.
  /// 
  /// @param chatRoomId Chat room to update
  /// @param userId New participant's user ID
  /// @param participantInfo New participant's info
  /// @throws Exception if addition fails
  @override
  Future<void> addParticipant(String chatRoomId, String userId, ParticipantInfo participantInfo) async {
    try {
      await _firestore.collection('chat_rooms').doc(chatRoomId).update({
        'participantIds': FieldValue.arrayUnion([userId]),
        'participants': FieldValue.arrayUnion([participantInfo.toMap()]),
        'updatedAt': FieldValue.serverTimestamp(),
      });
      
      LoggerService.info('Participant $userId added to chat room $chatRoomId', tag: _tag);
    } catch (e) {
      LoggerService.error('Failed to add participant', tag: _tag, error: e);
      rethrow;
    }
  }

  /// Removes a participant from a chat room.
  /// 
  /// Retrieves participant info to ensure complete removal
  /// from both ID and info arrays.
  /// 
  /// @param chatRoomId Chat room to update
  /// @param userId Participant to remove
  /// @throws Exception if removal fails
  @override
  Future<void> removeParticipant(String chatRoomId, String userId) async {
    try {
      // Get chat room to find participant info
      final chatRoom = await getChatRoom(chatRoomId);
      if (chatRoom == null) return;

      final participant = chatRoom.participants.firstWhere(
        (p) => p.id == userId,
        orElse: () => ParticipantInfo(id: userId, name: '', role: ''),
      );

      await _firestore.collection('chat_rooms').doc(chatRoomId).update({
        'participantIds': FieldValue.arrayRemove([userId]),
        'participants': FieldValue.arrayRemove([participant.toMap()]),
        'updatedAt': FieldValue.serverTimestamp(),
      });
      
      LoggerService.info('Participant $userId removed from chat room $chatRoomId', tag: _tag);
    } catch (e) {
      LoggerService.error('Failed to remove participant', tag: _tag, error: e);
      rethrow;
    }
  }

  /// Removes the current user from a chat room.
  /// 
  /// Convenience method that removes the authenticated
  /// user as a participant.
  /// 
  /// @param chatRoomId Chat room to leave
  /// @throws Exception if leaving fails
  @override
  Future<void> leaveChatRoom(String chatRoomId) async {
    try {
      await removeParticipant(chatRoomId, _currentUserId);
    } catch (e) {
      LoggerService.error('Failed to leave chat room', tag: _tag, error: e);
      rethrow;
    }
  }

  /// Updates the chat room's last message metadata.
  /// 
  /// Stores message preview information for chat list display.
  /// Updates modification timestamp for proper ordering.
  /// 
  /// @param chatRoomId Chat room to update
  /// @param message Latest message sent
  /// @throws Exception if update fails
  @override
  Future<void> updateLastMessage(String chatRoomId, Message message) async {
    try {
      await _firestore.collection('chat_rooms').doc(chatRoomId).update({
        'lastMessage': message.content,
        'lastMessageTime': message.timestamp,
        'lastMessageSenderId': message.senderId,
        'lastMessageSenderName': message.senderName,
        'updatedAt': FieldValue.serverTimestamp(),
      });
    } catch (e) {
      LoggerService.error('Failed to update last message', tag: _tag, error: e);
      rethrow;
    }
  }

  /// Marks all unread messages in a chat as read.
  /// 
  /// Process:
  /// 1. Queries unread messages from other users
  /// 2. Batch updates status to 'read'
  /// 3. Resets unread count for current user
  /// 
  /// Uses batch operations for efficiency with many messages.
  /// 
  /// @param chatRoomId Chat room to mark as read
  /// @throws Exception if marking fails
  @override
  Future<void> markMessagesAsRead(String chatRoomId) async {
    try {
      // Get all delivered messages and filter in memory to avoid complex index
      final deliveredMessages = await _firestore
          .collection('chat_rooms')
          .doc(chatRoomId)
          .collection('messages')
          .where('status', isEqualTo: MessageStatus.delivered.name)
          .get();
          
      // Filter out current user's messages
      final unreadMessages = deliveredMessages.docs
          .where((doc) => doc.data()['senderId'] != _currentUserId)
          .toList();

      // Batch update to read status
      final batch = _firestore.batch();
      for (final doc in unreadMessages) {
        batch.update(doc.reference, {
          'status': MessageStatus.read.name,
          'readAt': FieldValue.serverTimestamp(),
        });
      }
      
      await batch.commit();
      
      // Update unread count in chat room
      await _firestore.collection('chat_rooms').doc(chatRoomId).update({
        'unreadCounts.$_currentUserId': 0,
      });
      
      LoggerService.info('Marked ${unreadMessages.length} messages as read', tag: _tag);
    } catch (e) {
      LoggerService.error('Failed to mark messages as read', tag: _tag, error: e);
      rethrow;
    }
  }

  /// Marks a single message as delivered.
  /// 
  /// Updates message status and records delivery timestamp.
  /// Typically called when message appears in recipient's UI.
  /// 
  /// @param chatRoomId Chat room containing the message
  /// @param messageId Message to mark as delivered
  /// @throws Exception if marking fails
  @override
  Future<void> markMessageAsDelivered(String chatRoomId, String messageId) async {
    try {
      await _firestore
          .collection('chat_rooms')
          .doc(chatRoomId)
          .collection('messages')
          .doc(messageId)
          .update({
            'status': MessageStatus.delivered.name,
            'deliveredAt': FieldValue.serverTimestamp(),
          });
    } catch (e) {
      LoggerService.error('Failed to mark message as delivered', tag: _tag, error: e);
      rethrow;
    }
  }

  /// Searches for messages containing specific text.
  /// 
  /// Performs case-insensitive search through message content.
  /// Current implementation loads all messages and filters
  /// client-side. For production with large message volumes,
  /// consider implementing server-side search with:
  /// - Firestore composite indexes
  /// - External search services (Algolia, Elasticsearch)
  /// - Pagination for large result sets
  /// 
  /// @param chatRoomId Chat room to search within
  /// @param query Search terms to match
  /// @return List of matching messages
  /// @throws Exception if search fails
  @override
  Future<List<Message>> searchMessages(String chatRoomId, String query) async {
    try {
      // Note: This is a simple implementation. For better search,
      // consider using a search service like Algolia
      final messages = await _firestore
          .collection('chat_rooms')
          .doc(chatRoomId)
          .collection('messages')
          .get();
      
      final lowercaseQuery = query.toLowerCase();
      return messages.docs
          .map((doc) => Message.fromFirestore(doc))
          .where((message) => message.content.toLowerCase().contains(lowercaseQuery))
          .toList();
    } catch (e) {
      LoggerService.error('Failed to search messages', tag: _tag, error: e);
      rethrow;
    }
  }

  /// Searches for chat rooms by name.
  /// 
  /// Performs case-insensitive search through chat room names
  /// where the user is a participant. Client-side filtering
  /// approach suitable for moderate chat room counts.
  /// 
  /// @param query Search terms to match room names
  /// @return List of matching chat rooms
  /// @throws Exception if search fails
  @override
  Future<List<ChatRoom>> searchChatRooms(String query) async {
    try {
      final chatRooms = await list(
        conditions: [
          QueryCondition(field: 'participantIds', arrayContains: _currentUserId),
        ],
      );
      
      final lowercaseQuery = query.toLowerCase();
      return chatRooms.where((room) => 
        room.name.toLowerCase().contains(lowercaseQuery)
      ).toList();
    } catch (e) {
      LoggerService.error('Failed to search chat rooms', tag: _tag, error: e);
      rethrow;
    }
  }

  /// Finds an existing direct chat between two users.
  /// 
  /// Searches for a direct chat room containing exactly the
  /// specified two users. Used to prevent duplicate direct
  /// chat creation.
  /// 
  /// @param userId1 First user's ID
  /// @param userId2 Second user's ID
  /// @return Existing chat room or null if none found
  /// @throws Exception if search fails
  @override
  Future<ChatRoom?> findDirectChat(String userId1, String userId2) async {
    try {
      final chatRooms = await list(
        conditions: [
          QueryCondition(field: 'type', isEqualTo: 'direct'),
          QueryCondition(field: 'participantIds', arrayContains: userId1),
        ],
      );
      
      return chatRooms.firstWhere(
        (room) => room.participantIds.contains(userId2) && room.participantIds.length == 2,
        orElse: () => null as dynamic,
      );
    } catch (e) {
      LoggerService.error('Failed to find direct chat', tag: _tag, error: e);
      rethrow;
    }
  }

  /// Updates the current user's typing status.
  /// 
  /// Sets or clears typing indicator for real-time feedback.
  /// Status is stored per-user in the chat room document.
  /// 
  /// @param chatRoomId Chat room where typing occurs
  /// @param isTyping true if typing, false when stopped
  /// @throws Exception if status update fails
  @override
  Future<void> setTypingStatus(String chatRoomId, bool isTyping) async {
    try {
      await _firestore.collection('chat_rooms').doc(chatRoomId).update({
        'typingUsers.$_currentUserId': isTyping,
      });
    } catch (e) {
      LoggerService.error('Failed to set typing status', tag: _tag, error: e);
      rethrow;
    }
  }

  /// Streams real-time typing status for all users.
  /// 
  /// Returns a map of user IDs to typing status (true/false).
  /// Updates in real-time as users start or stop typing.
  /// Empty map returned if no typing data available.
  /// 
  /// @param chatRoomId Chat room to monitor
  /// @return Stream of user typing statuses
  @override
  Stream<Map<String, bool>> getTypingStatuses(String chatRoomId) {
    return _firestore
        .collection('chat_rooms')
        .doc(chatRoomId)
        .snapshots()
        .map((snapshot) {
          final data = snapshot.data();
          if (data != null && data['typingUsers'] != null) {
            return Map<String, bool>.from(data['typingUsers'] as Map);
          }
          return {};
        });
  }

  /// Gets unread message count for current user.
  /// 
  /// Retrieves the cached unread count from the chat room
  /// document. Returns 0 if no count found or on error.
  /// Count is updated when new messages arrive.
  /// 
  /// @param chatRoomId Chat room to check
  /// @return Number of unread messages
  @override
  Future<int> getUnreadCount(String chatRoomId) async {
    try {
      final chatRoom = await getChatRoom(chatRoomId);
      if (chatRoom?.unreadCounts != null) {
        return chatRoom!.unreadCounts![_currentUserId] ?? 0;
      }
      return 0;
    } catch (e) {
      LoggerService.error('Failed to get unread count', tag: _tag, error: e);
      return 0;
    }
  }

  /// Gets unread counts across all user's chat rooms.
  /// 
  /// Aggregates unread message counts from all chat rooms
  /// where the user is a participant. Useful for:
  /// - Badge counts in navigation
  /// - Notification summaries
  /// - Priority sorting of chats
  /// 
  /// @return Map of chat room ID to unread count
  @override
  Future<Map<String, int>> getAllUnreadCounts() async {
    try {
      final chatRooms = await list(
        conditions: [
          QueryCondition(field: 'participantIds', arrayContains: _currentUserId),
        ],
      );
      
      final unreadCounts = <String, int>{};
      for (final room in chatRooms) {
        if (room.unreadCounts != null && room.unreadCounts![_currentUserId] != null) {
          unreadCounts[room.id] = room.unreadCounts![_currentUserId]!;
        }
      }
      
      return unreadCounts;
    } catch (e) {
      LoggerService.error('Failed to get all unread counts', tag: _tag, error: e);
      return {};
    }
  }

  /// Deletes multiple messages in one atomic operation.
  /// 
  /// Efficient bulk deletion for:
  /// - Message cleanup
  /// - Moderation actions
  /// - Storage management
  /// 
  /// All deletions succeed or fail together.
  /// 
  /// @param chatRoomId Chat room containing messages
  /// @param messageIds List of message IDs to delete
  /// @throws Exception if batch deletion fails
  @override
  Future<void> batchDeleteMessages(String chatRoomId, List<String> messageIds) async {
    try {
      final batch = _firestore.batch();
      
      for (final messageId in messageIds) {
        final ref = _firestore
            .collection('chat_rooms')
            .doc(chatRoomId)
            .collection('messages')
            .doc(messageId);
        batch.delete(ref);
      }
      
      await batch.commit();
      LoggerService.info('Batch deleted ${messageIds.length} messages', tag: _tag);
    } catch (e) {
      LoggerService.error('Failed to batch delete messages', tag: _tag, error: e);
      rethrow;
    }
  }

  /// Updates multiple message statuses in one atomic operation.
  /// 
  /// Efficient bulk status update for:
  /// - Marking multiple messages as delivered
  /// - Batch marking as read
  /// - Status synchronization
  /// 
  /// Automatically sets appropriate timestamps:
  /// - deliveredAt for delivered status
  /// - readAt for read status
  /// 
  /// @param chatRoomId Chat room containing messages
  /// @param messageIds List of message IDs to update
  /// @param status New status to apply
  /// @throws Exception if batch update fails
  @override
  Future<void> batchUpdateMessageStatus(String chatRoomId, List<String> messageIds, MessageStatus status) async {
    try {
      final batch = _firestore.batch();
      final now = DateTime.now();
      
      for (final messageId in messageIds) {
        final ref = _firestore
            .collection('chat_rooms')
            .doc(chatRoomId)
            .collection('messages')
            .doc(messageId);
        
        final updates = <String, dynamic>{
          'status': status.name,
        };
        
        if (status == MessageStatus.delivered) {
          updates['deliveredAt'] = now;
        } else if (status == MessageStatus.read) {
          updates['readAt'] = now;
        }
        
        batch.update(ref, updates);
      }
      
      await batch.commit();
      LoggerService.info('Batch updated ${messageIds.length} messages to status ${status.name}', tag: _tag);
    } catch (e) {
      LoggerService.error('Failed to batch update message status', tag: _tag, error: e);
      rethrow;
    }
  }
}