This file is a merged representation of the entire codebase, combined into a single document by Repomix.

# File Summary

## Purpose
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

## File Format
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  a. A header with the file path (## File: path/to/file)
  b. The full contents of the file in a code block

## Usage Guidelines
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

## Notes
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)

# Directory Structure
```
.github/dependa-bot.yml
.github/workflows/apisec-scan.yml
.github/workflows/build.yml
.github/workflows/claude.yml
.github/workflows/qodana_code_quality.yml
.gitignore
.snapshots/config.json
.snapshots/readme.md
.snapshots/sponsors.md
analysis_options.yaml
android/.gitignore
android/app/build.gradle.kts
android/app/proguard-rules.pro
android/app/src/debug/AndroidManifest.xml
android/app/src/main/AndroidManifest.xml
android/app/src/main/java/io/flutter/plugins/GeneratedPluginRegistrant.java
android/app/src/main/kotlin/com/teacherdashboard/teacher_dashboard_flutter_firebase/MainActivity.kt
android/app/src/main/res/drawable-v21/launch_background.xml
android/app/src/main/res/drawable/launch_background.xml
android/app/src/main/res/values-night/styles.xml
android/app/src/main/res/values/styles.xml
android/app/src/main/res/xml/network_security_config.xml
android/app/src/profile/AndroidManifest.xml
android/build.gradle.kts
android/build/reports/problems/problems-report.html
android/gradle/wrapper/gradle-wrapper.properties
android/settings.gradle.kts
docker-compose.yml
firebase_options.dart
firebase.json
firestore.indexes.json
firestore.rules
ios/.gitignore
ios/Flutter/AppFrameworkInfo.plist
ios/Flutter/Debug.xcconfig
ios/Flutter/Release.xcconfig
ios/Runner.xcodeproj/project.pbxproj
ios/Runner.xcworkspace/contents.xcworkspacedata
ios/Runner/AppDelegate.swift
ios/Runner/Assets.xcassets/AppIcon.appiconset/Contents.json
ios/Runner/Assets.xcassets/LaunchImage.imageset/Contents.json
ios/Runner/Assets.xcassets/LaunchImage.imageset/README.md
ios/Runner/Base.lproj/LaunchScreen.storyboard
ios/Runner/Base.lproj/Main.storyboard
ios/Runner/Info.plist
ios/Runner/Runner-Bridging-Header.h
ios/Runner/upload_dsyms.sh
ios/RunnerTests/RunnerTests.swift
lib/config/firebase_options.dart
lib/features/assignments/data/repositories/assignment_repository_impl.dart
lib/features/assignments/data/repositories/submission_repository_impl.dart
lib/features/assignments/data/services/assignment_service.dart
lib/features/assignments/data/services/submission_service.dart
lib/features/assignments/domain/models/assignment.dart
lib/features/assignments/domain/models/submission.dart
lib/features/assignments/domain/repositories/assignment_repository.dart
lib/features/assignments/domain/repositories/submission_repository.dart
lib/features/assignments/presentation/providers/assignment_provider.dart
lib/features/assignments/presentation/providers/student_assignment_provider.dart
lib/features/assignments/presentation/screens/student/assignment_submission_screen.dart
lib/features/assignments/presentation/screens/student/assignments_list_screen.dart
lib/features/assignments/presentation/screens/teacher/assignment_create_screen.dart
lib/features/assignments/presentation/screens/teacher/assignment_detail_screen.dart
lib/features/assignments/presentation/screens/teacher/assignment_edit_screen.dart
lib/features/assignments/presentation/screens/teacher/assignments_list_screen.dart
lib/features/auth/data/repositories/auth_repository_impl.dart
lib/features/auth/data/repositories/user_repository_impl.dart
lib/features/auth/data/services/auth_service.dart
lib/features/auth/data/services/google_sign_in_service.dart
lib/features/auth/data/services/web_auth_helper_interface.dart
lib/features/auth/data/services/web_auth_helper_stub.dart
lib/features/auth/data/services/web_auth_helper.dart
lib/features/auth/domain/repositories/auth_repository.dart
lib/features/auth/domain/repositories/user_repository.dart
lib/features/auth/presentation/providers/auth_provider.dart
lib/features/auth/presentation/screens/forgot_password_screen.dart
lib/features/auth/presentation/screens/login_screen.dart
lib/features/auth/presentation/screens/role_selection_screen.dart
lib/features/auth/presentation/screens/signup_screen.dart
lib/features/auth/presentation/widgets/auth_text_field.dart
lib/features/auth/presentation/widgets/google_sign_in_button_web.dart
lib/features/calendar/data/repositories/calendar_repository_impl.dart
lib/features/calendar/data/services/calendar_service.dart
lib/features/calendar/data/services/device_calendar_service_factory.dart
lib/features/calendar/data/services/device_calendar_service_interface.dart
lib/features/calendar/data/services/device_calendar_service_mobile.dart
lib/features/calendar/data/services/device_calendar_service_stub.dart
lib/features/calendar/data/services/device_calendar_service_web.dart
lib/features/calendar/domain/models/calendar_event.dart
lib/features/calendar/domain/repositories/calendar_repository.dart
lib/features/calendar/presentation/providers/calendar_provider.dart
lib/features/calendar/presentation/screens/calendar_screen.dart
lib/features/chat/data/repositories/chat_repository_impl.dart
lib/features/chat/data/services/chat_service.dart
lib/features/chat/data/services/scheduled_messages_service.dart
lib/features/chat/data/services/webrtc_service.dart
lib/features/chat/data/services/webrtc_signaling_service.dart
lib/features/chat/domain/models/call.dart
lib/features/chat/domain/models/chat_room.dart
lib/features/chat/domain/models/message.dart
lib/features/chat/domain/repositories/chat_repository.dart
lib/features/chat/presentation/providers/call_provider.dart
lib/features/chat/presentation/providers/chat_provider.dart
lib/features/chat/presentation/providers/webrtc_call_manager.dart
lib/features/chat/presentation/screens/call_screen.dart
lib/features/chat/presentation/screens/chat_detail_screen.dart
lib/features/chat/presentation/screens/chat_list_screen.dart
lib/features/chat/presentation/screens/class_selection_screen.dart
lib/features/chat/presentation/screens/group_creation_screen.dart
lib/features/chat/presentation/screens/incoming_call_screen.dart
lib/features/chat/presentation/screens/user_selection_screen.dart
lib/features/classes/data/repositories/class_repository_impl.dart
lib/features/classes/data/services/class_service_enhanced.dart
lib/features/classes/data/services/class_service.dart
lib/features/classes/domain/models/class_model.dart
lib/features/classes/domain/repositories/class_repository.dart
lib/features/classes/presentation/providers/class_provider.dart
lib/features/classes/presentation/screens/student/courses_screen.dart
lib/features/classes/presentation/screens/student/enrollment_screen.dart
lib/features/classes/presentation/screens/teacher/classes_screen.dart
lib/features/classes/presentation/widgets/create_class_dialog.dart
lib/features/discussions/data/repositories/discussion_repository_impl.dart
lib/features/discussions/domain/models/discussion_board.dart
lib/features/discussions/domain/repositories/discussion_repository.dart
lib/features/discussions/presentation/providers/discussion_provider.dart
lib/features/discussions/presentation/screens/discussion_board_detail_screen.dart
lib/features/discussions/presentation/screens/discussion_boards_screen.dart
lib/features/discussions/presentation/screens/thread_detail_screen.dart
lib/features/discussions/presentation/widgets/create_board_dialog.dart
lib/features/discussions/presentation/widgets/create_thread_dialog.dart
lib/features/games/data/repositories/firebase_jeopardy_repository.dart
lib/features/games/domain/models/jeopardy_game.dart
lib/features/games/domain/repositories/jeopardy_repository.dart
lib/features/games/presentation/providers/jeopardy_provider.dart
lib/features/games/presentation/screens/jeopardy_create_screen.dart
lib/features/games/presentation/screens/jeopardy_play_screen.dart
lib/features/games/presentation/screens/jeopardy_screen.dart
lib/features/grades/data/repositories/grade_repository_impl.dart
lib/features/grades/data/services/grade_analytics_service.dart
lib/features/grades/domain/models/grade_analytics.dart
lib/features/grades/domain/models/grade.dart
lib/features/grades/domain/repositories/grade_repository.dart
lib/features/grades/presentation/providers/grade_analytics_provider.dart
lib/features/grades/presentation/providers/grade_provider.dart
lib/features/grades/presentation/screens/student/grades_screen.dart
lib/features/grades/presentation/screens/teacher/grade_analytics_screen.dart
lib/features/grades/presentation/screens/teacher/gradebook_screen.dart
lib/features/notifications/data/services/firebase_messaging_service.dart
lib/features/notifications/data/services/firebase_notification_service.dart
lib/features/notifications/data/services/notification_service_stub.dart
lib/features/notifications/data/services/notification_service_web.dart
lib/features/notifications/data/services/notification_service.dart
lib/features/notifications/data/services/voip_token_service.dart
lib/features/notifications/domain/models/notification_model.dart
lib/features/notifications/domain/models/notification.dart
lib/features/notifications/presentation/providers/notification_provider.dart
lib/features/notifications/presentation/screens/notifications_screen.dart
lib/features/notifications/presentation/screens/student_notifications_screen.dart
lib/features/student/data/repositories/student_repository_impl.dart
lib/features/student/data/services/presence_service.dart
lib/features/student/data/services/student_service.dart
lib/features/student/domain/models/student.dart
lib/features/student/domain/repositories/student_repository.dart
lib/features/student/presentation/providers/student_provider.dart
lib/features/student/presentation/screens/messages_screen.dart
lib/features/student/presentation/screens/student_dashboard_screen.dart
lib/features/student/presentation/screens/teacher/students_screen.dart
lib/features/student/presentation/widgets/online_users_card.dart
lib/features/teacher/presentation/screens/messages_screen.dart
lib/features/teacher/presentation/screens/teacher_dashboard_screen.dart
lib/main.dart
lib/shared/core/app_initializer.dart
lib/shared/core/app_providers.dart
lib/shared/core/service_locator.dart
lib/shared/example/example_repository.dart
lib/shared/models/nav_item.dart
lib/shared/models/user_model.dart
lib/shared/providers/navigation_provider.dart
lib/shared/providers/theme_provider.dart
lib/shared/repositories/base_repository.dart
lib/shared/repositories/firestore_repository_enhanced.dart
lib/shared/repositories/firestore_repository.dart
lib/shared/repositories/mixins/pagination_mixin.dart
lib/shared/routing/app_router.dart
lib/shared/screens/common/common/dashboard_screen.dart
lib/shared/screens/common/common/placeholder_screen.dart
lib/shared/screens/contact_support_screen.dart
lib/shared/screens/debug/debug/update_display_name_screen.dart
lib/shared/screens/help_screen.dart
lib/shared/screens/settings_screen.dart
lib/shared/services/cache_service.dart
lib/shared/services/error_handler_service.dart
lib/shared/services/firestore_service_enhanced.dart
lib/shared/services/firestore_service.dart
lib/shared/services/logger_service.dart
lib/shared/services/navigation_service.dart
lib/shared/services/performance_service.dart
lib/shared/services/retry_service.dart
lib/shared/services/validation_service.dart
lib/shared/theme/app_spacing.dart
lib/shared/theme/app_theme.dart
lib/shared/theme/app_typography.dart
lib/shared/utils/error_handler.dart
lib/shared/widgets/common/adaptive_layout.dart
lib/shared/widgets/common/app_card.dart
lib/shared/widgets/common/common_widgets.dart
lib/shared/widgets/common/custom_list_tile.dart
lib/shared/widgets/common/empty_state.dart
lib/shared/widgets/common/error_aware_stream_builder.dart
lib/shared/widgets/common/firebase_error_boundary.dart
lib/shared/widgets/common/global_error_handler.dart
lib/shared/widgets/common/responsive_layout.dart
lib/shared/widgets/common/stat_card.dart
lib/shared/widgets/common/status_badge.dart
lib/shared/widgets/navigation/app_drawer.dart
lib/shared/widgets/navigation/bottom_nav_bar.dart
lib/shared/widgets/navigation/favorites_nav_bar.dart
lib/shared/widgets/preview/example_badge.dart
lib/shared/widgets/preview/preview_example_wrapper.dart
lib/shared/widgets/splash_screen.dart
linux/.gitignore
linux/CMakeLists.txt
linux/flutter/CMakeLists.txt
linux/flutter/generated_plugin_registrant.cc
linux/flutter/generated_plugin_registrant.h
linux/flutter/generated_plugins.cmake
linux/runner/CMakeLists.txt
linux/runner/main.cc
linux/runner/my_application.cc
linux/runner/my_application.h
macos/.gitignore
macos/Flutter/Flutter-Debug.xcconfig
macos/Flutter/Flutter-Release.xcconfig
macos/Flutter/GeneratedPluginRegistrant.swift
macos/Runner.xcodeproj/project.pbxproj
macos/Runner.xcworkspace/contents.xcworkspacedata
macos/Runner/AppDelegate.swift
macos/Runner/Assets.xcassets/AppIcon.appiconset/Contents.json
macos/Runner/Base.lproj/MainMenu.xib
macos/Runner/Configs/AppInfo.xcconfig
macos/Runner/Configs/Debug.xcconfig
macos/Runner/Configs/Release.xcconfig
macos/Runner/Configs/Warnings.xcconfig
macos/Runner/DebugProfile.entitlements
macos/Runner/Info.plist
macos/Runner/MainFlutterWindow.swift
macos/Runner/Release.entitlements
macos/RunnerTests/RunnerTests.swift
pubspec.yaml
qodana.yaml
README.md
scripts/fetch_secrets.ps1
scripts/fetch_secrets.sh
scripts/setup_secrets.ps1
set_java21.bat
sonar-project.properties
storage.rules
test/widget_test.dart
tools/README.md
web/firebase-messaging-sw.js
web/index.html
web/manifest.json
web/web_server_config.md
windows/.gitignore
windows/CMakeLists.txt
windows/flutter/generated_plugin_registrant.cc
windows/flutter/generated_plugin_registrant.h
windows/flutter/generated_plugins.cmake
windows/runner/CMakeLists.txt
windows/runner/flutter_window.cpp
windows/runner/flutter_window.h
windows/runner/main.cpp
windows/runner/resource.h
windows/runner/runner.exe.manifest
windows/runner/Runner.rc
windows/runner/utils.cpp
windows/runner/utils.h
windows/runner/win32_window.cpp
windows/runner/win32_window.h
```

# Files

## File: .snapshots/config.json
````json
{
    "excluded_patterns": [
        ".git",
        ".gitignore",
        "gradle",
        "gradlew",
        "gradlew.*",
        "node_modules",
        ".snapshots",
        ".idea",
        ".vscode",
        "*.log",
        "*.tmp",
        "target",
        "dist",
        "build",
        ".DS_Store",
        "*.bak",
        "*.swp",
        "*.swo",
        "*.lock",
        "*.iml",
        "coverage",
        "*.min.js",
        "*.min.css",
        "__pycache__",
        ".marketing",
        ".env",
        ".env.*",
        "*.jpg",
        "*.jpeg",
        "*.png",
        "*.gif",
        "*.bmp",
        "*.tiff",
        "*.ico",
        "*.svg",
        "*.webp",
        "*.psd",
        "*.ai",
        "*.eps",
        "*.indd",
        "*.raw",
        "*.cr2",
        "*.nef",
        "*.mp4",
        "*.mov",
        "*.avi",
        "*.wmv",
        "*.flv",
        "*.mkv",
        "*.webm",
        "*.m4v",
        "*.wfp",
        "*.prproj",
        "*.aep",
        "*.psb",
        "*.xcf",
        "*.sketch",
        "*.fig",
        "*.xd",
        "*.db",
        "*.sqlite",
        "*.sqlite3",
        "*.mdb",
        "*.accdb",
        "*.frm",
        "*.myd",
        "*.myi",
        "*.ibd",
        "*.dbf",
        "*.rdb",
        "*.aof",
        "*.pdb",
        "*.sdb",
        "*.s3db",
        "*.ddb",
        "*.db-shm",
        "*.db-wal",
        "*.sqlitedb",
        "*.sql.gz",
        "*.bak.sql",
        "dump.sql",
        "dump.rdb",
        "*.vsix",
        "*.jar",
        "*.war",
        "*.ear",
        "*.zip",
        "*.tar",
        "*.tar.gz",
        "*.tgz",
        "*.rar",
        "*.7z",
        "*.exe",
        "*.dll",
        "*.so",
        "*.dylib",
        "*.app",
        "*.dmg",
        "*.iso",
        "*.msi",
        "*.deb",
        "*.rpm",
        "*.apk",
        "*.aab",
        "*.ipa",
        "*.pkg",
        "*.nupkg",
        "*.snap",
        "*.whl",
        "*.gem",
        "*.pyc",
        "*.pyo",
        "*.pyd",
        "*.class",
        "*.o",
        "*.obj",
        "*.lib",
        "*.a",
        "*.map",
        ".npmrc"
    ],
    "default": {
        "default_prompt": "Enter your prompt here",
        "default_include_all_files": false,
        "default_include_entire_project_structure": true
    },
    "included_patterns": [
        "build.gradle",
        "settings.gradle",
        "gradle.properties",
        "pom.xml",
        "Makefile",
        "CMakeLists.txt",
        "package.json",
        "requirements.txt",
        "Pipfile",
        "Gemfile",
        "composer.json",
        ".editorconfig",
        ".eslintrc.json",
        ".eslintrc.js",
        ".prettierrc",
        ".babelrc",
        ".dockerignore",
        ".gitattributes",
        ".stylelintrc",
        ".npmrc"
    ]
}
````

## File: .snapshots/readme.md
````markdown
# Snapshots Directory

This directory contains snapshots of your code for AI interactions. Each snapshot is a markdown file that includes relevant code context and project structure information.

## What's included in snapshots?
- Selected code files and their contents
- Project structure (if enabled)
- Your prompt/question for the AI

## Configuration
You can customize snapshot behavior in `config.json`.
````

## File: .snapshots/sponsors.md
````markdown
# Thank you for using Snapshots for AI

Thanks for using Snapshots for AI. We hope this tool has helped you solve a problem or two. 

If you would like to support our work, please help us by considering the following offers and requests:

## Ways to Support

### Join the GBTI Network!!! 🙏🙏🙏
The GBTI Network is a community of developers who are passionate about open source and community-driven development. Members enjoy access to exclussive tools, resources, a private MineCraft server, a listing in our members directory, co-op opportunities and more.

- Support our work by becoming a [GBTI Network member](https://gbti.network/membership/).

### Try out BugHerd 🐛
BugHerd is a visual feedback and bug-tracking tool designed to streamline website development by enabling users to pin feedback directly onto web pages. This approach facilitates clear communication among clients, designers, developers, and project managers.

- Start your free trial with [BugHerd](https://partners.bugherd.com/55z6c8az8rvr) today.

### Hire Developers from Codeable 👥
Codeable connects you with top-tier professionals skilled in frameworks and technologies such as Laravel, React, Django, Node, Vue.js, Angular, Ruby on Rails, and Node.js. Don't let the WordPress focus discourage you. Codeable experts do it all.

- Visit [Codeable](https://www.codeable.io/developers/?ref=z8h3e) to hire your next team member. 

### Lead positive reviews on our marketplace listing ⭐⭐⭐⭐⭐
- Rate us on [VSCode marketplace](https://marketplace.visualstudio.com/items?itemName=GBTI.snapshots-for-ai)
- Review us on [Cursor marketplace](https://open-vsx.org/extension/GBTI/snapshots-for-ai)

### Star Our GitHub Repository ⭐
- Star and watch our [repository](https://github.com/gbti-network/vscode-snapshots-for-ai)

### 📡 Stay Connected
Follow us on your favorite platforms for updates, news, and community discussions:
- **[Twitter/X](https://twitter.com/gbti_network)**
- **[GitHub](https://github.com/gbti-network)**
- **[YouTube](https://www.youtube.com/channel/UCh4FjB6r4oWQW-QFiwqv-UA)**
- **[Dev.to](https://dev.to/gbti)**
- **[Daily.dev](https://dly.to/zfCriM6JfRF)**
- **[Hashnode](https://gbti.hashnode.dev/)**
- **[Discord Community](https://gbti.network)**
- **[Reddit Community](https://www.reddit.com/r/GBTI_network)**

---

Thank you for supporting open source software! 🙏
````

## File: android/app/src/main/java/io/flutter/plugins/GeneratedPluginRegistrant.java
````java
package io.flutter.plugins;

import androidx.annotation.Keep;
import androidx.annotation.NonNull;
import io.flutter.Log;

import io.flutter.embedding.engine.FlutterEngine;

/**
 * Generated file. Do not edit.
 * This file is generated by the Flutter tool based on the
 * plugins that support the Android platform.
 */
@Keep
public final class GeneratedPluginRegistrant {
  private static final String TAG = "GeneratedPluginRegistrant";
  public static void registerWith(@NonNull FlutterEngine flutterEngine) {
    try {
      flutterEngine.getPlugins().add(new io.flutter.plugins.firebase.firestore.FlutterFirebaseFirestorePlugin());
    } catch (Exception e) {
      Log.e(TAG, "Error registering plugin cloud_firestore, io.flutter.plugins.firebase.firestore.FlutterFirebaseFirestorePlugin", e);
    }
    try {
      flutterEngine.getPlugins().add(new com.builttoroam.devicecalendar.DeviceCalendarPlugin());
    } catch (Exception e) {
      Log.e(TAG, "Error registering plugin device_calendar, com.builttoroam.devicecalendar.DeviceCalendarPlugin", e);
    }
    try {
      flutterEngine.getPlugins().add(new com.mr.flutter.plugin.filepicker.FilePickerPlugin());
    } catch (Exception e) {
      Log.e(TAG, "Error registering plugin file_picker, com.mr.flutter.plugin.filepicker.FilePickerPlugin", e);
    }
    try {
      flutterEngine.getPlugins().add(new io.flutter.plugins.firebase.auth.FlutterFirebaseAuthPlugin());
    } catch (Exception e) {
      Log.e(TAG, "Error registering plugin firebase_auth, io.flutter.plugins.firebase.auth.FlutterFirebaseAuthPlugin", e);
    }
    try {
      flutterEngine.getPlugins().add(new io.flutter.plugins.firebase.core.FlutterFirebaseCorePlugin());
    } catch (Exception e) {
      Log.e(TAG, "Error registering plugin firebase_core, io.flutter.plugins.firebase.core.FlutterFirebaseCorePlugin", e);
    }
    try {
      flutterEngine.getPlugins().add(new io.flutter.plugins.firebase.crashlytics.FlutterFirebaseCrashlyticsPlugin());
    } catch (Exception e) {
      Log.e(TAG, "Error registering plugin firebase_crashlytics, io.flutter.plugins.firebase.crashlytics.FlutterFirebaseCrashlyticsPlugin", e);
    }
    try {
      flutterEngine.getPlugins().add(new io.flutter.plugins.firebase.database.FirebaseDatabasePlugin());
    } catch (Exception e) {
      Log.e(TAG, "Error registering plugin firebase_database, io.flutter.plugins.firebase.database.FirebaseDatabasePlugin", e);
    }
    try {
      flutterEngine.getPlugins().add(new io.flutter.plugins.firebase.messaging.FlutterFirebaseMessagingPlugin());
    } catch (Exception e) {
      Log.e(TAG, "Error registering plugin firebase_messaging, io.flutter.plugins.firebase.messaging.FlutterFirebaseMessagingPlugin", e);
    }
    try {
      flutterEngine.getPlugins().add(new io.flutter.plugins.firebase.storage.FlutterFirebaseStoragePlugin());
    } catch (Exception e) {
      Log.e(TAG, "Error registering plugin firebase_storage, io.flutter.plugins.firebase.storage.FlutterFirebaseStoragePlugin", e);
    }
    try {
      flutterEngine.getPlugins().add(new com.hiennv.flutter_callkit_incoming.FlutterCallkitIncomingPlugin());
    } catch (Exception e) {
      Log.e(TAG, "Error registering plugin flutter_callkit_incoming, com.hiennv.flutter_callkit_incoming.FlutterCallkitIncomingPlugin", e);
    }
    try {
      flutterEngine.getPlugins().add(new com.dexterous.flutterlocalnotifications.FlutterLocalNotificationsPlugin());
    } catch (Exception e) {
      Log.e(TAG, "Error registering plugin flutter_local_notifications, com.dexterous.flutterlocalnotifications.FlutterLocalNotificationsPlugin", e);
    }
    try {
      flutterEngine.getPlugins().add(new io.flutter.plugins.flutter_plugin_android_lifecycle.FlutterAndroidLifecyclePlugin());
    } catch (Exception e) {
      Log.e(TAG, "Error registering plugin flutter_plugin_android_lifecycle, io.flutter.plugins.flutter_plugin_android_lifecycle.FlutterAndroidLifecyclePlugin", e);
    }
    try {
      flutterEngine.getPlugins().add(new com.cloudwebrtc.webrtc.FlutterWebRTCPlugin());
    } catch (Exception e) {
      Log.e(TAG, "Error registering plugin flutter_webrtc, com.cloudwebrtc.webrtc.FlutterWebRTCPlugin", e);
    }
    try {
      flutterEngine.getPlugins().add(new io.flutter.plugins.googlesignin.GoogleSignInPlugin());
    } catch (Exception e) {
      Log.e(TAG, "Error registering plugin google_sign_in_android, io.flutter.plugins.googlesignin.GoogleSignInPlugin", e);
    }
    try {
      flutterEngine.getPlugins().add(new io.flutter.plugins.imagepicker.ImagePickerPlugin());
    } catch (Exception e) {
      Log.e(TAG, "Error registering plugin image_picker_android, io.flutter.plugins.imagepicker.ImagePickerPlugin", e);
    }
    try {
      flutterEngine.getPlugins().add(new io.flutter.plugins.pathprovider.PathProviderPlugin());
    } catch (Exception e) {
      Log.e(TAG, "Error registering plugin path_provider_android, io.flutter.plugins.pathprovider.PathProviderPlugin", e);
    }
    try {
      flutterEngine.getPlugins().add(new com.baseflow.permissionhandler.PermissionHandlerPlugin());
    } catch (Exception e) {
      Log.e(TAG, "Error registering plugin permission_handler_android, com.baseflow.permissionhandler.PermissionHandlerPlugin", e);
    }
    try {
      flutterEngine.getPlugins().add(new io.flutter.plugins.sharedpreferences.SharedPreferencesPlugin());
    } catch (Exception e) {
      Log.e(TAG, "Error registering plugin shared_preferences_android, io.flutter.plugins.sharedpreferences.SharedPreferencesPlugin", e);
    }
    try {
      flutterEngine.getPlugins().add(new com.tekartik.sqflite.SqflitePlugin());
    } catch (Exception e) {
      Log.e(TAG, "Error registering plugin sqflite_android, com.tekartik.sqflite.SqflitePlugin", e);
    }
    try {
      flutterEngine.getPlugins().add(new com.example.video_compress.VideoCompressPlugin());
    } catch (Exception e) {
      Log.e(TAG, "Error registering plugin video_compress, com.example.video_compress.VideoCompressPlugin", e);
    }
    try {
      flutterEngine.getPlugins().add(new io.flutter.plugins.videoplayer.VideoPlayerPlugin());
    } catch (Exception e) {
      Log.e(TAG, "Error registering plugin video_player_android, io.flutter.plugins.videoplayer.VideoPlayerPlugin", e);
    }
  }
}
````

## File: android/app/src/main/res/xml/network_security_config.xml
````xml
<?xml version="1.0" encoding="utf-8"?>
<network-security-config>
    <!-- Allow cleartext traffic for Android emulator localhost -->
    <domain-config cleartextTrafficPermitted="true">
        <domain includeSubdomains="true">10.0.2.2</domain>
        <domain includeSubdomains="true">localhost</domain>
        <domain includeSubdomains="true">127.0.0.1</domain>
    </domain-config>
    
    <!-- Default configuration for all other domains -->
    <base-config cleartextTrafficPermitted="false">
        <trust-anchors>
            <certificates src="system" />
            <certificates src="user" />
        </trust-anchors>
    </base-config>
</network-security-config>
````

## File: lib/features/chat/data/services/webrtc_signaling_service.dart
````dart
import 'dart:async';
import 'package:firebase_auth/firebase_auth.dart';
import 'package:firebase_database/firebase_database.dart';
import 'package:flutter_webrtc/flutter_webrtc.dart';
import '../../../../shared/services/logger_service.dart';
import '../../domain/models/call.dart';
import '../../../notifications/data/services/notification_service.dart';

/// Service for handling WebRTC signaling through Firebase Realtime Database
class WebRTCSignalingService {
  static const String _tag = 'WebRTCSignalingService';
  
  final FirebaseDatabase _database = FirebaseDatabase.instance;
  final FirebaseAuth _auth = FirebaseAuth.instance;
  final NotificationService _notificationService = NotificationService();
  
  // Signaling paths in Firebase
  static const String _callsPath = 'calls';
  static const String _incomingCallsPath = 'incoming_calls';
  
  // Stream subscriptions
  final Map<String, StreamSubscription> _subscriptions = {};
  
  // Callbacks
  Function(Call call)? onIncomingCall;
  Function(String callId, RTCSessionDescription offer)? onOffer;
  Function(String callId, RTCSessionDescription answer)? onAnswer;
  Function(String callId, RTCIceCandidate candidate)? onIceCandidate;
  Function(String callId)? onCallEnded;
  
  /// Initialize signaling service
  Future<void> initialize() async {
    await _notificationService.initialize();
    _listenForIncomingCalls();
  }
  
  /// Clean up resources
  void dispose() {
    for (final subscription in _subscriptions.values) {
      subscription.cancel();
    }
    _subscriptions.clear();
  }
  
  /// Listen for incoming calls
  void _listenForIncomingCalls() {
    final userId = _auth.currentUser?.uid;
    if (userId == null) return;
    
    // Cancel existing subscription if any
    _subscriptions['incoming_calls']?.cancel();
    
    // Listen for calls where we are the callee
    _subscriptions['incoming_calls'] = _database
        .ref('$_incomingCallsPath/$userId')
        .onChildAdded
        .listen((DatabaseEvent event) async {
      try {
        final data = event.snapshot.value as Map?;
        if (data == null) return;
        
        final callId = event.snapshot.key;
        if (callId == null) return;
        
        // Create Call object from data
        final call = Call(
          id: callId,
          callerId: data['callerId'] as String,
          callerName: data['callerName'] as String? ?? 'Unknown Caller',
          callerPhotoUrl: data['callerPhotoUrl'] as String? ?? '',
          receiverId: userId,
          receiverName: data['calleeName'] as String? ?? 'You',
          receiverPhotoUrl: data['calleePhotoUrl'] as String? ?? '',
          type: (data['isVideo'] as bool? ?? false) ? CallType.video : CallType.voice,
          status: CallStatus.ringing,
          startedAt: DateTime.fromMillisecondsSinceEpoch(
              data['timestamp'] as int? ?? DateTime.now().millisecondsSinceEpoch),
          chatRoomId: data['chatRoomId'] as String?,
        );
        
        // Show notification
        await _notificationService.showIncomingCall(call);
        
        // Notify listeners
        onIncomingCall?.call(call);
        
        // Listen for this specific call's signaling data
        _listenToCallSignaling(callId);
        
        // Remove from incoming calls queue
        await event.snapshot.ref.remove();
        
      } catch (e) {
        LoggerService.error('Error processing incoming call', error: e, tag: _tag);
      }
    });
  }
  
  /// Initiate a call
  Future<String> initiateCall({
    required String calleeId,
    required bool isVideo,
    String? calleeName,
  }) async {
    final userId = _auth.currentUser?.uid;
    final userDisplayName = _auth.currentUser?.displayName;
    final userPhotoUrl = _auth.currentUser?.photoURL;
    
    if (userId == null) throw Exception('User not authenticated');
    
    // Generate unique call ID
    final callId = _database.ref().child(_callsPath).push().key;
    if (callId == null) throw Exception('Failed to generate call ID');
    
    // Create call data
    final callData = {
      'callId': callId,
      'callerId': userId,
      'callerName': userDisplayName,
      'callerPhotoUrl': userPhotoUrl,
      'calleeId': calleeId,
      'calleeName': calleeName,
      'isVideo': isVideo,
      'isGroupCall': false,
      'participants': [userId, calleeId],
      'timestamp': ServerValue.timestamp,
      'status': 'initiating',
    };
    
    // Save call data
    await _database.ref('$_callsPath/$callId').set(callData);
    
    // Notify callee
    await _database.ref('$_incomingCallsPath/$calleeId/$callId').set({
      ...callData,
      'timestamp': DateTime.now().millisecondsSinceEpoch,
    });
    
    // Listen for signaling on this call
    _listenToCallSignaling(callId);
    
    return callId;
  }
  
  /// Send offer
  Future<void> sendOffer(String callId, RTCSessionDescription offer) async {
    await _database.ref('$_callsPath/$callId/offer').set({
      'sdp': offer.sdp,
      'type': offer.type,
      'timestamp': ServerValue.timestamp,
    });
  }
  
  /// Send answer
  Future<void> sendAnswer(String callId, RTCSessionDescription answer) async {
    await _database.ref('$_callsPath/$callId/answer').set({
      'sdp': answer.sdp,
      'type': answer.type,
      'timestamp': ServerValue.timestamp,
    });
  }
  
  /// Send ICE candidate
  Future<void> sendIceCandidate(String callId, RTCIceCandidate candidate) async {
    final candidateData = {
      'candidate': candidate.candidate,
      'sdpMid': candidate.sdpMid,
      'sdpMLineIndex': candidate.sdpMLineIndex,
      'timestamp': ServerValue.timestamp,
    };
    
    await _database
        .ref('$_callsPath/$callId/iceCandidates')
        .push()
        .set(candidateData);
  }
  
  /// End call
  Future<void> endCall(String callId) async {
    // Update call status
    await _database.ref('$_callsPath/$callId/status').set('ended');
    await _database.ref('$_callsPath/$callId/endTime').set(ServerValue.timestamp);
    
    // Clean up notifications
    await _notificationService.endCall(callId);
    
    // Cancel subscriptions for this call
    _cancelCallSubscriptions(callId);
    
    // Notify listeners
    onCallEnded?.call(callId);
  }
  
  /// Listen to signaling data for a specific call
  void _listenToCallSignaling(String callId) {
    final callRef = _database.ref('$_callsPath/$callId');
    
    // Listen for offer
    _subscriptions['offer_$callId'] = callRef
        .child('offer')
        .onValue
        .listen((DatabaseEvent event) {
      final data = event.snapshot.value as Map?;
      if (data != null && data['sdp'] != null) {
        final offer = RTCSessionDescription(
          data['sdp'] as String,
          data['type'] as String?,
        );
        onOffer?.call(callId, offer);
      }
    });
    
    // Listen for answer
    _subscriptions['answer_$callId'] = callRef
        .child('answer')
        .onValue
        .listen((DatabaseEvent event) {
      final data = event.snapshot.value as Map?;
      if (data != null && data['sdp'] != null) {
        final answer = RTCSessionDescription(
          data['sdp'] as String,
          data['type'] as String?,
        );
        onAnswer?.call(callId, answer);
      }
    });
    
    // Listen for ICE candidates
    _subscriptions['ice_$callId'] = callRef
        .child('iceCandidates')
        .onChildAdded
        .listen((DatabaseEvent event) {
      final data = event.snapshot.value as Map?;
      if (data != null && data['candidate'] != null) {
        final candidate = RTCIceCandidate(
          data['candidate'] as String,
          data['sdpMid'] as String?,
          data['sdpMLineIndex'] as int?,
        );
        onIceCandidate?.call(callId, candidate);
      }
    });
    
    // Listen for call end
    _subscriptions['status_$callId'] = callRef
        .child('status')
        .onValue
        .listen((DatabaseEvent event) {
      final status = event.snapshot.value as String?;
      if (status == 'ended') {
        onCallEnded?.call(callId);
        _cancelCallSubscriptions(callId);
      }
    });
  }
  
  /// Cancel subscriptions for a specific call
  void _cancelCallSubscriptions(String callId) {
    _subscriptions['offer_$callId']?.cancel();
    _subscriptions['answer_$callId']?.cancel();
    _subscriptions['ice_$callId']?.cancel();
    _subscriptions['status_$callId']?.cancel();
    
    _subscriptions.remove('offer_$callId');
    _subscriptions.remove('answer_$callId');
    _subscriptions.remove('ice_$callId');
    _subscriptions.remove('status_$callId');
  }
  
  /// Accept incoming call
  Future<void> acceptCall(String callId) async {
    await _database.ref('$_callsPath/$callId/status').set('accepted');
  }
  
  /// Decline incoming call
  Future<void> declineCall(String callId) async {
    await _database.ref('$_callsPath/$callId/status').set('declined');
    await _notificationService.endCall(callId);
    _cancelCallSubscriptions(callId);
  }
  
  /// Get call data
  Future<Map<String, dynamic>?> getCallData(String callId) async {
    final snapshot = await _database.ref('$_callsPath/$callId').get();
    return snapshot.value as Map<String, dynamic>?;
  }
  
  /// Update call status
  Future<void> updateCallStatus(String callId, String status) async {
    await _database.ref('$_callsPath/$callId/status').set(status);
  }
}
````

## File: lib/features/chat/presentation/providers/webrtc_call_manager.dart
````dart
import 'dart:async';
import 'package:flutter/material.dart';
import 'package:flutter_webrtc/flutter_webrtc.dart';
import 'package:permission_handler/permission_handler.dart';
import '../../data/services/webrtc_service.dart';
import '../../data/services/webrtc_signaling_service.dart';
import '../../domain/models/call.dart';
import '../../../../shared/services/logger_service.dart';

/// Manages WebRTC calls with Firebase signaling
class WebRTCCallManager extends ChangeNotifier {
  static const String _tag = 'WebRTCCallManager';
  
  final WebRTCService _webrtcService = WebRTCService();
  final WebRTCSignalingService _signalingService = WebRTCSignalingService();
  
  // WebRTC configuration
  final Map<String, dynamic> _configuration = {
    'iceServers': [
      {'urls': 'stun:stun.l.google.com:19302'},
      {'urls': 'stun:stun1.l.google.com:19302'},
      // Add TURN servers for better connectivity
      // {
      //   'urls': 'turn:your-turn-server.com:3478',
      //   'username': 'username',
      //   'credential': 'password',
      // },
    ],
    'sdpSemantics': 'unified-plan',
  };
  
  // Peer connections map
  final Map<String, RTCPeerConnection> _peerConnections = {};
  
  // Media streams
  MediaStream? _localStream;
  final Map<String, MediaStream> _remoteStreams = {};
  
  // Renderers
  final localRenderer = RTCVideoRenderer();
  final Map<String, RTCVideoRenderer> remoteRenderers = {};
  
  // Call state
  Call? _currentCall;
  bool _isCaller = false;
  
  // Getters
  Call? get currentCall => _currentCall;
  bool get isCaller => _isCaller;
  MediaStream? get localStream => _localStream;
  Map<String, MediaStream> get remoteStreams => _remoteStreams;
  
  /// Initialize the call manager
  Future<void> initialize() async {
    await localRenderer.initialize();
    await _signalingService.initialize();
    
    // Set up signaling callbacks
    _signalingService.onIncomingCall = _handleIncomingCall;
    _signalingService.onOffer = _handleOffer;
    _signalingService.onAnswer = _handleAnswer;
    _signalingService.onIceCandidate = _handleIceCandidate;
    _signalingService.onCallEnded = _handleCallEnded;
  }
  
  /// Start a call
  Future<void> startCall({
    required String calleeId,
    required bool isVideo,
    String? calleeName,
  }) async {
    try {
      _isCaller = true;
      
      // Initialize local stream
      await _initializeLocalStream(isVideo);
      
      // Initiate call through signaling
      final callId = await _signalingService.initiateCall(
        calleeId: calleeId,
        isVideo: isVideo,
        calleeName: calleeName,
      );
      
      // Create peer connection
      final pc = await _createPeerConnection(callId);
      
      // Add local stream tracks
      if (_localStream != null) {
        _localStream!.getTracks().forEach((track) {
          pc.addTrack(track, _localStream!);
        });
      }
      
      // Create offer
      final offer = await pc.createOffer();
      await pc.setLocalDescription(offer);
      
      // Send offer through signaling
      await _signalingService.sendOffer(callId, offer);
      
      // Update current call
      _currentCall = Call(
        id: callId,
        callerId: _webrtcService.currentUserId,
        callerName: _webrtcService.currentUserName,
        callerPhotoUrl: _webrtcService.currentUserPhoto,
        receiverId: calleeId,
        receiverName: calleeName ?? 'Unknown',
        receiverPhotoUrl: '', // TODO: Get receiver photo URL
        type: isVideo ? CallType.video : CallType.voice,
        status: CallStatus.ringing,
        startedAt: DateTime.now(),
        chatRoomId: null, // TODO: Add chatRoomId if available
      );
      
      notifyListeners();
      
    } catch (e) {
      LoggerService.error('Failed to start call', error: e, tag: _tag);
      await endCall();
      rethrow;
    }
  }
  
  /// Accept incoming call
  Future<void> acceptCall(Call call) async {
    try {
      _currentCall = call;
      _isCaller = false;
      
      // Initialize local stream
      await _initializeLocalStream(call.isVideo);
      
      // Accept call through signaling
      await _signalingService.acceptCall(call.id);
      
      // Create peer connection
      final pc = await _createPeerConnection(call.id);
      
      // Add local stream tracks
      if (_localStream != null) {
        _localStream!.getTracks().forEach((track) {
          pc.addTrack(track, _localStream!);
        });
      }
      
      notifyListeners();
      
    } catch (e) {
      LoggerService.error('Failed to accept call', error: e, tag: _tag);
      await endCall();
      rethrow;
    }
  }
  
  /// Decline incoming call
  Future<void> declineCall(String callId) async {
    await _signalingService.declineCall(callId);
    _cleanup();
  }
  
  /// End current call
  Future<void> endCall() async {
    if (_currentCall != null) {
      await _signalingService.endCall(_currentCall!.id);
    }
    _cleanup();
  }
  
  /// Toggle camera
  Future<void> toggleCamera() async {
    if (_localStream != null) {
      final videoTrack = _localStream!.getVideoTracks().firstOrNull;
      if (videoTrack != null) {
        videoTrack.enabled = !videoTrack.enabled;
        notifyListeners();
      }
    }
  }
  
  /// Toggle microphone
  Future<void> toggleMicrophone() async {
    if (_localStream != null) {
      final audioTrack = _localStream!.getAudioTracks().firstOrNull;
      if (audioTrack != null) {
        audioTrack.enabled = !audioTrack.enabled;
        notifyListeners();
      }
    }
  }
  
  /// Switch camera
  Future<void> switchCamera() async {
    if (_localStream != null) {
      final videoTrack = _localStream!.getVideoTracks().firstOrNull;
      if (videoTrack != null) {
        await Helper.switchCamera(videoTrack);
      }
    }
  }
  
  // Private methods
  
  Future<void> _initializeLocalStream(bool isVideo) async {
    // Request permissions before accessing media
    final permissions = await _requestMediaPermissions(isVideo);
    if (!permissions) {
      throw Exception('Media permissions denied');
    }
    
    final mediaConstraints = {
      'audio': true,
      'video': isVideo ? {
        'facingMode': 'user',
        'width': {'min': 640, 'ideal': 1280, 'max': 1920},
        'height': {'min': 480, 'ideal': 720, 'max': 1080},
      } : false,
    };
    
    try {
      _localStream = await navigator.mediaDevices.getUserMedia(mediaConstraints);
      localRenderer.srcObject = _localStream;
    } catch (e) {
      LoggerService.error('Failed to get user media', error: e, tag: _tag);
      throw Exception('Failed to access camera/microphone: ${e.toString()}');
    }
  }
  
  Future<bool> _requestMediaPermissions(bool isVideo) async {
    try {
      // Request microphone permission (always needed)
      var micStatus = await Permission.microphone.status;
      if (!micStatus.isGranted) {
        micStatus = await Permission.microphone.request();
        if (!micStatus.isGranted) {
          LoggerService.error('Microphone permission denied', tag: _tag);
          return false;
        }
      }
      
      // Request camera permission if video call
      if (isVideo) {
        var cameraStatus = await Permission.camera.status;
        if (!cameraStatus.isGranted) {
          cameraStatus = await Permission.camera.request();
          if (!cameraStatus.isGranted) {
            LoggerService.error('Camera permission denied', tag: _tag);
            return false;
          }
        }
      }
      
      LoggerService.info('Media permissions granted', tag: _tag);
      return true;
    } catch (e) {
      LoggerService.error('Failed to request media permissions', error: e, tag: _tag);
      return false;
    }
  }
  
  Future<RTCPeerConnection> _createPeerConnection(String callId) async {
    final pc = await createPeerConnection(_configuration);
    _peerConnections[callId] = pc;
    
    // Set up event handlers
    pc.onIceCandidate = (candidate) {
      _signalingService.sendIceCandidate(callId, candidate);
    };
    
    pc.onTrack = (event) {
      if (event.streams.isNotEmpty) {
        final stream = event.streams.first;
        _remoteStreams[callId] = stream;
        
        // Initialize renderer if needed
        if (!remoteRenderers.containsKey(callId)) {
          final renderer = RTCVideoRenderer();
          renderer.initialize().then((_) {
            renderer.srcObject = stream;
            remoteRenderers[callId] = renderer;
            notifyListeners();
          });
        } else {
          remoteRenderers[callId]!.srcObject = stream;
          notifyListeners();
        }
      }
    };
    
    pc.onConnectionState = (state) {
      LoggerService.info('Connection state: $state', tag: _tag);
      if (state == RTCPeerConnectionState.RTCPeerConnectionStateFailed ||
          state == RTCPeerConnectionState.RTCPeerConnectionStateDisconnected) {
        // Handle connection failure
        endCall();
      }
    };
    
    return pc;
  }
  
  void _handleIncomingCall(Call call) {
    // This is handled by the CallProvider
    // You can emit an event or update state here if needed
  }
  
  void _handleOffer(String callId, RTCSessionDescription offer) async {
    try {
      final pc = _peerConnections[callId];
      if (pc == null) return;
      
      // Set remote description
      await pc.setRemoteDescription(offer);
      
      // Create answer
      final answer = await pc.createAnswer();
      await pc.setLocalDescription(answer);
      
      // Send answer through signaling
      await _signalingService.sendAnswer(callId, answer);
      
    } catch (e) {
      LoggerService.error('Failed to handle offer', error: e, tag: _tag);
    }
  }
  
  void _handleAnswer(String callId, RTCSessionDescription answer) async {
    try {
      final pc = _peerConnections[callId];
      if (pc == null) return;
      
      await pc.setRemoteDescription(answer);
      
    } catch (e) {
      LoggerService.error('Failed to handle answer', error: e, tag: _tag);
    }
  }
  
  void _handleIceCandidate(String callId, RTCIceCandidate candidate) async {
    try {
      final pc = _peerConnections[callId];
      if (pc == null) return;
      
      await pc.addCandidate(candidate);
      
    } catch (e) {
      LoggerService.error('Failed to add ICE candidate', error: e, tag: _tag);
    }
  }
  
  void _handleCallEnded(String callId) {
    if (_currentCall?.id == callId) {
      _cleanup();
    }
  }
  
  void _cleanup() {
    // Close peer connections
    for (final pc in _peerConnections.values) {
      pc.close();
    }
    _peerConnections.clear();
    
    // Dispose local stream
    _localStream?.dispose();
    _localStream = null;
    
    // Clear remote streams
    _remoteStreams.clear();
    
    // Dispose renderers
    for (final renderer in remoteRenderers.values) {
      renderer.dispose();
    }
    remoteRenderers.clear();
    
    // Reset state
    _currentCall = null;
    _isCaller = false;
    
    notifyListeners();
  }
  
  @override
  void dispose() {
    _cleanup();
    localRenderer.dispose();
    _signalingService.dispose();
    super.dispose();
  }
}
````

## File: lib/features/games/data/repositories/firebase_jeopardy_repository.dart
````dart
/// Firebase implementation of JeopardyRepository.
/// 
/// This module provides Firebase Firestore-based persistence
/// for Jeopardy game data in the education platform.
library;

import 'dart:async';
import 'package:cloud_firestore/cloud_firestore.dart';
import '../../domain/models/jeopardy_game.dart';
import '../../domain/repositories/jeopardy_repository.dart';
import '../../../../shared/services/logger_service.dart';

/// Firebase implementation for Jeopardy game operations.
/// 
/// Handles all Jeopardy game data persistence using Firestore,
/// providing real-time synchronization and scalable storage.
/// 
/// Collection structure:
/// - /jeopardy_games/{gameId} - Individual game documents
/// 
/// Indexes recommended:
/// - teacherId + updatedAt (descending) - For teacher game lists
/// - isPublic + updatedAt (descending) - For public game lists
/// - title (text search) - For game searching
class FirebaseJeopardyRepository implements JeopardyRepository {
  /// Logger tag for this repository.
  static const String _tag = 'FirebaseJeopardyRepository';
  
  /// Firestore instance for database operations.
  final FirebaseFirestore _firestore;
  
  /// Active stream subscriptions for cleanup.
  final List<StreamSubscription> _subscriptions = [];
  
  /// Collection reference for Jeopardy games.
  late final CollectionReference<Map<String, dynamic>> _gamesCollection;
  
  /// Creates repository with Firestore dependency.
  /// 
  /// @param firestore Firestore instance (optional for testing)
  FirebaseJeopardyRepository({FirebaseFirestore? firestore}) 
      : _firestore = firestore ?? FirebaseFirestore.instance {
    _gamesCollection = _firestore.collection('jeopardy_games');
  }
  
  @override
  Future<String> createGame(JeopardyGame game) async {
    try {
      final docRef = await _gamesCollection.add(game.toFirestore());
      LoggerService.info('Created Jeopardy game: ${docRef.id}', tag: _tag);
      return docRef.id;
    } catch (e, stack) {
      LoggerService.error(
        'Failed to create Jeopardy game',
        tag: _tag,
        error: e,
        stackTrace: stack,
      );
      throw Exception('Failed to create game: $e');
    }
  }
  
  @override
  Future<void> updateGame(String gameId, JeopardyGame game) async {
    try {
      await _gamesCollection.doc(gameId).update(game.toFirestore());
      LoggerService.info('Updated Jeopardy game: $gameId', tag: _tag);
    } catch (e, stack) {
      LoggerService.error(
        'Failed to update Jeopardy game',
        tag: _tag,
        error: e,
        stackTrace: stack,
      );
      throw Exception('Failed to update game: $e');
    }
  }
  
  @override
  Future<JeopardyGame?> getGame(String gameId) async {
    try {
      final doc = await _gamesCollection.doc(gameId).get();
      
      if (!doc.exists) {
        LoggerService.warning('Jeopardy game not found: $gameId', tag: _tag);
        return null;
      }
      
      return _gameFromFirestore(doc);
    } catch (e, stack) {
      LoggerService.error(
        'Failed to get Jeopardy game',
        tag: _tag,
        error: e,
        stackTrace: stack,
      );
      throw Exception('Failed to get game: $e');
    }
  }
  
  @override
  Future<List<JeopardyGame>> getTeacherGames(String teacherId) async {
    try {
      final query = _gamesCollection
          .where('teacherId', isEqualTo: teacherId)
          .orderBy('updatedAt', descending: true);
          
      final snapshot = await query.get();
      
      return snapshot.docs
          .map((doc) => _gameFromFirestore(doc))
          .where((game) => game != null)
          .cast<JeopardyGame>()
          .toList();
    } catch (e, stack) {
      LoggerService.error(
        'Failed to get teacher games',
        tag: _tag,
        error: e,
        stackTrace: stack,
      );
      throw Exception('Failed to get teacher games: $e');
    }
  }
  
  @override
  Future<List<JeopardyGame>> getPublicGames() async {
    try {
      final query = _gamesCollection
          .where('isPublic', isEqualTo: true)
          .orderBy('updatedAt', descending: true)
          .limit(50); // Limit public games to prevent large downloads
          
      final snapshot = await query.get();
      
      return snapshot.docs
          .map((doc) => _gameFromFirestore(doc))
          .where((game) => game != null)
          .cast<JeopardyGame>()
          .toList();
    } catch (e, stack) {
      LoggerService.error(
        'Failed to get public games',
        tag: _tag,
        error: e,
        stackTrace: stack,
      );
      throw Exception('Failed to get public games: $e');
    }
  }
  
  @override
  Future<void> deleteGame(String gameId) async {
    try {
      await _gamesCollection.doc(gameId).delete();
      LoggerService.info('Deleted Jeopardy game: $gameId', tag: _tag);
    } catch (e, stack) {
      LoggerService.error(
        'Failed to delete Jeopardy game',
        tag: _tag,
        error: e,
        stackTrace: stack,
      );
      throw Exception('Failed to delete game: $e');
    }
  }
  
  @override
  Future<void> togglePublicStatus(String gameId, bool isPublic) async {
    try {
      await _gamesCollection.doc(gameId).update({
        'isPublic': isPublic,
        'updatedAt': DateTime.now().toIso8601String(),
      });
      LoggerService.info(
        'Toggled public status for game $gameId to $isPublic',
        tag: _tag,
      );
    } catch (e, stack) {
      LoggerService.error(
        'Failed to toggle public status',
        tag: _tag,
        error: e,
        stackTrace: stack,
      );
      throw Exception('Failed to toggle public status: $e');
    }
  }
  
  @override
  Stream<List<JeopardyGame>> streamTeacherGames(String teacherId) {
    try {
      final query = _gamesCollection
          .where('teacherId', isEqualTo: teacherId)
          .orderBy('updatedAt', descending: true);
          
      return query.snapshots().map((snapshot) {
        return snapshot.docs
            .map((doc) => _gameFromFirestore(doc))
            .where((game) => game != null)
            .cast<JeopardyGame>()
            .toList();
      });
    } catch (e, stack) {
      LoggerService.error(
        'Failed to stream teacher games',
        tag: _tag,
        error: e,
        stackTrace: stack,
      );
      return Stream.error('Failed to stream teacher games: $e');
    }
  }
  
  @override
  Future<List<JeopardyGame>> searchGames(String query, {String? teacherId}) async {
    try {
      // Note: This is a simple implementation. For production,
      // consider using a dedicated search service like Algolia
      Query<Map<String, dynamic>> searchQuery = _gamesCollection;
      
      if (teacherId != null) {
        searchQuery = searchQuery.where('teacherId', isEqualTo: teacherId);
      }
      
      final snapshot = await searchQuery.get();
      
      final lowercaseQuery = query.toLowerCase();
      return snapshot.docs
          .map((doc) => _gameFromFirestore(doc))
          .where((game) => game != null)
          .cast<JeopardyGame>()
          .where((game) {
            // Search in title
            if (game.title.toLowerCase().contains(lowercaseQuery)) {
              return true;
            }
            // Search in categories
            for (final category in game.categories) {
              if (category.name.toLowerCase().contains(lowercaseQuery)) {
                return true;
              }
              // Search in questions
              for (final question in category.questions) {
                if (question.question.toLowerCase().contains(lowercaseQuery) ||
                    question.answer.toLowerCase().contains(lowercaseQuery)) {
                  return true;
                }
              }
            }
            return false;
          })
          .toList();
    } catch (e, stack) {
      LoggerService.error(
        'Failed to search games',
        tag: _tag,
        error: e,
        stackTrace: stack,
      );
      throw Exception('Failed to search games: $e');
    }
  }
  
  @override
  void dispose() {
    for (final subscription in _subscriptions) {
      subscription.cancel();
    }
    _subscriptions.clear();
    LoggerService.info('Disposed FirebaseJeopardyRepository', tag: _tag);
  }
  
  /// Converts Firestore document to JeopardyGame model.
  /// 
  /// Handles data parsing and validation with proper
  /// error handling for malformed data.
  /// 
  /// @param doc Firestore document
  /// @return JeopardyGame instance or null if parsing fails
  JeopardyGame? _gameFromFirestore(DocumentSnapshot<Map<String, dynamic>> doc) {
    try {
      final data = doc.data();
      if (data == null) return null;
      
      return JeopardyGame(
        id: doc.id,
        title: data['title'] ?? '',
        teacherId: data['teacherId'] ?? '',
        categories: (data['categories'] as List? ?? [])
            .map((c) => JeopardyCategory.fromJson(c))
            .toList(),
        finalJeopardy: data['finalJeopardy'] != null
            ? FinalJeopardyData.fromJson(data['finalJeopardy'])
            : null,
        createdAt: DateTime.parse(data['createdAt'] ?? DateTime.now().toIso8601String()),
        updatedAt: DateTime.parse(data['updatedAt'] ?? DateTime.now().toIso8601String()),
        isPublic: data['isPublic'] ?? false,
      );
    } catch (e) {
      LoggerService.error(
        'Failed to parse Jeopardy game from Firestore',
        tag: _tag,
        error: e,
      );
      return null;
    }
  }
}
````

## File: lib/features/games/domain/repositories/jeopardy_repository.dart
````dart
/// Repository interface for Jeopardy game operations.
/// 
/// This module defines the contract for Jeopardy game data persistence
/// and retrieval operations in the education platform.
library;

import '../models/jeopardy_game.dart';

/// Abstract repository defining Jeopardy game operations.
/// 
/// This interface provides a comprehensive contract for Jeopardy
/// game implementations, supporting:
/// - Game creation and management
/// - Teacher-specific game collections
/// - Public game library access
/// - Real-time game streaming
/// - Search capabilities
/// 
/// Concrete implementations handle the actual game
/// storage infrastructure and data persistence.
abstract class JeopardyRepository {
  /// Creates a new Jeopardy game.
  /// 
  /// Stores the game with generated ID and returns
  /// the ID for reference.
  /// 
  /// @param game Game model with configuration
  /// @return Generated unique game ID
  /// @throws Exception if creation fails
  Future<String> createGame(JeopardyGame game);
  
  /// Updates an existing Jeopardy game.
  /// 
  /// Modifies game content, settings, or categories.
  /// Updates the timestamp automatically.
  /// 
  /// @param gameId Game to update
  /// @param game Updated game information
  /// @throws Exception if update fails
  Future<void> updateGame(String gameId, JeopardyGame game);
  
  /// Retrieves a specific Jeopardy game.
  /// 
  /// Fetches complete game details including
  /// categories, questions, and settings.
  /// 
  /// @param gameId Unique game identifier
  /// @return Game instance or null if not found
  /// @throws Exception if retrieval fails
  Future<JeopardyGame?> getGame(String gameId);
  
  /// Retrieves all games created by a teacher.
  /// 
  /// Returns games sorted by last update time,
  /// newest first for easy access.
  /// 
  /// @param teacherId Teacher's unique identifier
  /// @return List of teacher's games
  /// @throws Exception if retrieval fails
  Future<List<JeopardyGame>> getTeacherGames(String teacherId);
  
  /// Retrieves public games available to all.
  /// 
  /// Returns games marked as public, useful for
  /// sharing educational content.
  /// 
  /// @return List of public games
  /// @throws Exception if retrieval fails
  Future<List<JeopardyGame>> getPublicGames();
  
  /// Deletes a Jeopardy game.
  /// 
  /// Permanently removes the game from storage.
  /// This operation cannot be undone.
  /// 
  /// @param gameId Game to delete
  /// @throws Exception if deletion fails
  Future<void> deleteGame(String gameId);
  
  /// Toggles public visibility of a game.
  /// 
  /// Makes game available to all users or
  /// restricts to creator only.
  /// 
  /// @param gameId Game to toggle
  /// @param isPublic Whether game should be public
  /// @throws Exception if toggle fails
  Future<void> togglePublicStatus(String gameId, bool isPublic);
  
  /// Streams teacher's games in real-time.
  /// 
  /// Returns live updates when games are created,
  /// updated, or deleted.
  /// 
  /// @param teacherId Teacher to monitor
  /// @return Stream of game lists
  Stream<List<JeopardyGame>> streamTeacherGames(String teacherId);
  
  /// Searches games by title or content.
  /// 
  /// Performs text search across game titles,
  /// categories, and questions.
  /// 
  /// @param query Search terms
  /// @param teacherId Optional teacher filter
  /// @return List of matching games
  /// @throws Exception if search fails
  Future<List<JeopardyGame>> searchGames(String query, {String? teacherId});
  
  /// Disposes of repository resources.
  /// 
  /// Cleans up streams and connections.
  void dispose();
}
````

## File: lib/features/games/presentation/providers/jeopardy_provider.dart
````dart
/// Jeopardy game state management provider.
/// 
/// This module manages Jeopardy game state for the education platform,
/// handling game creation, updates, and real-time synchronization.
library;

import 'dart:async';
import 'package:flutter/material.dart';
import 'package:firebase_auth/firebase_auth.dart';
import '../../domain/models/jeopardy_game.dart';
import '../../domain/repositories/jeopardy_repository.dart';
import '../../../../shared/core/service_locator.dart';
import '../../../../shared/services/logger_service.dart';

/// Provider managing Jeopardy game state.
/// 
/// This provider serves as the central state manager for Jeopardy games,
/// coordinating between the UI and repository. Key features:
/// - Real-time game updates for teachers
/// - Public game library access
/// - Game creation and editing workflows
/// - Search functionality
/// - Automatic stream management
/// 
/// Maintains separate caches for teacher games and public games
/// with automatic synchronization.
class JeopardyProvider with ChangeNotifier {
  /// Logger tag for this provider.
  static const String _tag = 'JeopardyProvider';
  
  /// Repository for game data operations.
  late final JeopardyRepository _repository;
  
  /// Firebase Auth for user identification.
  final FirebaseAuth _auth = FirebaseAuth.instance;
  
  // State variables
  
  /// Teacher's games.
  List<JeopardyGame> _teacherGames = [];
  
  /// Public games available to all.
  List<JeopardyGame> _publicGames = [];
  
  /// Currently selected/editing game.
  JeopardyGame? _currentGame;
  
  /// Loading state for async operations.
  bool _isLoading = false;
  
  /// Latest error message for UI display.
  String? _error;
  
  /// Search query for filtering games.
  String _searchQuery = '';
  
  // Stream subscriptions
  
  /// Subscription for teacher games updates.
  StreamSubscription<List<JeopardyGame>>? _teacherGamesSubscription;
  
  /// Creates provider with repository dependency.
  /// 
  /// Retrieves repository from dependency injection.
  JeopardyProvider() {
    _repository = getIt<JeopardyRepository>();
  }
  
  // Getters
  
  /// Teacher's games list.
  List<JeopardyGame> get teacherGames => _teacherGames;
  
  /// Public games list.
  List<JeopardyGame> get publicGames => _publicGames;
  
  /// Currently selected game or null.
  JeopardyGame? get currentGame => _currentGame;
  
  /// Whether an operation is in progress.
  bool get isLoading => _isLoading;
  
  /// Latest error message or null.
  String? get error => _error;
  
  /// Current search query.
  String get searchQuery => _searchQuery;
  
  /// Current user's ID from Firebase Auth.
  String get currentUserId => _auth.currentUser?.uid ?? '';
  
  /// Filtered teacher games based on search query.
  List<JeopardyGame> get filteredTeacherGames {
    if (_searchQuery.isEmpty) return _teacherGames;
    
    final query = _searchQuery.toLowerCase();
    return _teacherGames.where((game) {
      return game.title.toLowerCase().contains(query) ||
             game.categories.any((cat) => 
               cat.name.toLowerCase().contains(query) ||
               cat.questions.any((q) => 
                 q.question.toLowerCase().contains(query) ||
                 q.answer.toLowerCase().contains(query)
               )
             );
    }).toList();
  }
  
  /// Filtered public games based on search query.
  List<JeopardyGame> get filteredPublicGames {
    if (_searchQuery.isEmpty) return _publicGames;
    
    final query = _searchQuery.toLowerCase();
    return _publicGames.where((game) {
      return game.title.toLowerCase().contains(query) ||
             game.categories.any((cat) => 
               cat.name.toLowerCase().contains(query) ||
               cat.questions.any((q) => 
                 q.question.toLowerCase().contains(query) ||
                 q.answer.toLowerCase().contains(query)
               )
             );
    }).toList();
  }
  
  /// Initializes provider and loads teacher games.
  /// 
  /// Sets up real-time stream for teacher's games.
  /// Should be called when teacher dashboard opens.
  Future<void> initialize() async {
    _setLoading(true);
    _error = null;
    
    try {
      // Set up real-time stream for teacher games
      _teacherGamesSubscription?.cancel();
      _teacherGamesSubscription = _repository
          .streamTeacherGames(currentUserId)
          .listen(
            (games) {
              _teacherGames = games;
              _error = null;
              notifyListeners();
            },
            onError: (error) {
              _error = error.toString();
              LoggerService.error(
                'Failed to stream teacher games',
                tag: _tag,
                error: error,
              );
              notifyListeners();
            },
          );
      
      // Load public games
      await loadPublicGames();
    } catch (e) {
      _error = e.toString();
      LoggerService.error(
        'Failed to initialize JeopardyProvider',
        tag: _tag,
        error: e,
      );
    } finally {
      _setLoading(false);
    }
  }
  
  /// Loads public games from repository.
  /// 
  /// Fetches games marked as public for sharing.
  Future<void> loadPublicGames() async {
    try {
      _publicGames = await _repository.getPublicGames();
      notifyListeners();
    } catch (e) {
      LoggerService.error(
        'Failed to load public games',
        tag: _tag,
        error: e,
      );
    }
  }
  
  /// Creates a new Jeopardy game.
  /// 
  /// Saves game to Firestore and updates local cache.
  /// 
  /// @param game Game data to create
  /// @return Created game ID or null if failed
  Future<String?> createGame(JeopardyGame game) async {
    _setLoading(true);
    _error = null;
    
    try {
      // Ensure teacherId is set
      final gameToCreate = JeopardyGame(
        id: '',
        title: game.title,
        teacherId: currentUserId,
        categories: game.categories,
        finalJeopardy: game.finalJeopardy,
        createdAt: DateTime.now(),
        updatedAt: DateTime.now(),
        isPublic: game.isPublic,
      );
      
      final gameId = await _repository.createGame(gameToCreate);
      LoggerService.info('Created Jeopardy game: $gameId', tag: _tag);
      
      return gameId;
    } catch (e) {
      _error = e.toString();
      LoggerService.error(
        'Failed to create game',
        tag: _tag,
        error: e,
      );
      return null;
    } finally {
      _setLoading(false);
    }
  }
  
  /// Updates an existing Jeopardy game.
  /// 
  /// Modifies game in Firestore and updates local cache.
  /// 
  /// @param gameId Game to update
  /// @param game Updated game data
  /// @return true if update successful
  Future<bool> updateGame(String gameId, JeopardyGame game) async {
    _setLoading(true);
    _error = null;
    
    try {
      // Update with new timestamp
      final gameToUpdate = JeopardyGame(
        id: gameId,
        title: game.title,
        teacherId: game.teacherId,
        categories: game.categories,
        finalJeopardy: game.finalJeopardy,
        createdAt: game.createdAt,
        updatedAt: DateTime.now(),
        isPublic: game.isPublic,
      );
      
      await _repository.updateGame(gameId, gameToUpdate);
      LoggerService.info('Updated Jeopardy game: $gameId', tag: _tag);
      
      return true;
    } catch (e) {
      _error = e.toString();
      LoggerService.error(
        'Failed to update game',
        tag: _tag,
        error: e,
      );
      return false;
    } finally {
      _setLoading(false);
    }
  }
  
  /// Loads a specific game by ID.
  /// 
  /// Fetches game from repository and sets as current.
  /// 
  /// @param gameId Game to load
  /// @return Game instance or null if not found
  Future<JeopardyGame?> loadGame(String gameId) async {
    _setLoading(true);
    _error = null;
    
    try {
      _currentGame = await _repository.getGame(gameId);
      notifyListeners();
      return _currentGame;
    } catch (e) {
      _error = e.toString();
      LoggerService.error(
        'Failed to load game',
        tag: _tag,
        error: e,
      );
      return null;
    } finally {
      _setLoading(false);
    }
  }
  
  /// Deletes a Jeopardy game.
  /// 
  /// Removes game from Firestore and local cache.
  /// 
  /// @param gameId Game to delete
  /// @return true if deletion successful
  Future<bool> deleteGame(String gameId) async {
    _setLoading(true);
    _error = null;
    
    try {
      await _repository.deleteGame(gameId);
      LoggerService.info('Deleted Jeopardy game: $gameId', tag: _tag);
      
      return true;
    } catch (e) {
      _error = e.toString();
      LoggerService.error(
        'Failed to delete game',
        tag: _tag,
        error: e,
      );
      return false;
    } finally {
      _setLoading(false);
    }
  }
  
  /// Toggles public visibility of a game.
  /// 
  /// Makes game available to all users or restricts to creator.
  /// 
  /// @param gameId Game to toggle
  /// @param isPublic Whether game should be public
  /// @return true if toggle successful
  Future<bool> togglePublicStatus(String gameId, bool isPublic) async {
    try {
      await _repository.togglePublicStatus(gameId, isPublic);
      
      // Reload public games if making public
      if (isPublic) {
        await loadPublicGames();
      }
      
      return true;
    } catch (e) {
      _error = e.toString();
      LoggerService.error(
        'Failed to toggle public status',
        tag: _tag,
        error: e,
      );
      notifyListeners();
      return false;
    }
  }
  
  /// Updates search query and notifies listeners.
  /// 
  /// @param query New search query
  void updateSearchQuery(String query) {
    _searchQuery = query;
    notifyListeners();
  }
  
  /// Sets the current game for editing or playing.
  /// 
  /// @param game Game to set as current
  void setCurrentGame(JeopardyGame? game) {
    _currentGame = game;
    notifyListeners();
  }
  
  /// Clears the current game selection.
  void clearCurrentGame() {
    _currentGame = null;
    notifyListeners();
  }
  
  /// Clears error message.
  void clearError() {
    _error = null;
    notifyListeners();
  }
  
  // Helper methods
  
  /// Sets loading state and notifies listeners.
  void _setLoading(bool loading) {
    _isLoading = loading;
    notifyListeners();
  }
  
  /// Cleans up resources when provider is disposed.
  @override
  void dispose() {
    _teacherGamesSubscription?.cancel();
    _repository.dispose();
    super.dispose();
  }
}
````

## File: lib/features/notifications/data/services/firebase_messaging_service.dart
````dart
import 'dart:async';
import 'dart:io';
import 'package:firebase_messaging/firebase_messaging.dart';
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:firebase_auth/firebase_auth.dart';
import 'package:flutter/foundation.dart';
import 'notification_service.dart';
import '../../../chat/domain/models/call.dart';
import '../../../../shared/services/logger_service.dart';

/// Background message handler - must be top-level function
@pragma('vm:entry-point')
Future<void> _firebaseMessagingBackgroundHandler(RemoteMessage message) async {
  // Initialize Firebase if needed
  LoggerService.info('Handling background message: ${message.messageId}');
  
  // Check if this is a VoIP call notification
  if (message.data['type'] == 'voip_call') {
    await _handleBackgroundVoIPCall(message);
  }
}

/// Handle VoIP call in background
Future<void> _handleBackgroundVoIPCall(RemoteMessage message) async {
  try {
    final callData = message.data;
    if (callData.isEmpty) {
      LoggerService.warning('Empty call data - discarding');
      return;
    }
    
    // Check if notification is stale (older than 60 seconds)
    final timestampStr = callData['timestamp'] as String?;
    if (timestampStr == null) {
      LoggerService.warning('No timestamp - discarding as stale');
      return;
    }
    
    final timestamp = int.tryParse(timestampStr);
    if (timestamp == null || (DateTime.now().millisecondsSinceEpoch - timestamp > 60000)) { // 60s
      LoggerService.info('Stale/invalid timestamp - discarded');
      return;
    }
    
    final call = Call(
      id: callData['callId'] ?? '',
      callerId: callData['callerId'] ?? '',
      callerName: callData['callerName'] ?? 'Unknown',
      callerPhotoUrl: callData['callerPhotoUrl'] ?? '',
      receiverId: callData['receiverId'] ?? '',
      receiverName: callData['receiverName'] ?? '',
      receiverPhotoUrl: callData['receiverPhotoUrl'] ?? '',
      type: callData['isVideo'] == 'true' ? CallType.video : CallType.voice,
      status: CallStatus.ringing,
      startedAt: DateTime.now(),
      chatRoomId: callData['chatRoomId'],
    );
    
    // Show call notification
    final notificationService = NotificationService();
    await notificationService.initialize();
    await notificationService.showIncomingCall(call);
  } catch (e) {
    LoggerService.error('Error handling background VoIP call', error: e);
  }
}

/// Firebase Cloud Messaging service for push notifications and VoIP
class FirebaseMessagingService {
  static final FirebaseMessagingService _instance = FirebaseMessagingService._internal();
  factory FirebaseMessagingService() => _instance;
  FirebaseMessagingService._internal();
  
  final FirebaseMessaging _messaging = FirebaseMessaging.instance;
  final FirebaseFirestore _firestore = FirebaseFirestore.instance;
  final FirebaseAuth _auth = FirebaseAuth.instance;
  
  bool _isInitialized = false;
  StreamSubscription<RemoteMessage>? _foregroundMessageSubscription;
  StreamSubscription<RemoteMessage>? _messageOpenedSubscription;
  
  // Callbacks
  Function(Call)? onIncomingCall;
  Function(RemoteMessage)? onMessage;
  
  /// Initialize Firebase Messaging
  Future<void> initialize() async {
    if (_isInitialized) return;
    
    try {
      // Force token refresh to drop old queues
      await _messaging.deleteToken();
      LoggerService.info('Deleted old FCM token', tag: 'FirebaseMessagingService');
      
      // Request permissions
      await _requestPermissions();
      
      // Configure message handlers
      FirebaseMessaging.onBackgroundMessage(_firebaseMessagingBackgroundHandler);
      
      // Handle foreground messages
      _foregroundMessageSubscription = FirebaseMessaging.onMessage.listen(_handleForegroundMessage);
      
      // Handle when app is opened from notification
      _messageOpenedSubscription = FirebaseMessaging.onMessageOpenedApp.listen(_handleMessageOpenedApp);
      
      // Get initial message if app was launched from notification
      final initialMessage = await _messaging.getInitialMessage();
      if (initialMessage != null) {
        _handleMessageOpenedApp(initialMessage);
      }
      
      // Set foreground notification presentation options for iOS
      await _messaging.setForegroundNotificationPresentationOptions(
        alert: true,
        badge: true,
        sound: true,
      );
      
      // Get and save FCM token
      await _updateFCMToken();
      
      // Listen for token refresh
      _messaging.onTokenRefresh.listen(_saveFCMToken);
      
      _isInitialized = true;
      LoggerService.info('Firebase Messaging initialized', tag: 'FirebaseMessagingService');
    } catch (e) {
      LoggerService.error('Failed to initialize Firebase Messaging', error: e, tag: 'FirebaseMessagingService');
    }
  }
  
  /// Request notification permissions
  Future<void> _requestPermissions() async {
    if (kIsWeb) {
      // Web doesn't support all permission types
      await _messaging.requestPermission(
        alert: true,
        badge: true,
        sound: true,
      );
    } else if (!kIsWeb && (Platform.isIOS || Platform.isMacOS)) {
      // iOS/macOS require explicit permission
      final settings = await _messaging.requestPermission(
        alert: true,
        announcement: false,
        badge: true,
        carPlay: false,
        criticalAlert: false,
        provisional: false,
        sound: true,
      );
      
      LoggerService.info('User granted permission: ${settings.authorizationStatus}', tag: 'FirebaseMessagingService');
    }
    // Android permissions are handled at runtime when showing notifications
  }
  
  /// Update FCM token in Firestore
  Future<void> _updateFCMToken() async {
    try {
      String? token;
      
      if (kIsWeb) {
        // Web requires VAPID key - get from Firebase Console > Project Settings > Cloud Messaging > Web Push certificates
        const vapidKey = 'BOjhbAUKihT8cj0S6RqK-JvgtA5C-BLRifWimw-93Fz0AmS_52g2YB6bDK2EduEcUTkxljLhG6YuKpDfE9pm2QI';
        
        try {
          // Use VAPID key for web FCM token generation
          token = await _messaging.getToken(vapidKey: vapidKey);
          LoggerService.info('FCM token generated successfully with VAPID key', tag: 'FirebaseMessagingService');
        } catch (e) {
          LoggerService.error('Failed to get FCM token for web with VAPID key: $e', tag: 'FirebaseMessagingService');
          // Fallback: try without VAPID key for development
          try {
            token = await _messaging.getToken();
            LoggerService.warning('Using FCM token without VAPID key (development only)', tag: 'FirebaseMessagingService');
          } catch (fallbackError) {
            LoggerService.error('Failed to get FCM token completely: $fallbackError', tag: 'FirebaseMessagingService');
          }
        }
      } else {
        token = await _messaging.getToken();
      }
      
      if (token != null) {
        await _saveFCMToken(token);
      }
    } catch (e) {
      LoggerService.error('Failed to get FCM token', error: e, tag: 'FirebaseMessagingService');
    }
  }
  
  /// Save FCM token to Firestore
  Future<void> _saveFCMToken(String token) async {
    final userId = _auth.currentUser?.uid;
    if (userId == null) return;
    
    try {
      // Save to user document
      await _firestore.collection('users').doc(userId).update({
        'fcmToken': token,
        'fcmTokenUpdatedAt': FieldValue.serverTimestamp(),
        'platform': _getPlatformString(),
      });
      
      // Also save in a separate tokens collection for easier querying
      await _firestore.collection('fcm_tokens').doc(userId).set({
        'token': token,
        'userId': userId,
        'platform': _getPlatformString(),
        'updatedAt': FieldValue.serverTimestamp(),
      });
      
      LoggerService.info('FCM token saved', tag: 'FirebaseMessagingService');
    } catch (e) {
      LoggerService.error('Failed to save FCM token', error: e, tag: 'FirebaseMessagingService');
    }
  }
  
  /// Get platform string
  String _getPlatformString() {
    if (kIsWeb) return 'web';
    if (Platform.isAndroid) return 'android';
    if (Platform.isIOS) return 'ios';
    if (Platform.isMacOS) return 'macos';
    if (Platform.isWindows) return 'windows';
    if (Platform.isLinux) return 'linux';
    return 'unknown';
  }
  
  /// Handle foreground messages
  void _handleForegroundMessage(RemoteMessage message) {
    LoggerService.info('Received foreground message: ${message.messageId}', tag: 'FirebaseMessagingService');
    
    // Check if this is a VoIP call
    if (message.data['type'] == 'voip_call') {
      _handleVoIPCall(message);
    } else {
      // Handle other message types
      onMessage?.call(message);
      
      // Show local notification for non-VoIP messages
      if (message.notification != null) {
        final notificationService = NotificationService();
        notificationService.sendImmediateNotification(
          title: message.notification!.title ?? 'New Message',
          body: message.notification!.body ?? '',
          payload: message.data['payload'],
        );
      }
    }
  }
  
  /// Handle when app is opened from notification
  void _handleMessageOpenedApp(RemoteMessage message) {
    LoggerService.info('App opened from notification: ${message.messageId}', tag: 'FirebaseMessagingService');
    
    // Navigate based on notification type
    if (message.data['type'] == 'voip_call') {
      // Call should already be shown, just log
      LoggerService.info('Opened app from VoIP call notification', tag: 'FirebaseMessagingService');
    } else if (message.data['type'] == 'chat') {
      // TODO: Navigate to chat screen
      final chatRoomId = message.data['chatRoomId'];
      if (chatRoomId != null) {
        LoggerService.info('Navigate to chat: $chatRoomId', tag: 'FirebaseMessagingService');
      }
    }
  }
  
  /// Handle VoIP call notification
  void _handleVoIPCall(RemoteMessage message) {
    try {
      final callData = message.data;
      if (callData.isEmpty) {
        LoggerService.warning('Empty call data - discarding', tag: 'FirebaseMessagingService');
        return;
      }
      
      // Check if notification is stale (older than 60 seconds)
      final timestampStr = callData['timestamp'] as String?;
      if (timestampStr == null) {
        LoggerService.warning('No timestamp - discarding as stale', tag: 'FirebaseMessagingService');
        return;
      }
      
      final timestamp = int.tryParse(timestampStr);
      if (timestamp == null || (DateTime.now().millisecondsSinceEpoch - timestamp > 60000)) { // 60s
        LoggerService.info('Stale/invalid timestamp - discarded', tag: 'FirebaseMessagingService');
        return;
      }
      
      final call = Call(
        id: callData['callId'] ?? '',
        callerId: callData['callerId'] ?? '',
        callerName: callData['callerName'] ?? 'Unknown',
        callerPhotoUrl: callData['callerPhotoUrl'] ?? '',
        receiverId: callData['receiverId'] ?? '',
        receiverName: callData['receiverName'] ?? '',
        receiverPhotoUrl: callData['receiverPhotoUrl'] ?? '',
        type: callData['isVideo'] == 'true' ? CallType.video : CallType.voice,
        status: CallStatus.ringing,
        startedAt: DateTime.now(),
        chatRoomId: callData['chatRoomId'],
      );
      
      // Invoke callback
      onIncomingCall?.call(call);
      
      // Show call notification
      final notificationService = NotificationService();
      notificationService.showIncomingCall(call);
    } catch (e) {
      LoggerService.error('Error handling VoIP call', error: e, tag: 'FirebaseMessagingService');
    }
  }
  
  /// Send call notification to receiver
  Future<void> sendCallNotification({
    required String receiverId,
    required String callId,
    required String callerName,
    required bool isVideo,
    String? callerPhotoUrl,
    String? chatRoomId,
  }) async {
    try {
      // Get receiver's FCM token
      final tokenDoc = await _firestore.collection('fcm_tokens').doc(receiverId).get();
      if (!tokenDoc.exists) {
        LoggerService.error('No FCM token found for receiver', tag: 'FirebaseMessagingService');
        return;
      }
      
      final token = tokenDoc.data()?['token'] as String?;
      if (token == null) return;
      
      // Create notification payload
      // Note: In production, you would send this to your backend server
      // which would then send the FCM message using the Firebase Admin SDK
      final payload = {
        'to': token,
        'priority': 'high',
        'data': {
          'type': 'voip_call',
          'callId': callId,
          'callerId': _auth.currentUser?.uid ?? '',
          'callerName': callerName,
          'callerPhotoUrl': callerPhotoUrl ?? '',
          'receiverId': receiverId,
          'isVideo': isVideo.toString(),
          'chatRoomId': chatRoomId ?? '',
          'timestamp': DateTime.now().millisecondsSinceEpoch.toString(),
        },
        // For iOS, we need to include notification for it to wake up the app
        'notification': {
          'title': isVideo ? 'Incoming Video Call' : 'Incoming Voice Call',
          'body': '$callerName is calling you',
          'sound': 'default',
        },
        // iOS specific options for VoIP
        'apns': {
          'headers': {
            'apns-priority': '10',
            'apns-push-type': 'voip',
          },
          'payload': {
            'aps': {
              'content-available': 1,
            },
          },
        },
        // Android specific options
        'android': {
          'priority': 'high',
          'ttl': '30s',
        },
      };
      
      // In a real app, you would call your backend API here
      // For now, just log the payload
      LoggerService.info('Would send FCM notification: $payload', tag: 'FirebaseMessagingService');
      
      // TODO: Implement backend API call to send FCM message
      // await yourBackendAPI.sendFCMMessage(payload);
      
    } catch (e) {
      LoggerService.error('Failed to send call notification', error: e, tag: 'FirebaseMessagingService');
    }
  }
  
  /// Get current FCM token
  Future<String?> getCurrentToken() async {
    try {
      if (kIsWeb) {
        // Use VAPID key for web
        const vapidKey = 'BOjhbAUKihT8cj0S6RqK-JvgtA5C-BLRifWimw-93Fz0AmS_52g2YB6bDK2EduEcUTkxljLhG6YuKpDfE9pm2QI';
        
        try {
          return await _messaging.getToken(vapidKey: vapidKey);
        } catch (e) {
          LoggerService.warning('Failed to get current token for web with VAPID key: $e', tag: 'FirebaseMessagingService');
          // Fallback without VAPID key for development
          try {
            return await _messaging.getToken();
          } catch (fallbackError) {
            LoggerService.error('Failed to get current token completely: $fallbackError', tag: 'FirebaseMessagingService');
            return null;
          }
        }
      } else {
        return await _messaging.getToken();
      }
    } catch (e) {
      LoggerService.error('Failed to get current token', error: e, tag: 'FirebaseMessagingService');
      return null;
    }
  }
  
  /// Delete FCM token (for logout)
  Future<void> deleteToken() async {
    try {
      await _messaging.deleteToken();
      
      // Remove from Firestore
      final userId = _auth.currentUser?.uid;
      if (userId != null) {
        await _firestore.collection('users').doc(userId).update({
          'fcmToken': FieldValue.delete(),
          'fcmTokenUpdatedAt': FieldValue.delete(),
        });
        
        await _firestore.collection('fcm_tokens').doc(userId).delete();
      }
      
      LoggerService.info('FCM token deleted', tag: 'FirebaseMessagingService');
    } catch (e) {
      LoggerService.error('Failed to delete token', error: e, tag: 'FirebaseMessagingService');
    }
  }
  
  /// Dispose of resources
  void dispose() {
    _foregroundMessageSubscription?.cancel();
    _messageOpenedSubscription?.cancel();
  }
}
````

## File: lib/features/notifications/data/services/notification_service_stub.dart
````dart
/// Stub implementation for non-web platforms
class WebNotification {
  static bool get supported => false;
  static String? get permission => null;
  static Future<String> requestPermission() async => 'denied';
}
````

## File: lib/features/notifications/data/services/notification_service_web.dart
````dart
/// Web implementation for notification permissions
library;

import 'dart:html' as html show Notification;

class WebNotification {
  static bool get supported => html.Notification.supported;
  static String? get permission => html.Notification.permission;
  static Future<String> requestPermission() =>
      html.Notification.requestPermission();
}
````

## File: lib/features/notifications/data/services/voip_token_service.dart
````dart
import 'dart:io';
import 'package:flutter/foundation.dart';
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:firebase_auth/firebase_auth.dart';
import 'package:flutter_callkit_incoming/flutter_callkit_incoming.dart';
import '../../../../shared/services/logger_service.dart';

/// Service to handle VoIP push token management for iOS
class VoIPTokenService {
  static final VoIPTokenService _instance = VoIPTokenService._internal();
  factory VoIPTokenService() => _instance;
  VoIPTokenService._internal();
  
  final FirebaseFirestore _firestore = FirebaseFirestore.instance;
  final FirebaseAuth _auth = FirebaseAuth.instance;
  
  String? _currentVoIPToken;
  
  /// Initialize VoIP token handling
  Future<void> initialize() async {
    if (kIsWeb || !Platform.isIOS) {
      LoggerService.info('VoIP tokens only supported on iOS native', tag: 'VoIPTokenService');
      return;
    }
    
    try {
      // Listen for VoIP token updates from iOS
      // Note: flutter_callkit_incoming doesn't have onTokenRefresh stream
      // VoIP tokens are handled by the native iOS code in AppDelegate.swift
      
      // Get current token if available (this may return null if not set from native side)
      try {
        final currentToken = await FlutterCallkitIncoming.getDevicePushTokenVoIP();
        if (currentToken != null && currentToken.isNotEmpty) {
          LoggerService.info('Current VoIP token: $currentToken', tag: 'VoIPTokenService');
          await _saveVoIPToken(currentToken);
        }
      } catch (e) {
        LoggerService.warning('Could not get VoIP token - may not be available yet', tag: 'VoIPTokenService');
      }
    } catch (e) {
      LoggerService.error('Failed to initialize VoIP token service', error: e, tag: 'VoIPTokenService');
    }
  }
  
  /// Save VoIP token to Firestore
  Future<void> _saveVoIPToken(String token) async {
    if (token == _currentVoIPToken) return; // Skip if same token
    
    final userId = _auth.currentUser?.uid;
    if (userId == null) {
      LoggerService.warning('Cannot save VoIP token - user not authenticated', tag: 'VoIPTokenService');
      return;
    }
    
    try {
      // Update user document
      await _firestore.collection('users').doc(userId).update({
        'voipToken': token,
        'voipTokenUpdatedAt': FieldValue.serverTimestamp(),
        'platform': 'ios',
      });
      
      // Also save in separate collection for easier querying
      await _firestore.collection('voip_tokens').doc(userId).set({
        'token': token,
        'userId': userId,
        'platform': 'ios',
        'updatedAt': FieldValue.serverTimestamp(),
      });
      
      _currentVoIPToken = token;
      LoggerService.info('VoIP token saved successfully', tag: 'VoIPTokenService');
    } catch (e) {
      LoggerService.error('Failed to save VoIP token', error: e, tag: 'VoIPTokenService');
    }
  }
  
  /// Get VoIP token for a user
  Future<String?> getVoIPTokenForUser(String userId) async {
    try {
      final doc = await _firestore.collection('voip_tokens').doc(userId).get();
      if (doc.exists) {
        return doc.data()?['token'] as String?;
      }
    } catch (e) {
      LoggerService.error('Failed to get VoIP token for user', error: e, tag: 'VoIPTokenService');
    }
    return null;
  }
  
  /// Delete VoIP token (for logout)
  Future<void> deleteVoIPToken() async {
    final userId = _auth.currentUser?.uid;
    if (userId == null) return;
    
    try {
      // Remove from user document
      await _firestore.collection('users').doc(userId).update({
        'voipToken': FieldValue.delete(),
        'voipTokenUpdatedAt': FieldValue.delete(),
      });
      
      // Remove from tokens collection
      await _firestore.collection('voip_tokens').doc(userId).delete();
      
      _currentVoIPToken = null;
      LoggerService.info('VoIP token deleted', tag: 'VoIPTokenService');
    } catch (e) {
      LoggerService.error('Failed to delete VoIP token', error: e, tag: 'VoIPTokenService');
    }
  }
  
  /// Send VoIP push notification (for server implementation reference)
  /// This would typically be implemented on your backend server
  Map<String, dynamic> generateVoIPPushPayload({
    required String voipToken,
    required String callId,
    required String callerId,
    required String callerName,
    required bool isVideo,
    String? callerPhotoUrl,
    String? chatRoomId,
  }) {
    return {
      'aps': {
        // Empty aps for VoIP push
      },
      'callId': callId,
      'callerId': callerId,
      'callerName': callerName,
      'callerPhotoUrl': callerPhotoUrl ?? '',
      'isVideo': isVideo,
      'chatRoomId': chatRoomId ?? '',
      'timestamp': DateTime.now().millisecondsSinceEpoch,
    };
  }
}
````

## File: lib/shared/example/example_repository.dart
````dart
/// Central repository for example/preview data used across the app.
/// 
/// This module provides consistent, realistic example data that appears
/// in empty states to help users understand the app's potential.
library;

import '../../features/student/domain/models/student.dart';
import '../../features/classes/domain/models/class_model.dart';

/// Enumeration of different example data domains.
enum ExampleDomain {
  students,
  classes,
  assignments,
  grades,
}

/// Central repository for managing example data across the application.
/// 
/// Provides consistent, realistic example data for empty states.
/// All example data is clearly distinguishable from real content.
class ExampleRepository {
  ExampleRepository._();
  static final ExampleRepository _instance = ExampleRepository._();
  static ExampleRepository get instance => _instance;
  
  /// Get example data for a specific domain and type.
  static List<T> of<T>(ExampleDomain domain) {
    switch (domain) {
      case ExampleDomain.students:
        return _exampleStudents.cast<T>();
      case ExampleDomain.classes:
        return _exampleClasses.cast<T>();
      case ExampleDomain.assignments:
        return _exampleAssignments.cast<T>();
      case ExampleDomain.grades:
        return _exampleGrades.cast<T>();
    }
  }
  
  /// Example students with realistic but clearly fake data.
  static final List<Student> _exampleStudents = [
    Student(
      id: 'example_student_1',
      userId: 'example_user_1',
      firstName: 'Emma',
      lastName: 'Example',
      displayName: 'Emma Example',
      email: 'emma.example@preview.edu',
      gradeLevel: 10,
      parentEmail: 'sarah.example@preview.edu',
      classIds: ['example_class_1', 'example_class_2'],
      createdAt: DateTime.now().subtract(const Duration(days: 90)),
      updatedAt: DateTime.now().subtract(const Duration(days: 2)),
      isActive: true,
    ),
    Student(
      id: 'example_student_2',
      userId: 'example_user_2',
      firstName: 'Marcus',
      lastName: 'Sample',
      displayName: 'Marcus Sample',
      email: 'marcus.sample@preview.edu',
      gradeLevel: 10,
      parentEmail: 'carlos.sample@preview.edu',
      classIds: ['example_class_1', 'example_class_3'],
      createdAt: DateTime.now().subtract(const Duration(days: 85)),
      updatedAt: DateTime.now().subtract(const Duration(days: 5)),
      isActive: true,
    ),
    Student(
      id: 'example_student_3',
      userId: 'example_user_3',
      firstName: 'Aisha',
      lastName: 'Demo',
      displayName: 'Aisha Demo',
      email: 'aisha.demo@preview.edu',
      gradeLevel: 10,
      parentEmail: 'priya.demo@preview.edu',
      classIds: ['example_class_2', 'example_class_4'],
      createdAt: DateTime.now().subtract(const Duration(days: 92)),
      updatedAt: DateTime.now().subtract(const Duration(days: 1)),
      isActive: true,
    ),
    Student(
      id: 'example_student_4',
      userId: 'example_user_4',
      firstName: 'David',
      lastName: 'Preview',
      displayName: 'David Preview',
      email: 'david.preview@preview.edu',
      gradeLevel: 10,
      parentEmail: 'michael.preview@preview.edu',
      classIds: ['example_class_1'],
      createdAt: DateTime.now().subtract(const Duration(days: 88)),
      updatedAt: DateTime.now().subtract(const Duration(days: 3)),
      isActive: true,
    ),
    Student(
      id: 'example_student_5',
      userId: 'example_user_5',
      firstName: 'Sophie',
      lastName: 'Test',
      displayName: 'Sophie Test',
      email: 'sophie.test@preview.edu',
      gradeLevel: 10,
      parentEmail: 'lisa.test@preview.edu',
      classIds: ['example_class_3', 'example_class_4'],
      createdAt: DateTime.now().subtract(const Duration(days: 94)),
      updatedAt: DateTime.now().subtract(const Duration(days: 7)),
      isActive: true,
    ),
  ];
  
  /// Example classes with realistic scheduling and enrollment data.
  static final List<ClassModel> _exampleClasses = [
    ClassModel(
      id: 'example_class_1',
      teacherId: 'current_teacher',
      name: 'Advanced Mathematics',
      subject: 'Mathematics',
      gradeLevel: '10th Grade',
      room: 'Room 205',
      schedule: 'MWF 9:00-10:00 AM',
      studentIds: ['example_student_1', 'example_student_2', 'example_student_4'],
      maxStudents: 30,
      enrollmentCode: 'MATH205',
      description: 'Advanced algebra and introduction to calculus concepts.',
      academicYear: '2024-2025',
      semester: 'Fall',
      isActive: true,
      createdAt: DateTime.now().subtract(const Duration(days: 120)),
    ),
    ClassModel(
      id: 'example_class_2',
      teacherId: 'current_teacher',
      name: 'Environmental Science',
      subject: 'Science',
      gradeLevel: '10th Grade',
      room: 'Lab 101',
      schedule: 'TTh 1:00-2:30 PM',
      studentIds: ['example_student_1', 'example_student_3'],
      maxStudents: 25,
      enrollmentCode: 'ENVS101',
      description: 'Study of environmental systems and sustainability.',
      academicYear: '2024-2025',
      semester: 'Fall',
      isActive: true,
      createdAt: DateTime.now().subtract(const Duration(days: 115)),
    ),
    ClassModel(
      id: 'example_class_3',
      teacherId: 'current_teacher',
      name: 'Creative Writing',
      subject: 'English',
      gradeLevel: '10th Grade',
      room: 'Room 312',
      schedule: 'MWF 2:00-3:00 PM',
      studentIds: ['example_student_2', 'example_student_5'],
      maxStudents: 24,
      enrollmentCode: 'ENG312',
      description: 'Develop writing skills through poetry, short stories, and essays.',
      academicYear: '2024-2025',
      semester: 'Fall',
      isActive: true,
      createdAt: DateTime.now().subtract(const Duration(days: 110)),
    ),
    ClassModel(
      id: 'example_class_4',
      teacherId: 'current_teacher',
      name: 'Physics Honors',
      subject: 'Physics',
      gradeLevel: '10th Grade',
      room: 'Lab 203',
      schedule: 'TTh 10:00-11:30 AM',
      studentIds: ['example_student_3', 'example_student_5'],
      maxStudents: 20,
      enrollmentCode: 'PHYS203',
      description: 'Advanced physics concepts with hands-on laboratory work.',
      academicYear: '2024-2025',
      semester: 'Fall',
      isActive: true,
      createdAt: DateTime.now().subtract(const Duration(days: 105)),
    ),
  ];
  
  /// Example assignments for gradebook demonstrations.
  static final List<dynamic> _exampleAssignments = [
    {
      'id': 'example_assignment_1',
      'name': 'Quadratic Functions Worksheet',
      'type': 'homework',
      'dueDate': DateTime.now().subtract(const Duration(days: 14)),
      'maxPoints': 25,
      'weight': 1.0,
      'description': 'Practice problems on quadratic equations and graphing.',
    },
    {
      'id': 'example_assignment_2',
      'name': 'Chapter 5 Quiz',
      'type': 'quiz',
      'dueDate': DateTime.now().subtract(const Duration(days: 10)),
      'maxPoints': 50,
      'weight': 1.5,
      'description': 'Quiz covering polynomial functions and factoring.',
    },
    {
      'id': 'example_assignment_3',
      'name': 'Midterm Exam',
      'type': 'test',
      'dueDate': DateTime.now().subtract(const Duration(days: 7)),
      'maxPoints': 100,
      'weight': 3.0,
      'description': 'Comprehensive exam covering units 1-4.',
    },
    {
      'id': 'example_assignment_4',
      'name': 'Trigonometry Project',
      'type': 'project',
      'dueDate': DateTime.now().add(const Duration(days: 5)),
      'maxPoints': 75,
      'weight': 2.5,
      'description': 'Real-world application of trigonometric functions.',
    },
    {
      'id': 'example_assignment_5',
      'name': 'Functions Review',
      'type': 'homework',
      'dueDate': DateTime.now().add(const Duration(days: 3)),
      'maxPoints': 20,
      'weight': 1.0,
      'description': 'Review exercises for upcoming test.',
    },
  ];
  
  /// Example grades for gradebook demonstrations.
  static final List<dynamic> _exampleGrades = [
    // Emma Example's grades
    {'studentId': 'example_student_1', 'assignmentId': 'example_assignment_1', 'points': 23.0, 'status': 'graded'},
    {'studentId': 'example_student_1', 'assignmentId': 'example_assignment_2', 'points': 47.0, 'status': 'graded'},
    {'studentId': 'example_student_1', 'assignmentId': 'example_assignment_3', 'points': 94.0, 'status': 'graded'},
    {'studentId': 'example_student_1', 'assignmentId': 'example_assignment_4', 'points': null, 'status': 'not_submitted'},
    {'studentId': 'example_student_1', 'assignmentId': 'example_assignment_5', 'points': null, 'status': 'not_submitted'},
    
    // Marcus Sample's grades
    {'studentId': 'example_student_2', 'assignmentId': 'example_assignment_1', 'points': 21.0, 'status': 'graded'},
    {'studentId': 'example_student_2', 'assignmentId': 'example_assignment_2', 'points': 43.0, 'status': 'graded'},
    {'studentId': 'example_student_2', 'assignmentId': 'example_assignment_3', 'points': 87.0, 'status': 'graded'},
    {'studentId': 'example_student_2', 'assignmentId': 'example_assignment_4', 'points': null, 'status': 'not_submitted'},
    {'studentId': 'example_student_2', 'assignmentId': 'example_assignment_5', 'points': null, 'status': 'not_submitted'},
    
    // Aisha Demo's grades
    {'studentId': 'example_student_3', 'assignmentId': 'example_assignment_1', 'points': 25.0, 'status': 'graded'},
    {'studentId': 'example_student_3', 'assignmentId': 'example_assignment_2', 'points': 49.0, 'status': 'graded'},
    {'studentId': 'example_student_3', 'assignmentId': 'example_assignment_3', 'points': 98.0, 'status': 'graded'},
    {'studentId': 'example_student_3', 'assignmentId': 'example_assignment_4', 'points': null, 'status': 'not_submitted'},
    {'studentId': 'example_student_3', 'assignmentId': 'example_assignment_5', 'points': null, 'status': 'not_submitted'},
    
    // David Preview's grades
    {'studentId': 'example_student_4', 'assignmentId': 'example_assignment_1', 'points': 18.0, 'status': 'graded'},
    {'studentId': 'example_student_4', 'assignmentId': 'example_assignment_2', 'points': null, 'status': 'missing'},
    {'studentId': 'example_student_4', 'assignmentId': 'example_assignment_3', 'points': 82.0, 'status': 'graded'},
    {'studentId': 'example_student_4', 'assignmentId': 'example_assignment_4', 'points': null, 'status': 'not_submitted'},
    {'studentId': 'example_student_4', 'assignmentId': 'example_assignment_5', 'points': null, 'status': 'not_submitted'},
    
    // Sophie Test's grades
    {'studentId': 'example_student_5', 'assignmentId': 'example_assignment_1', 'points': 22.0, 'status': 'graded'},
    {'studentId': 'example_student_5', 'assignmentId': 'example_assignment_2', 'points': 45.0, 'status': 'graded'},
    {'studentId': 'example_student_5', 'assignmentId': 'example_assignment_3', 'points': 91.0, 'status': 'graded'},
    {'studentId': 'example_student_5', 'assignmentId': 'example_assignment_4', 'points': null, 'status': 'not_submitted'},
    {'studentId': 'example_student_5', 'assignmentId': 'example_assignment_5', 'points': null, 'status': 'not_submitted'},
  ];
}
````

## File: lib/shared/widgets/preview/example_badge.dart
````dart
/// ExampleBadge component with accessibility support.
/// 
/// This widget provides a clear visual indicator that content is example/preview
/// data with proper accessibility labels and interaction handling.
library;

import 'package:flutter/material.dart';

/// A badge widget that clearly indicates example/preview content.
/// 
/// Features:
/// - Clear visual design with example text and icon
/// - Accessibility support with semantic labels
/// - Optional tap interaction for more information
/// - Material Design 3 styling
/// - Customizable appearance
class ExampleBadge extends StatelessWidget {
  /// Callback when the badge is tapped
  final VoidCallback? onTap;
  
  /// Custom text for the badge (defaults to "Example")
  final String? text;
  
  /// Custom icon for the badge
  final IconData? icon;
  
  /// Size variant of the badge
  final ExampleBadgeSize size;
  
  /// Whether the badge should be interactive
  final bool interactive;
  
  /// Custom background color
  final Color? backgroundColor;
  
  /// Custom text/icon color
  final Color? foregroundColor;

  const ExampleBadge({
    super.key,
    this.onTap,
    this.text,
    this.icon,
    this.size = ExampleBadgeSize.medium,
    this.interactive = true,
    this.backgroundColor,
    this.foregroundColor,
  });

  /// Create a compact badge variant
  const ExampleBadge.compact({
    super.key,
    this.onTap,
    this.text,
    this.icon,
    this.interactive = true,
    this.backgroundColor,
    this.foregroundColor,
  }) : size = ExampleBadgeSize.compact;

  /// Create a large badge variant
  const ExampleBadge.large({
    super.key,
    this.onTap,
    this.text,
    this.icon,
    this.interactive = true,
    this.backgroundColor,
    this.foregroundColor,
  }) : size = ExampleBadgeSize.large;

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final colorScheme = theme.colorScheme;
    
    // Determine colors
    final bgColor = backgroundColor ?? colorScheme.tertiary.withValues(alpha: 0.9);
    final fgColor = foregroundColor ?? colorScheme.onTertiary;
    
    // Get size-specific properties
    final sizeProps = _getSizeProperties();
    
    final badgeContent = Container(
      padding: sizeProps.padding,
      decoration: BoxDecoration(
        color: bgColor,
        borderRadius: BorderRadius.circular(sizeProps.borderRadius),
        boxShadow: [
          BoxShadow(
            color: Colors.black.withValues(alpha: 0.1),
            blurRadius: 4,
            offset: const Offset(0, 2),
          ),
        ],
      ),
      child: Row(
        mainAxisSize: MainAxisSize.min,
        children: [
          Icon(
            icon ?? Icons.visibility_outlined,
            size: sizeProps.iconSize,
            color: fgColor,
          ),
          if (size != ExampleBadgeSize.compact) ...[
            SizedBox(width: sizeProps.spacing),
            Text(
              text ?? 'Example',
              style: theme.textTheme.labelSmall?.copyWith(
                color: fgColor,
                fontWeight: FontWeight.w600,
                fontSize: sizeProps.fontSize,
              ),
            ),
          ],
        ],
      ),
    );

    if (!interactive || onTap == null) {
      return Semantics(
        label: 'Example content badge - indicates preview data',
        hint: 'This content is for demonstration purposes',
        child: badgeContent,
      );
    }

    return Semantics(
      label: 'Example content badge - tap for more information',
      hint: 'Double tap to learn about example content',
      button: true,
      child: Material(
        color: Colors.transparent,
        child: InkWell(
          onTap: onTap,
          borderRadius: BorderRadius.circular(sizeProps.borderRadius),
          child: badgeContent,
        ),
      ),
    );
  }

  _BadgeSizeProperties _getSizeProperties() {
    switch (size) {
      case ExampleBadgeSize.compact:
        return const _BadgeSizeProperties(
          padding: EdgeInsets.all(6),
          iconSize: 14,
          fontSize: 10,
          spacing: 4,
          borderRadius: 8,
        );
      case ExampleBadgeSize.medium:
        return const _BadgeSizeProperties(
          padding: EdgeInsets.symmetric(horizontal: 8, vertical: 6),
          iconSize: 16,
          fontSize: 12,
          spacing: 6,
          borderRadius: 10,
        );
      case ExampleBadgeSize.large:
        return const _BadgeSizeProperties(
          padding: EdgeInsets.symmetric(horizontal: 12, vertical: 8),
          iconSize: 18,
          fontSize: 14,
          spacing: 8,
          borderRadius: 12,
        );
    }
  }
}

/// Size variants for the ExampleBadge
enum ExampleBadgeSize {
  /// Compact size - icon only
  compact,
  
  /// Medium size - icon and text (default)
  medium,
  
  /// Large size - larger icon and text
  large,
}

/// Internal class to hold size-specific properties
class _BadgeSizeProperties {
  final EdgeInsets padding;
  final double iconSize;
  final double fontSize;
  final double spacing;
  final double borderRadius;

  const _BadgeSizeProperties({
    required this.padding,
    required this.iconSize,
    required this.fontSize,
    required this.spacing,
    required this.borderRadius,
  });
}

/// Utility widget for showing example info dialogs
class ExampleInfoDialog extends StatelessWidget {
  /// Title for the dialog
  final String title;
  
  /// Message content for the dialog
  final String message;
  
  /// Optional action button text
  final String? actionText;
  
  /// Optional action callback
  final VoidCallback? onAction;

  const ExampleInfoDialog({
    super.key,
    this.title = 'Example Content',
    this.message = 'This is preview content to show you how the app works. Create your own content to replace these examples.',
    this.actionText,
    this.onAction,
  });

  /// Show the example info dialog
  static Future<void> show(
    BuildContext context, {
    String? title,
    String? message,
    String? actionText,
    VoidCallback? onAction,
  }) {
    return showDialog<void>(
      context: context,
      builder: (context) => ExampleInfoDialog(
        title: title ?? 'Example Content',
        message: message ?? 'This is preview content to show you how the app works. Create your own content to replace these examples.',
        actionText: actionText,
        onAction: onAction,
      ),
    );
  }

  @override
  Widget build(BuildContext context) {
    return AlertDialog(
      icon: Icon(
        Icons.info_outline,
        color: Theme.of(context).colorScheme.primary,
      ),
      title: Text(title),
      content: Text(message),
      actions: [
        if (actionText != null && onAction != null)
          TextButton(
            onPressed: () {
              Navigator.of(context).pop();
              onAction!();
            },
            child: Text(actionText!),
          ),
        TextButton(
          onPressed: () => Navigator.of(context).pop(),
          child: const Text('Got it'),
        ),
      ],
    );
  }
}
````

## File: lib/shared/widgets/preview/preview_example_wrapper.dart
````dart
/// PreviewExampleWrapper widget with explicit DataState enum.
/// 
/// This widget provides a robust state management solution for showing
/// example/preview content when real data is empty, with clear visual
/// indicators and smooth transitions.
library;

import 'package:flutter/material.dart';
import 'example_badge.dart';

/// Enumeration representing different data states to prevent race conditions.
enum DataState {
  /// Data is currently being loaded
  loading,
  
  /// No data available (empty state)
  empty,
  
  /// Real data is available and populated
  populated,
  
  /// Error occurred while loading data
  error,
}

/// A wrapper widget that intelligently shows example data when real data is empty.
/// 
/// This widget provides:
/// - Explicit state management with DataState enum
/// - Visual indicators for example content
/// - Smooth transitions between states
/// - Accessibility support
/// - Interaction guards for example items
class PreviewExampleWrapper<T> extends StatelessWidget {
  /// Real data from the application
  final List<T>? realData;
  
  /// Example/preview data to show when real data is empty
  final List<T> exampleData;
  
  /// Builder function to render the data
  final Widget Function(BuildContext context, List<T> data, bool isExample) builder;
  
  /// Whether data is currently loading
  final bool isLoading;
  
  /// Error message if data loading failed
  final String? error;
  
  /// Callback when user taps on an example item
  final VoidCallback? onExampleTap;
  
  /// Custom empty state widget
  final Widget? emptyWidget;
  
  /// Custom loading widget
  final Widget? loadingWidget;
  
  /// Custom error widget
  final Widget? errorWidget;
  
  /// Whether to show the example badge
  final bool showExampleBadge;
  
  /// Animation duration for state transitions
  final Duration animationDuration;

  const PreviewExampleWrapper({
    super.key,
    this.realData,
    required this.exampleData,
    required this.builder,
    this.isLoading = false,
    this.error,
    this.onExampleTap,
    this.emptyWidget,
    this.loadingWidget,
    this.errorWidget,
    this.showExampleBadge = true,
    this.animationDuration = const Duration(milliseconds: 300),
  });

  /// Determine the current data state based on inputs
  DataState get _currentState {
    if (error != null) return DataState.error;
    if (isLoading) return DataState.loading;
    if (realData != null && realData!.isNotEmpty) return DataState.populated;
    return DataState.empty;
  }


  @override
  Widget build(BuildContext context) {
    return AnimatedSwitcher(
      duration: animationDuration,
      transitionBuilder: (Widget child, Animation<double> animation) {
        return FadeTransition(
          opacity: animation,
          child: SlideTransition(
            position: Tween<Offset>(
              begin: const Offset(0.0, 0.1),
              end: Offset.zero,
            ).animate(CurvedAnimation(
              parent: animation,
              curve: Curves.easeOutCubic,
            )),
            child: child,
          ),
        );
      },
      child: _buildStateContent(context),
    );
  }

  Widget _buildStateContent(BuildContext context) {
    switch (_currentState) {
      case DataState.loading:
        return _buildLoadingState(context);
      
      case DataState.error:
        return _buildErrorState(context);
      
      case DataState.empty:
        return _buildExampleState(context);
      
      case DataState.populated:
        return _buildPopulatedState(context);
    }
  }

  Widget _buildLoadingState(BuildContext context) {
    if (loadingWidget != null) return loadingWidget!;
    
    return const Center(
      child: Padding(
        padding: EdgeInsets.all(32.0),
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            CircularProgressIndicator(),
            SizedBox(height: 16),
            Text('Loading...'),
          ],
        ),
      ),
    );
  }

  Widget _buildErrorState(BuildContext context) {
    if (errorWidget != null) return errorWidget!;
    
    return Center(
      child: Padding(
        padding: const EdgeInsets.all(32.0),
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Icon(
              Icons.error_outline,
              size: 64,
              color: Theme.of(context).colorScheme.error,
            ),
            const SizedBox(height: 16),
            Text(
              'Error: $error',
              style: Theme.of(context).textTheme.bodyLarge,
              textAlign: TextAlign.center,
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildExampleState(BuildContext context) {
    if (exampleData.isEmpty) {
      return _buildTrueEmptyState(context);
    }

    return Semantics(
      label: 'Preview examples - showing sample content to demonstrate features',
      child: Stack(
        children: [
          // Example content with interaction guard
          _InteractionGuard(
            onTap: onExampleTap,
            child: builder(context, exampleData, true),
          ),
          
          // Example badge
          if (showExampleBadge)
            Positioned(
              top: 8,
              right: 8,
              child: ExampleBadge(
                onTap: onExampleTap,
              ),
            ),
        ],
      ),
    );
  }

  Widget _buildPopulatedState(BuildContext context) {
    return builder(context, realData!, false);
  }

  Widget _buildTrueEmptyState(BuildContext context) {
    if (emptyWidget != null) return emptyWidget!;
    
    return Center(
      child: Padding(
        padding: const EdgeInsets.all(32.0),
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Icon(
              Icons.inbox_outlined,
              size: 64,
              color: Theme.of(context).colorScheme.onSurfaceVariant,
            ),
            const SizedBox(height: 16),
            Text(
              'No content available',
              style: Theme.of(context).textTheme.titleMedium,
            ),
            const SizedBox(height: 8),
            Text(
              'Create your first item to get started',
              style: Theme.of(context).textTheme.bodyMedium?.copyWith(
                color: Theme.of(context).colorScheme.onSurfaceVariant,
              ),
            ),
          ],
        ),
      ),
    );
  }
}

/// Widget that guards interactions with example content
class _InteractionGuard extends StatelessWidget {
  final Widget child;
  final VoidCallback? onTap;

  const _InteractionGuard({
    required this.child,
    this.onTap,
  });

  @override
  Widget build(BuildContext context) {
    return AbsorbPointer(
      absorbing: true,
      child: GestureDetector(
        onTap: () {
          // Show info dialog about example content
          if (onTap != null) {
            onTap!.call();
          } else {
            _showExampleInfoDialog(context);
          }
        },
        child: child,
      ),
    );
  }

  void _showExampleInfoDialog(BuildContext context) {
    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        icon: const Icon(Icons.info_outline),
        title: const Text('Example Content'),
        content: const Text(
          'This is preview content to show you how the app works. '
          'Create your own content to replace these examples.',
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.of(context).pop(),
            child: const Text('Got it'),
          ),
        ],
      ),
    );
  }
}
````

## File: lib/shared/widgets/splash_screen.dart
````dart
import 'package:flutter/material.dart';

/// Splash screen shown during app initialization
class SplashScreen extends StatelessWidget {
  final String? message;
  final double? progress;
  
  const SplashScreen({
    super.key,
    this.message,
    this.progress,
  });

  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      debugShowCheckedModeBanner: false,
      home: Scaffold(
        backgroundColor: const Color(0xFFF5F5F5),
        body: Center(
          child: Column(
            mainAxisAlignment: MainAxisAlignment.center,
            children: [
              // App logo or icon
              const Icon(
                Icons.school,
                size: 80,
                color: Color(0xFF2196F3),
              ),
              const SizedBox(height: 24),
              
              // App title
              const Text(
                'Teacher Dashboard',
                style: TextStyle(
                  fontSize: 28,
                  fontWeight: FontWeight.bold,
                  color: Color(0xFF212121),
                ),
              ),
              const SizedBox(height: 48),
              
              // Progress indicator
              SizedBox(
                width: 200,
                child: Column(
                  children: [
                    if (progress != null)
                      LinearProgressIndicator(
                        value: progress,
                        backgroundColor: Colors.grey[300],
                      )
                    else
                      const CircularProgressIndicator(),
                    const SizedBox(height: 16),
                    
                    // Status message
                    Text(
                      message ?? 'Loading...',
                      style: const TextStyle(
                        fontSize: 14,
                        color: Color(0xFF757575),
                      ),
                      textAlign: TextAlign.center,
                    ),
                  ],
                ),
              ),
            ],
          ),
        ),
      ),
    );
  }
}
````

## File: set_java21.bat
````
@echo off
setx JAVA_HOME "C:\Program Files\Java\jdk-21"
setx PATH "%JAVA_HOME%\bin;%PATH%"
echo Java 21 has been set as default
echo Please restart VS Code after running this script
````

## File: web/firebase-messaging-sw.js
````javascript
importScripts("https://www.gstatic.com/firebasejs/9.10.0/firebase-app-compat.js");
importScripts("https://www.gstatic.com/firebasejs/9.10.0/firebase-messaging-compat.js");

// Initialize the Firebase app in the service worker
// Firebase configuration from firebase_options.dart
const firebaseConfig = {
  apiKey: "AIzaSyD_nLVRdyd6ZlIyFrRGCW5IStXnM2-uUac",
  authDomain: "teacher-dashboard-flutterfire.firebaseapp.com",
  projectId: "teacher-dashboard-flutterfire",
  storageBucket: "teacher-dashboard-flutterfire.firebasestorage.app",
  messagingSenderId: "218352465432",
  appId: "1:218352465432:web:6e1c0fa4f21416df38b56d"
};

firebase.initializeApp(firebaseConfig);

// Retrieve firebase messaging
const messaging = firebase.messaging();

// Note: Token retrieval should be done in the main app after permission is granted,
// not in the service worker. The service worker only handles background messages.

// Handle background messages
messaging.onBackgroundMessage((payload) => {
  console.log("[firebase-messaging-sw.js] Received background message ", payload);
  
  const notificationTitle = payload.notification.title;
  const notificationOptions = {
    body: payload.notification.body,
    icon: "/icons/icon-192.png",
    badge: "/icons/icon-72.png",
    data: payload.data
  };

  self.registration.showNotification(notificationTitle, notificationOptions);
});

// Handle notification clicks
self.addEventListener('notificationclick', (event) => {
  console.log('[firebase-messaging-sw.js] Notification click received.');
  
  event.notification.close();
  
  // Handle the click action based on the notification data
  if (event.notification.data && event.notification.data.type === 'voip_call') {
    // Open the app and handle the call
    event.waitUntil(
      clients.openWindow('/')
    );
  }
});
````

## File: .github/dependa-bot.yml
````yaml
# To get started with Dependabot version updates, you'll need to specify which
# package ecosystems to update and where the package manifests are located.
# Please see the documentation for all configuration options:
# https://docs.github.com/code-security/dependabot/dependabot-version-updates/configuration-options-for-the-dependabot.yml-file

version: 2
updates:
  - package-ecosystem: "" # See documentation for possible values
    directory: "/" # Location of package manifests
    schedule:
      interval: "weekly"
````

## File: .github/workflows/apisec-scan.yml
````yaml
# This workflow uses actions that are not certified by GitHub.
# They are provided by a third-party and are governed by
# separate terms of service, privacy policy, and support
# documentation.

# APIsec addresses the critical need to secure APIs before they reach production.
# APIsec provides the industry’s only automated and continuous API testing platform that uncovers security vulnerabilities and logic flaws in APIs.
# Clients rely on APIsec to evaluate every update and release, ensuring that no APIs go to production with vulnerabilities.

# How to Get Started with APIsec.ai
# 1. Schedule a demo at https://www.apisec.ai/request-a-demo .
#
# 2. Register your account at https://cloud.apisec.ai/#/signup .
#
# 3. Register your API . See the video (https://www.youtube.com/watch?v=MK3Xo9Dbvac) to get up and running with APIsec quickly.
#
# 4. Get GitHub Actions scan attributes from APIsec Project -> Configurations -> Integrations -> CI-CD -> GitHub Actions
#
# apisec-run-scan
#
# This action triggers the on-demand scans for projects registered in APIsec.
# If your GitHub account allows code scanning alerts, you can then upload the sarif file generated by this action to show the scan findings.
# Else you can view the scan results from the project home page in APIsec Platform.
# The link to view the scan results is also displayed on the console on successful completion of action.

# This is a starter workflow to help you get started with APIsec-Scan Actions

name: APIsec

# Controls when the workflow will run
on:
  # Triggers the workflow on push or pull request events but only for the "main" branch
  # Customize trigger events based on your DevSecOps processes.
  push:
    branches: [ "main" ]
  pull_request:
    branches: [ "main" ]
  schedule:
    - cron: '32 2 * * 3'

  # Allows you to run this workflow manually from the Actions tab
  workflow_dispatch:


permissions:
  contents: read

jobs:

  Trigger_APIsec_scan:
    permissions:
      security-events: write # for github/codeql-action/upload-sarif to upload SARIF results
      actions: read # only required for a private repository by github/codeql-action/upload-sarif to get the Action run status
    runs-on: ubuntu-latest

    steps:
       - name: APIsec scan
         uses: apisec-inc/apisec-run-scan@025432089674a28ba8fb55f8ab06c10215e772ea
         with:
          # The APIsec username with which the scans will be executed
          apisec-username: ${{ secrets.apisec_username }}
          # The Password of the APIsec user with which the scans will be executed
          apisec-password: ${{ secrets.apisec_password}}
          # The name of the project for security scan
          apisec-project: "VAmPI"
          # The name of the sarif format result file The file is written only if this property is provided.
          sarif-result-file: "apisec-results.sarif"
       - name: Import results
         uses: github/codeql-action/upload-sarif@v3
         with:
          sarif_file: ./apisec-results.sarif
````

## File: .github/workflows/claude.yml
````yaml
name: Claude Assistant
on:
  issue_comment:
    types: [created]
  pull_request_review_comment:
    types: [created]
  issues:
    types: [opened, assigned, labeled]
  pull_request_review:
    types: [submitted]

jobs:
  claude-response:
    runs-on: ubuntu-latest
    steps:
      - uses: anthropics/claude-code-action@beta
        with:
          anthropic_api_key: ${{ secrets.ANTHROPIC_API_KEY }}
          github_token: ${{ secrets.GITHUB_TOKEN }}
          # Optional: add custom trigger phrase (default: @claude)
          # trigger_phrase: "/claude"
          # Optional: add assignee trigger for issues
          # assignee_trigger: "claude"
          # Optional: add label trigger for issues
          # label_trigger: "claude"
          # Optional: add custom environment variables (YAML format)
          # claude_env: |
          #   NODE_ENV: test
          #   DEBUG: true
          #   API_URL: https://api.example.com
          # Optional: limit the number of conversation turns
          # max_turns: "5"
````

## File: .github/workflows/qodana_code_quality.yml
````yaml
name: Qodana
on:
  workflow_dispatch:
  pull_request:
  push:
    branches: # Specify your branches here
      - main # The 'main' branch
      - 'releases/*' # The release branches

jobs:
  qodana:
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write
      checks: write
    steps:
      - uses: actions/checkout@v3
        with:
          ref: ${{ github.event.pull_request.head.sha }}  # to check out the actual pull request commit, not the merge commit
          fetch-depth: 0  # a full history is required for pull request analysis
      - name: 'Qodana Scan'
        uses: JetBrains/qodana-action@v2025.1
        with:
          pr-mode: false
        env:
          QODANA_TOKEN: ${{ secrets.QODANA_TOKEN_431200767 }}
          QODANA_ENDPOINT: 'https://qodana.cloud'
````

## File: analysis_options.yaml
````yaml
# This file configures the analyzer, which statically analyzes Dart code to
# check for errors, warnings, and lints.
#
# The issues identified by the analyzer are surfaced in the UI of Dart-enabled
# IDEs (https://dart.dev/tools#ides-and-editors). The analyzer can also be
# invoked from the command line by running `flutter analyze`.

# The following line activates a set of recommended lints for Flutter apps,
# packages, and plugins designed to encourage good coding practices.
include: package:flutter_lints/flutter.yaml

linter:
  # The lint rules applied to this project can be customized in the
  # section below to disable rules from the `package:flutter_lints/flutter.yaml`
  # included above or to enable additional rules. A list of all available lints
  # and their documentation is published at https://dart.dev/lints.
  #
  # Instead of disabling a lint rule for the entire project in the
  # section below, it can also be suppressed for a single line of code
  # or a specific dart file by using the `// ignore: name_of_lint` and
  # `// ignore_for_file: name_of_lint` syntax on the line or in the file
  # producing the lint.
  rules:
    # avoid_print: false  # Uncomment to disable the `avoid_print` rule
    # prefer_single_quotes: true  # Uncomment to enable the `prefer_single_quotes` rule

# Additional information about this file can be found at
# https://dart.dev/guides/language/analysis-options
````

## File: android/.gitignore
````
gradle-wrapper.jar
/.gradle
/captures/
/gradlew
/gradlew.bat
/local.properties
GeneratedPluginRegistrant.java

# Remember to never publicly share your keystore.
# See https://flutter.dev/to/reference-keystore
key.properties
**/*.keystore
**/*.jks
````

## File: android/app/src/debug/AndroidManifest.xml
````xml
<manifest xmlns:android="http://schemas.android.com/apk/res/android">
    <!-- The INTERNET permission is required for development. Specifically,
         the Flutter tool needs it to communicate with the running application
         to allow setting breakpoints, to provide hot reload, etc.
    -->
    <uses-permission android:name="android.permission.INTERNET"/>
</manifest>
````

## File: android/app/src/main/kotlin/com/teacherdashboard/teacher_dashboard_flutter_firebase/MainActivity.kt
````kotlin
package com.teacherdashboard.teacher_dashboard_flutter_firebase

import io.flutter.embedding.android.FlutterActivity

class MainActivity: FlutterActivity()
````

## File: android/app/src/main/res/drawable-v21/launch_background.xml
````xml
<?xml version="1.0" encoding="utf-8"?>
<!-- Modify this file to customize your launch splash screen -->
<layer-list xmlns:android="http://schemas.android.com/apk/res/android">
    <item android:drawable="?android:colorBackground" />

    <!-- You can insert your own image assets here -->
    <!-- <item>
        <bitmap
            android:gravity="center"
            android:src="@mipmap/launch_image" />
    </item> -->
</layer-list>
````

## File: android/app/src/main/res/drawable/launch_background.xml
````xml
<?xml version="1.0" encoding="utf-8"?>
<!-- Modify this file to customize your launch splash screen -->
<layer-list xmlns:android="http://schemas.android.com/apk/res/android">
    <item android:drawable="@android:color/white" />

    <!-- You can insert your own image assets here -->
    <!-- <item>
        <bitmap
            android:gravity="center"
            android:src="@mipmap/launch_image" />
    </item> -->
</layer-list>
````

## File: android/app/src/main/res/values-night/styles.xml
````xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <!-- Theme applied to the Android Window while the process is starting when the OS's Dark Mode setting is on -->
    <style name="LaunchTheme" parent="@android:style/Theme.Black.NoTitleBar">
        <!-- Show a splash screen on the activity. Automatically removed when
             the Flutter engine draws its first frame -->
        <item name="android:windowBackground">@drawable/launch_background</item>
    </style>
    <!-- Theme applied to the Android Window as soon as the process has started.
         This theme determines the color of the Android Window while your
         Flutter UI initializes, as well as behind your Flutter UI while its
         running.

         This Theme is only used starting with V2 of Flutter's Android embedding. -->
    <style name="NormalTheme" parent="@android:style/Theme.Black.NoTitleBar">
        <item name="android:windowBackground">?android:colorBackground</item>
    </style>
</resources>
````

## File: android/app/src/main/res/values/styles.xml
````xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <!-- Theme applied to the Android Window while the process is starting when the OS's Dark Mode setting is off -->
    <style name="LaunchTheme" parent="@android:style/Theme.Light.NoTitleBar">
        <!-- Show a splash screen on the activity. Automatically removed when
             the Flutter engine draws its first frame -->
        <item name="android:windowBackground">@drawable/launch_background</item>
    </style>
    <!-- Theme applied to the Android Window as soon as the process has started.
         This theme determines the color of the Android Window while your
         Flutter UI initializes, as well as behind your Flutter UI while its
         running.

         This Theme is only used starting with V2 of Flutter's Android embedding. -->
    <style name="NormalTheme" parent="@android:style/Theme.Light.NoTitleBar">
        <item name="android:windowBackground">?android:colorBackground</item>
    </style>
</resources>
````

## File: android/app/src/profile/AndroidManifest.xml
````xml
<manifest xmlns:android="http://schemas.android.com/apk/res/android">
    <!-- The INTERNET permission is required for development. Specifically,
         the Flutter tool needs it to communicate with the running application
         to allow setting breakpoints, to provide hot reload, etc.
    -->
    <uses-permission android:name="android.permission.INTERNET"/>
</manifest>
````

## File: android/build.gradle.kts
````
allprojects {
    repositories {
        google()
        mavenCentral()
    }
}


val newBuildDir: Directory = rootProject.layout.buildDirectory.dir("../../build").get()
rootProject.layout.buildDirectory.value(newBuildDir)

subprojects {
    val newSubprojectBuildDir: Directory = newBuildDir.dir(project.name)
    project.layout.buildDirectory.value(newSubprojectBuildDir)
    
    plugins.withId("com.android.base") {
        extensions.configure<com.android.build.gradle.BaseExtension>("android") {
            compileOptions {
                sourceCompatibility = JavaVersion.VERSION_11
                targetCompatibility = JavaVersion.VERSION_11
            }
        }
    }
    
    plugins.withId("kotlin-android") {
        extensions.configure<org.jetbrains.kotlin.gradle.dsl.KotlinJvmOptions>("kotlinOptions") {
            jvmTarget = "11"
        }
    }
}

tasks.register<Delete>("clean") {
    delete(rootProject.layout.buildDirectory)
}
````

## File: docker-compose.yml
````yaml
services:
  neo4j:
    image: neo4j:5.13.0-enterprise
    container_name: memento-neo4j
    platform: linux/amd64
    environment:
      - NEO4J_AUTH=neo4j/memento_password
      - NEO4J_ACCEPT_LICENSE_AGREEMENT=yes
      - NEO4J_apoc_export_file_enabled=true
      - NEO4J_apoc_import_file_enabled=true
      - NEO4J_apoc_import_file_use__neo4j__config=true
      - NEO4J_dbms_security_procedures_unrestricted=apoc.*,gds.*
      - NEO4J_dbms_security_procedures_allowlist=apoc.*,gds.*
    ports:
      - "7474:7474"
      - "7687:7687"
    volumes:
      - ./neo4j-data:/data
      - ./neo4j-logs:/logs
      - ./neo4j-import:/import
````

## File: firebase_options.dart
````dart
// File generated by FlutterFire CLI.
// ignore_for_file: lines_longer_than_80_chars, avoid_classes_with_only_static_members
import 'package:firebase_core/firebase_core.dart' show FirebaseOptions;
import 'package:flutter/foundation.dart'
    show defaultTargetPlatform, kIsWeb, TargetPlatform;

/// Default [FirebaseOptions] for use with your Firebase apps.
///
/// Example:
/// ```dart
/// import 'firebase_options.dart';
/// // ...
/// await Firebase.initializeApp(
///   options: DefaultFirebaseOptions.currentPlatform,
/// );
/// ```
class DefaultFirebaseOptions {
  static FirebaseOptions get currentPlatform {
    if (kIsWeb) {
      return web;
    }
    switch (defaultTargetPlatform) {
      case TargetPlatform.android:
        return android;
      case TargetPlatform.iOS:
        return ios;
      case TargetPlatform.macOS:
        return macos;
      case TargetPlatform.windows:
        return windows;
      case TargetPlatform.linux:
        return linux;
      default:
        throw UnsupportedError(
          'DefaultFirebaseOptions have not been configured for this platform.',
        );
    }
  }

  static const FirebaseOptions web = FirebaseOptions(
    apiKey: 'AIzaSyD_nLVRdyd6ZlIyFrRGCW5IStXnM2-uUac',
    appId: '1:218352465432:web:6e1c0fa4f21416df38b56d',
    messagingSenderId: '218352465432',
    projectId: 'teacher-dashboard-flutterfire',
    authDomain: 'teacher-dashboard-flutterfire.firebaseapp.com',
    storageBucket: 'teacher-dashboard-flutterfire.firebasestorage.app',
    databaseURL: 'https://teacher-dashboard-flutterfire-default-rtdb.firebaseio.com',
  );

  static const FirebaseOptions android = FirebaseOptions(
    apiKey: 'AIzaSyD_nLVRdyd6ZlIyFrRGCW5IStXnM2-uUac',
    appId: '1:218352465432:android:a7d591b9db6bef6038b56d',
    messagingSenderId: '218352465432',
    projectId: 'teacher-dashboard-flutterfire',
    storageBucket: 'teacher-dashboard-flutterfire.firebasestorage.app',
    databaseURL: 'https://teacher-dashboard-flutterfire-default-rtdb.firebaseio.com',
  );

  static const FirebaseOptions ios = FirebaseOptions(
    apiKey: 'AIzaSyD_nLVRdyd6ZlIyFrRGCW5IStXnM2-uUac',
    appId: '1:218352465432:ios:5lt4mte28dqof4ae3igmi6m8i261jh99',
    messagingSenderId: '218352465432',
    projectId: 'teacher-dashboard-flutterfire',
    storageBucket: 'teacher-dashboard-flutterfire.firebasestorage.app',
    databaseURL: 'https://teacher-dashboard-flutterfire-default-rtdb.firebaseio.com',
    iosBundleId: 'com.teacherdashboard.teacherDashboardFlutter',
  );

  static const FirebaseOptions macos = FirebaseOptions(
    apiKey: 'AIzaSyD_nLVRdyd6ZlIyFrRGCW5IStXnM2-uUac',
    appId: '1:218352465432:ios:5lt4mte28dqof4ae3igmi6m8i261jh99',
    messagingSenderId: '218352465432',
    projectId: 'teacher-dashboard-flutterfire',
    storageBucket: 'teacher-dashboard-flutterfire.firebasestorage.app',
    databaseURL: 'https://teacher-dashboard-flutterfire-default-rtdb.firebaseio.com',
    iosBundleId: 'com.teacherdashboard.teacherDashboardFlutter',
  );

  static const FirebaseOptions windows = FirebaseOptions(
    apiKey: 'AIzaSyD_nLVRdyd6ZlIyFrRGCW5IStXnM2-uUac',
    appId: '1:218352465432:web:6e1c0fa4f21416df38b56d',
    messagingSenderId: '218352465432',
    projectId: 'teacher-dashboard-flutterfire',
    authDomain: 'teacher-dashboard-flutterfire.firebaseapp.com',
    storageBucket: 'teacher-dashboard-flutterfire.firebasestorage.app',
    databaseURL: 'https://teacher-dashboard-flutterfire-default-rtdb.firebaseio.com',
  );

  static const FirebaseOptions linux = FirebaseOptions(
    apiKey: 'AIzaSyD_nLVRdyd6ZlIyFrRGCW5IStXnM2-uUac',
    appId: '1:218352465432:web:6e1c0fa4f21416df38b56d',
    messagingSenderId: '218352465432',
    projectId: 'teacher-dashboard-flutterfire',
    authDomain: 'teacher-dashboard-flutterfire.firebaseapp.com',
    storageBucket: 'teacher-dashboard-flutterfire.firebasestorage.app',
    databaseURL: 'https://teacher-dashboard-flutterfire-default-rtdb.firebaseio.com',
  );
}
````

## File: firebase.json
````json
{
  "hosting": {
    "public": "build/web",
    "ignore": [
      "firebase.json",
      "**/.*",
      "**/node_modules/**"
    ],
    "rewrites": [
      {
        "source": "**",
        "destination": "/index.html"
      }
    ]
  },
  "firestore": {
    "rules": "firestore.rules",
    "indexes": "firestore.indexes.json"
  },
  "storage": {
    "rules": "storage.rules"
  },
  "emulators": {
    "auth": {
      "port": 9099
    },
    "firestore": {
      "port": 8080
    },
    "storage": {
      "port": 9199
    },
    "ui": {
      "enabled": true,
      "port": 4000
    },
    "singleProjectMode": true,
    "hosting": {
      "port": 5000
    }
  }
}
````

## File: ios/.gitignore
````
**/dgph
*.mode1v3
*.mode2v3
*.moved-aside
*.pbxuser
*.perspectivev3
**/*sync/
.sconsign.dblite
.tags*
**/.vagrant/
**/DerivedData/
Icon?
**/Pods/
**/.symlinks/
profile
xcuserdata
**/.generated/
Flutter/App.framework
Flutter/Flutter.framework
Flutter/Flutter.podspec
Flutter/Generated.xcconfig
Flutter/ephemeral/
Flutter/app.flx
Flutter/app.zip
Flutter/flutter_assets/
Flutter/flutter_export_environment.sh
ServiceDefinitions.json
Runner/GeneratedPluginRegistrant.*

# Exceptions to above rules.
!default.mode1v3
!default.mode2v3
!default.pbxuser
!default.perspectivev3
````

## File: ios/Flutter/AppFrameworkInfo.plist
````
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
  <key>CFBundleDevelopmentRegion</key>
  <string>en</string>
  <key>CFBundleExecutable</key>
  <string>App</string>
  <key>CFBundleIdentifier</key>
  <string>io.flutter.flutter.app</string>
  <key>CFBundleInfoDictionaryVersion</key>
  <string>6.0</string>
  <key>CFBundleName</key>
  <string>App</string>
  <key>CFBundlePackageType</key>
  <string>FMWK</string>
  <key>CFBundleShortVersionString</key>
  <string>1.0</string>
  <key>CFBundleSignature</key>
  <string>????</string>
  <key>CFBundleVersion</key>
  <string>1.0</string>
  <key>MinimumOSVersion</key>
  <string>12.0</string>
</dict>
</plist>
````

## File: ios/Runner.xcodeproj/project.pbxproj
````
// !$*UTF8*$!
{
	archiveVersion = 1;
	classes = {
	};
	objectVersion = 54;
	objects = {

/* Begin PBXBuildFile section */
		1498D2341E8E89220040F4C2 /* GeneratedPluginRegistrant.m in Sources */ = {isa = PBXBuildFile; fileRef = 1498D2331E8E89220040F4C2 /* GeneratedPluginRegistrant.m */; };
		331C808B294A63AB00263BE5 /* RunnerTests.swift in Sources */ = {isa = PBXBuildFile; fileRef = 331C807B294A618700263BE5 /* RunnerTests.swift */; };
		3B3967161E833CAA004F5970 /* AppFrameworkInfo.plist in Resources */ = {isa = PBXBuildFile; fileRef = 3B3967151E833CAA004F5970 /* AppFrameworkInfo.plist */; };
		74858FAF1ED2DC5600515810 /* AppDelegate.swift in Sources */ = {isa = PBXBuildFile; fileRef = 74858FAE1ED2DC5600515810 /* AppDelegate.swift */; };
		97C146FC1CF9000F007C117D /* Main.storyboard in Resources */ = {isa = PBXBuildFile; fileRef = 97C146FA1CF9000F007C117D /* Main.storyboard */; };
		97C146FE1CF9000F007C117D /* Assets.xcassets in Resources */ = {isa = PBXBuildFile; fileRef = 97C146FD1CF9000F007C117D /* Assets.xcassets */; };
		97C147011CF9000F007C117D /* LaunchScreen.storyboard in Resources */ = {isa = PBXBuildFile; fileRef = 97C146FF1CF9000F007C117D /* LaunchScreen.storyboard */; };
/* End PBXBuildFile section */

/* Begin PBXContainerItemProxy section */
		331C8085294A63A400263BE5 /* PBXContainerItemProxy */ = {
			isa = PBXContainerItemProxy;
			containerPortal = 97C146E61CF9000F007C117D /* Project object */;
			proxyType = 1;
			remoteGlobalIDString = 97C146ED1CF9000F007C117D;
			remoteInfo = Runner;
		};
/* End PBXContainerItemProxy section */

/* Begin PBXCopyFilesBuildPhase section */
		9705A1C41CF9048500538489 /* Embed Frameworks */ = {
			isa = PBXCopyFilesBuildPhase;
			buildActionMask = 2147483647;
			dstPath = "";
			dstSubfolderSpec = 10;
			files = (
			);
			name = "Embed Frameworks";
			runOnlyForDeploymentPostprocessing = 0;
		};
/* End PBXCopyFilesBuildPhase section */

/* Begin PBXFileReference section */
		1498D2321E8E86230040F4C2 /* GeneratedPluginRegistrant.h */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.h; path = GeneratedPluginRegistrant.h; sourceTree = "<group>"; };
		1498D2331E8E89220040F4C2 /* GeneratedPluginRegistrant.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = GeneratedPluginRegistrant.m; sourceTree = "<group>"; };
		331C807B294A618700263BE5 /* RunnerTests.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = RunnerTests.swift; sourceTree = "<group>"; };
		331C8081294A63A400263BE5 /* RunnerTests.xctest */ = {isa = PBXFileReference; explicitFileType = wrapper.cfbundle; includeInIndex = 0; path = RunnerTests.xctest; sourceTree = BUILT_PRODUCTS_DIR; };
		3B3967151E833CAA004F5970 /* AppFrameworkInfo.plist */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = text.plist.xml; name = AppFrameworkInfo.plist; path = Flutter/AppFrameworkInfo.plist; sourceTree = "<group>"; };
		74858FAD1ED2DC5600515810 /* Runner-Bridging-Header.h */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.h; path = "Runner-Bridging-Header.h"; sourceTree = "<group>"; };
		74858FAE1ED2DC5600515810 /* AppDelegate.swift */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.swift; path = AppDelegate.swift; sourceTree = "<group>"; };
		7AFA3C8E1D35360C0083082E /* Release.xcconfig */ = {isa = PBXFileReference; lastKnownFileType = text.xcconfig; name = Release.xcconfig; path = Flutter/Release.xcconfig; sourceTree = "<group>"; };
		9740EEB21CF90195004384FC /* Debug.xcconfig */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = text.xcconfig; name = Debug.xcconfig; path = Flutter/Debug.xcconfig; sourceTree = "<group>"; };
		9740EEB31CF90195004384FC /* Generated.xcconfig */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = text.xcconfig; name = Generated.xcconfig; path = Flutter/Generated.xcconfig; sourceTree = "<group>"; };
		97C146EE1CF9000F007C117D /* Runner.app */ = {isa = PBXFileReference; explicitFileType = wrapper.application; includeInIndex = 0; path = Runner.app; sourceTree = BUILT_PRODUCTS_DIR; };
		97C146FB1CF9000F007C117D /* Base */ = {isa = PBXFileReference; lastKnownFileType = file.storyboard; name = Base; path = Base.lproj/Main.storyboard; sourceTree = "<group>"; };
		97C146FD1CF9000F007C117D /* Assets.xcassets */ = {isa = PBXFileReference; lastKnownFileType = folder.assetcatalog; path = Assets.xcassets; sourceTree = "<group>"; };
		97C147001CF9000F007C117D /* Base */ = {isa = PBXFileReference; lastKnownFileType = file.storyboard; name = Base; path = Base.lproj/LaunchScreen.storyboard; sourceTree = "<group>"; };
		97C147021CF9000F007C117D /* Info.plist */ = {isa = PBXFileReference; lastKnownFileType = text.plist.xml; path = Info.plist; sourceTree = "<group>"; };
/* End PBXFileReference section */

/* Begin PBXFrameworksBuildPhase section */
		97C146EB1CF9000F007C117D /* Frameworks */ = {
			isa = PBXFrameworksBuildPhase;
			buildActionMask = 2147483647;
			files = (
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
/* End PBXFrameworksBuildPhase section */

/* Begin PBXGroup section */
		331C8082294A63A400263BE5 /* RunnerTests */ = {
			isa = PBXGroup;
			children = (
				331C807B294A618700263BE5 /* RunnerTests.swift */,
			);
			path = RunnerTests;
			sourceTree = "<group>";
		};
		9740EEB11CF90186004384FC /* Flutter */ = {
			isa = PBXGroup;
			children = (
				3B3967151E833CAA004F5970 /* AppFrameworkInfo.plist */,
				9740EEB21CF90195004384FC /* Debug.xcconfig */,
				7AFA3C8E1D35360C0083082E /* Release.xcconfig */,
				9740EEB31CF90195004384FC /* Generated.xcconfig */,
			);
			name = Flutter;
			sourceTree = "<group>";
		};
		97C146E51CF9000F007C117D = {
			isa = PBXGroup;
			children = (
				9740EEB11CF90186004384FC /* Flutter */,
				97C146F01CF9000F007C117D /* Runner */,
				97C146EF1CF9000F007C117D /* Products */,
				331C8082294A63A400263BE5 /* RunnerTests */,
			);
			sourceTree = "<group>";
		};
		97C146EF1CF9000F007C117D /* Products */ = {
			isa = PBXGroup;
			children = (
				97C146EE1CF9000F007C117D /* Runner.app */,
				331C8081294A63A400263BE5 /* RunnerTests.xctest */,
			);
			name = Products;
			sourceTree = "<group>";
		};
		97C146F01CF9000F007C117D /* Runner */ = {
			isa = PBXGroup;
			children = (
				97C146FA1CF9000F007C117D /* Main.storyboard */,
				97C146FD1CF9000F007C117D /* Assets.xcassets */,
				97C146FF1CF9000F007C117D /* LaunchScreen.storyboard */,
				97C147021CF9000F007C117D /* Info.plist */,
				1498D2321E8E86230040F4C2 /* GeneratedPluginRegistrant.h */,
				1498D2331E8E89220040F4C2 /* GeneratedPluginRegistrant.m */,
				74858FAE1ED2DC5600515810 /* AppDelegate.swift */,
				74858FAD1ED2DC5600515810 /* Runner-Bridging-Header.h */,
			);
			path = Runner;
			sourceTree = "<group>";
		};
/* End PBXGroup section */

/* Begin PBXNativeTarget section */
		331C8080294A63A400263BE5 /* RunnerTests */ = {
			isa = PBXNativeTarget;
			buildConfigurationList = 331C8087294A63A400263BE5 /* Build configuration list for PBXNativeTarget "RunnerTests" */;
			buildPhases = (
				331C807D294A63A400263BE5 /* Sources */,
				331C807F294A63A400263BE5 /* Resources */,
			);
			buildRules = (
			);
			dependencies = (
				331C8086294A63A400263BE5 /* PBXTargetDependency */,
			);
			name = RunnerTests;
			productName = RunnerTests;
			productReference = 331C8081294A63A400263BE5 /* RunnerTests.xctest */;
			productType = "com.apple.product-type.bundle.unit-test";
		};
		97C146ED1CF9000F007C117D /* Runner */ = {
			isa = PBXNativeTarget;
			buildConfigurationList = 97C147051CF9000F007C117D /* Build configuration list for PBXNativeTarget "Runner" */;
			buildPhases = (
				9740EEB61CF901F6004384FC /* Run Script */,
				97C146EA1CF9000F007C117D /* Sources */,
				97C146EB1CF9000F007C117D /* Frameworks */,
				97C146EC1CF9000F007C117D /* Resources */,
				9705A1C41CF9048500538489 /* Embed Frameworks */,
				3B06AD1E1E4923F5004D2608 /* Thin Binary */,
			);
			buildRules = (
			);
			dependencies = (
			);
			name = Runner;
			productName = Runner;
			productReference = 97C146EE1CF9000F007C117D /* Runner.app */;
			productType = "com.apple.product-type.application";
		};
/* End PBXNativeTarget section */

/* Begin PBXProject section */
		97C146E61CF9000F007C117D /* Project object */ = {
			isa = PBXProject;
			attributes = {
				BuildIndependentTargetsInParallel = YES;
				LastUpgradeCheck = 1510;
				ORGANIZATIONNAME = "";
				TargetAttributes = {
					331C8080294A63A400263BE5 = {
						CreatedOnToolsVersion = 14.0;
						TestTargetID = 97C146ED1CF9000F007C117D;
					};
					97C146ED1CF9000F007C117D = {
						CreatedOnToolsVersion = 7.3.1;
						LastSwiftMigration = 1100;
					};
				};
			};
			buildConfigurationList = 97C146E91CF9000F007C117D /* Build configuration list for PBXProject "Runner" */;
			compatibilityVersion = "Xcode 9.3";
			developmentRegion = en;
			hasScannedForEncodings = 0;
			knownRegions = (
				en,
				Base,
			);
			mainGroup = 97C146E51CF9000F007C117D;
			productRefGroup = 97C146EF1CF9000F007C117D /* Products */;
			projectDirPath = "";
			projectRoot = "";
			targets = (
				97C146ED1CF9000F007C117D /* Runner */,
				331C8080294A63A400263BE5 /* RunnerTests */,
			);
		};
/* End PBXProject section */

/* Begin PBXResourcesBuildPhase section */
		331C807F294A63A400263BE5 /* Resources */ = {
			isa = PBXResourcesBuildPhase;
			buildActionMask = 2147483647;
			files = (
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
		97C146EC1CF9000F007C117D /* Resources */ = {
			isa = PBXResourcesBuildPhase;
			buildActionMask = 2147483647;
			files = (
				97C147011CF9000F007C117D /* LaunchScreen.storyboard in Resources */,
				3B3967161E833CAA004F5970 /* AppFrameworkInfo.plist in Resources */,
				97C146FE1CF9000F007C117D /* Assets.xcassets in Resources */,
				97C146FC1CF9000F007C117D /* Main.storyboard in Resources */,
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
/* End PBXResourcesBuildPhase section */

/* Begin PBXShellScriptBuildPhase section */
		3B06AD1E1E4923F5004D2608 /* Thin Binary */ = {
			isa = PBXShellScriptBuildPhase;
			alwaysOutOfDate = 1;
			buildActionMask = 2147483647;
			files = (
			);
			inputPaths = (
				"${TARGET_BUILD_DIR}/${INFOPLIST_PATH}",
			);
			name = "Thin Binary";
			outputPaths = (
			);
			runOnlyForDeploymentPostprocessing = 0;
			shellPath = /bin/sh;
			shellScript = "/bin/sh \"$FLUTTER_ROOT/packages/flutter_tools/bin/xcode_backend.sh\" embed_and_thin";
		};
		9740EEB61CF901F6004384FC /* Run Script */ = {
			isa = PBXShellScriptBuildPhase;
			alwaysOutOfDate = 1;
			buildActionMask = 2147483647;
			files = (
			);
			inputPaths = (
			);
			name = "Run Script";
			outputPaths = (
			);
			runOnlyForDeploymentPostprocessing = 0;
			shellPath = /bin/sh;
			shellScript = "/bin/sh \"$FLUTTER_ROOT/packages/flutter_tools/bin/xcode_backend.sh\" build";
		};
/* End PBXShellScriptBuildPhase section */

/* Begin PBXSourcesBuildPhase section */
		331C807D294A63A400263BE5 /* Sources */ = {
			isa = PBXSourcesBuildPhase;
			buildActionMask = 2147483647;
			files = (
				331C808B294A63AB00263BE5 /* RunnerTests.swift in Sources */,
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
		97C146EA1CF9000F007C117D /* Sources */ = {
			isa = PBXSourcesBuildPhase;
			buildActionMask = 2147483647;
			files = (
				74858FAF1ED2DC5600515810 /* AppDelegate.swift in Sources */,
				1498D2341E8E89220040F4C2 /* GeneratedPluginRegistrant.m in Sources */,
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
/* End PBXSourcesBuildPhase section */

/* Begin PBXTargetDependency section */
		331C8086294A63A400263BE5 /* PBXTargetDependency */ = {
			isa = PBXTargetDependency;
			target = 97C146ED1CF9000F007C117D /* Runner */;
			targetProxy = 331C8085294A63A400263BE5 /* PBXContainerItemProxy */;
		};
/* End PBXTargetDependency section */

/* Begin PBXVariantGroup section */
		97C146FA1CF9000F007C117D /* Main.storyboard */ = {
			isa = PBXVariantGroup;
			children = (
				97C146FB1CF9000F007C117D /* Base */,
			);
			name = Main.storyboard;
			sourceTree = "<group>";
		};
		97C146FF1CF9000F007C117D /* LaunchScreen.storyboard */ = {
			isa = PBXVariantGroup;
			children = (
				97C147001CF9000F007C117D /* Base */,
			);
			name = LaunchScreen.storyboard;
			sourceTree = "<group>";
		};
/* End PBXVariantGroup section */

/* Begin XCBuildConfiguration section */
		249021D3217E4FDB00AE95B9 /* Profile */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				ALWAYS_SEARCH_USER_PATHS = NO;
				ASSETCATALOG_COMPILER_GENERATE_SWIFT_ASSET_SYMBOL_EXTENSIONS = YES;
				CLANG_ANALYZER_NONNULL = YES;
				CLANG_CXX_LANGUAGE_STANDARD = "gnu++0x";
				CLANG_CXX_LIBRARY = "libc++";
				CLANG_ENABLE_MODULES = YES;
				CLANG_ENABLE_OBJC_ARC = YES;
				CLANG_WARN_BLOCK_CAPTURE_AUTORELEASING = YES;
				CLANG_WARN_BOOL_CONVERSION = YES;
				CLANG_WARN_COMMA = YES;
				CLANG_WARN_CONSTANT_CONVERSION = YES;
				CLANG_WARN_DEPRECATED_OBJC_IMPLEMENTATIONS = YES;
				CLANG_WARN_DIRECT_OBJC_ISA_USAGE = YES_ERROR;
				CLANG_WARN_EMPTY_BODY = YES;
				CLANG_WARN_ENUM_CONVERSION = YES;
				CLANG_WARN_INFINITE_RECURSION = YES;
				CLANG_WARN_INT_CONVERSION = YES;
				CLANG_WARN_NON_LITERAL_NULL_CONVERSION = YES;
				CLANG_WARN_OBJC_IMPLICIT_RETAIN_SELF = YES;
				CLANG_WARN_OBJC_LITERAL_CONVERSION = YES;
				CLANG_WARN_OBJC_ROOT_CLASS = YES_ERROR;
				CLANG_WARN_RANGE_LOOP_ANALYSIS = YES;
				CLANG_WARN_STRICT_PROTOTYPES = YES;
				CLANG_WARN_SUSPICIOUS_MOVE = YES;
				CLANG_WARN_UNREACHABLE_CODE = YES;
				CLANG_WARN__DUPLICATE_METHOD_MATCH = YES;
				"CODE_SIGN_IDENTITY[sdk=iphoneos*]" = "iPhone Developer";
				COPY_PHASE_STRIP = NO;
				DEBUG_INFORMATION_FORMAT = "dwarf-with-dsym";
				ENABLE_NS_ASSERTIONS = NO;
				ENABLE_STRICT_OBJC_MSGSEND = YES;
				ENABLE_USER_SCRIPT_SANDBOXING = NO;
				GCC_C_LANGUAGE_STANDARD = gnu99;
				GCC_NO_COMMON_BLOCKS = YES;
				GCC_WARN_64_TO_32_BIT_CONVERSION = YES;
				GCC_WARN_ABOUT_RETURN_TYPE = YES_ERROR;
				GCC_WARN_UNDECLARED_SELECTOR = YES;
				GCC_WARN_UNINITIALIZED_AUTOS = YES_AGGRESSIVE;
				GCC_WARN_UNUSED_FUNCTION = YES;
				GCC_WARN_UNUSED_VARIABLE = YES;
				IPHONEOS_DEPLOYMENT_TARGET = 12.0;
				MTL_ENABLE_DEBUG_INFO = NO;
				SDKROOT = iphoneos;
				SUPPORTED_PLATFORMS = iphoneos;
				TARGETED_DEVICE_FAMILY = "1,2";
				VALIDATE_PRODUCT = YES;
			};
			name = Profile;
		};
		249021D4217E4FDB00AE95B9 /* Profile */ = {
			isa = XCBuildConfiguration;
			baseConfigurationReference = 7AFA3C8E1D35360C0083082E /* Release.xcconfig */;
			buildSettings = {
				ASSETCATALOG_COMPILER_APPICON_NAME = AppIcon;
				CLANG_ENABLE_MODULES = YES;
				CURRENT_PROJECT_VERSION = "$(FLUTTER_BUILD_NUMBER)";
				ENABLE_BITCODE = NO;
				INFOPLIST_FILE = Runner/Info.plist;
				LD_RUNPATH_SEARCH_PATHS = (
					"$(inherited)",
					"@executable_path/Frameworks",
				);
				PRODUCT_BUNDLE_IDENTIFIER = com.teacherdashboard.teacherDashboardFlutter;
				PRODUCT_NAME = "$(TARGET_NAME)";
				SWIFT_OBJC_BRIDGING_HEADER = "Runner/Runner-Bridging-Header.h";
				SWIFT_VERSION = 5.0;
				VERSIONING_SYSTEM = "apple-generic";
			};
			name = Profile;
		};
		331C8088294A63A400263BE5 /* Debug */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				BUNDLE_LOADER = "$(TEST_HOST)";
				CODE_SIGN_STYLE = Automatic;
				CURRENT_PROJECT_VERSION = 1;
				GENERATE_INFOPLIST_FILE = YES;
				MARKETING_VERSION = 1.0;
				PRODUCT_BUNDLE_IDENTIFIER = com.teacherdashboard.teacherDashboardFlutter.RunnerTests;
				PRODUCT_NAME = "$(TARGET_NAME)";
				SWIFT_ACTIVE_COMPILATION_CONDITIONS = DEBUG;
				SWIFT_OPTIMIZATION_LEVEL = "-Onone";
				SWIFT_VERSION = 5.0;
				TEST_HOST = "$(BUILT_PRODUCTS_DIR)/Runner.app/$(BUNDLE_EXECUTABLE_FOLDER_PATH)/Runner";
			};
			name = Debug;
		};
		331C8089294A63A400263BE5 /* Release */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				BUNDLE_LOADER = "$(TEST_HOST)";
				CODE_SIGN_STYLE = Automatic;
				CURRENT_PROJECT_VERSION = 1;
				GENERATE_INFOPLIST_FILE = YES;
				MARKETING_VERSION = 1.0;
				PRODUCT_BUNDLE_IDENTIFIER = com.teacherdashboard.teacherDashboardFlutter.RunnerTests;
				PRODUCT_NAME = "$(TARGET_NAME)";
				SWIFT_VERSION = 5.0;
				TEST_HOST = "$(BUILT_PRODUCTS_DIR)/Runner.app/$(BUNDLE_EXECUTABLE_FOLDER_PATH)/Runner";
			};
			name = Release;
		};
		331C808A294A63A400263BE5 /* Profile */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				BUNDLE_LOADER = "$(TEST_HOST)";
				CODE_SIGN_STYLE = Automatic;
				CURRENT_PROJECT_VERSION = 1;
				GENERATE_INFOPLIST_FILE = YES;
				MARKETING_VERSION = 1.0;
				PRODUCT_BUNDLE_IDENTIFIER = com.teacherdashboard.teacherDashboardFlutter.RunnerTests;
				PRODUCT_NAME = "$(TARGET_NAME)";
				SWIFT_VERSION = 5.0;
				TEST_HOST = "$(BUILT_PRODUCTS_DIR)/Runner.app/$(BUNDLE_EXECUTABLE_FOLDER_PATH)/Runner";
			};
			name = Profile;
		};
		97C147031CF9000F007C117D /* Debug */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				ALWAYS_SEARCH_USER_PATHS = NO;
				ASSETCATALOG_COMPILER_GENERATE_SWIFT_ASSET_SYMBOL_EXTENSIONS = YES;
				CLANG_ANALYZER_NONNULL = YES;
				CLANG_CXX_LANGUAGE_STANDARD = "gnu++0x";
				CLANG_CXX_LIBRARY = "libc++";
				CLANG_ENABLE_MODULES = YES;
				CLANG_ENABLE_OBJC_ARC = YES;
				CLANG_WARN_BLOCK_CAPTURE_AUTORELEASING = YES;
				CLANG_WARN_BOOL_CONVERSION = YES;
				CLANG_WARN_COMMA = YES;
				CLANG_WARN_CONSTANT_CONVERSION = YES;
				CLANG_WARN_DEPRECATED_OBJC_IMPLEMENTATIONS = YES;
				CLANG_WARN_DIRECT_OBJC_ISA_USAGE = YES_ERROR;
				CLANG_WARN_EMPTY_BODY = YES;
				CLANG_WARN_ENUM_CONVERSION = YES;
				CLANG_WARN_INFINITE_RECURSION = YES;
				CLANG_WARN_INT_CONVERSION = YES;
				CLANG_WARN_NON_LITERAL_NULL_CONVERSION = YES;
				CLANG_WARN_OBJC_IMPLICIT_RETAIN_SELF = YES;
				CLANG_WARN_OBJC_LITERAL_CONVERSION = YES;
				CLANG_WARN_OBJC_ROOT_CLASS = YES_ERROR;
				CLANG_WARN_RANGE_LOOP_ANALYSIS = YES;
				CLANG_WARN_STRICT_PROTOTYPES = YES;
				CLANG_WARN_SUSPICIOUS_MOVE = YES;
				CLANG_WARN_UNREACHABLE_CODE = YES;
				CLANG_WARN__DUPLICATE_METHOD_MATCH = YES;
				"CODE_SIGN_IDENTITY[sdk=iphoneos*]" = "iPhone Developer";
				COPY_PHASE_STRIP = NO;
				DEBUG_INFORMATION_FORMAT = dwarf;
				ENABLE_STRICT_OBJC_MSGSEND = YES;
				ENABLE_TESTABILITY = YES;
				ENABLE_USER_SCRIPT_SANDBOXING = NO;
				GCC_C_LANGUAGE_STANDARD = gnu99;
				GCC_DYNAMIC_NO_PIC = NO;
				GCC_NO_COMMON_BLOCKS = YES;
				GCC_OPTIMIZATION_LEVEL = 0;
				GCC_PREPROCESSOR_DEFINITIONS = (
					"DEBUG=1",
					"$(inherited)",
				);
				GCC_WARN_64_TO_32_BIT_CONVERSION = YES;
				GCC_WARN_ABOUT_RETURN_TYPE = YES_ERROR;
				GCC_WARN_UNDECLARED_SELECTOR = YES;
				GCC_WARN_UNINITIALIZED_AUTOS = YES_AGGRESSIVE;
				GCC_WARN_UNUSED_FUNCTION = YES;
				GCC_WARN_UNUSED_VARIABLE = YES;
				IPHONEOS_DEPLOYMENT_TARGET = 12.0;
				MTL_ENABLE_DEBUG_INFO = YES;
				ONLY_ACTIVE_ARCH = YES;
				SDKROOT = iphoneos;
				TARGETED_DEVICE_FAMILY = "1,2";
			};
			name = Debug;
		};
		97C147041CF9000F007C117D /* Release */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				ALWAYS_SEARCH_USER_PATHS = NO;
				ASSETCATALOG_COMPILER_GENERATE_SWIFT_ASSET_SYMBOL_EXTENSIONS = YES;
				CLANG_ANALYZER_NONNULL = YES;
				CLANG_CXX_LANGUAGE_STANDARD = "gnu++0x";
				CLANG_CXX_LIBRARY = "libc++";
				CLANG_ENABLE_MODULES = YES;
				CLANG_ENABLE_OBJC_ARC = YES;
				CLANG_WARN_BLOCK_CAPTURE_AUTORELEASING = YES;
				CLANG_WARN_BOOL_CONVERSION = YES;
				CLANG_WARN_COMMA = YES;
				CLANG_WARN_CONSTANT_CONVERSION = YES;
				CLANG_WARN_DEPRECATED_OBJC_IMPLEMENTATIONS = YES;
				CLANG_WARN_DIRECT_OBJC_ISA_USAGE = YES_ERROR;
				CLANG_WARN_EMPTY_BODY = YES;
				CLANG_WARN_ENUM_CONVERSION = YES;
				CLANG_WARN_INFINITE_RECURSION = YES;
				CLANG_WARN_INT_CONVERSION = YES;
				CLANG_WARN_NON_LITERAL_NULL_CONVERSION = YES;
				CLANG_WARN_OBJC_IMPLICIT_RETAIN_SELF = YES;
				CLANG_WARN_OBJC_LITERAL_CONVERSION = YES;
				CLANG_WARN_OBJC_ROOT_CLASS = YES_ERROR;
				CLANG_WARN_RANGE_LOOP_ANALYSIS = YES;
				CLANG_WARN_STRICT_PROTOTYPES = YES;
				CLANG_WARN_SUSPICIOUS_MOVE = YES;
				CLANG_WARN_UNREACHABLE_CODE = YES;
				CLANG_WARN__DUPLICATE_METHOD_MATCH = YES;
				"CODE_SIGN_IDENTITY[sdk=iphoneos*]" = "iPhone Developer";
				COPY_PHASE_STRIP = NO;
				DEBUG_INFORMATION_FORMAT = "dwarf-with-dsym";
				ENABLE_NS_ASSERTIONS = NO;
				ENABLE_STRICT_OBJC_MSGSEND = YES;
				ENABLE_USER_SCRIPT_SANDBOXING = NO;
				GCC_C_LANGUAGE_STANDARD = gnu99;
				GCC_NO_COMMON_BLOCKS = YES;
				GCC_WARN_64_TO_32_BIT_CONVERSION = YES;
				GCC_WARN_ABOUT_RETURN_TYPE = YES_ERROR;
				GCC_WARN_UNDECLARED_SELECTOR = YES;
				GCC_WARN_UNINITIALIZED_AUTOS = YES_AGGRESSIVE;
				GCC_WARN_UNUSED_FUNCTION = YES;
				GCC_WARN_UNUSED_VARIABLE = YES;
				IPHONEOS_DEPLOYMENT_TARGET = 12.0;
				MTL_ENABLE_DEBUG_INFO = NO;
				SDKROOT = iphoneos;
				SUPPORTED_PLATFORMS = iphoneos;
				SWIFT_COMPILATION_MODE = wholemodule;
				SWIFT_OPTIMIZATION_LEVEL = "-O";
				TARGETED_DEVICE_FAMILY = "1,2";
				VALIDATE_PRODUCT = YES;
			};
			name = Release;
		};
		97C147061CF9000F007C117D /* Debug */ = {
			isa = XCBuildConfiguration;
			baseConfigurationReference = 9740EEB21CF90195004384FC /* Debug.xcconfig */;
			buildSettings = {
				ASSETCATALOG_COMPILER_APPICON_NAME = AppIcon;
				CLANG_ENABLE_MODULES = YES;
				CURRENT_PROJECT_VERSION = "$(FLUTTER_BUILD_NUMBER)";
				ENABLE_BITCODE = NO;
				INFOPLIST_FILE = Runner/Info.plist;
				LD_RUNPATH_SEARCH_PATHS = (
					"$(inherited)",
					"@executable_path/Frameworks",
				);
				PRODUCT_BUNDLE_IDENTIFIER = com.teacherdashboard.teacherDashboardFlutter;
				PRODUCT_NAME = "$(TARGET_NAME)";
				SWIFT_OBJC_BRIDGING_HEADER = "Runner/Runner-Bridging-Header.h";
				SWIFT_OPTIMIZATION_LEVEL = "-Onone";
				SWIFT_VERSION = 5.0;
				VERSIONING_SYSTEM = "apple-generic";
			};
			name = Debug;
		};
		97C147071CF9000F007C117D /* Release */ = {
			isa = XCBuildConfiguration;
			baseConfigurationReference = 7AFA3C8E1D35360C0083082E /* Release.xcconfig */;
			buildSettings = {
				ASSETCATALOG_COMPILER_APPICON_NAME = AppIcon;
				CLANG_ENABLE_MODULES = YES;
				CURRENT_PROJECT_VERSION = "$(FLUTTER_BUILD_NUMBER)";
				ENABLE_BITCODE = NO;
				INFOPLIST_FILE = Runner/Info.plist;
				LD_RUNPATH_SEARCH_PATHS = (
					"$(inherited)",
					"@executable_path/Frameworks",
				);
				PRODUCT_BUNDLE_IDENTIFIER = com.teacherdashboard.teacherDashboardFlutter;
				PRODUCT_NAME = "$(TARGET_NAME)";
				SWIFT_OBJC_BRIDGING_HEADER = "Runner/Runner-Bridging-Header.h";
				SWIFT_VERSION = 5.0;
				VERSIONING_SYSTEM = "apple-generic";
			};
			name = Release;
		};
/* End XCBuildConfiguration section */

/* Begin XCConfigurationList section */
		331C8087294A63A400263BE5 /* Build configuration list for PBXNativeTarget "RunnerTests" */ = {
			isa = XCConfigurationList;
			buildConfigurations = (
				331C8088294A63A400263BE5 /* Debug */,
				331C8089294A63A400263BE5 /* Release */,
				331C808A294A63A400263BE5 /* Profile */,
			);
			defaultConfigurationIsVisible = 0;
			defaultConfigurationName = Release;
		};
		97C146E91CF9000F007C117D /* Build configuration list for PBXProject "Runner" */ = {
			isa = XCConfigurationList;
			buildConfigurations = (
				97C147031CF9000F007C117D /* Debug */,
				97C147041CF9000F007C117D /* Release */,
				249021D3217E4FDB00AE95B9 /* Profile */,
			);
			defaultConfigurationIsVisible = 0;
			defaultConfigurationName = Release;
		};
		97C147051CF9000F007C117D /* Build configuration list for PBXNativeTarget "Runner" */ = {
			isa = XCConfigurationList;
			buildConfigurations = (
				97C147061CF9000F007C117D /* Debug */,
				97C147071CF9000F007C117D /* Release */,
				249021D4217E4FDB00AE95B9 /* Profile */,
			);
			defaultConfigurationIsVisible = 0;
			defaultConfigurationName = Release;
		};
/* End XCConfigurationList section */
	};
	rootObject = 97C146E61CF9000F007C117D /* Project object */;
}
````

## File: ios/Runner.xcworkspace/contents.xcworkspacedata
````
<?xml version="1.0" encoding="UTF-8"?>
<Workspace
   version = "1.0">
   <FileRef
      location = "group:Runner.xcodeproj">
   </FileRef>
</Workspace>
````

## File: ios/Runner/Assets.xcassets/AppIcon.appiconset/Contents.json
````json
{
  "images" : [
    {
      "size" : "20x20",
      "idiom" : "iphone",
      "filename" : "Icon-App-20x20@2x.png",
      "scale" : "2x"
    },
    {
      "size" : "20x20",
      "idiom" : "iphone",
      "filename" : "Icon-App-20x20@3x.png",
      "scale" : "3x"
    },
    {
      "size" : "29x29",
      "idiom" : "iphone",
      "filename" : "Icon-App-29x29@1x.png",
      "scale" : "1x"
    },
    {
      "size" : "29x29",
      "idiom" : "iphone",
      "filename" : "Icon-App-29x29@2x.png",
      "scale" : "2x"
    },
    {
      "size" : "29x29",
      "idiom" : "iphone",
      "filename" : "Icon-App-29x29@3x.png",
      "scale" : "3x"
    },
    {
      "size" : "40x40",
      "idiom" : "iphone",
      "filename" : "Icon-App-40x40@2x.png",
      "scale" : "2x"
    },
    {
      "size" : "40x40",
      "idiom" : "iphone",
      "filename" : "Icon-App-40x40@3x.png",
      "scale" : "3x"
    },
    {
      "size" : "60x60",
      "idiom" : "iphone",
      "filename" : "Icon-App-60x60@2x.png",
      "scale" : "2x"
    },
    {
      "size" : "60x60",
      "idiom" : "iphone",
      "filename" : "Icon-App-60x60@3x.png",
      "scale" : "3x"
    },
    {
      "size" : "20x20",
      "idiom" : "ipad",
      "filename" : "Icon-App-20x20@1x.png",
      "scale" : "1x"
    },
    {
      "size" : "20x20",
      "idiom" : "ipad",
      "filename" : "Icon-App-20x20@2x.png",
      "scale" : "2x"
    },
    {
      "size" : "29x29",
      "idiom" : "ipad",
      "filename" : "Icon-App-29x29@1x.png",
      "scale" : "1x"
    },
    {
      "size" : "29x29",
      "idiom" : "ipad",
      "filename" : "Icon-App-29x29@2x.png",
      "scale" : "2x"
    },
    {
      "size" : "40x40",
      "idiom" : "ipad",
      "filename" : "Icon-App-40x40@1x.png",
      "scale" : "1x"
    },
    {
      "size" : "40x40",
      "idiom" : "ipad",
      "filename" : "Icon-App-40x40@2x.png",
      "scale" : "2x"
    },
    {
      "size" : "76x76",
      "idiom" : "ipad",
      "filename" : "Icon-App-76x76@1x.png",
      "scale" : "1x"
    },
    {
      "size" : "76x76",
      "idiom" : "ipad",
      "filename" : "Icon-App-76x76@2x.png",
      "scale" : "2x"
    },
    {
      "size" : "83.5x83.5",
      "idiom" : "ipad",
      "filename" : "Icon-App-83.5x83.5@2x.png",
      "scale" : "2x"
    },
    {
      "size" : "1024x1024",
      "idiom" : "ios-marketing",
      "filename" : "Icon-App-1024x1024@1x.png",
      "scale" : "1x"
    }
  ],
  "info" : {
    "version" : 1,
    "author" : "xcode"
  }
}
````

## File: ios/Runner/Assets.xcassets/LaunchImage.imageset/Contents.json
````json
{
  "images" : [
    {
      "idiom" : "universal",
      "filename" : "LaunchImage.png",
      "scale" : "1x"
    },
    {
      "idiom" : "universal",
      "filename" : "LaunchImage@2x.png",
      "scale" : "2x"
    },
    {
      "idiom" : "universal",
      "filename" : "LaunchImage@3x.png",
      "scale" : "3x"
    }
  ],
  "info" : {
    "version" : 1,
    "author" : "xcode"
  }
}
````

## File: ios/Runner/Assets.xcassets/LaunchImage.imageset/README.md
````markdown
# Launch Screen Assets

You can customize the launch screen with your own desired assets by replacing the image files in this directory.

You can also do it by opening your Flutter project's Xcode project with `open ios/Runner.xcworkspace`, selecting `Runner/Assets.xcassets` in the Project Navigator and dropping in the desired images.
````

## File: ios/Runner/Base.lproj/LaunchScreen.storyboard
````
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<document type="com.apple.InterfaceBuilder3.CocoaTouch.Storyboard.XIB" version="3.0" toolsVersion="12121" systemVersion="16G29" targetRuntime="iOS.CocoaTouch" propertyAccessControl="none" useAutolayout="YES" launchScreen="YES" colorMatched="YES" initialViewController="01J-lp-oVM">
    <dependencies>
        <deployment identifier="iOS"/>
        <plugIn identifier="com.apple.InterfaceBuilder.IBCocoaTouchPlugin" version="12089"/>
    </dependencies>
    <scenes>
        <!--View Controller-->
        <scene sceneID="EHf-IW-A2E">
            <objects>
                <viewController id="01J-lp-oVM" sceneMemberID="viewController">
                    <layoutGuides>
                        <viewControllerLayoutGuide type="top" id="Ydg-fD-yQy"/>
                        <viewControllerLayoutGuide type="bottom" id="xbc-2k-c8Z"/>
                    </layoutGuides>
                    <view key="view" contentMode="scaleToFill" id="Ze5-6b-2t3">
                        <autoresizingMask key="autoresizingMask" widthSizable="YES" heightSizable="YES"/>
                        <subviews>
                            <imageView opaque="NO" clipsSubviews="YES" multipleTouchEnabled="YES" contentMode="center" image="LaunchImage" translatesAutoresizingMaskIntoConstraints="NO" id="YRO-k0-Ey4">
                            </imageView>
                        </subviews>
                        <color key="backgroundColor" red="1" green="1" blue="1" alpha="1" colorSpace="custom" customColorSpace="sRGB"/>
                        <constraints>
                            <constraint firstItem="YRO-k0-Ey4" firstAttribute="centerX" secondItem="Ze5-6b-2t3" secondAttribute="centerX" id="1a2-6s-vTC"/>
                            <constraint firstItem="YRO-k0-Ey4" firstAttribute="centerY" secondItem="Ze5-6b-2t3" secondAttribute="centerY" id="4X2-HB-R7a"/>
                        </constraints>
                    </view>
                </viewController>
                <placeholder placeholderIdentifier="IBFirstResponder" id="iYj-Kq-Ea1" userLabel="First Responder" sceneMemberID="firstResponder"/>
            </objects>
            <point key="canvasLocation" x="53" y="375"/>
        </scene>
    </scenes>
    <resources>
        <image name="LaunchImage" width="168" height="185"/>
    </resources>
</document>
````

## File: ios/Runner/Base.lproj/Main.storyboard
````
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<document type="com.apple.InterfaceBuilder3.CocoaTouch.Storyboard.XIB" version="3.0" toolsVersion="10117" systemVersion="15F34" targetRuntime="iOS.CocoaTouch" propertyAccessControl="none" useAutolayout="YES" useTraitCollections="YES" initialViewController="BYZ-38-t0r">
    <dependencies>
        <deployment identifier="iOS"/>
        <plugIn identifier="com.apple.InterfaceBuilder.IBCocoaTouchPlugin" version="10085"/>
    </dependencies>
    <scenes>
        <!--Flutter View Controller-->
        <scene sceneID="tne-QT-ifu">
            <objects>
                <viewController id="BYZ-38-t0r" customClass="FlutterViewController" sceneMemberID="viewController">
                    <layoutGuides>
                        <viewControllerLayoutGuide type="top" id="y3c-jy-aDJ"/>
                        <viewControllerLayoutGuide type="bottom" id="wfy-db-euE"/>
                    </layoutGuides>
                    <view key="view" contentMode="scaleToFill" id="8bC-Xf-vdC">
                        <rect key="frame" x="0.0" y="0.0" width="600" height="600"/>
                        <autoresizingMask key="autoresizingMask" widthSizable="YES" heightSizable="YES"/>
                        <color key="backgroundColor" white="1" alpha="1" colorSpace="custom" customColorSpace="calibratedWhite"/>
                    </view>
                </viewController>
                <placeholder placeholderIdentifier="IBFirstResponder" id="dkx-z0-nzr" sceneMemberID="firstResponder"/>
            </objects>
        </scene>
    </scenes>
</document>
````

## File: ios/Runner/Info.plist
````
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>CFBundleDevelopmentRegion</key>
	<string>$(DEVELOPMENT_LANGUAGE)</string>
	<key>CFBundleDisplayName</key>
	<string>Teacher Dashboard Flutter</string>
	<key>CFBundleExecutable</key>
	<string>$(EXECUTABLE_NAME)</string>
	<key>CFBundleIdentifier</key>
	<string>$(PRODUCT_BUNDLE_IDENTIFIER)</string>
	<key>CFBundleInfoDictionaryVersion</key>
	<string>6.0</string>
	<key>CFBundleName</key>
	<string>teacher_dashboard_flutter</string>
	<key>CFBundlePackageType</key>
	<string>APPL</string>
	<key>CFBundleShortVersionString</key>
	<string>$(FLUTTER_BUILD_NAME)</string>
	<key>CFBundleSignature</key>
	<string>????</string>
	<key>CFBundleVersion</key>
	<string>$(FLUTTER_BUILD_NUMBER)</string>
	<key>LSRequiresIPhoneOS</key>
	<true/>
	<key>UILaunchStoryboardName</key>
	<string>LaunchScreen</string>
	<key>UIMainStoryboardFile</key>
	<string>Main</string>
	<key>UISupportedInterfaceOrientations</key>
	<array>
		<string>UIInterfaceOrientationPortrait</string>
		<string>UIInterfaceOrientationLandscapeLeft</string>
		<string>UIInterfaceOrientationLandscapeRight</string>
	</array>
	<key>UISupportedInterfaceOrientations~ipad</key>
	<array>
		<string>UIInterfaceOrientationPortrait</string>
		<string>UIInterfaceOrientationPortraitUpsideDown</string>
		<string>UIInterfaceOrientationLandscapeLeft</string>
		<string>UIInterfaceOrientationLandscapeRight</string>
	</array>
	<key>CADisableMinimumFrameDurationOnPhone</key>
	<true/>
	<key>UIApplicationSupportsIndirectInputEvents</key>
	<true/>
	
	<!-- WebRTC Permissions -->
	<key>NSMicrophoneUsageDescription</key>
	<string>Allow microphone access for voice and video calls</string>
	<key>NSCameraUsageDescription</key>
	<string>Allow camera access for video calls</string>
	
	<!-- Background modes for VoIP -->
	<key>UIBackgroundModes</key>
	<array>
		<string>voip</string>
		<string>remote-notification</string>
		<string>processing</string>
	</array>
	
	<!-- Photo Library Access (for profile pictures) -->
	<key>NSPhotoLibraryUsageDescription</key>
	<string>Allow access to photo library to select profile pictures</string>
</dict>
</plist>
````

## File: ios/Runner/Runner-Bridging-Header.h
````
#import "GeneratedPluginRegistrant.h"
````

## File: ios/Runner/upload_dsyms.sh
````bash
#!/bin/zsh

# Firebase Crashlytics dSYM upload script
# This script uploads debug symbols to Firebase Crashlytics

if [ -z "$FLUTTER_BUILD_MODE" ] || [ "$FLUTTER_BUILD_MODE" = "release" ]; then
    echo "Uploading dSYMs to Firebase Crashlytics..."
    
    # Path to Crashlytics upload script (installed via Firebase SDK)
    UPLOAD_SCRIPT="${PODS_ROOT}/FirebaseCrashlytics/upload-symbols"
    
    if [ -f "$UPLOAD_SCRIPT" ]; then
        # Upload dSYMs
        "$UPLOAD_SCRIPT" -gsp "${PROJECT_DIR}/Runner/GoogleService-Info.plist" -p ios "${DWARF_DSYM_FOLDER_PATH}/${DWARF_DSYM_FILE_NAME}"
        echo "dSYM upload completed"
    else
        echo "Warning: Firebase Crashlytics upload script not found at $UPLOAD_SCRIPT"
        echo "Make sure FirebaseCrashlytics pod is installed"
    fi
else
    echo "Skipping dSYM upload for non-release build"
fi
````

## File: ios/RunnerTests/RunnerTests.swift
````swift
import Flutter
import UIKit
import XCTest

class RunnerTests: XCTestCase {

  func testExample() {
    // If you add code to the Runner application, consider adding tests here.
    // See https://developer.apple.com/documentation/xctest for more information about using XCTest.
  }

}
````

## File: lib/config/firebase_options.dart
````dart
// File generated by FlutterFire CLI.
// ignore_for_file: lines_longer_than_80_chars, avoid_classes_with_only_static_members
import 'package:firebase_core/firebase_core.dart' show FirebaseOptions;
import 'package:flutter/foundation.dart'
    show defaultTargetPlatform, kIsWeb, TargetPlatform;

/// Default [FirebaseOptions] for use with your Firebase apps.
///
/// Example:
/// ```dart
/// import 'firebase_options.dart';
/// // ...
/// await Firebase.initializeApp(
///   options: DefaultFirebaseOptions.currentPlatform,
/// );
/// ```
class DefaultFirebaseOptions {
  static FirebaseOptions get currentPlatform {
    if (kIsWeb) {
      return web;
    }
    switch (defaultTargetPlatform) {
      case TargetPlatform.android:
        return android;
      case TargetPlatform.iOS:
        return ios;
      case TargetPlatform.macOS:
        return macos;
      case TargetPlatform.windows:
        return windows;
      case TargetPlatform.linux:
        return linux;
      default:
        throw UnsupportedError(
          'DefaultFirebaseOptions have not been configured for this platform.',
        );
    }
  }

  static const FirebaseOptions web = FirebaseOptions(
    apiKey: 'AIzaSyD_nLVRdyd6ZlIyFrRGCW5IStXnM2-uUac',
    appId: '1:218352465432:web:6e1c0fa4f21416df38b56d',
    messagingSenderId: '218352465432',
    projectId: 'teacher-dashboard-flutterfire',
    authDomain: 'teacher-dashboard-flutterfire.firebaseapp.com',
    storageBucket: 'teacher-dashboard-flutterfire.firebasestorage.app',
    databaseURL: 'https://teacher-dashboard-flutterfire-default-rtdb.firebaseio.com',
  );

  static const FirebaseOptions android = FirebaseOptions(
    apiKey: 'AIzaSyD_nLVRdyd6ZlIyFrRGCW5IStXnM2-uUac',
    appId: '1:218352465432:android:a7d591b9db6bef6038b56d',
    messagingSenderId: '218352465432',
    projectId: 'teacher-dashboard-flutterfire',
    storageBucket: 'teacher-dashboard-flutterfire.firebasestorage.app',
    databaseURL: 'https://teacher-dashboard-flutterfire-default-rtdb.firebaseio.com',
  );

  static const FirebaseOptions ios = FirebaseOptions(
    apiKey: 'AIzaSyD_nLVRdyd6ZlIyFrRGCW5IStXnM2-uUac',
    appId: '1:218352465432:ios:5lt4mte28dqof4ae3igmi6m8i261jh99',
    messagingSenderId: '218352465432',
    projectId: 'teacher-dashboard-flutterfire',
    storageBucket: 'teacher-dashboard-flutterfire.firebasestorage.app',
    databaseURL: 'https://teacher-dashboard-flutterfire-default-rtdb.firebaseio.com',
    iosBundleId: 'com.teacherdashboard.teacherDashboardFlutter',
  );

  static const FirebaseOptions macos = FirebaseOptions(
    apiKey: 'AIzaSyD_nLVRdyd6ZlIyFrRGCW5IStXnM2-uUac',
    appId: '1:218352465432:ios:5lt4mte28dqof4ae3igmi6m8i261jh99',
    messagingSenderId: '218352465432',
    projectId: 'teacher-dashboard-flutterfire',
    storageBucket: 'teacher-dashboard-flutterfire.firebasestorage.app',
    databaseURL: 'https://teacher-dashboard-flutterfire-default-rtdb.firebaseio.com',
    iosBundleId: 'com.teacherdashboard.teacherDashboardFlutter',
  );

  static const FirebaseOptions windows = FirebaseOptions(
    apiKey: 'AIzaSyD_nLVRdyd6ZlIyFrRGCW5IStXnM2-uUac',
    appId: '1:218352465432:web:6e1c0fa4f21416df38b56d',
    messagingSenderId: '218352465432',
    projectId: 'teacher-dashboard-flutterfire',
    authDomain: 'teacher-dashboard-flutterfire.firebaseapp.com',
    storageBucket: 'teacher-dashboard-flutterfire.firebasestorage.app',
    databaseURL: 'https://teacher-dashboard-flutterfire-default-rtdb.firebaseio.com',
  );

  static const FirebaseOptions linux = FirebaseOptions(
    apiKey: 'AIzaSyD_nLVRdyd6ZlIyFrRGCW5IStXnM2-uUac',
    appId: '1:218352465432:web:6e1c0fa4f21416df38b56d',
    messagingSenderId: '218352465432',
    projectId: 'teacher-dashboard-flutterfire',
    authDomain: 'teacher-dashboard-flutterfire.firebaseapp.com',
    storageBucket: 'teacher-dashboard-flutterfire.firebasestorage.app',
    databaseURL: 'https://teacher-dashboard-flutterfire-default-rtdb.firebaseio.com',
  );
}
````

## File: lib/features/assignments/data/repositories/assignment_repository_impl.dart
````dart
/// Concrete implementation of the assignment repository.
/// 
/// This module implements the AssignmentRepository interface using
/// Firebase Firestore as the data source. It provides comprehensive
/// assignment management functionality with status workflows
/// and statistical analysis.
library;

import 'package:cloud_firestore/cloud_firestore.dart';
import '../../domain/models/assignment.dart';
import '../../../../shared/services/firestore_service.dart';
import '../../../../shared/services/logger_service.dart';
import '../../domain/repositories/assignment_repository.dart';
import '../../../../shared/repositories/firestore_repository.dart';

/// Firestore-based implementation of AssignmentRepository.
/// 
/// This class extends FirestoreRepository to leverage common
/// CRUD operations while implementing assignment-specific features:
/// - Status workflow management (draft, active, completed, archived)
/// - Publishing and unpublishing controls
/// - Due date tracking and overdue detection
/// - Multi-class assignment streaming
/// - Statistical analysis for dashboards
/// - Automatic timestamp management
/// 
/// All operations include comprehensive logging for debugging
/// and audit trail purposes.
class AssignmentRepositoryImpl extends FirestoreRepository<Assignment> 
    implements AssignmentRepository {
  
  /// Creates an assignment repository with Firestore backend.
  /// 
  /// Initializes the parent FirestoreRepository with assignment-specific
  /// configuration including collection path and serialization functions.
  /// 
  /// @param firestore Firestore database instance
  AssignmentRepositoryImpl(FirebaseFirestore firestore)
      : super(
          firestore: firestore,
          collectionPath: 'assignments',
          fromFirestore: (doc) => Assignment.fromFirestore(doc),
          toFirestore: (assignment) => assignment.toFirestore(),
          logTag: 'AssignmentRepository',
        );
  
  /// Creates a new assignment with automatic timestamps.
  /// 
  /// Sets both creation and update timestamps to current time.
  /// The assignment ID is generated by Firestore for uniqueness.
  /// New assignments start in draft status by default.
  /// 
  /// @param assignment Assignment model with content and settings
  /// @return Generated unique assignment ID
  /// @throws Exception if creation fails
  @override
  Future<String> createAssignment(Assignment assignment) async {
    try {
      final assignmentWithTimestamp = assignment.copyWith(
        createdAt: DateTime.now(),
        updatedAt: DateTime.now(),
      );
      return await create(assignmentWithTimestamp);
    } catch (e) {
      LoggerService.error('Failed to create assignment', tag: tag, error: e);
      rethrow;
    }
  }  
  /// Retrieves an assignment by its unique identifier.
  /// 
  /// Delegates to parent repository for consistent error handling.
  /// 
  /// @param assignmentId Unique assignment identifier
  /// @return Assignment instance or null if not found
  @override
  Future<Assignment?> getAssignment(String assignmentId) => read(assignmentId);
  
  /// Updates an existing assignment with new timestamp.
  /// 
  /// Automatically updates the modification timestamp while
  /// preserving the assignment ID and creation date.
  /// 
  /// @param assignmentId ID of assignment to update
  /// @param assignment Updated assignment information
  /// @throws Exception if update fails
  @override
  Future<void> updateAssignment(String assignmentId, Assignment assignment) async {
    try {
      final updatedAssignment = assignment.copyWith(
        id: assignmentId,
        updatedAt: DateTime.now(),
      );
      await update(assignmentId, updatedAssignment);
    } catch (e) {
      LoggerService.error('Failed to update assignment', tag: tag, error: e);
      rethrow;
    }
  }
  
  /// Permanently deletes an assignment.
  /// 
  /// This operation cannot be undone. Consider archiving
  /// for recoverable removal.
  /// 
  /// @param assignmentId ID of assignment to delete
  /// @throws Exception if deletion fails
  @override
  Future<void> deleteAssignment(String assignmentId) => delete(assignmentId);
  
  /// Streams all assignments for a specific class.
  /// 
  /// Returns real-time updates ordered by creation date,
  /// most recent first. Includes all assignment statuses.
  /// 
  /// @param classId Class to get assignments from
  /// @return Stream of assignment lists
  @override
  Stream<List<Assignment>> getClassAssignments(String classId) {
    return stream(
      conditions: [
        QueryCondition(field: 'classId', isEqualTo: classId),
      ],
      orderBy: [
        OrderBy(field: 'createdAt', descending: true),
      ],
    );
  }  
  /// Streams all assignments created by a teacher.
  /// 
  /// Returns comprehensive assignment list across all classes
  /// taught by the teacher, ordered by most recent first.
  /// 
  /// @param teacherId Teacher's unique identifier
  /// @return Stream of teacher's assignments
  @override
  Stream<List<Assignment>> getTeacherAssignments(String teacherId) {
    return stream(
      conditions: [
        QueryCondition(field: 'teacherId', isEqualTo: teacherId),
      ],
      orderBy: [
        OrderBy(field: 'createdAt', descending: true),
      ],
    );
  }
  
  /// Streams assignments for multiple classes.
  /// 
  /// Efficient query for students enrolled in multiple classes.
  /// Returns assignments ordered by due date (earliest first)
  /// to help prioritize work.
  /// 
  /// @param classIds List of class identifiers
  /// @return Stream of assignments from all specified classes
  @override
  Stream<List<Assignment>> getClassAssignmentsForMultipleClasses(List<String> classIds) {
    if (classIds.isEmpty) {
      return Stream.value([]);
    }
    
    return stream(
      conditions: [
        QueryCondition(field: 'classId', whereIn: classIds),
      ],
      orderBy: [
        OrderBy(field: 'dueDate', descending: false),
      ],
    );
  }
  
  /// Gets upcoming assignments for a class.
  /// 
  /// Filters to show only:
  /// - Published assignments
  /// - Active status
  /// - Due date in the future
  /// 
  /// Ordered by due date (soonest first) for priority display.
  /// 
  /// @param classId Class to query
  /// @param limit Maximum assignments to return (default: 5)
  /// @return List of upcoming assignments
  /// @throws Exception if query fails
  @override
  Future<List<Assignment>> getUpcomingAssignments(String classId, {int limit = 5}) async {
    final now = DateTime.now();
    return await list(
      conditions: [
        QueryCondition(field: 'classId', isEqualTo: classId),
        QueryCondition(field: 'dueDate', isGreaterThan: Timestamp.fromDate(now)),
        QueryCondition(field: 'isPublished', isEqualTo: true),
        QueryCondition(field: 'status', isEqualTo: 'active'),
      ],
      orderBy: [
        OrderBy(field: 'dueDate', descending: false),
      ],
      limit: limit,
    );
  }  
  /// Gets overdue assignments for a class.
  /// 
  /// Filters to show only:
  /// - Published assignments
  /// - Active status  
  /// - Due date in the past
  /// 
  /// Ordered by due date (most recent first) to show
  /// assignments that just became overdue.
  /// 
  /// @param classId Class to query
  /// @return List of overdue assignments
  /// @throws Exception if query fails
  @override
  Future<List<Assignment>> getOverdueAssignments(String classId) async {
    final now = DateTime.now();
    return await list(
      conditions: [
        QueryCondition(field: 'classId', isEqualTo: classId),
        QueryCondition(field: 'dueDate', isLessThan: Timestamp.fromDate(now)),
        QueryCondition(field: 'isPublished', isEqualTo: true),
        QueryCondition(field: 'status', isEqualTo: 'active'),
      ],
      orderBy: [
        OrderBy(field: 'dueDate', descending: true),
      ],
    );
  }
  
  /// Publishes an assignment to make it visible to students.
  /// 
  /// Updates:
  /// - isPublished flag to true
  /// - Status to 'active'
  /// - Update timestamp
  /// 
  /// Published assignments appear in student dashboards
  /// and accept submissions.
  /// 
  /// @param assignmentId Assignment to publish
  /// @throws Exception if publishing fails
  @override
  Future<void> publishAssignment(String assignmentId) async {
    try {
      final assignment = await getAssignment(assignmentId);
      if (assignment != null) {
        final published = assignment.copyWith(
          isPublished: true,
          status: AssignmentStatus.active,
          updatedAt: DateTime.now(),
        );
        await update(assignmentId, published);
      }
    } catch (e) {
      LoggerService.error('Failed to publish assignment', tag: tag, error: e);
      rethrow;
    }
  }  
  /// Archives an assignment to hide it from active lists.
  /// 
  /// Archived assignments:
  /// - No longer accept submissions
  /// - Hidden from student views
  /// - Preserved for historical records
  /// - Can be restored later
  /// 
  /// @param assignmentId Assignment to archive
  /// @throws Exception if archiving fails
  @override
  Future<void> archiveAssignment(String assignmentId) async {
    try {
      final assignment = await getAssignment(assignmentId);
      if (assignment != null) {
        final archived = assignment.copyWith(
          status: AssignmentStatus.archived,
          updatedAt: DateTime.now(),
        );
        await update(assignmentId, archived);
      }
    } catch (e) {
      LoggerService.error('Failed to archive assignment', tag: tag, error: e);
      rethrow;
    }
  }
  
  /// Unpublishes an assignment to hide it from students.
  /// 
  /// Updates:
  /// - isPublished flag to false
  /// - Status back to 'draft'
  /// - Update timestamp
  /// 
  /// Useful for corrections before re-publishing.
  /// 
  /// @param assignmentId Assignment to unpublish
  /// @throws Exception if unpublishing fails
  @override
  Future<void> unpublishAssignment(String assignmentId) async {
    try {
      final assignment = await getAssignment(assignmentId);
      if (assignment != null) {
        final unpublished = assignment.copyWith(
          isPublished: false,
          status: AssignmentStatus.draft,
          updatedAt: DateTime.now(),
        );
        await update(assignmentId, unpublished);
      }
    } catch (e) {
      LoggerService.error('Failed to unpublish assignment', tag: tag, error: e);
      rethrow;
    }
  }
  
  /// Restores an archived assignment to draft status.
  /// 
  /// Allows reactivation of archived assignments for:
  /// - Reuse in new terms
  /// - Template creation
  /// - Error correction
  /// 
  /// Restored assignments must be republished to
  /// become visible to students again.
  /// 
  /// @param assignmentId Assignment to restore
  /// @throws Exception if restoration fails
  @override
  Future<void> restoreAssignment(String assignmentId) async {
    try {
      final assignment = await getAssignment(assignmentId);
      if (assignment != null) {
        final restored = assignment.copyWith(
          status: AssignmentStatus.draft,
          updatedAt: DateTime.now(),
        );
        await update(assignmentId, restored);
      }
    } catch (e) {
      LoggerService.error('Failed to restore assignment', tag: tag, error: e);
      rethrow;
    }
  }
  
  /// Calculates comprehensive statistics for a class's assignments.
  /// 
  /// Aggregates assignment data to provide insights:
  /// - Total assignment count
  /// - Active assignments
  /// - Overdue assignments
  /// - Upcoming assignments
  /// - Completed assignments
  /// - Archived assignments
  /// 
  /// Useful for teacher dashboards and progress tracking.
  /// 
  /// @param classId Class to analyze
  /// @return Map of statistical data
  /// @throws Exception if calculation fails
  @override
  Future<Map<String, dynamic>> getAssignmentStats(String classId) async {
    try {
      final assignments = await list(
        conditions: [
          QueryCondition(field: 'classId', isEqualTo: classId),
        ],
      );
      
      final now = DateTime.now();
      final total = assignments.length;
      final active = assignments.where((a) => a.status == AssignmentStatus.active).length;
      final overdue = assignments.where((a) => 
        a.status == AssignmentStatus.active && 
        a.dueDate.isBefore(now)
      ).length;
      final upcoming = assignments.where((a) => 
        a.status == AssignmentStatus.active && 
        a.dueDate.isAfter(now)
      ).length;
      
      return {
        'total': total,
        'active': active,
        'overdue': overdue,
        'upcoming': upcoming,
        'completed': assignments.where((a) => a.status == AssignmentStatus.completed).length,
        'archived': assignments.where((a) => a.status == AssignmentStatus.archived).length,
      };
    } catch (e) {
      LoggerService.error('Failed to get assignment stats', tag: tag, error: e);
      rethrow;
    }
  }
}
````

## File: lib/features/assignments/data/repositories/submission_repository_impl.dart
````dart
/// Concrete implementation of the submission repository.
/// 
/// This module implements the SubmissionRepository interface using
/// Firebase Firestore as the data source. It provides comprehensive
/// submission management functionality with automatic timestamps
/// and status tracking.
library;

import 'package:cloud_firestore/cloud_firestore.dart';
import '../../domain/models/submission.dart';
import '../../../../shared/services/firestore_service.dart';
import '../../../../shared/services/logger_service.dart';
import '../../domain/repositories/submission_repository.dart';
import '../../../../shared/repositories/firestore_repository.dart';

/// Firestore-based implementation of SubmissionRepository.
/// 
/// This class extends FirestoreRepository to leverage common
/// CRUD operations while implementing submission-specific features:
/// - Automatic duplicate detection and updates
/// - Text and file submission handling
/// - Status workflow management
/// - Real-time submission streaming
/// - Statistical analysis for completion tracking
/// - Batch operations for bulk updates
/// 
/// All operations include comprehensive logging and automatic
/// timestamp management for audit trails.
class SubmissionRepositoryImpl extends FirestoreRepository<Submission> implements SubmissionRepository {
  /// Logger tag for this repository.
  static const String _tag = 'SubmissionRepository';
  
  /// Firestore instance for direct database operations.
  final FirebaseFirestore _firestore;

  /// Creates a submission repository with Firestore backend.
  /// 
  /// Initializes the parent FirestoreRepository with submission-specific
  /// configuration including collection path and serialization functions.
  /// 
  /// @param _firestore Firestore database instance
  SubmissionRepositoryImpl(this._firestore)
      : super(
          firestore: _firestore,
          collectionPath: 'submissions',
          fromFirestore: (doc) => Submission.fromFirestore(doc),
          toFirestore: (submission) => submission.toFirestore(),
          logTag: _tag,
        );

  /// Creates a new submission with automatic timestamps.
  /// 
  /// Sets both submission and update timestamps to current time.
  /// The submission ID is generated by Firestore for uniqueness.
  /// 
  /// @param submission Submission model with content and metadata
  /// @return Generated unique submission ID
  /// @throws Exception if creation fails
  @override
  Future<String> createSubmission(Submission submission) async {
    try {
      // Update timestamp
      final submissionToCreate = submission.copyWith(
        submittedAt: DateTime.now(),
        updatedAt: DateTime.now(),
      );
      return await create(submissionToCreate);
    } catch (e) {
      LoggerService.error('Failed to create submission', tag: _tag, error: e);
      rethrow;
    }
  }

  /// Retrieves a submission by its unique identifier.
  /// 
  /// Delegates to parent repository for consistent error handling.
  /// 
  /// @param id Unique submission identifier
  /// @return Submission instance or null if not found
  @override
  Future<Submission?> getSubmission(String id) => read(id);

  /// Retrieves a student's submission for a specific assignment.
  /// 
  /// Queries for the unique submission matching both student and
  /// assignment IDs. Uses limit 1 for efficiency since only one
  /// submission should exist per student-assignment pair.
  /// 
  /// @param assignmentId Assignment identifier
  /// @param studentId Student identifier
  /// @return Submission instance or null if not submitted
  /// @throws Exception if retrieval fails
  @override
  Future<Submission?> getStudentSubmission(String assignmentId, String studentId) async {
    try {
      final submissions = await list(
        conditions: [
          QueryCondition(field: 'assignmentId', isEqualTo: assignmentId),
          QueryCondition(field: 'studentId', isEqualTo: studentId),
        ],
        limit: 1,
      );
      return submissions.isEmpty ? null : submissions.first;
    } catch (e) {
      LoggerService.error('Failed to get student submission', tag: _tag, error: e);
      rethrow;
    }
  }

  /// Updates an existing submission with new timestamp.
  /// 
  /// Automatically updates the modification timestamp while
  /// preserving other metadata like submission date.
  /// 
  /// @param id Submission ID to update
  /// @param submission Updated submission information
  /// @throws Exception if update fails
  @override
  Future<void> updateSubmission(String id, Submission submission) async {
    try {
      // Update timestamp
      final submissionToUpdate = submission.copyWith(
        updatedAt: DateTime.now(),
      );
      await update(id, submissionToUpdate);
    } catch (e) {
      LoggerService.error('Failed to update submission', tag: _tag, error: e);
      rethrow;
    }
  }

  /// Permanently deletes a submission.
  /// 
  /// This operation cannot be undone. Consider using status
  /// changes for recoverable operations.
  /// 
  /// @param id Submission ID to delete
  /// @throws Exception if deletion fails
  @override
  Future<void> deleteSubmission(String id) => delete(id);

  /// Creates or updates a text-based submission.
  /// 
  /// Intelligent submission handling:
  /// - Checks for existing submission to prevent duplicates
  /// - Updates existing submission if found
  /// - Creates new submission if none exists
  /// 
  /// This ensures students can resubmit without creating
  /// multiple submission records.
  /// 
  /// @param assignmentId Target assignment
  /// @param studentId Submitting student
  /// @param studentName Student's display name
  /// @param textContent Written response content
  /// @return Created or updated submission
  /// @throws Exception if submission fails
  @override
  Future<Submission> submitTextContent({
    required String assignmentId,
    required String studentId,
    required String studentName,
    required String textContent,
  }) async {
    try {
      // Check if submission already exists
      final existing = await getStudentSubmission(assignmentId, studentId);
      
      if (existing != null) {
        // Update existing submission
        final updated = existing.copyWith(
          textContent: textContent,
          status: SubmissionStatus.submitted,
          submittedAt: DateTime.now(),
          updatedAt: DateTime.now(),
        );
        await updateSubmission(existing.id, updated);
        return updated;
      } else {
        // Create new submission
        final submission = Submission(
          id: '',
          assignmentId: assignmentId,
          studentId: studentId,
          studentName: studentName,
          textContent: textContent,
          status: SubmissionStatus.submitted,
          submittedAt: DateTime.now(),
          updatedAt: DateTime.now(),
        );
        final id = await createSubmission(submission);
        return submission.copyWith(id: id);
      }
    } catch (e) {
      LoggerService.error('Failed to submit text content', tag: _tag, error: e);
      rethrow;
    }
  }

  /// Creates or updates a file-based submission.
  /// 
  /// Intelligent submission handling:
  /// - Checks for existing submission to prevent duplicates
  /// - Updates existing submission with new file if found
  /// - Creates new submission if none exists
  /// 
  /// File URL should point to pre-uploaded content in
  /// Firebase Storage or other file hosting service.
  /// 
  /// @param assignmentId Target assignment
  /// @param studentId Submitting student
  /// @param studentName Student's display name
  /// @param fileUrl URL of uploaded file
  /// @param fileName Original file name for display
  /// @return Created or updated submission
  /// @throws Exception if submission fails
  @override
  Future<Submission> submitFile({
    required String assignmentId,
    required String studentId,
    required String studentName,
    required String fileUrl,
    required String fileName,
  }) async {
    try {
      // Check if submission already exists
      final existing = await getStudentSubmission(assignmentId, studentId);
      
      if (existing != null) {
        // Update existing submission
        final updated = existing.copyWith(
          fileUrl: fileUrl,
          fileName: fileName,
          status: SubmissionStatus.submitted,
          submittedAt: DateTime.now(),
          updatedAt: DateTime.now(),
        );
        await updateSubmission(existing.id, updated);
        return updated;
      } else {
        // Create new submission
        final submission = Submission(
          id: '',
          assignmentId: assignmentId,
          studentId: studentId,
          studentName: studentName,
          fileUrl: fileUrl,
          fileName: fileName,
          status: SubmissionStatus.submitted,
          submittedAt: DateTime.now(),
          updatedAt: DateTime.now(),
        );
        final id = await createSubmission(submission);
        return submission.copyWith(id: id);
      }
    } catch (e) {
      LoggerService.error('Failed to submit file', tag: _tag, error: e);
      rethrow;
    }
  }

  /// Updates the status of a submission.
  /// 
  /// Uses server timestamp for consistency across clients.
  /// Status changes may trigger notifications or other
  /// workflow actions.
  /// 
  /// @param id Submission to update
  /// @param status New submission status
  /// @throws Exception if status update fails
  @override
  Future<void> updateSubmissionStatus(String id, SubmissionStatus status) async {
    try {
      await _firestore.collection('submissions').doc(id).update({
        'status': status.name,
        'updatedAt': FieldValue.serverTimestamp(),
      });
      LoggerService.info('Updated submission status to ${status.name}', tag: _tag);
    } catch (e) {
      LoggerService.error('Failed to update submission status', tag: _tag, error: e);
      rethrow;
    }
  }

  /// Streams all submissions for an assignment.
  /// 
  /// Returns real-time updates ordered by submission time,
  /// with most recent first. Useful for grading dashboards.
  /// 
  /// @param assignmentId Assignment to monitor
  /// @return Stream of submission lists
  @override
  Stream<List<Submission>> getAssignmentSubmissions(String assignmentId) {
    return stream(
      conditions: [
        QueryCondition(field: 'assignmentId', isEqualTo: assignmentId),
      ],
      orderBy: [OrderBy(field: 'submittedAt', descending: true)],
    );
  }

  /// Streams all submissions by a specific student.
  /// 
  /// Returns comprehensive submission history ordered by
  /// submission time, most recent first.
  /// 
  /// @param studentId Student to monitor
  /// @return Stream of submission lists
  @override
  Stream<List<Submission>> getStudentSubmissions(String studentId) {
    return stream(
      conditions: [
        QueryCondition(field: 'studentId', isEqualTo: studentId),
      ],
      orderBy: [OrderBy(field: 'submittedAt', descending: true)],
    );
  }

  /// Streams submissions for a student in a specific class.
  /// 
  /// Note: This implementation currently returns all student
  /// submissions. Filtering by class requires joining with
  /// assignments collection, which should be done in the
  /// provider layer for better performance.
  /// 
  /// @param studentId Student to monitor
  /// @param classId Class context (not currently used)
  /// @return Stream of student submissions
  @override
  Stream<List<Submission>> getStudentClassSubmissions(String studentId, String classId) {
    // Note: This requires joining with assignments to filter by classId
    // For now, returning student submissions and filtering will be done in the provider
    return getStudentSubmissions(studentId);
  }

  /// Calculates submission statistics for an assignment.
  /// 
  /// Aggregates submission data to provide insights:
  /// - Total submissions (currently based on actual submissions)
  /// - Number submitted vs pending
  /// - Number graded
  /// - Submission rate percentage
  /// - Latest submission timestamp
  /// 
  /// Note: Total count should ideally come from enrolled
  /// students in the class, requiring a join with classes.
  /// 
  /// @param assignmentId Assignment to analyze
  /// @return Statistical summary of submissions
  /// @throws Exception if calculation fails
  @override
  Future<SubmissionStatistics> getAssignmentSubmissionStatistics(String assignmentId) async {
    try {
      // Get all submissions for the assignment
      final submissions = await list(
        conditions: [
          QueryCondition(field: 'assignmentId', isEqualTo: assignmentId),
        ],
      );
      
      // Get total students count from assignment's class
      // This would require joining with assignments and classes
      // For now, we'll use submissions count as total
      final total = submissions.length;
      final submitted = submissions.where((s) => 
        s.status == SubmissionStatus.submitted || 
        s.status == SubmissionStatus.graded
      ).length;
      final graded = submissions.where((s) => s.status == SubmissionStatus.graded).length;
      final pending = total - submitted;
      
      DateTime? lastSubmissionAt;
      if (submissions.isNotEmpty) {
        submissions.sort((a, b) => b.submittedAt.compareTo(a.submittedAt));
        lastSubmissionAt = submissions.first.submittedAt;
      }
      
      return SubmissionStatistics(
        total: total,
        submitted: submitted,
        graded: graded,
        pending: pending,
        submissionRate: total > 0 ? (submitted / total) : 0,
        lastSubmissionAt: lastSubmissionAt,
      );
    } catch (e) {
      LoggerService.error('Failed to get submission statistics', tag: _tag, error: e);
      rethrow;
    }
  }

  /// Marks a submission as graded.
  /// 
  /// Convenience method that updates status to 'graded'.
  /// Should be called after grade has been recorded.
  /// 
  /// @param id Submission to mark as graded
  /// @throws Exception if marking fails
  @override
  Future<void> markAsGraded(String id) async {
    try {
      await updateSubmissionStatus(id, SubmissionStatus.graded);
    } catch (e) {
      LoggerService.error('Failed to mark submission as graded', tag: _tag, error: e);
      rethrow;
    }
  }

  /// Adds teacher feedback to a submission.
  /// 
  /// Updates the feedback field and modification timestamp.
  /// Feedback is preserved even if submission is resubmitted.
  /// 
  /// @param id Submission to add feedback to
  /// @param feedback Teacher's comments and suggestions
  /// @throws Exception if feedback addition fails
  @override
  Future<void> addFeedback(String id, String feedback) async {
    try {
      await _firestore.collection('submissions').doc(id).update({
        'feedback': feedback,
        'updatedAt': FieldValue.serverTimestamp(),
      });
      LoggerService.info('Added feedback to submission', tag: _tag);
    } catch (e) {
      LoggerService.error('Failed to add feedback', tag: _tag, error: e);
      rethrow;
    }
  }

  /// Creates multiple submissions in one atomic operation.
  /// 
  /// Efficient bulk creation for:
  /// - Programmatic submission generation
  /// - Data migration
  /// - Testing purposes
  /// 
  /// All submissions get the same timestamp for consistency.
  /// Uses batch operations to ensure atomicity.
  /// 
  /// @param submissions List of submissions to create
  /// @throws Exception if batch creation fails
  @override
  Future<void> batchCreateSubmissions(List<Submission> submissions) async {
    try {
      final batch = _firestore.batch();
      final now = DateTime.now();
      
      for (final submission in submissions) {
        final ref = _firestore.collection('submissions').doc();
        final submissionToCreate = submission.copyWith(
          id: ref.id,
          submittedAt: now,
          updatedAt: now,
        );
        batch.set(ref, submissionToCreate.toFirestore());
      }
      
      await batch.commit();
      LoggerService.info('Batch created ${submissions.length} submissions', tag: _tag);
    } catch (e) {
      LoggerService.error('Failed to batch create submissions', tag: _tag, error: e);
      rethrow;
    }
  }

  /// Updates multiple submissions in one atomic operation.
  /// 
  /// Efficient bulk update for:
  /// - Batch status changes
  /// - Mass feedback updates
  /// - Bulk grading operations
  /// 
  /// All updates use the same timestamp for consistency.
  /// Operations are atomic - all succeed or fail together.
  /// 
  /// @param submissions Map of submission IDs to updated data
  /// @throws Exception if batch update fails
  @override
  Future<void> batchUpdateSubmissions(Map<String, Submission> submissions) async {
    try {
      final batch = _firestore.batch();
      final now = DateTime.now();
      
      submissions.forEach((submissionId, submission) {
        final ref = _firestore.collection('submissions').doc(submissionId);
        final submissionToUpdate = submission.copyWith(
          updatedAt: now,
        );
        batch.update(ref, submissionToUpdate.toFirestore());
      });
      
      await batch.commit();
      LoggerService.info('Batch updated ${submissions.length} submissions', tag: _tag);
    } catch (e) {
      LoggerService.error('Failed to batch update submissions', tag: _tag, error: e);
      rethrow;
    }
  }
}
````

## File: lib/features/assignments/data/services/submission_service.dart
````dart
/// Service for managing assignment submissions in the education platform.
/// 
/// This service handles all submission-related operations including
/// creation, retrieval, status tracking, and file management for
/// student assignment submissions.
library;

import 'package:cloud_firestore/cloud_firestore.dart';
import '../../domain/models/submission.dart';

/// Core service for handling student assignment submissions.
/// 
/// This service provides:
/// - Submission creation with duplicate prevention
/// - Submission retrieval and monitoring
/// - Status tracking and grading workflows
/// - File and text submission support
/// - Late submission tracking
/// - Submission counting and analytics
/// 
/// Ensures each student can only submit once per assignment
/// and tracks submission timestamps for deadline compliance.
class SubmissionService {
  /// Reference to the submissions collection in Firestore.
  final CollectionReference _submissionsCollection;

  /// Creates a SubmissionService instance.
  /// 
  /// Accepts optional Firestore instance for dependency injection,
  /// supporting both production use and unit testing.
  /// 
  /// @param firestore Optional Firestore instance for testing
  SubmissionService({FirebaseFirestore? firestore})
      : _submissionsCollection = (firestore ?? FirebaseFirestore.instance).collection('submissions');

  /// Creates a new assignment submission.
  /// 
  /// Validates that the student hasn't already submitted
  /// for this assignment before creating the submission.
  /// Prevents duplicate submissions at the service level.
  /// 
  /// @param submission Submission model to create
  /// @return Created submission with generated ID
  /// @throws Exception if student already submitted
  Future<Submission> createSubmission(Submission submission) async {
    try {
      // Check if student already has a submission for this assignment
      final existing = await getSubmissionForStudentAndAssignment(
        submission.studentId,
        submission.assignmentId,
      );
      
      if (existing != null) {
        throw Exception('Student has already submitted this assignment');
      }

      final docRef = await _submissionsCollection.add(submission.toFirestore());
      return submission.copyWith(id: docRef.id);
    } catch (e) {
      // Error creating submission: $e
      rethrow;
    }
  }

  /// Retrieves a single submission by ID.
  /// 
  /// Fetches the submission document from Firestore.
  /// Returns null if the submission doesn't exist.
  /// 
  /// @param submissionId Unique identifier of the submission
  /// @return Submission instance or null if not found
  /// @throws Exception if retrieval fails
  Future<Submission?> getSubmission(String submissionId) async {
    try {
      final doc = await _submissionsCollection.doc(submissionId).get();
      if (!doc.exists) return null;
      return Submission.fromFirestore(doc);
    } catch (e) {
      // Error getting submission: $e
      rethrow;
    }
  }

  /// Retrieves submission for a specific student-assignment pair.
  /// 
  /// Queries for the unique submission matching both student
  /// and assignment IDs. Used to check if a student has
  /// already submitted and to retrieve their submission.
  /// 
  /// @param studentId ID of the student
  /// @param assignmentId ID of the assignment
  /// @return Submission instance or null if not submitted
  /// @throws Exception if query fails
  Future<Submission?> getSubmissionForStudentAndAssignment(
    String studentId,
    String assignmentId,
  ) async {
    try {
      final query = await _submissionsCollection
          .where('studentId', isEqualTo: studentId)
          .where('assignmentId', isEqualTo: assignmentId)
          .limit(1)
          .get();
      
      if (query.docs.isEmpty) return null;
      return Submission.fromFirestore(query.docs.first);
    } catch (e) {
      // Error getting submission: $e
      rethrow;
    }
  }

  /// Streams all submissions for a specific assignment.
  /// 
  /// Returns a real-time stream of submissions:
  /// - Filtered by assignment ID
  /// - Ordered by submission time (newest first)
  /// - Updates automatically when submissions change
  /// 
  /// Useful for teachers viewing all student submissions.
  /// 
  /// @param assignmentId Assignment to get submissions for
  /// @return Stream of submission lists
  Stream<List<Submission>> getSubmissionsForAssignment(String assignmentId) {
    return _submissionsCollection
        .where('assignmentId', isEqualTo: assignmentId)
        .orderBy('submittedAt', descending: true)
        .snapshots()
        .map((snapshot) => snapshot.docs
            .map((doc) => Submission.fromFirestore(doc))
            .toList());
  }

  /// Streams all submissions for a specific student.
  /// 
  /// Returns a real-time stream of submissions:
  /// - Filtered by student ID
  /// - Ordered by submission time (newest first)
  /// - Across all assignments
  /// 
  /// Useful for student submission history views.
  /// 
  /// @param studentId Student to get submissions for
  /// @return Stream of submission lists
  Stream<List<Submission>> getSubmissionsForStudent(String studentId) {
    return _submissionsCollection
        .where('studentId', isEqualTo: studentId)
        .orderBy('submittedAt', descending: true)
        .snapshots()
        .map((snapshot) => snapshot.docs
            .map((doc) => Submission.fromFirestore(doc))
            .toList());
  }

  /// Updates an existing submission.
  /// 
  /// Primarily used for adding file uploads after initial
  /// submission or updating submission content. Overwrites
  /// all submission fields with provided data.
  /// 
  /// @param submission Updated submission model
  /// @throws Exception if update fails
  Future<void> updateSubmission(Submission submission) async {
    try {
      await _submissionsCollection
          .doc(submission.id)
          .update(submission.toFirestore());
    } catch (e) {
      // Error updating submission: $e
      rethrow;
    }
  }

  /// Marks a submission as graded.
  /// 
  /// Updates submission status to 'graded' and sets the
  /// graded timestamp. Should be called after a grade
  /// has been assigned through the grading service.
  /// 
  /// @param submissionId ID of submission to mark as graded
  /// @throws Exception if update fails
  Future<void> markSubmissionAsGraded(String submissionId) async {
    try {
      await _submissionsCollection.doc(submissionId).update({
        'status': SubmissionStatus.graded.toString().split('.').last,
        'gradedAt': FieldValue.serverTimestamp(),
      });
    } catch (e) {
      // Error marking submission as graded: $e
      rethrow;
    }
  }

  /// Deletes a submission (teachers only).
  /// 
  /// Permanently removes the submission from Firestore.
  /// This operation cannot be undone. Should be restricted
  /// to teacher roles in the UI layer.
  /// 
  /// @param submissionId ID of submission to delete
  /// @throws Exception if deletion fails
  Future<void> deleteSubmission(String submissionId) async {
    try {
      await _submissionsCollection.doc(submissionId).delete();
    } catch (e) {
      // Error deleting submission: $e
      rethrow;
    }
  }

  /// Gets the total submission count for an assignment.
  /// 
  /// Uses Firestore's count aggregation for efficient
  /// counting without loading all submission documents.
  /// Returns 0 if counting fails.
  /// 
  /// @param assignmentId Assignment to count submissions for
  /// @return Number of submissions or 0 on error
  Future<int> getSubmissionCountForAssignment(String assignmentId) async {
    try {
      final query = await _submissionsCollection
          .where('assignmentId', isEqualTo: assignmentId)
          .count()
          .get();
      return query.count ?? 0;
    } catch (e) {
      // Error getting submission count: $e
      return 0;
    }
  }

  /// Checks if a student has submitted an assignment.
  /// 
  /// Quick check to determine submission status without
  /// loading the full submission data. Useful for UI
  /// state management and submission buttons.
  /// 
  /// @param studentId ID of the student to check
  /// @param assignmentId ID of the assignment to check
  /// @return true if submitted, false otherwise or on error
  Future<bool> isAssignmentSubmitted(String studentId, String assignmentId) async {
    try {
      final submission = await getSubmissionForStudentAndAssignment(
        studentId,
        assignmentId,
      );
      return submission != null;
    } catch (e) {
      // Error checking submission status: $e
      return false;
    }
  }

  /// Streams real-time submission status for a student-assignment pair.
  /// 
  /// Returns a stream that emits true when a submission exists
  /// and false when it doesn't. Updates automatically when
  /// submission status changes.
  /// 
  /// @param studentId ID of the student to monitor
  /// @param assignmentId ID of the assignment to monitor
  /// @return Stream of submission existence status
  Stream<bool> watchSubmissionStatus(String studentId, String assignmentId) {
    return _submissionsCollection
        .where('studentId', isEqualTo: studentId)
        .where('assignmentId', isEqualTo: assignmentId)
        .snapshots()
        .map((snapshot) => snapshot.docs.isNotEmpty);
  }

  /// Streams late submissions for an assignment.
  /// 
  /// Returns a real-time stream of submissions that were
  /// submitted after the assignment's due date. Useful for
  /// tracking late submission penalties and reports.
  /// 
  /// @param assignmentId Assignment to check for late submissions
  /// @param dueDate Assignment's due date for comparison
  /// @return Stream of late submission lists
  Stream<List<Submission>> getLateSubmissionsForAssignment(
    String assignmentId,
    DateTime dueDate,
  ) {
    return _submissionsCollection
        .where('assignmentId', isEqualTo: assignmentId)
        .where('submittedAt', isGreaterThan: Timestamp.fromDate(dueDate))
        .snapshots()
        .map((snapshot) => snapshot.docs
            .map((doc) => Submission.fromFirestore(doc))
            .toList());
  }

  /// Submits a text-only assignment response.
  /// 
  /// Creates a submission containing only text content without
  /// any file attachments. This method is a convenience wrapper
  /// around createSubmission for text-based assignments.
  /// 
  /// Automatically sets submission status to 'submitted' and
  /// captures the current timestamp.
  /// 
  /// @param assignmentId ID of the assignment being submitted
  /// @param studentId ID of the submitting student
  /// @param studentName Name of the student for display
  /// @param textContent The text response content
  /// @return Created submission with generated ID
  /// @throws Exception if student already submitted
  Future<Submission> submitTextContent({
    required String assignmentId,
    required String studentId,
    required String studentName,
    required String textContent,
  }) async {
    final submission = Submission(
      id: '',
      assignmentId: assignmentId,
      studentId: studentId,
      studentName: studentName,
      textContent: textContent,
      submittedAt: DateTime.now(),
      status: SubmissionStatus.submitted,
    );

    return createSubmission(submission);
  }

  /// Submits a file-based assignment response.
  /// 
  /// Creates a submission containing a file attachment with
  /// optional text content. This method is a convenience wrapper
  /// around createSubmission for file-based assignments.
  /// 
  /// The file should already be uploaded to Firebase Storage
  /// and the URL provided here. File upload is typically handled
  /// by the UI layer before calling this method.
  /// 
  /// @param assignmentId ID of the assignment being submitted
  /// @param studentId ID of the submitting student
  /// @param studentName Name of the student for display
  /// @param fileUrl Firebase Storage URL of the uploaded file
  /// @param fileName Original filename for display purposes
  /// @param textContent Optional text description or notes
  /// @return Created submission with generated ID
  /// @throws Exception if student already submitted
  Future<Submission> submitFile({
    required String assignmentId,
    required String studentId,
    required String studentName,
    required String fileUrl,
    required String fileName,
    String? textContent,
  }) async {
    final submission = Submission(
      id: '',
      assignmentId: assignmentId,
      studentId: studentId,
      studentName: studentName,
      fileUrl: fileUrl,
      fileName: fileName,
      textContent: textContent,
      submittedAt: DateTime.now(),
      status: SubmissionStatus.submitted,
    );

    return createSubmission(submission);
  }
}

/// Extension adding immutable update capabilities to Submission.
/// 
/// Provides a copyWith method following the immutable data pattern
/// commonly used in Flutter applications for state management.
/// This allows creating modified copies of submissions without
/// mutating the original instance.
extension SubmissionExtension on Submission {
  /// Creates a copy of the Submission with updated fields.
  /// 
  /// Follows the immutable data pattern for safe state updates.
  /// All parameters are optional - only provided fields will be
  /// updated in the new instance.
  /// 
  /// Common uses:
  /// - Adding generated ID after creation
  /// - Updating submission status
  /// - Adding grading timestamp
  /// - Attaching file information
  /// 
  /// @param id New submission ID
  /// @param assignmentId New assignment reference
  /// @param studentId New student ID
  /// @param studentName New student display name
  /// @param fileUrl New file attachment URL
  /// @param fileName New file name
  /// @param textContent New text content
  /// @param submittedAt New submission timestamp
  /// @param gradedAt New grading timestamp
  /// @param status New submission status
  /// @return New Submission instance with updated fields
  Submission copyWith({
    String? id,
    String? assignmentId,
    String? studentId,
    String? studentName,
    String? fileUrl,
    String? fileName,
    String? textContent,
    DateTime? submittedAt,
    DateTime? gradedAt,
    SubmissionStatus? status,
  }) {
    return Submission(
      id: id ?? this.id,
      assignmentId: assignmentId ?? this.assignmentId,
      studentId: studentId ?? this.studentId,
      studentName: studentName ?? this.studentName,
      fileUrl: fileUrl ?? this.fileUrl,
      fileName: fileName ?? this.fileName,
      textContent: textContent ?? this.textContent,
      submittedAt: submittedAt ?? this.submittedAt,
      gradedAt: gradedAt ?? this.gradedAt,
      status: status ?? this.status,
    );
  }
}
````

## File: lib/features/assignments/domain/models/assignment.dart
````dart
/// Assignment model for managing educational assignments and tasks.
/// 
/// This module contains the data models for assignments, including
/// their lifecycle states and various types used throughout the
/// teacher dashboard application.
library;

import 'package:cloud_firestore/cloud_firestore.dart';

/// Enumeration representing the lifecycle states of an assignment.
/// 
/// Each assignment progresses through these states:
/// - [draft]: Assignment is being created/edited, not visible to students
/// - [active]: Assignment is published and accepting submissions
/// - [completed]: Assignment due date has passed or manually marked complete
/// - [archived]: Assignment is no longer active but kept for records
enum AssignmentStatus {
  draft,
  active,
  completed,
  archived
}

/// Core assignment model representing educational tasks and assessments.
/// 
/// This model encapsulates all data related to an assignment, including:
/// - Basic information (title, description, instructions)
/// - Grading configuration (points, late penalties)
/// - Publishing controls (status, scheduled publishing)
/// - Submission settings (late submissions, attachments)
/// 
/// Assignments can be of various types (homework, quiz, test, etc.) and
/// progress through different lifecycle states from draft to archived.
class Assignment {
  /// Unique identifier for the assignment
  final String id;
  
  /// ID of the teacher who created this assignment
  final String teacherId;
  
  /// ID of the class this assignment belongs to
  final String classId;
  
  /// Assignment title displayed to students
  final String title;
  
  /// Brief description of the assignment
  final String description;
  
  /// Detailed instructions for completing the assignment
  final String instructions;
  
  /// Due date and time for submissions
  final DateTime dueDate;
  
  /// Total points possible for this assignment
  final double totalPoints;
  
  /// Maximum points that can be earned (may differ from totalPoints for extra credit)
  final double maxPoints;
  
  /// Optional URL to attached file or resource
  final String? attachmentUrl;
  
  /// Timestamp when the assignment was created
  final DateTime createdAt;
  
  /// Timestamp of last modification (null if never updated)
  final DateTime? updatedAt;
  
  /// Type of assignment (homework, quiz, test, etc.)
  final AssignmentType type;
  
  /// Current status in the assignment lifecycle
  final AssignmentStatus status;
  
  /// Category for organizing assignments (e.g., "Math", "Science")
  final String category;
  
  /// Name of the teacher (cached for display purposes)
  final String teacherName;
  
  /// Whether the assignment is visible to students
  final bool isPublished;
  
  /// Whether submissions are accepted after the due date
  final bool allowLateSubmissions;
  
  /// Percentage penalty applied to late submissions (0-100)
  final int latePenaltyPercentage;
  
  /// Optional future date/time to automatically publish the assignment
  final DateTime? publishAt; // For scheduled publishing

  Assignment({
    required this.id,
    required this.teacherId,
    required this.classId,
    required this.title,
    required this.description,
    required this.instructions,
    required this.dueDate,
    required this.totalPoints,
    required this.maxPoints,
    this.attachmentUrl,
    required this.createdAt,
    this.updatedAt,
    required this.type,
    required this.status,
    required this.category,
    required this.teacherName,
    required this.isPublished,
    required this.allowLateSubmissions,
    required this.latePenaltyPercentage,
    this.publishAt,
  });

  /// Factory constructor to create Assignment from Firestore document.
  /// 
  /// Handles data parsing and type conversions including:
  /// - Timestamp to DateTime conversions
  /// - Enum parsing with fallback defaults
  /// - Null safety for optional fields
  /// - Type casting for numeric values
  /// 
  /// @param doc Firestore document snapshot containing assignment data
  /// @return Parsed Assignment instance
  factory Assignment.fromFirestore(DocumentSnapshot doc) {
    final data = doc.data() as Map<String, dynamic>;
    return Assignment(
      id: doc.id,
      teacherId: data['teacherId'] ?? '',
      classId: data['classId'] ?? '',
      title: data['title'] ?? '',
      description: data['description'] ?? '',
      instructions: data['instructions'] ?? '',
      dueDate: (data['dueDate'] as Timestamp).toDate(),
      totalPoints: (data['totalPoints'] ?? 0).toDouble(),
      maxPoints: (data['maxPoints'] ?? data['totalPoints'] ?? 0).toDouble(),
      attachmentUrl: data['attachmentUrl'],
      createdAt: (data['createdAt'] as Timestamp).toDate(),
      updatedAt: data['updatedAt'] != null 
          ? (data['updatedAt'] as Timestamp).toDate() 
          : null,
      type: AssignmentType.values.firstWhere(
        (e) => e.toString() == 'AssignmentType.${data['type']}',
        orElse: () => AssignmentType.homework,
      ),
      status: AssignmentStatus.values.firstWhere(
        (e) => e.toString() == 'AssignmentStatus.${data['status']}',
        orElse: () => AssignmentStatus.draft,
      ),
      category: data['category'] ?? 'Other',
      teacherName: data['teacherName'] ?? '',
      isPublished: data['isPublished'] ?? false,
      allowLateSubmissions: data['allowLateSubmissions'] ?? true,
      latePenaltyPercentage: data['latePenaltyPercentage'] ?? 10,
      publishAt: data['publishAt'] != null 
          ? (data['publishAt'] as Timestamp).toDate() 
          : null,
    );
  }

  /// Converts the Assignment instance to a Map for Firestore storage.
  /// 
  /// Serializes all assignment data for persistence, including:
  /// - DateTime fields to Firestore Timestamps
  /// - Enum values to string representations
  /// - Null checks for optional fields
  /// 
  /// @return Map containing all assignment data ready for Firestore
  Map<String, dynamic> toFirestore() {
    return {
      'teacherId': teacherId,
      'classId': classId,
      'title': title,
      'description': description,
      'instructions': instructions,
      'dueDate': Timestamp.fromDate(dueDate),
      'totalPoints': totalPoints,
      'maxPoints': maxPoints,
      'attachmentUrl': attachmentUrl,
      'createdAt': Timestamp.fromDate(createdAt),
      'updatedAt': updatedAt != null ? Timestamp.fromDate(updatedAt!) : null,
      'type': type.toString().split('.').last,
      'status': status.toString().split('.').last,
      'category': category,
      'teacherName': teacherName,
      'isPublished': isPublished,
      'allowLateSubmissions': allowLateSubmissions,
      'latePenaltyPercentage': latePenaltyPercentage,
      'publishAt': publishAt != null ? Timestamp.fromDate(publishAt!) : null,
    };
  }

  /// Creates a copy of the Assignment with updated fields.
  /// 
  /// Follows the immutable data pattern, allowing selective field updates
  /// while preserving all other values. Useful for:
  /// - Updating assignment details
  /// - Changing status or publishing state
  /// - Modifying grading settings
  /// 
  /// All parameters are optional - only provided fields will be updated.
  /// 
  /// @return New Assignment instance with updated fields
  Assignment copyWith({
    String? id,
    String? teacherId,
    String? classId,
    String? title,
    String? description,
    String? instructions,
    DateTime? dueDate,
    double? totalPoints,
    double? maxPoints,
    String? attachmentUrl,
    DateTime? createdAt,
    DateTime? updatedAt,
    AssignmentType? type,
    AssignmentStatus? status,
    String? category,
    String? teacherName,
    bool? isPublished,
    bool? allowLateSubmissions,
    int? latePenaltyPercentage,
    DateTime? publishAt,
  }) {
    return Assignment(
      id: id ?? this.id,
      teacherId: teacherId ?? this.teacherId,
      classId: classId ?? this.classId,
      title: title ?? this.title,
      description: description ?? this.description,
      instructions: instructions ?? this.instructions,
      dueDate: dueDate ?? this.dueDate,
      totalPoints: totalPoints ?? this.totalPoints,
      maxPoints: maxPoints ?? this.maxPoints,
      attachmentUrl: attachmentUrl ?? this.attachmentUrl,
      createdAt: createdAt ?? this.createdAt,
      updatedAt: updatedAt ?? this.updatedAt,
      type: type ?? this.type,
      status: status ?? this.status,
      category: category ?? this.category,
      teacherName: teacherName ?? this.teacherName,
      isPublished: isPublished ?? this.isPublished,
      allowLateSubmissions: allowLateSubmissions ?? this.allowLateSubmissions,
      latePenaltyPercentage: latePenaltyPercentage ?? this.latePenaltyPercentage,
      publishAt: publishAt ?? this.publishAt,
    );
  }
}

/// Enumeration of supported assignment types.
/// 
/// These types help categorize assignments and may influence:
/// - Default grading rubrics
/// - UI presentation
/// - Submission requirements
/// - Time limits or restrictions
/// 
/// Types include:
/// - [homework]: Regular take-home assignments
/// - [quiz]: Short assessments, often timed
/// - [test]: Formal assessments covering specific topics
/// - [exam]: Major assessments, typically weighted heavily
/// - [project]: Long-term assignments with multiple components
/// - [classwork]: In-class activities and assignments
/// - [essay]: Written assignments requiring extended responses
/// - [lab]: Science or practical lab assignments
/// - [presentation]: Oral or visual presentation assignments
/// - [other]: Miscellaneous assignment types
enum AssignmentType {
  homework,
  quiz,
  test,
  exam,
  project,
  classwork,
  essay,
  lab,
  presentation,
  other
}
````

## File: lib/features/assignments/domain/models/submission.dart
````dart
/// Submission model for managing student assignment submissions.
/// 
/// This module contains the data model for submissions, representing
/// student work submitted for assignments in the education platform.
library;

import 'package:cloud_firestore/cloud_firestore.dart';

/// Core submission model representing student work submitted for assignments.
/// 
/// This model encapsulates all data related to a student's submission:
/// - Link to the assignment and student
/// - Submission content (file and/or text)
/// - Timestamps for tracking submission lifecycle
/// - Status tracking (submitted, graded, returned, late)
/// 
/// Submissions support multiple content types:
/// - File uploads (with URL and filename tracking)
/// - Text content for inline submissions
/// - Combined file and text submissions
class Submission {
  /// Unique identifier for the submission
  final String id;
  
  /// ID of the assignment this submission is for
  final String assignmentId;
  
  /// ID of the student who submitted this work
  final String studentId;
  
  /// Cached student name for display purposes
  final String studentName;
  
  /// Optional URL to uploaded file (for file submissions)
  final String? fileUrl;
  
  /// Original filename of uploaded file
  final String? fileName;
  
  /// Optional text content (for inline text submissions)
  final String? textContent;
  
  /// Timestamp when the submission was created
  final DateTime submittedAt;
  
  /// Timestamp when the submission was graded (null if not graded)
  final DateTime? gradedAt;
  
  /// Timestamp of last modification to the submission
  final DateTime? updatedAt;
  
  /// Current status of the submission in its lifecycle
  final SubmissionStatus status;

  Submission({
    required this.id,
    required this.assignmentId,
    required this.studentId,
    required this.studentName,
    this.fileUrl,
    this.fileName,
    this.textContent,
    required this.submittedAt,
    this.gradedAt,
    this.updatedAt,
    required this.status,
  });

  /// Factory constructor to create Submission from Firestore document.
  /// 
  /// Handles data parsing with safe defaults including:
  /// - Timestamp conversions for date fields
  /// - Status enum parsing with fallback to 'submitted'
  /// - Null safety for optional fields
  /// - Caching of student name for performance
  /// 
  /// @param doc Firestore document snapshot containing submission data
  /// @return Parsed Submission instance
  factory Submission.fromFirestore(DocumentSnapshot doc) {
    final data = doc.data() as Map<String, dynamic>;
    return Submission(
      id: doc.id,
      assignmentId: data['assignmentId'] ?? '',
      studentId: data['studentId'] ?? '',
      studentName: data['studentName'] ?? '',
      fileUrl: data['fileUrl'],
      fileName: data['fileName'],
      textContent: data['textContent'],
      submittedAt: (data['submittedAt'] as Timestamp).toDate(),
      gradedAt: data['gradedAt'] != null 
          ? (data['gradedAt'] as Timestamp).toDate() 
          : null,
      updatedAt: data['updatedAt'] != null 
          ? (data['updatedAt'] as Timestamp).toDate() 
          : null,
      status: SubmissionStatus.values.firstWhere(
        (e) => e.toString() == 'SubmissionStatus.${data['status']}',
        orElse: () => SubmissionStatus.submitted,
      ),
    );
  }

  /// Converts the Submission instance to a Map for Firestore storage.
  /// 
  /// Serializes all submission data including:
  /// - DateTime fields to Firestore Timestamps
  /// - Status enum to string representation
  /// - Preservation of null values for optional fields
  /// 
  /// @return Map containing all submission data for Firestore
  Map<String, dynamic> toFirestore() {
    return {
      'assignmentId': assignmentId,
      'studentId': studentId,
      'studentName': studentName,
      'fileUrl': fileUrl,
      'fileName': fileName,
      'textContent': textContent,
      'submittedAt': Timestamp.fromDate(submittedAt),
      'gradedAt': gradedAt != null ? Timestamp.fromDate(gradedAt!) : null,
      'updatedAt': updatedAt != null ? Timestamp.fromDate(updatedAt!) : null,
      'status': status.toString().split('.').last,
    };
  }
  
  /// Creates a copy of the Submission with updated fields.
  /// 
  /// Follows immutable data pattern for state management.
  /// Useful for:
  /// - Updating submission status after grading
  /// - Adding grading timestamp
  /// - Modifying submission content
  /// - Tracking updates
  /// 
  /// All parameters are optional - only provided fields will be updated.
  /// 
  /// @return New Submission instance with updated fields
  Submission copyWith({
    String? id,
    String? assignmentId,
    String? studentId,
    String? studentName,
    String? fileUrl,
    String? fileName,
    String? textContent,
    DateTime? submittedAt,
    DateTime? gradedAt,
    DateTime? updatedAt,
    SubmissionStatus? status,
  }) {
    return Submission(
      id: id ?? this.id,
      assignmentId: assignmentId ?? this.assignmentId,
      studentId: studentId ?? this.studentId,
      studentName: studentName ?? this.studentName,
      fileUrl: fileUrl ?? this.fileUrl,
      fileName: fileName ?? this.fileName,
      textContent: textContent ?? this.textContent,
      submittedAt: submittedAt ?? this.submittedAt,
      gradedAt: gradedAt ?? this.gradedAt,
      updatedAt: updatedAt ?? this.updatedAt,
      status: status ?? this.status,
    );
  }
}

/// Enumeration representing the lifecycle states of a submission.
/// 
/// Each submission progresses through these states:
/// - [submitted]: Initial state when student submits work
/// - [graded]: Teacher has assigned a grade to the submission
/// - [returned]: Graded work has been returned to student
/// - [late]: Submission was received after the due date
/// 
/// Note: A submission can be both 'late' and progress through
/// other states (e.g., late → graded → returned)
enum SubmissionStatus {
  submitted,
  graded,
  returned,
  late
}
````

## File: lib/features/assignments/domain/repositories/assignment_repository.dart
````dart
/// Assignment repository interface for academic task management.
/// 
/// This module defines the contract for assignment operations
/// in the education platform, supporting creation, management,
/// and tracking of academic assignments.
library;

import '../models/assignment.dart';
import '../../../../shared/repositories/base_repository.dart';

/// Abstract repository defining assignment management operations.
/// 
/// This interface provides a comprehensive contract for assignment
/// implementations, supporting:
/// - CRUD operations for assignments
/// - Class and teacher-based assignment queries
/// - Assignment state management (publish/archive)
/// - Due date tracking and filtering
/// - Statistical analysis of assignments
/// - Real-time assignment updates
/// 
/// Concrete implementations handle the actual data persistence
/// and retrieval logic with specific data sources.
abstract class AssignmentRepository extends BaseRepository {
  /// Creates a new assignment in the system.
  /// 
  /// Creates an assignment with all required metadata including
  /// title, description, due date, and associated class.
  /// 
  /// @param assignment Assignment model to create
  /// @return Generated assignment ID
  /// @throws Exception if creation fails
  Future<String> createAssignment(Assignment assignment);
  
  /// Retrieves a single assignment by ID.
  /// 
  /// Fetches the complete assignment details including
  /// all metadata, attachments, and settings.
  /// 
  /// @param assignmentId Unique assignment identifier
  /// @return Assignment instance or null if not found
  /// @throws Exception if retrieval fails
  Future<Assignment?> getAssignment(String assignmentId);
  
  /// Updates an existing assignment.
  /// 
  /// Modifies assignment details such as title, description,
  /// due date, or instructions. Cannot change the associated
  /// class after creation.
  /// 
  /// @param assignmentId ID of assignment to update
  /// @param assignment Updated assignment model
  /// @throws Exception if update fails or assignment not found
  Future<void> updateAssignment(String assignmentId, Assignment assignment);
  
  /// Permanently deletes an assignment.
  /// 
  /// Removes the assignment and all associated data.
  /// This operation cannot be undone. Consider archiving
  /// instead for recoverable deletion.
  /// 
  /// @param assignmentId ID of assignment to delete
  /// @throws Exception if deletion fails
  Future<void> deleteAssignment(String assignmentId);
  
  /// Streams all assignments for a specific class.
  /// 
  /// Returns a real-time stream of assignments associated
  /// with the given class. Updates automatically when
  /// assignments are added, modified, or removed.
  /// 
  /// @param classId Class identifier
  /// @return Stream of assignment lists
  Stream<List<Assignment>> getClassAssignments(String classId);
  
  /// Streams all assignments created by a teacher.
  /// 
  /// Returns assignments across all classes taught by
  /// the specified teacher. Useful for teacher dashboards
  /// and cross-class assignment management.
  /// 
  /// @param teacherId Teacher's user ID
  /// @return Stream of assignment lists
  Stream<List<Assignment>> getTeacherAssignments(String teacherId);
  
  /// Streams assignments for multiple classes.
  /// 
  /// Aggregates assignments from multiple classes into a
  /// single stream. Useful for students enrolled in multiple
  /// classes or teachers viewing all their assignments.
  /// 
  /// @param classIds List of class identifiers
  /// @return Stream of combined assignment lists
  Stream<List<Assignment>> getClassAssignmentsForMultipleClasses(List<String> classIds);
  
  /// Retrieves upcoming assignments for a class.
  /// 
  /// Fetches assignments with due dates in the future,
  /// sorted by due date (earliest first). Useful for
  /// showing upcoming work in dashboards.
  /// 
  /// @param classId Class identifier
  /// @param limit Maximum number of assignments to return
  /// @return List of upcoming assignments
  /// @throws Exception if query fails
  Future<List<Assignment>> getUpcomingAssignments(String classId, {int limit = 5});
  
  /// Retrieves overdue assignments for a class.
  /// 
  /// Fetches assignments with due dates in the past that
  /// may still accept late submissions. Useful for tracking
  /// missing work and sending reminders.
  /// 
  /// @param classId Class identifier
  /// @return List of overdue assignments
  /// @throws Exception if query fails
  Future<List<Assignment>> getOverdueAssignments(String classId);
  
  /// Publishes a draft assignment to students.
  /// 
  /// Makes the assignment visible to students and starts
  /// accepting submissions. Sets the published timestamp
  /// and sends notifications if configured.
  /// 
  /// @param assignmentId ID of assignment to publish
  /// @throws Exception if publishing fails
  Future<void> publishAssignment(String assignmentId);
  
  /// Archives an assignment.
  /// 
  /// Moves the assignment to archived state, hiding it
  /// from active lists while preserving all data. Can
  /// be restored later if needed.
  /// 
  /// @param assignmentId ID of assignment to archive
  /// @throws Exception if archiving fails
  Future<void> archiveAssignment(String assignmentId);
  
  /// Unpublishes a published assignment.
  /// 
  /// Reverts assignment to draft state, hiding it from
  /// students. Existing submissions are preserved but
  /// new submissions are blocked.
  /// 
  /// @param assignmentId ID of assignment to unpublish
  /// @throws Exception if unpublishing fails
  Future<void> unpublishAssignment(String assignmentId);
  
  /// Restores an archived assignment.
  /// 
  /// Returns the assignment to its previous state before
  /// archiving. The assignment becomes visible again in
  /// active lists.
  /// 
  /// @param assignmentId ID of assignment to restore
  /// @throws Exception if restoration fails
  Future<void> restoreAssignment(String assignmentId);
  
  /// Calculates assignment statistics for a class.
  /// 
  /// Generates aggregate statistics including:
  /// - Total assignments
  /// - Active vs archived counts
  /// - Average completion rates
  /// - Submission statistics
  /// - Grade distributions
  /// 
  /// @param classId Class identifier
  /// @return Map of statistical data
  /// @throws Exception if calculation fails
  Future<Map<String, dynamic>> getAssignmentStats(String classId);
}
````

## File: lib/features/assignments/domain/repositories/submission_repository.dart
````dart
/// Submission repository interface for assignment submission management.
/// 
/// This module defines the contract for submission operations in the
/// education platform, supporting file uploads, text submissions,
/// grading workflows, and submission tracking.
library;

import '../models/submission.dart';
import '../../../../shared/repositories/base_repository.dart';

/// Abstract repository defining submission management operations.
/// 
/// This interface provides a comprehensive contract for submission
/// implementations, supporting:
/// - Multiple submission types (text, file, link)
/// - Submission status tracking and workflow
/// - Grading and feedback integration
/// - Statistical analysis for completion rates
/// - Real-time submission monitoring
/// - Batch operations for efficiency
/// 
/// Concrete implementations handle the actual submission
/// storage and business logic.
abstract class SubmissionRepository extends BaseRepository {
  // CRUD operations
  
  /// Creates a new submission record.
  /// 
  /// Initializes a submission with content, metadata, and
  /// timestamps. Returns the generated submission ID.
  /// 
  /// @param submission Submission model with content and metadata
  /// @return Generated unique submission ID
  /// @throws Exception if creation fails
  Future<String> createSubmission(Submission submission);
  
  /// Retrieves a submission by its unique identifier.
  /// 
  /// Fetches complete submission details including content,
  /// metadata, and grading information.
  /// 
  /// @param id Unique submission identifier
  /// @return Submission instance or null if not found
  /// @throws Exception if retrieval fails
  Future<Submission?> getSubmission(String id);
  
  /// Retrieves a student's submission for a specific assignment.
  /// 
  /// Queries for the unique submission matching both student
  /// and assignment. Returns null if not yet submitted.
  /// 
  /// @param assignmentId Assignment identifier
  /// @param studentId Student identifier
  /// @return Submission instance or null if not submitted
  /// @throws Exception if retrieval fails
  Future<Submission?> getStudentSubmission(String assignmentId, String studentId);
  
  /// Updates an existing submission.
  /// 
  /// Modifies submission content, status, or metadata.
  /// Typically used for resubmissions or status updates.
  /// 
  /// @param id Submission ID to update
  /// @param submission Updated submission information
  /// @throws Exception if update fails
  Future<void> updateSubmission(String id, Submission submission);
  
  /// Permanently deletes a submission.
  /// 
  /// Removes the submission record and associated files.
  /// This operation cannot be undone.
  /// 
  /// @param id Submission ID to delete
  /// @throws Exception if deletion fails
  Future<void> deleteSubmission(String id);
  
  // Specialized submission methods
  
  /// Creates a text-based submission.
  /// 
  /// Convenience method for submitting written responses,
  /// essays, or code. Automatically sets submission type
  /// and formats content appropriately.
  /// 
  /// @param assignmentId Target assignment
  /// @param studentId Submitting student
  /// @param studentName Student's display name
  /// @param textContent Written response content
  /// @return Created submission with generated ID
  /// @throws Exception if submission fails
  Future<Submission> submitTextContent({
    required String assignmentId,
    required String studentId,
    required String studentName,
    required String textContent,
  });
  
  /// Creates a file-based submission.
  /// 
  /// Convenience method for submitting documents, images,
  /// or other file attachments. Records file metadata
  /// and storage location.
  /// 
  /// @param assignmentId Target assignment
  /// @param studentId Submitting student
  /// @param studentName Student's display name
  /// @param fileUrl URL of uploaded file
  /// @param fileName Original file name
  /// @return Created submission with generated ID
  /// @throws Exception if submission fails
  Future<Submission> submitFile({
    required String assignmentId,
    required String studentId,
    required String studentName,
    required String fileUrl,
    required String fileName,
  });
  
  /// Updates the status of a submission.
  /// 
  /// Transitions submission through workflow states:
  /// submitted -> graded -> returned.
  /// May trigger notifications to students.
  /// 
  /// @param id Submission to update
  /// @param status New submission status
  /// @throws Exception if status update fails
  Future<void> updateSubmissionStatus(String id, SubmissionStatus status);
  
  // Query and streaming operations
  
  /// Streams all submissions for an assignment.
  /// 
  /// Returns real-time updates of student submissions,
  /// useful for grading dashboards and progress tracking.
  /// 
  /// @param assignmentId Assignment to monitor
  /// @return Stream of submission lists
  Stream<List<Submission>> getAssignmentSubmissions(String assignmentId);
  
  /// Streams all submissions by a specific student.
  /// 
  /// Returns comprehensive submission history across
  /// all assignments and classes.
  /// 
  /// @param studentId Student to monitor
  /// @return Stream of submission lists
  Stream<List<Submission>> getStudentSubmissions(String studentId);
  
  /// Streams submissions for a student in a specific class.
  /// 
  /// Filters submissions to show only those related to
  /// assignments in the specified class.
  /// 
  /// @param studentId Student to monitor
  /// @param classId Class context
  /// @return Stream of class-specific submissions
  Stream<List<Submission>> getStudentClassSubmissions(String studentId, String classId);
  
  /// Calculates submission statistics for an assignment.
  /// 
  /// Aggregates data to show:
  /// - Total expected submissions
  /// - Number submitted
  /// - Number graded
  /// - Submission rate percentage
  /// - Latest submission timestamp
  /// 
  /// @param assignmentId Assignment to analyze
  /// @return Statistical summary of submissions
  /// @throws Exception if calculation fails
  Future<SubmissionStatistics> getAssignmentSubmissionStatistics(String assignmentId);
  
  // Grading operations
  
  /// Marks a submission as graded.
  /// 
  /// Updates status to 'graded' and records grading
  /// timestamp. Should be called after grade entry.
  /// 
  /// @param id Submission to mark as graded
  /// @throws Exception if marking fails
  Future<void> markAsGraded(String id);
  
  /// Adds teacher feedback to a submission.
  /// 
  /// Records qualitative feedback along with grades.
  /// Updates submission timestamp to reflect changes.
  /// 
  /// @param id Submission to add feedback to
  /// @param feedback Teacher's comments and suggestions
  /// @throws Exception if feedback addition fails
  Future<void> addFeedback(String id, String feedback);
  
  // Batch operations
  
  /// Creates multiple submissions in one atomic operation.
  /// 
  /// Efficient bulk import for programmatic submission
  /// creation or migration. All creates succeed or fail together.
  /// 
  /// @param submissions List of submissions to create
  /// @throws Exception if batch creation fails
  Future<void> batchCreateSubmissions(List<Submission> submissions);
  
  /// Updates multiple submissions in one atomic operation.
  /// 
  /// Efficient bulk update for status changes or
  /// batch grading operations.
  /// 
  /// @param submissions Map of submission IDs to updated data
  /// @throws Exception if batch update fails
  Future<void> batchUpdateSubmissions(Map<String, Submission> submissions);
}

/// Statistical summary of assignment submissions.
/// 
/// This model aggregates submission data to provide
/// insights into assignment completion rates and
/// student engagement.
class SubmissionStatistics {
  /// Total number of expected submissions.
  final int total;
  
  /// Number of submissions received.
  final int submitted;
  
  /// Number of submissions graded.
  final int graded;
  
  /// Number of submissions pending grading.
  final int pending;
  
  /// Percentage of students who submitted (0.0-1.0).
  final double submissionRate;
  
  /// Timestamp of most recent submission.
  final DateTime? lastSubmissionAt;
  
  /// Creates a submission statistics summary.
  /// 
  /// All counts are required for accurate reporting.
  /// Submission rate should be pre-calculated as
  /// submitted/total.
  SubmissionStatistics({
    required this.total,
    required this.submitted,
    required this.graded,
    required this.pending,
    required this.submissionRate,
    this.lastSubmissionAt,
  });
}
````

## File: lib/features/assignments/presentation/providers/assignment_provider.dart
````dart
/// Assignment state management provider.
/// 
/// This module manages assignment and grade state for the education platform,
/// handling teacher assignment creation, student submissions, grading workflows,
/// and real-time updates through stream subscriptions.
library;

import 'dart:async';
import 'package:flutter/material.dart';
import '../../domain/models/assignment.dart';
import '../../../grades/domain/models/grade.dart';
import '../../domain/repositories/assignment_repository.dart';
import '../../../grades/domain/repositories/grade_repository.dart';
import '../../../../shared/core/service_locator.dart';

/// Provider managing assignment and grade state.
/// 
/// This provider serves as the central state manager for assignments,
/// coordinating between assignment and grade repositories. Key features:
/// - Real-time assignment updates for teachers and students
/// - Grade management and bulk grading operations
/// - Assignment status workflows (draft, active, completed, archived)
/// - Publishing/unpublishing controls
/// - Automatic grade initialization for published assignments
/// - Statistical analysis for grading insights
/// 
/// Maintains separate lists for teacher-created and class-specific
/// assignments with automatic stream management.
class AssignmentProvider with ChangeNotifier {
  /// Repository for assignment data operations.
  late final AssignmentRepository _assignmentRepository;
  
  /// Repository for grade data operations.
  late final GradeRepository _gradeRepository;
  
  // State variables
  
  /// Assignments for a specific class (student view).
  List<Assignment> _assignments = [];
  
  /// All assignments created by the teacher.
  List<Assignment> _teacherAssignments = [];
  
  /// Grades for the selected assignment.
  List<Grade> _grades = [];
  
  /// Loading state for async operations.
  bool _isLoading = false;
  
  /// Latest error message for UI display.
  String? _error;
  
  /// Selected assignment for detail view.
  Assignment? _selectedAssignment;
  
  // Stream subscriptions
  
  /// Subscription for class assignment updates.
  StreamSubscription<List<Assignment>>? _classAssignmentsSubscription;
  
  /// Subscription for teacher assignment updates.
  StreamSubscription<List<Assignment>>? _teacherAssignmentsSubscription;
  
  /// Subscription for grade updates.
  StreamSubscription<List<Grade>>? _gradesSubscription;
  
  /// Creates assignment provider with repository dependencies.
  /// 
  /// Retrieves repositories from dependency injection container.
  AssignmentProvider() {
    _assignmentRepository = getIt<AssignmentRepository>();
    _gradeRepository = getIt<GradeRepository>();
  }
  
  // Getters
  
  /// Class-specific assignments (student view).
  List<Assignment> get assignments => _assignments;
  
  /// All assignments created by teacher.
  List<Assignment> get teacherAssignments => _teacherAssignments;
  
  /// Grades for selected assignment.
  List<Grade> get grades => _grades;
  
  /// Whether an operation is in progress.
  bool get isLoading => _isLoading;
  
  /// Latest error message or null.
  String? get error => _error;
  
  /// Currently selected assignment or null.
  Assignment? get selectedAssignment => _selectedAssignment;
  
  /// Filters teacher's assignments by status.
  /// 
  /// Useful for categorized views (drafts, active, archived).
  /// 
  /// @param status Status to filter by
  /// @return List of assignments with matching status
  List<Assignment> getAssignmentsByStatus(AssignmentStatus status) {
    return _teacherAssignments.where((a) => a.status == status).toList();
  }
  
  /// Gets assignments due within the next 7 days.
  /// 
  /// Filters active assignments with upcoming due dates
  /// and sorts by soonest first for priority display.
  /// 
  /// @return List of upcoming assignments
  List<Assignment> get upcomingAssignments {
    final now = DateTime.now();
    final weekFromNow = now.add(const Duration(days: 7));
    return _assignments
        .where((a) => a.dueDate.isAfter(now) && a.dueDate.isBefore(weekFromNow))
        .toList()
      ..sort((a, b) => a.dueDate.compareTo(b.dueDate));
  }
  
  /// Gets assignments past their due date.
  /// 
  /// Filters incomplete assignments with past due dates
  /// and sorts by most recently overdue first.
  /// 
  /// @return List of overdue assignments
  List<Assignment> get overdueAssignments {
    final now = DateTime.now();
    return _assignments
        .where((a) => a.dueDate.isBefore(now) && a.status != AssignmentStatus.completed)
        .toList()
      ..sort((a, b) => b.dueDate.compareTo(a.dueDate));
  }
  
  /// Loads and subscribes to assignments for a class.
  /// 
  /// Sets up real-time stream for assignment updates.
  /// Used in student views to show class-specific assignments.
  /// Cancels any existing subscription before creating new one.
  /// 
  /// @param classId Class to load assignments from
  /// @throws Exception if loading fails
  Future<void> loadAssignmentsForClass(String classId) async {
    _setLoading(true);
    try {
      // Cancel existing subscription before creating new one
      _classAssignmentsSubscription?.cancel();
      
      // Store the subscription
      _classAssignmentsSubscription = _assignmentRepository.getClassAssignments(classId).listen(
        (assignmentList) {
          _assignments = assignmentList;
          _setLoading(false);
          notifyListeners();
        },
        onError: (error) {
          _setError(error.toString());
          _setLoading(false);
        },
      );
    } catch (e) {
      _setError(e.toString());
      _setLoading(false);
    }
  }
  
  /// Loads and subscribes to all teacher's assignments.
  /// 
  /// Sets up real-time stream for teacher's assignments
  /// across all classes. Used in teacher dashboard views.
  /// Cancels any existing subscription before creating new one.
  /// 
  /// @param teacherId Teacher's unique identifier
  /// @throws Exception if loading fails
  Future<void> loadAssignmentsForTeacher(String teacherId) async {
    _setLoading(true);
    try {
      // Cancel existing subscription before creating new one
      _teacherAssignmentsSubscription?.cancel();
      
      // Store the subscription
      _teacherAssignmentsSubscription = _assignmentRepository.getTeacherAssignments(teacherId).listen(
        (assignmentList) {
          _teacherAssignments = assignmentList;
          _setLoading(false);
          notifyListeners();
        },
        onError: (error) {
          _setError(error.toString());
          _setLoading(false);
        },
      );
    } catch (e) {
      _setError(e.toString());
      _setLoading(false);
    }
  }
  
  /// Loads and subscribes to grades for an assignment.
  /// 
  /// Sets up real-time stream for grade updates.
  /// Used in grading views to show all student grades.
  /// Cancels any existing subscription before creating new one.
  /// 
  /// @param assignmentId Assignment to load grades for
  /// @throws Exception if loading fails
  Future<void> loadGradesForAssignment(String assignmentId) async {
    _setLoading(true);
    try {
      // Cancel existing subscription before creating new one
      _gradesSubscription?.cancel();
      
      // Store the subscription
      _gradesSubscription = _gradeRepository.getAssignmentGrades(assignmentId).listen(
        (gradeList) {
          _grades = gradeList;
          _setLoading(false);
          notifyListeners();
        },
        onError: (error) {
          _setError(error.toString());
          _setLoading(false);
        },
      );
    } catch (e) {
      _setError(e.toString());
      _setLoading(false);
    }
  }
  
  /// Creates a new assignment in the system.
  /// 
  /// Process:
  /// 1. Creates assignment in Firestore
  /// 2. If published, initializes grade records for all students
  /// 3. Updates local state through stream subscription
  /// 
  /// @param assignment Assignment data to create
  /// @return true if creation successful
  Future<bool> createAssignment(Assignment assignment) async {
    _setLoading(true);
    try {
      final assignmentId = await _assignmentRepository.createAssignment(assignment);
      
      // Initialize grades for all students if published
      if (assignment.isPublished) {
        await _gradeRepository.initializeGradesForAssignment(
          assignmentId,
          assignment.classId,
          assignment.teacherId,
          assignment.totalPoints,
        );
      }
      
      _setLoading(false);
      return true;
    } catch (e) {
      _setError(e.toString());
      _setLoading(false);
      return false;
    }
  }
  
  /// Updates existing assignment information.
  /// 
  /// Modifies assignment in Firestore and updates local cache
  /// for immediate UI response. Does not affect existing grades.
  /// 
  /// @param assignment Updated assignment data with ID
  /// @return true if update successful
  Future<bool> updateAssignment(Assignment assignment) async {
    _setLoading(true);
    try {
      await _assignmentRepository.updateAssignment(assignment.id, assignment);
      
      // Update local list
      final index = _teacherAssignments.indexWhere((a) => a.id == assignment.id);
      if (index != -1) {
        _teacherAssignments[index] = assignment;
        notifyListeners();
      }
      
      _setLoading(false);
      return true;
    } catch (e) {
      _setError(e.toString());
      _setLoading(false);
      return false;
    }
  }
  
  /// Permanently deletes an assignment.
  /// 
  /// Removes assignment from Firestore and local cache.
  /// This operation cannot be undone. Consider archiving instead.
  /// 
  /// @param assignmentId Assignment to delete
  /// @return true if deletion successful
  Future<bool> deleteAssignment(String assignmentId) async {
    _setLoading(true);
    try {
      await _assignmentRepository.deleteAssignment(assignmentId);
      
      // Remove from local list
      _teacherAssignments.removeWhere((a) => a.id == assignmentId);
      notifyListeners();
      
      _setLoading(false);
      return true;
    } catch (e) {
      _setError(e.toString());
      _setLoading(false);
      return false;
    }
  }
  
  /// Toggles assignment publication status.
  /// 
  /// Publishing:
  /// - Makes assignment visible to students
  /// - Initializes grade records for all enrolled students
  /// - Allows submission acceptance
  /// 
  /// Unpublishing:
  /// - Hides assignment from students
  /// - Reverts to draft status
  /// - Preserves existing grades
  /// 
  /// @param assignmentId Assignment to toggle
  /// @param publish true to publish, false to unpublish
  /// @return true if toggle successful
  Future<bool> togglePublishStatus(String assignmentId, bool publish) async {
    _setLoading(true);
    try {
      if (publish) {
        final assignment = await _assignmentRepository.getAssignment(assignmentId);
        if (assignment != null) {
          await _assignmentRepository.publishAssignment(assignmentId);
          
          // Initialize grades for all students
          await _gradeRepository.initializeGradesForAssignment(
            assignmentId,
            assignment.classId,
            assignment.teacherId,
            assignment.totalPoints,
          );
        }
      } else {
        await _assignmentRepository.unpublishAssignment(assignmentId);
      }
      
      // Update local list
      final index = _teacherAssignments.indexWhere((a) => a.id == assignmentId);
      if (index != -1) {
        _teacherAssignments[index] = _teacherAssignments[index].copyWith(
          isPublished: publish,
          updatedAt: DateTime.now(),
        );
        notifyListeners();
      }
      
      _setLoading(false);
      return true;
    } catch (e) {
      _setError(e.toString());
      _setLoading(false);
      return false;
    }
  }
  
  /// Updates a single grade entry.
  /// 
  /// Modifies grade in Firestore and updates local cache
  /// for immediate UI response. Recalculates percentage
  /// and letter grade automatically.
  /// 
  /// @param grade Updated grade data with ID
  /// @return true if update successful
  Future<bool> updateGrade(Grade grade) async {
    _setLoading(true);
    try {
      await _gradeRepository.updateGrade(grade.id, grade);
      
      // Update local list
      final index = _grades.indexWhere((g) => g.id == grade.id);
      if (index != -1) {
        _grades[index] = grade;
        notifyListeners();
      }
      
      _setLoading(false);
      return true;
    } catch (e) {
      _setError(e.toString());
      _setLoading(false);
      return false;
    }
  }
  
  /// Updates multiple grades in one atomic operation.
  /// 
  /// Efficient batch update for grading multiple submissions.
  /// All updates succeed or fail together. Updates local cache
  /// after successful batch operation.
  /// 
  /// @param grades Map of grade IDs to updated grade objects
  /// @return true if batch update successful
  Future<bool> bulkUpdateGrades(Map<String, Grade> grades) async {
    _setLoading(true);
    try {
      await _gradeRepository.batchUpdateGrades(grades);
      
      // Update local list
      grades.forEach((gradeId, grade) {
        final index = _grades.indexWhere((g) => g.id == gradeId);
        if (index != -1) {
          _grades[index] = grade;
        }
      });
      notifyListeners();
      
      _setLoading(false);
      return true;
    } catch (e) {
      _setError(e.toString());
      _setLoading(false);
      return false;
    }
  }
  
  /// Retrieves statistical analysis for an assignment.
  /// 
  /// Calculates aggregate statistics including:
  /// - Average, median, and mode scores
  /// - Grade distribution
  /// - Completion rates
  /// - Performance metrics
  /// 
  /// @param assignmentId Assignment to analyze
  /// @return Grade statistics or null if error
  Future<GradeStatistics?> getAssignmentStatistics(String assignmentId) async {
    try {
      return await _gradeRepository.getAssignmentStatistics(assignmentId);
    } catch (e) {
      _setError(e.toString());
      return null;
    }
  }
  
  /// Gets a single assignment by ID.
  /// 
  /// Retrieves assignment from repository or cache.
  /// 
  /// @param assignmentId Assignment to retrieve
  /// @return Assignment object or null if not found
  Future<Assignment?> getAssignmentById(String assignmentId) async {
    try {
      // First check if it's in local cache
      final cachedAssignment = _teacherAssignments.firstWhere(
        (a) => a.id == assignmentId,
        orElse: () => Assignment(
          id: '',
          title: '',
          description: '',
          instructions: '',
          type: AssignmentType.other,
          status: AssignmentStatus.draft,
          category: '',
          classId: '',
          teacherId: '',
          teacherName: '',
          totalPoints: 0,
          maxPoints: 0,
          dueDate: DateTime.now(),
          isPublished: false,
          allowLateSubmissions: false,
          latePenaltyPercentage: 0,
          createdAt: DateTime.now(),
          updatedAt: DateTime.now(),
        ),
      );
      
      if (cachedAssignment.id.isNotEmpty) {
        return cachedAssignment;
      }
      
      // Otherwise fetch from repository
      return await _assignmentRepository.getAssignment(assignmentId);
    } catch (e) {
      _setError(e.toString());
      return null;
    }
  }
  
  /// Updates assignment status (active, completed, archived).
  /// 
  /// Changes assignment workflow status and updates local cache.
  /// 
  /// @param assignmentId Assignment to update
  /// @param status New status to apply
  /// @return true if update successful
  Future<bool> updateAssignmentStatus(String assignmentId, AssignmentStatus status) async {
    _setLoading(true);
    try {
      // Get the current assignment
      final assignment = await _assignmentRepository.getAssignment(assignmentId);
      if (assignment == null) {
        throw Exception('Assignment not found');
      }
      
      // Update status
      final updatedAssignment = assignment.copyWith(
        status: status,
        updatedAt: DateTime.now(),
      );
      
      await _assignmentRepository.updateAssignment(assignmentId, updatedAssignment);
      
      // Update local list
      final index = _teacherAssignments.indexWhere((a) => a.id == assignmentId);
      if (index != -1) {
        _teacherAssignments[index] = updatedAssignment;
        notifyListeners();
      }
      
      _setLoading(false);
      return true;
    } catch (e) {
      _setError(e.toString());
      _setLoading(false);
      return false;
    }
  }

  /// Archives an assignment to hide from active lists.
  /// 
  /// Archived assignments:
  /// - No longer accept submissions
  /// - Hidden from student views
  /// - Preserved for historical records
  /// - Can be restored later
  /// 
  /// @param assignmentId Assignment to archive
  /// @return true if archiving successful
  Future<bool> archiveAssignment(String assignmentId) async {
    _setLoading(true);
    try {
      await _assignmentRepository.archiveAssignment(assignmentId);
      
      // Update local list
      final index = _teacherAssignments.indexWhere((a) => a.id == assignmentId);
      if (index != -1) {
        _teacherAssignments[index] = _teacherAssignments[index].copyWith(
          status: AssignmentStatus.archived,
          updatedAt: DateTime.now(),
        );
        notifyListeners();
      }
      
      _setLoading(false);
      return true;
    } catch (e) {
      _setError(e.toString());
      _setLoading(false);
      return false;
    }
  }
  
  /// Restores an archived assignment to draft status.
  /// 
  /// Allows reactivation of archived assignments for:
  /// - Reuse in new terms
  /// - Template creation
  /// - Error correction
  /// 
  /// Restored assignments must be republished to
  /// become visible to students again.
  /// 
  /// @param assignmentId Assignment to restore
  /// @return true if restoration successful
  Future<bool> restoreAssignment(String assignmentId) async {
    _setLoading(true);
    try {
      await _assignmentRepository.restoreAssignment(assignmentId);
      
      // Update local list
      final index = _teacherAssignments.indexWhere((a) => a.id == assignmentId);
      if (index != -1) {
        _teacherAssignments[index] = _teacherAssignments[index].copyWith(
          status: AssignmentStatus.draft,
          updatedAt: DateTime.now(),
        );
        notifyListeners();
      }
      
      _setLoading(false);
      return true;
    } catch (e) {
      _setError(e.toString());
      _setLoading(false);
      return false;
    }
  }
  
  /// Sets the currently selected assignment.
  /// 
  /// Used for detail views and context-aware operations.
  /// 
  /// @param assignment Assignment to select or null to clear
  void setSelectedAssignment(Assignment? assignment) {
    _selectedAssignment = assignment;
    notifyListeners();
  }
  
  // Helper methods
  
  /// Sets loading state and notifies listeners.
  /// 
  /// @param loading New loading state
  void _setLoading(bool loading) {
    _isLoading = loading;
    notifyListeners();
  }
  
  /// Sets error message and notifies listeners.
  /// 
  /// @param error Error description or null
  void _setError(String? error) {
    _error = error;
    notifyListeners();
  }
  
  /// Clears error message and notifies UI.
  /// 
  /// Called after user acknowledges error.
  void clearError() {
    _error = null;
    notifyListeners();
  }
  
  /// Clears all cached data.
  /// 
  /// Resets provider to initial state.
  /// Useful for user logout or role switch.
  void clearData() {
    _assignments = [];
    _teacherAssignments = [];
    _grades = [];
    _selectedAssignment = null;
    _isLoading = false;
    _error = null;
    notifyListeners();
  }
  
  /// Cleans up resources when provider is disposed.
  /// 
  /// Cancels all stream subscriptions and disposes
  /// repositories to prevent memory leaks.
  @override
  void dispose() {
    // Cancel all stream subscriptions
    _classAssignmentsSubscription?.cancel();
    _teacherAssignmentsSubscription?.cancel();
    _gradesSubscription?.cancel();
    
    // Dispose repositories
    _assignmentRepository.dispose();
    _gradeRepository.dispose();
    
    super.dispose();
  }
}
````

## File: lib/features/assignments/presentation/providers/student_assignment_provider.dart
````dart
/// Student assignment state management provider.
/// 
/// This module manages the student's view of assignments, combining
/// assignment details with submission status and grades into a unified
/// interface for student dashboards and assignment tracking.
library;

import 'package:flutter/foundation.dart';
import 'dart:async';
import 'package:file_picker/file_picker.dart';
import 'package:firebase_storage/firebase_storage.dart';
import '../../../../main.dart';
import '../../domain/models/assignment.dart';
import '../../domain/models/submission.dart';
import '../../../grades/domain/models/grade.dart';
import '../../domain/repositories/assignment_repository.dart';
import '../../domain/repositories/submission_repository.dart';
import '../../../grades/domain/repositories/grade_repository.dart';
import '../../../student/domain/repositories/student_repository.dart';
import '../../../../shared/core/service_locator.dart';

/// Combined model for student assignment view.
/// 
/// Aggregates assignment details, submission status, and grade
/// information into a single model for efficient UI rendering.
/// Provides computed properties for common status checks.
class StudentAssignment {
  /// The assignment details.
  final Assignment assignment;
  
  /// The student's submission, if any.
  final Submission? submission;
  
  /// The grade for this assignment, if available.
  final Grade? grade;
  
  /// Creates a student assignment view model.
  StudentAssignment({
    required this.assignment,
    this.submission,
    this.grade,
  });
  
  // Helper getters
  
  /// Whether the assignment has been submitted.
  bool get isSubmitted => submission != null;
  
  /// Whether the assignment has been graded.
  bool get isGraded => grade != null && grade!.status == GradeStatus.graded;
  
  /// Whether the assignment is past due and unsubmitted.
  bool get isOverdue => assignment.dueDate.isBefore(DateTime.now()) && !isSubmitted;
  
  /// Whether the assignment is due within 24 hours.
  bool get isDueSoon => assignment.dueDate.difference(DateTime.now()).inHours < 24 && !isSubmitted;
  
  /// Computed status string for UI display.
  /// 
  /// Priority order: Graded > Submitted > Overdue > Draft > Pending
  String get status {
    if (isGraded) return 'Graded';
    if (isSubmitted) return 'Submitted';
    if (isOverdue) return 'Overdue';
    if (assignment.status == AssignmentStatus.draft) return 'Draft';
    return 'Pending';
  }
  
  /// Points earned for this assignment.
  double? get earnedPoints => grade?.pointsEarned;
  
  /// Percentage score for this assignment.
  double? get percentage => grade?.percentage;
  
  /// Letter grade representation.
  String? get letterGrade => grade?.letterGrade ?? 
    (grade != null ? Grade.calculateLetterGrade(grade!.percentage) : null);
  
  /// Teacher's feedback on the submission.
  String? get feedback => grade?.feedback;
}

/// Provider managing student's assignment view and operations.
/// 
/// This provider coordinates between multiple repositories to present
/// a unified view of assignments, submissions, and grades. Key features:
/// - Real-time updates combining assignment, submission, and grade data
/// - Status tracking (pending, submitted, graded, overdue)
/// - Assignment filtering and categorization
/// - Submission handling and tracking
/// - Performance statistics calculation
/// - Multi-class assignment aggregation
/// 
/// Uses stream combination to maintain synchronized state across
/// assignment lifecycle stages.
class StudentAssignmentProvider with ChangeNotifier {
  /// Repository for assignment data.
  late final AssignmentRepository _assignmentRepository;
  
  /// Repository for submission operations.
  late final SubmissionRepository _submissionRepository;
  
  /// Repository for grade data.
  late final GradeRepository _gradeRepository;
  
  /// Repository for student information.
  late final StudentRepository _studentRepository;
  
  /// Creates provider with repository dependencies.
  /// 
  /// Retrieves repositories from dependency injection container.
  StudentAssignmentProvider() {
    _assignmentRepository = getIt<AssignmentRepository>();
    _submissionRepository = getIt<SubmissionRepository>();
    _gradeRepository = getIt<GradeRepository>();
    _studentRepository = getIt<StudentRepository>();
  }
  
  /// All assignments for the current student.
  List<StudentAssignment> _assignments = [];
  
  /// Loading state for async operations.
  bool _isLoading = false;
  
  /// Latest error message.
  String _error = '';
  
  /// Current student identifier.
  String? _currentStudentId;
  
  
  // Stream subscriptions
  
  /// Subscription for combined assignment data.
  StreamSubscription<List<StudentAssignment>>? _assignmentsSubscription;
  
  /// Stream controller for broadcasting combined data.
  final StreamController<List<StudentAssignment>> _studentAssignmentsController = 
      StreamController<List<StudentAssignment>>.broadcast();
  
  
  // Getters
  
  /// List of all student assignments.
  List<StudentAssignment> get assignments => _assignments;
  
  /// Whether data is currently loading.
  bool get isLoading => _isLoading;
  
  /// Latest error message or empty string.
  String get error => _error;
  
  /// Stream of assignment updates.
  Stream<List<StudentAssignment>> get assignmentsStream {
    // Create a new stream that emits current data immediately
    return Stream<List<StudentAssignment>>.multi((controller) {
      // Emit current assignments immediately
      controller.add(_assignments);
      
      // Then listen to future updates
      final subscription = _studentAssignmentsController.stream.listen(
        controller.add,
        onError: controller.addError,
        onDone: controller.close,
      );
      
      // Clean up subscription when done
      controller.onCancel = () {
        subscription.cancel();
      };
    });
  }
  
  // Filtered lists
  
  /// Assignments awaiting submission (not overdue).
  List<StudentAssignment> get pendingAssignments => 
    _assignments.where((a) => !a.isSubmitted && !a.isOverdue).toList();
  
  /// Assignments past due date without submission.
  List<StudentAssignment> get overdueAssignments =>
    _assignments.where((a) => a.isOverdue).toList();
    
  /// Submitted assignments awaiting grading.
  List<StudentAssignment> get submittedAssignments =>
    _assignments.where((a) => a.isSubmitted && !a.isGraded).toList();
    
  /// Assignments with grades available.
  List<StudentAssignment> get gradedAssignments =>
    _assignments.where((a) => a.isGraded).toList();

  /// Initializes the provider for a specific student.
  /// 
  /// Sets up real-time streams for assignments across all enrolled
  /// classes or a specific class if provided.
  /// 
  /// @param studentId Student's user identifier
  /// @param classId Optional class filter
  Future<void> initializeForStudent(String studentId, {String? classId}) async {
    _currentStudentId = studentId;
    
    // If Firebase is not initialized, emit empty data immediately
    if (!isFirebaseInitialized) {
      _assignments = [];
      _isLoading = false;
      notifyListeners();
      _studentAssignmentsController.add([]);
      return;
    }
    
    await setupAssignmentsStream();
  }

  /// Sets up real-time stream combining assignments, submissions, and grades.
  /// 
  /// Creates a unified stream that:
  /// - Monitors assignments from enrolled classes
  /// - Tracks submission status for each assignment
  /// - Updates grade information as available
  /// - Filters to show only published, active assignments
  /// 
  /// @throws Exception if student has no enrolled classes
  Future<void> setupAssignmentsStream() async {
    if (_currentStudentId == null) return;
    
    _isLoading = true;
    _error = '';
    notifyListeners();

    try {
      // Cancel existing subscription if any
      await _assignmentsSubscription?.cancel();

      // Get student document to get enrolled classes
      debugPrint('[StudentAssignmentProvider] Getting student document for userId: $_currentStudentId');
      final student = await _studentRepository.getStudentByUserId(_currentStudentId!);
      debugPrint('[StudentAssignmentProvider] Student found: ${student != null}');
      
      List<String> classIds = [];
      if (student != null) {
        debugPrint('[StudentAssignmentProvider] Student ID: ${student.id}');
        debugPrint('[StudentAssignmentProvider] Student name: ${student.displayName}');
        classIds = student.classIds;
        debugPrint('[StudentAssignmentProvider] Student classIds: $classIds');
      } else {
        debugPrint('[StudentAssignmentProvider] No student document found for userId: $_currentStudentId');
        // Student document doesn't exist yet, emit empty list
        _assignments = [];
        _isLoading = false;
        notifyListeners();
        _studentAssignmentsController.add([]);
        return;
      }

      if (classIds.isEmpty) {
        _assignments = [];
        _isLoading = false;
        notifyListeners();
        // Emit empty list to stream so UI updates
        _studentAssignmentsController.add([]);
        return;
      }

      // Create combined stream
      _assignmentsSubscription = _createCombinedStream(classIds).listen(
        (studentAssignments) {
          _assignments = studentAssignments;
          _isLoading = false;
          _error = '';
          notifyListeners();
          _studentAssignmentsController.add(studentAssignments);
        },
        onError: (error) {
          _error = 'Error loading assignments: $error';
          _isLoading = false;
          notifyListeners();
          // Also emit error to the stream controller
          _studentAssignmentsController.addError(error);
        },
      );
    } catch (e) {
      _error = 'Error setting up assignments stream: $e';
      _isLoading = false;
      notifyListeners();
    }
  }

  /// Creates a combined stream merging assignment, submission, and grade data.
  /// 
  /// Implements manual stream combination to synchronize data from
  /// three separate sources. Updates emit whenever any source changes.
  /// 
  /// @param classIds List of class identifiers to monitor
  /// @return Stream of combined student assignment data
  Stream<List<StudentAssignment>> _createCombinedStream(List<String> classIds) {
    // Using a StreamController to manually combine streams
    final controller = StreamController<List<StudentAssignment>>();
    
    // Store latest data from each stream
    List<Assignment>? latestAssignments;
    Map<String, Submission>? latestSubmissions = {};
    Map<String, Grade>? latestGrades = {};
    
    // Helper function to combine and emit data
    void combineAndEmit() {
      if (latestAssignments != null) {
        final studentAssignments = latestAssignments!.map((assignment) {
          return StudentAssignment(
            assignment: assignment,
            submission: latestSubmissions?[assignment.id],
            grade: latestGrades?[assignment.id],
          );
        }).toList();

        // Sort by due date
        studentAssignments.sort((a, b) => a.assignment.dueDate.compareTo(b.assignment.dueDate));
        
        controller.add(studentAssignments);
      }
    }

    // Subscribe to assignments stream
    final assignmentsSubscription = _assignmentRepository
        .getClassAssignmentsForMultipleClasses(classIds)
        .listen(
          (assignments) {
            final now = DateTime.now();
            latestAssignments = assignments
                .where((assignment) {
                  // Only show published assignments that are active or completed
                  return assignment.isPublished &&
                      (assignment.status == AssignmentStatus.active ||
                       assignment.status == AssignmentStatus.completed) &&
                      (assignment.publishAt == null || assignment.publishAt!.isBefore(now));
                })
                .toList();
            combineAndEmit();
          },
          onError: (error) {
            // Forward error to the controller
            controller.addError(error);
          },
        );

    // Subscribe to submissions stream
    final submissionsSubscription = _submissionRepository
        .getStudentSubmissions(_currentStudentId!)
        .listen(
          (submissions) {
            final submissionMap = <String, Submission>{};
            for (final submission in submissions) {
              submissionMap[submission.assignmentId] = submission;
            }
            latestSubmissions = submissionMap;
            combineAndEmit();
          },
          onError: (error) {
            // Forward error to the controller
            controller.addError(error);
          },
        );

    // Subscribe to grades stream
    final gradesSubscription = _gradeRepository
        .getStudentGrades(_currentStudentId!)
        .listen(
          (grades) {
            final gradeMap = <String, Grade>{};
            for (final grade in grades) {
              gradeMap[grade.assignmentId] = grade;
            }
            latestGrades = gradeMap;
            combineAndEmit();
          },
          onError: (error) {
            // Forward error to the controller
            controller.addError(error);
          },
        );

    // Clean up subscriptions when the controller is closed
    controller.onCancel = () {
      assignmentsSubscription.cancel();
      submissionsSubscription.cancel();
      gradesSubscription.cancel();
    };

    return controller.stream;
  }

  /// Submits an assignment for grading.
  /// 
  /// Creates a submission record and updates local state immediately.
  /// Supports both text content and file uploads. Files are uploaded
  /// to Firebase Storage before creating the submission record.
  /// 
  /// @param assignmentId Assignment to submit
  /// @param studentName Student's display name
  /// @param textContent Text-based submission content
  /// @param file Optional file attachment
  /// @return true if submission successful
  Future<bool> submitAssignment({
    required String assignmentId,
    required String studentName,
    String? textContent,
    PlatformFile? file,
  }) async {
    if (_currentStudentId == null) return false;

    try {
      Submission submission;
      
      // If file is provided, upload it first
      if (file != null && file.bytes != null) {
        // Upload file to Firebase Storage
        final storageRef = FirebaseStorage.instance.ref();
        final fileName = '${DateTime.now().millisecondsSinceEpoch}_${file.name}';
        final fileRef = storageRef.child('submissions/$assignmentId/$_currentStudentId/$fileName');
        
        // Upload the file
        final uploadTask = await fileRef.putData(file.bytes!);
        final fileUrl = await uploadTask.ref.getDownloadURL();
        
        // Submit with file
        submission = await _submissionRepository.submitFile(
          assignmentId: assignmentId,
          studentId: _currentStudentId!,
          studentName: studentName,
          fileUrl: fileUrl,
          fileName: file.name,
        );
      } else {
        // Submit with text content only
        submission = await _submissionRepository.submitTextContent(
          assignmentId: assignmentId,
          studentId: _currentStudentId!,
          studentName: studentName,
          textContent: textContent ?? '',
        );
      }

      // Update local state
      final index = _assignments.indexWhere((a) => a.assignment.id == assignmentId);
      if (index != -1) {
        _assignments[index] = StudentAssignment(
          assignment: _assignments[index].assignment,
          submission: submission,
          grade: _assignments[index].grade,
        );
        notifyListeners();
      }

      return true;
    } catch (e) {
      _error = 'Error submitting assignment: $e';
      notifyListeners();
      return false;
    }
  }

  /// Loads assignment details if not already loaded.
  /// 
  /// Ensures assignment data is available for submission screen.
  /// This is useful when navigating directly to submission screen.
  /// 
  /// @param assignmentId Assignment to load
  Future<void> loadAssignmentDetails(String assignmentId) async {
    // Check if assignment is already loaded
    final existing = getAssignmentById(assignmentId);
    if (existing != null) return;
    
    // If not loaded, trigger a refresh
    await refresh();
  }

  /// Retrieves a specific assignment by ID.
  /// 
  /// @param assignmentId Assignment identifier
  /// @return Student assignment or null if not found
  StudentAssignment? getAssignmentById(String assignmentId) {
    try {
      return _assignments.firstWhere((a) => a.assignment.id == assignmentId);
    } catch (e) {
      return null;
    }
  }

  /// Filters assignments by type.
  /// 
  /// @param type Assignment type to filter by
  /// @return List of assignments matching the type
  List<StudentAssignment> getAssignmentsByType(AssignmentType type) {
    return _assignments.where((a) => a.assignment.type == type).toList();
  }

  /// Filters assignments by category.
  /// 
  /// @param category Category name to filter by
  /// @return List of assignments in the category
  List<StudentAssignment> getAssignmentsByCategory(String category) {
    return _assignments.where((a) => a.assignment.category == category).toList();
  }

  /// Gets assignments due within specified days.
  /// 
  /// Filters unsubmitted assignments with due dates in the
  /// near future for deadline awareness.
  /// 
  /// @param days Number of days to look ahead (default: 7)
  /// @return List of upcoming unsubmitted assignments
  List<StudentAssignment> getUpcomingAssignments({int days = 7}) {
    final now = DateTime.now();
    final future = now.add(Duration(days: days));
    
    return _assignments.where((a) {
      return !a.isSubmitted && 
             a.assignment.dueDate.isAfter(now) && 
             a.assignment.dueDate.isBefore(future);
    }).toList();
  }

  /// Calculates comprehensive assignment statistics.
  /// 
  /// Computes metrics including:
  /// - Submission and completion rates
  /// - Grade averages and distribution
  /// - Overdue assignment counts
  /// - Overall performance indicators
  /// 
  /// @return Map of statistical metrics
  Map<String, dynamic> getStatistics() {
    final total = _assignments.length;
    final submitted = _assignments.where((a) => a.isSubmitted).length;
    final graded = _assignments.where((a) => a.isGraded).length;
    final overdue = _assignments.where((a) => a.isOverdue).length;
    
    // Calculate average grade
    final gradedAssignments = _assignments.where((a) => a.isGraded).toList();
    double averageGrade = 0;
    if (gradedAssignments.isNotEmpty) {
      final totalPercentage = gradedAssignments.fold<double>(
        0,
        (total, a) => total + (a.grade?.percentage ?? 0),
      );
      averageGrade = totalPercentage / gradedAssignments.length;
    }
    
    return {
      'total': total,
      'submitted': submitted,
      'graded': graded,
      'overdue': overdue,
      'pending': total - submitted - overdue,
      'submissionRate': total > 0 ? (submitted / total * 100) : 0,
      'averageGrade': averageGrade,
      'letterGrade': averageGrade > 0 ? Grade.calculateLetterGrade(averageGrade) : 'N/A',
    };
  }

  /// Refreshes all assignment data.
  /// 
  /// Resets and re-establishes data streams for fresh data.
  Future<void> refresh() async {
    await setupAssignmentsStream();
  }

  /// Searches assignments by title, description, or category.
  /// 
  /// Case-insensitive search across multiple fields.
  /// 
  /// @param query Search terms
  /// @return List of matching assignments
  List<StudentAssignment> searchAssignments(String query) {
    if (query.isEmpty) return _assignments;
    
    final lowercaseQuery = query.toLowerCase();
    return _assignments.where((a) {
      return a.assignment.title.toLowerCase().contains(lowercaseQuery) ||
             a.assignment.description.toLowerCase().contains(lowercaseQuery) ||
             a.assignment.category.toLowerCase().contains(lowercaseQuery);
    }).toList();
  }

  /// Sorts assignments by specified criteria.
  /// 
  /// Supports sorting by:
  /// - dueDate: Chronological order
  /// - title: Alphabetical order
  /// - points: Highest value first
  /// - status: Status priority order
  /// 
  /// @param sortBy Sort criterion
  void sortAssignments(String sortBy) {
    switch (sortBy) {
      case 'dueDate':
        _assignments.sort((a, b) => a.assignment.dueDate.compareTo(b.assignment.dueDate));
        break;
      case 'title':
        _assignments.sort((a, b) => a.assignment.title.compareTo(b.assignment.title));
        break;
      case 'points':
        _assignments.sort((a, b) => b.assignment.totalPoints.compareTo(a.assignment.totalPoints));
        break;
      case 'status':
        _assignments.sort((a, b) => a.status.compareTo(b.status));
        break;
    }
    notifyListeners();
  }

  /// Cleans up resources when provider is disposed.
  /// 
  /// Cancels stream subscriptions, closes controllers,
  /// and disposes repositories to prevent memory leaks.
  @override
  void dispose() {
    _assignmentsSubscription?.cancel();
    _studentAssignmentsController.close();
    _assignments.clear();
    
    // Dispose repositories
    _assignmentRepository.dispose();
    _submissionRepository.dispose();
    _gradeRepository.dispose();
    _studentRepository.dispose();
    
    super.dispose();
  }
}
````

## File: lib/features/assignments/presentation/screens/teacher/assignment_detail_screen.dart
````dart
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'package:go_router/go_router.dart';
import '../../../domain/models/assignment.dart';
import '../../providers/assignment_provider.dart';
import '../../../../../shared/widgets/common/adaptive_layout.dart';
import '../../../../../shared/widgets/common/responsive_layout.dart';

class AssignmentDetailScreen extends StatefulWidget {
  final String assignmentId;

  const AssignmentDetailScreen({
    super.key,
    required this.assignmentId,
  });

  @override
  State<AssignmentDetailScreen> createState() => _AssignmentDetailScreenState();
}

class _AssignmentDetailScreenState extends State<AssignmentDetailScreen> {
  Assignment? _assignment;
  bool _isLoading = true;

  @override
  void initState() {
    super.initState();
    _loadAssignment();
  }

  Future<void> _loadAssignment() async {
    final assignmentProvider = context.read<AssignmentProvider>();
    
    try {
      final assignment = await assignmentProvider.getAssignmentById(widget.assignmentId);
      if (mounted) {
        setState(() {
          _assignment = assignment;
          _isLoading = false;
        });
      }
    } catch (e) {
      if (mounted) {
        setState(() => _isLoading = false);
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('Error loading assignment: $e'),
            backgroundColor: Colors.red,
          ),
        );
      }
    }
  }

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);

    if (_isLoading) {
      return const Scaffold(
        body: Center(child: CircularProgressIndicator()),
      );
    }

    if (_assignment == null) {
      return Scaffold(
        appBar: AppBar(title: const Text('Assignment Not Found')),
        body: const Center(
          child: Text('Assignment not found or you don\'t have access to it.'),
        ),
      );
    }

    return AdaptiveLayout(
      title: _assignment!.title,
      actions: [
        IconButton(
          icon: const Icon(Icons.edit),
          onPressed: () {
            context.push('/teacher/assignments/${widget.assignmentId}/edit');
          },
          tooltip: 'Edit Assignment',
        ),
        PopupMenuButton<String>(
          onSelected: (value) async {
            switch (value) {
              case 'duplicate':
                _duplicateAssignment();
                break;
              case 'archive':
                _archiveAssignment();
                break;
              case 'delete':
                _deleteAssignment();
                break;
            }
          },
          itemBuilder: (context) => [
            const PopupMenuItem(
              value: 'duplicate',
              child: ListTile(
                leading: Icon(Icons.copy),
                title: Text('Duplicate'),
                contentPadding: EdgeInsets.zero,
              ),
            ),
            const PopupMenuItem(
              value: 'archive',
              child: ListTile(
                leading: Icon(Icons.archive),
                title: Text('Archive'),
                contentPadding: EdgeInsets.zero,
              ),
            ),
            const PopupMenuDivider(),
            const PopupMenuItem(
              value: 'delete',
              child: ListTile(
                leading: Icon(Icons.delete, color: Colors.red),
                title: Text('Delete', style: TextStyle(color: Colors.red)),
                contentPadding: EdgeInsets.zero,
              ),
            ),
          ],
        ),
      ],
      body: ResponsiveContainer(
        child: SingleChildScrollView(
          padding: const EdgeInsets.all(16),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              // Status and Publishing Info
              _buildStatusCard(theme),
              const SizedBox(height: 16),

              // Assignment Details Card
              _buildDetailsCard(theme),
              const SizedBox(height: 16),

              // Instructions Card
              _buildInstructionsCard(theme),
              const SizedBox(height: 16),

              // Submission Settings Card
              _buildSubmissionSettingsCard(theme),
              const SizedBox(height: 16),

              // Submission Statistics Card
              _buildStatisticsCard(theme),
              const SizedBox(height: 16),

              // Action Buttons
              _buildActionButtons(theme),
            ],
          ),
        ),
      ),
    );
  }

  Widget _buildStatusCard(ThemeData theme) {
    Color statusColor;
    IconData statusIcon;
    String statusText;

    if (!_assignment!.isPublished) {
      if (_assignment!.publishAt != null) {
        statusColor = Colors.blue;
        statusIcon = Icons.schedule;
        statusText = 'Scheduled to publish on ${_formatDate(_assignment!.publishAt ?? DateTime.now())}';
      } else {
        statusColor = Colors.orange;
        statusIcon = Icons.visibility_off;
        statusText = 'Unpublished Draft';
      }
    } else {
      switch (_assignment!.status) {
        case AssignmentStatus.active:
          statusColor = Colors.green;
          statusIcon = Icons.play_circle_outline;
          statusText = 'Published and Active';
          break;
        case AssignmentStatus.completed:
          statusColor = Colors.grey;
          statusIcon = Icons.check_circle_outline;
          statusText = 'Completed';
          break;
        case AssignmentStatus.archived:
          statusColor = Colors.grey;
          statusIcon = Icons.archive_outlined;
          statusText = 'Archived';
          break;
        default:
          statusColor = Colors.grey;
          statusIcon = Icons.info_outline;
          statusText = _assignment!.status.name;
      }
    }

    return Card(
      child: Padding(
        padding: const EdgeInsets.all(16),
        child: Row(
          children: [
            Container(
              padding: const EdgeInsets.all(12),
              decoration: BoxDecoration(
                color: statusColor.withValues(alpha: 0.1),
                borderRadius: BorderRadius.circular(12),
              ),
              child: Icon(statusIcon, color: statusColor, size: 28),
            ),
            const SizedBox(width: 16),
            Expanded(
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Text(
                    statusText,
                    style: theme.textTheme.titleMedium?.copyWith(
                      fontWeight: FontWeight.bold,
                      color: statusColor,
                    ),
                  ),
                  if (_assignment!.isPublished)
                    Text(
                      'Published on ${_formatDate(_assignment!.createdAt)}',
                      style: theme.textTheme.bodySmall,
                    ),
                ],
              ),
            ),
            if (!_assignment!.isPublished)
              FilledButton.icon(
                onPressed: _publishAssignment,
                icon: const Icon(Icons.publish),
                label: const Text('Publish Now'),
              ),
          ],
        ),
      ),
    );
  }

  Widget _buildDetailsCard(ThemeData theme) {
    return Card(
      child: Padding(
        padding: const EdgeInsets.all(16),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(
              'Assignment Details',
              style: theme.textTheme.titleLarge?.copyWith(
                fontWeight: FontWeight.bold,
              ),
            ),
            const SizedBox(height: 16),
            _buildDetailRow('Type', _assignment!.type.name.toUpperCase()),
            _buildDetailRow('Category', _assignment!.category),
            _buildDetailRow('Due Date', _formatDateTime(_assignment!.dueDate)),
            _buildDetailRow('Points', '${_assignment!.maxPoints.toInt()}'),
            _buildDetailRow('Created', _formatDate(_assignment!.createdAt)),
            if (_assignment!.updatedAt != null)
              _buildDetailRow('Last Updated', _formatDate(_assignment!.updatedAt!)),
          ],
        ),
      ),
    );
  }

  Widget _buildInstructionsCard(ThemeData theme) {
    return Card(
      child: Padding(
        padding: const EdgeInsets.all(16),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(
              'Instructions',
              style: theme.textTheme.titleLarge?.copyWith(
                fontWeight: FontWeight.bold,
              ),
            ),
            const SizedBox(height: 16),
            Text(
              _assignment!.description,
              style: theme.textTheme.bodyMedium?.copyWith(
                fontWeight: FontWeight.w500,
              ),
            ),
            if (_assignment!.instructions.isNotEmpty) ...[
              const SizedBox(height: 12),
              const Divider(),
              const SizedBox(height: 12),
              Text(
                _assignment!.instructions,
                style: theme.textTheme.bodyMedium,
              ),
            ],
          ],
        ),
      ),
    );
  }

  Widget _buildSubmissionSettingsCard(ThemeData theme) {
    return Card(
      child: Padding(
        padding: const EdgeInsets.all(16),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(
              'Submission Settings',
              style: theme.textTheme.titleLarge?.copyWith(
                fontWeight: FontWeight.bold,
              ),
            ),
            const SizedBox(height: 16),
            ListTile(
              leading: Icon(
                _assignment!.allowLateSubmissions 
                    ? Icons.check_circle 
                    : Icons.cancel,
                color: _assignment!.allowLateSubmissions 
                    ? Colors.green 
                    : Colors.red,
              ),
              title: const Text('Late Submissions'),
              subtitle: Text(
                _assignment!.allowLateSubmissions
                    ? 'Allowed with ${_assignment!.latePenaltyPercentage}% penalty per day'
                    : 'Not allowed',
              ),
              contentPadding: EdgeInsets.zero,
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildStatisticsCard(ThemeData theme) {
    // These would come from real data in production
    const totalStudents = 30;
    const submittedCount = 18;
    const gradedCount = 12;
    const averageScore = 85.5;

    return Card(
      child: Padding(
        padding: const EdgeInsets.all(16),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(
              'Submission Statistics',
              style: theme.textTheme.titleLarge?.copyWith(
                fontWeight: FontWeight.bold,
              ),
            ),
            const SizedBox(height: 16),
            Row(
              children: [
                Expanded(
                  child: _buildStatItem(
                    'Submitted',
                    '$submittedCount/$totalStudents',
                    Colors.blue,
                    Icons.upload_file,
                  ),
                ),
                const SizedBox(width: 16),
                Expanded(
                  child: _buildStatItem(
                    'Graded',
                    '$gradedCount/$submittedCount',
                    Colors.green,
                    Icons.grading,
                  ),
                ),
              ],
            ),
            const SizedBox(height: 16),
            Row(
              children: [
                Expanded(
                  child: _buildStatItem(
                    'Average Score',
                    '${averageScore.toStringAsFixed(1)}%',
                    Colors.purple,
                    Icons.analytics,
                  ),
                ),
                const SizedBox(width: 16),
                Expanded(
                  child: _buildStatItem(
                    'Pending',
                    '${totalStudents - submittedCount}',
                    Colors.orange,
                    Icons.pending,
                  ),
                ),
              ],
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildStatItem(String label, String value, Color color, IconData icon) {
    return Container(
      padding: const EdgeInsets.all(16),
      decoration: BoxDecoration(
        color: color.withValues(alpha: 0.1),
        borderRadius: BorderRadius.circular(12),
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Icon(icon, color: color, size: 24),
          const SizedBox(height: 8),
          Text(
            value,
            style: TextStyle(
              fontSize: 20,
              fontWeight: FontWeight.bold,
              color: color,
            ),
          ),
          Text(
            label,
            style: TextStyle(
              color: color,
              fontSize: 12,
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildActionButtons(ThemeData theme) {
    return Row(
      children: [
        Expanded(
          child: OutlinedButton.icon(
            onPressed: () {
              context.go('/teacher/gradebook?assignmentId=${widget.assignmentId}');
            },
            icon: const Icon(Icons.grading),
            label: const Text('Grade Submissions'),
            style: OutlinedButton.styleFrom(
              padding: const EdgeInsets.symmetric(vertical: 16),
            ),
          ),
        ),
        const SizedBox(width: 16),
        Expanded(
          child: FilledButton.icon(
            onPressed: () {
              // Navigate to submissions view
              context.go('/teacher/assignments/${widget.assignmentId}/submissions');
            },
            icon: const Icon(Icons.folder_open),
            label: const Text('View Submissions'),
            style: FilledButton.styleFrom(
              padding: const EdgeInsets.symmetric(vertical: 16),
            ),
          ),
        ),
      ],
    );
  }

  Widget _buildDetailRow(String label, String value) {
    return Padding(
      padding: const EdgeInsets.symmetric(vertical: 8),
      child: Row(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          SizedBox(
            width: 120,
            child: Text(
              label,
              style: TextStyle(
                color: Colors.grey.shade600,
                fontWeight: FontWeight.w500,
              ),
            ),
          ),
          Expanded(
            child: Text(
              value,
              style: const TextStyle(fontWeight: FontWeight.w600),
            ),
          ),
        ],
      ),
    );
  }

  String _formatDate(DateTime date) {
    final months = [
      'Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun',
      'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'
    ];
    return '${months[date.month - 1]} ${date.day}, ${date.year}';
  }

  String _formatDateTime(DateTime date) {
    final time = TimeOfDay.fromDateTime(date);
    return '${_formatDate(date)} at ${time.format(context)}';
  }

  Future<void> _publishAssignment() async {
    final assignmentProvider = context.read<AssignmentProvider>();
    
    try {
      await assignmentProvider.togglePublishStatus(widget.assignmentId, true);
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(
            content: Text('Assignment published successfully'),
            backgroundColor: Colors.green,
          ),
        );
        _loadAssignment(); // Reload to update UI
      }
    } catch (e) {
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('Error publishing assignment: $e'),
            backgroundColor: Colors.red,
          ),
        );
      }
    }
  }

  Future<void> _duplicateAssignment() async {
    final assignmentProvider = context.read<AssignmentProvider>();
    final assignment = assignmentProvider.selectedAssignment;
    
    if (assignment == null) return;
    
    try {
      // Create a copy with a new ID and modified title
      final duplicatedAssignment = Assignment(
        id: '', // Will be generated by Firestore
        teacherId: assignment.teacherId,
        classId: assignment.classId,
        title: 'Copy of ${assignment.title}',
        description: assignment.description,
        instructions: assignment.instructions,
        dueDate: DateTime.now().add(const Duration(days: 7)), // Set new due date
        totalPoints: assignment.totalPoints,
        maxPoints: assignment.maxPoints,
        attachmentUrl: assignment.attachmentUrl,
        createdAt: DateTime.now(),
        updatedAt: null,
        type: assignment.type,
        status: AssignmentStatus.draft, // Start as draft
        category: assignment.category,
        teacherName: assignment.teacherName,
        isPublished: false, // Start unpublished
        allowLateSubmissions: assignment.allowLateSubmissions,
        latePenaltyPercentage: assignment.latePenaltyPercentage,
        publishAt: null,
      );
      
      final success = await assignmentProvider.createAssignment(duplicatedAssignment);
      
      if (success && mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(
            content: Text('Assignment duplicated successfully'),
            backgroundColor: Colors.green,
          ),
        );
        // Navigate to assignments list
        context.go('/teacher/assignments');
      }
    } catch (e) {
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('Error duplicating assignment: $e'),
            backgroundColor: Colors.red,
          ),
        );
      }
    }
  }

  Future<void> _archiveAssignment() async {
    final assignmentProvider = context.read<AssignmentProvider>();
    
    try {
      await assignmentProvider.updateAssignmentStatus(
        widget.assignmentId, 
        AssignmentStatus.archived,
      );
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(
            content: Text('Assignment archived successfully'),
            backgroundColor: Colors.green,
          ),
        );
        context.go('/teacher/assignments');
      }
    } catch (e) {
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('Error archiving assignment: $e'),
            backgroundColor: Colors.red,
          ),
        );
      }
    }
  }

  Future<void> _deleteAssignment() async {
    final confirmed = await showDialog<bool>(
      context: context,
      builder: (context) => AlertDialog(
        title: const Text('Delete Assignment'),
        content: const Text(
          'Are you sure you want to delete this assignment? '
          'This action cannot be undone.',
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.of(context).pop(false),
            child: const Text('Cancel'),
          ),
          FilledButton(
            onPressed: () => Navigator.of(context).pop(true),
            style: FilledButton.styleFrom(
              backgroundColor: Colors.red,
            ),
            child: const Text('Delete'),
          ),
        ],
      ),
    );

    if (confirmed == true && mounted) {
      final assignmentProvider = context.read<AssignmentProvider>();
      
      try {
        await assignmentProvider.deleteAssignment(widget.assignmentId);
        if (mounted) {
          ScaffoldMessenger.of(context).showSnackBar(
            const SnackBar(
              content: Text('Assignment deleted successfully'),
              backgroundColor: Colors.green,
            ),
          );
          context.go('/teacher/assignments');
        }
      } catch (e) {
        if (mounted) {
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(
              content: Text('Error deleting assignment: $e'),
              backgroundColor: Colors.red,
            ),
          );
        }
      }
    }
  }
}
````

## File: lib/features/assignments/presentation/screens/teacher/assignment_edit_screen.dart
````dart
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:provider/provider.dart';
import 'package:go_router/go_router.dart';
import '../../../domain/models/assignment.dart';
import '../../providers/assignment_provider.dart';
import '../../../../../shared/widgets/common/adaptive_layout.dart';
import '../../../../../shared/widgets/common/responsive_layout.dart';

class AssignmentEditScreen extends StatefulWidget {
  final String assignmentId;
  
  const AssignmentEditScreen({
    super.key,
    required this.assignmentId,
  });

  @override
  State<AssignmentEditScreen> createState() => _AssignmentEditScreenState();
}

class _AssignmentEditScreenState extends State<AssignmentEditScreen> {
  final _formKey = GlobalKey<FormState>();
  final _titleController = TextEditingController();
  final _descriptionController = TextEditingController();
  final _instructionsController = TextEditingController();
  final _maxPointsController = TextEditingController();
  
  Assignment? _assignment;
  DateTime _dueDate = DateTime.now().add(const Duration(days: 7));
  TimeOfDay _dueTime = const TimeOfDay(hour: 23, minute: 59);
  AssignmentType _selectedType = AssignmentType.essay;
  bool _allowLateSubmissions = true;
  int _latePenaltyPercentage = 10;
  bool _isLoading = true;
  bool _isSaving = false;
  
  // Publishing options
  bool _updatePublishStatus = false;
  bool _publishNow = false;
  DateTime? _scheduledPublishDate;
  TimeOfDay? _scheduledPublishTime;

  @override
  void initState() {
    super.initState();
    _loadAssignment();
  }

  @override
  void dispose() {
    _titleController.dispose();
    _descriptionController.dispose();
    _instructionsController.dispose();
    _maxPointsController.dispose();
    super.dispose();
  }

  Future<void> _loadAssignment() async {
    final assignmentProvider = context.read<AssignmentProvider>();
    
    try {
      final assignment = await assignmentProvider.getAssignmentById(widget.assignmentId);
      if (assignment != null && mounted) {
        setState(() {
          _assignment = assignment;
          _titleController.text = assignment.title;
          _descriptionController.text = assignment.description;
          _instructionsController.text = assignment.instructions;
          _maxPointsController.text = assignment.maxPoints.toInt().toString();
          _selectedType = assignment.type;
          _dueDate = assignment.dueDate;
          _dueTime = TimeOfDay.fromDateTime(assignment.dueDate);
          _allowLateSubmissions = assignment.allowLateSubmissions;
          _latePenaltyPercentage = assignment.latePenaltyPercentage;
          
          if (assignment.publishAt != null) {
            _scheduledPublishDate = assignment.publishAt;
            _scheduledPublishTime = TimeOfDay.fromDateTime(assignment.publishAt!);
          }
          
          _isLoading = false;
        });
      } else if (mounted) {
        setState(() => _isLoading = false);
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(
            content: Text('Assignment not found'),
            backgroundColor: Colors.red,
          ),
        );
        context.pop();
      }
    } catch (e) {
      if (mounted) {
        setState(() => _isLoading = false);
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('Error loading assignment: $e'),
            backgroundColor: Colors.red,
          ),
        );
        context.pop();
      }
    }
  }

  Future<void> _selectDueDate() async {
    final DateTime? picked = await showDatePicker(
      context: context,
      initialDate: _dueDate,
      firstDate: DateTime.now(),
      lastDate: DateTime.now().add(const Duration(days: 365)),
    );
    if (picked != null && picked != _dueDate) {
      setState(() {
        _dueDate = picked;
      });
    }
  }

  Future<void> _selectDueTime() async {
    final TimeOfDay? picked = await showTimePicker(
      context: context,
      initialTime: _dueTime,
    );
    if (picked != null && picked != _dueTime) {
      setState(() {
        _dueTime = picked;
      });
    }
  }

  DateTime _combineDateAndTime(DateTime date, TimeOfDay time) {
    return DateTime(
      date.year,
      date.month,
      date.day,
      time.hour,
      time.minute,
    );
  }

  Future<void> _saveChanges() async {
    if (!_formKey.currentState!.validate() || _assignment == null) {
      return;
    }

    setState(() => _isSaving = true);

    try {
      final assignmentProvider = context.read<AssignmentProvider>();
      
      // Determine new publish status and date
      DateTime? newPublishAt = _assignment!.publishAt;
      bool newIsPublished = _assignment!.isPublished;
      
      if (_updatePublishStatus) {
        if (_publishNow) {
          newIsPublished = true;
          newPublishAt = null;
        } else if (_scheduledPublishDate != null && _scheduledPublishTime != null) {
          newIsPublished = false;
          newPublishAt = _combineDateAndTime(_scheduledPublishDate!, _scheduledPublishTime!);
        }
      }
      
      final updatedAssignment = _assignment!.copyWith(
        title: _titleController.text.trim(),
        description: _descriptionController.text.trim(),
        instructions: _instructionsController.text.trim(),
        type: _selectedType,
        category: _selectedType.name.toUpperCase(),
        maxPoints: double.parse(_maxPointsController.text),
        totalPoints: double.parse(_maxPointsController.text),
        dueDate: _combineDateAndTime(_dueDate, _dueTime),
        allowLateSubmissions: _allowLateSubmissions,
        latePenaltyPercentage: _latePenaltyPercentage,
        updatedAt: DateTime.now(),
        isPublished: newIsPublished,
        publishAt: newPublishAt,
      );

      final success = await assignmentProvider.updateAssignment(updatedAssignment);

      if (success && mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('Assignment "${updatedAssignment.title}" updated successfully'),
            backgroundColor: Colors.green,
          ),
        );
        context.pop();
      }
    } catch (e) {
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('Error updating assignment: $e'),
            backgroundColor: Colors.red,
          ),
        );
      }
    } finally {
      if (mounted) {
        setState(() => _isSaving = false);
      }
    }
  }

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    
    if (_isLoading) {
      return const Scaffold(
        body: Center(child: CircularProgressIndicator()),
      );
    }

    if (_assignment == null) {
      return const Scaffold(
        body: Center(child: Text('Assignment not found')),
      );
    }
    
    return AdaptiveLayout(
      title: 'Edit Assignment',
      actions: [
        TextButton.icon(
          onPressed: _isSaving ? null : _saveChanges,
          icon: const Icon(Icons.save),
          label: const Text('Save Changes'),
        ),
      ],
      body: ResponsiveContainer(
        child: Form(
          key: _formKey,
          child: ListView(
            padding: const EdgeInsets.all(16.0),
            children: [
              // Basic Information Card
              Card(
                child: Padding(
                  padding: const EdgeInsets.all(16.0),
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      Text(
                        'Basic Information',
                        style: theme.textTheme.titleLarge?.copyWith(
                          fontWeight: FontWeight.bold,
                        ),
                      ),
                      const SizedBox(height: 16),
                      TextFormField(
                        controller: _titleController,
                        decoration: const InputDecoration(
                          labelText: 'Assignment Title',
                          prefixIcon: Icon(Icons.title),
                        ),
                        validator: (value) {
                          if (value == null || value.isEmpty) {
                            return 'Please enter a title';
                          }
                          return null;
                        },
                      ),
                      const SizedBox(height: 16),
                      TextFormField(
                        controller: _descriptionController,
                        decoration: const InputDecoration(
                          labelText: 'Brief Description',
                          prefixIcon: Icon(Icons.description),
                        ),
                        maxLines: 2,
                        validator: (value) {
                          if (value == null || value.isEmpty) {
                            return 'Please enter a description';
                          }
                          return null;
                        },
                      ),
                      const SizedBox(height: 16),
                      DropdownButtonFormField<AssignmentType>(
                        value: _selectedType,
                        decoration: const InputDecoration(
                          labelText: 'Assignment Type',
                          prefixIcon: Icon(Icons.category),
                        ),
                        items: AssignmentType.values.map((type) {
                          return DropdownMenuItem(
                            value: type,
                            child: Text(type.name.toUpperCase()),
                          );
                        }).toList(),
                        onChanged: (value) {
                          setState(() {
                            _selectedType = value!;
                          });
                        },
                      ),
                    ],
                  ),
                ),
              ),
              const SizedBox(height: 16),
              
              // Instructions Card
              Card(
                child: Padding(
                  padding: const EdgeInsets.all(16.0),
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      Text(
                        'Instructions',
                        style: theme.textTheme.titleLarge?.copyWith(
                          fontWeight: FontWeight.bold,
                        ),
                      ),
                      const SizedBox(height: 16),
                      TextFormField(
                        controller: _instructionsController,
                        decoration: const InputDecoration(
                          labelText: 'Detailed Instructions',
                          hintText: 'Provide clear instructions for students...',
                          prefixIcon: Icon(Icons.article),
                          alignLabelWithHint: true,
                        ),
                        maxLines: 5,
                        validator: (value) {
                          if (value == null || value.isEmpty) {
                            return 'Please provide instructions';
                          }
                          return null;
                        },
                      ),
                    ],
                  ),
                ),
              ),
              const SizedBox(height: 16),
              
              // Grading & Submission Card
              Card(
                child: Padding(
                  padding: const EdgeInsets.all(16.0),
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      Text(
                        'Grading & Submission',
                        style: theme.textTheme.titleLarge?.copyWith(
                          fontWeight: FontWeight.bold,
                        ),
                      ),
                      const SizedBox(height: 16),
                      TextFormField(
                        controller: _maxPointsController,
                        decoration: const InputDecoration(
                          labelText: 'Maximum Points',
                          prefixIcon: Icon(Icons.score),
                        ),
                        keyboardType: TextInputType.number,
                        inputFormatters: [
                          FilteringTextInputFormatter.digitsOnly,
                        ],
                        validator: (value) {
                          if (value == null || value.isEmpty) {
                            return 'Enter points';
                          }
                          final points = int.tryParse(value);
                          if (points == null || points <= 0) {
                            return 'Invalid points';
                          }
                          return null;
                        },
                      ),
                      const SizedBox(height: 16),
                      Row(
                        children: [
                          Expanded(
                            child: InkWell(
                              onTap: _selectDueDate,
                              child: InputDecorator(
                                decoration: const InputDecoration(
                                  labelText: 'Due Date',
                                  prefixIcon: Icon(Icons.calendar_today),
                                ),
                                child: Text(
                                  '${_dueDate.month}/${_dueDate.day}/${_dueDate.year}',
                                ),
                              ),
                            ),
                          ),
                          const SizedBox(width: 16),
                          Expanded(
                            child: InkWell(
                              onTap: _selectDueTime,
                              child: InputDecorator(
                                decoration: const InputDecoration(
                                  labelText: 'Due Time',
                                  prefixIcon: Icon(Icons.access_time),
                                ),
                                child: Text(
                                  _dueTime.format(context),
                                ),
                              ),
                            ),
                          ),
                        ],
                      ),
                      const SizedBox(height: 16),
                      SwitchListTile(
                        title: const Text('Allow Late Submissions'),
                        subtitle: const Text('Students can submit after due date with penalty'),
                        value: _allowLateSubmissions,
                        onChanged: (value) {
                          setState(() {
                            _allowLateSubmissions = value;
                          });
                        },
                      ),
                      if (_allowLateSubmissions)
                        Padding(
                          padding: const EdgeInsets.only(left: 16.0),
                          child: Row(
                            children: [
                              const Text('Late Penalty: '),
                              SizedBox(
                                width: 100,
                                child: Slider(
                                  value: _latePenaltyPercentage.toDouble(),
                                  min: 0,
                                  max: 50,
                                  divisions: 10,
                                  label: '$_latePenaltyPercentage%',
                                  onChanged: (value) {
                                    setState(() {
                                      _latePenaltyPercentage = value.round();
                                    });
                                  },
                                ),
                              ),
                              Text('$_latePenaltyPercentage% per day'),
                            ],
                          ),
                        ),
                    ],
                  ),
                ),
              ),
              const SizedBox(height: 16),
              
              // Publishing Status Card
              Card(
                child: Padding(
                  padding: const EdgeInsets.all(16.0),
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      Row(
                        children: [
                          Expanded(
                            child: Text(
                              'Publishing Status',
                              style: theme.textTheme.titleLarge?.copyWith(
                                fontWeight: FontWeight.bold,
                              ),
                            ),
                          ),
                          Switch(
                            value: _updatePublishStatus,
                            onChanged: (value) {
                              setState(() {
                                _updatePublishStatus = value;
                              });
                            },
                          ),
                        ],
                      ),
                      const SizedBox(height: 8),
                      Text(
                        _assignment!.isPublished 
                            ? 'Currently Published'
                            : _assignment!.publishAt != null
                                ? 'Scheduled for ${_formatDateTime(_assignment!.publishAt!)}'
                                : 'Currently Unpublished',
                        style: theme.textTheme.bodyMedium?.copyWith(
                          color: theme.colorScheme.onSurfaceVariant,
                        ),
                      ),
                      if (_updatePublishStatus) ...[
                        const SizedBox(height: 16),
                        RadioListTile<bool>(
                          title: const Text('Publish Now'),
                          subtitle: const Text('Make assignment visible to students immediately'),
                          value: true,
                          groupValue: _publishNow,
                          onChanged: (value) {
                            setState(() {
                              _publishNow = value!;
                            });
                          },
                        ),
                        RadioListTile<bool>(
                          title: const Text('Schedule for Later'),
                          subtitle: const Text('Set a future date for automatic publication'),
                          value: false,
                          groupValue: _publishNow,
                          onChanged: (value) {
                            setState(() {
                              _publishNow = value!;
                              if (!_publishNow && _scheduledPublishDate == null) {
                                _scheduledPublishDate = DateTime.now().add(const Duration(days: 1));
                                _scheduledPublishTime = TimeOfDay.now();
                              }
                            });
                          },
                        ),
                        if (!_publishNow) ...[
                          const SizedBox(height: 16),
                          Row(
                            children: [
                              Expanded(
                                child: InkWell(
                                  onTap: () async {
                                    final DateTime? picked = await showDatePicker(
                                      context: context,
                                      initialDate: _scheduledPublishDate ?? DateTime.now(),
                                      firstDate: DateTime.now(),
                                      lastDate: _dueDate,
                                    );
                                    if (picked != null) {
                                      setState(() {
                                        _scheduledPublishDate = picked;
                                      });
                                    }
                                  },
                                  child: InputDecorator(
                                    decoration: const InputDecoration(
                                      labelText: 'Publish Date',
                                      prefixIcon: Icon(Icons.calendar_today),
                                    ),
                                    child: Text(
                                      _scheduledPublishDate != null
                                          ? '${_scheduledPublishDate!.month}/${_scheduledPublishDate!.day}/${_scheduledPublishDate!.year}'
                                          : 'Select date',
                                    ),
                                  ),
                                ),
                              ),
                              const SizedBox(width: 16),
                              Expanded(
                                child: InkWell(
                                  onTap: () async {
                                    final TimeOfDay? picked = await showTimePicker(
                                      context: context,
                                      initialTime: _scheduledPublishTime ?? TimeOfDay.now(),
                                    );
                                    if (picked != null) {
                                      setState(() {
                                        _scheduledPublishTime = picked;
                                      });
                                    }
                                  },
                                  child: InputDecorator(
                                    decoration: const InputDecoration(
                                      labelText: 'Publish Time',
                                      prefixIcon: Icon(Icons.access_time),
                                    ),
                                    child: Text(
                                      _scheduledPublishTime?.format(context) ?? 'Select time',
                                    ),
                                  ),
                                ),
                              ),
                            ],
                          ),
                        ],
                      ],
                    ],
                  ),
                ),
              ),
              const SizedBox(height: 32),
              
              // Action Buttons
              Row(
                children: [
                  Expanded(
                    child: OutlinedButton(
                      onPressed: _isSaving ? null : () => context.pop(),
                      style: OutlinedButton.styleFrom(
                        padding: const EdgeInsets.symmetric(vertical: 16),
                      ),
                      child: const Text('Cancel'),
                    ),
                  ),
                  const SizedBox(width: 16),
                  Expanded(
                    child: FilledButton(
                      onPressed: _isSaving ? null : _saveChanges,
                      style: FilledButton.styleFrom(
                        padding: const EdgeInsets.symmetric(vertical: 16),
                      ),
                      child: _isSaving
                          ? const SizedBox(
                              height: 20,
                              width: 20,
                              child: CircularProgressIndicator(
                                strokeWidth: 2,
                              ),
                            )
                          : const Text('Save Changes'),
                    ),
                  ),
                ],
              ),
              const SizedBox(height: 16),
            ],
          ),
        ),
      ),
    );
  }

  String _formatDateTime(DateTime date) {
    final months = [
      'Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun',
      'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'
    ];
    final time = TimeOfDay.fromDateTime(date);
    return '${months[date.month - 1]} ${date.day}, ${date.year} at ${time.format(context)}';
  }
}
````

## File: lib/features/auth/data/services/google_sign_in_service.dart
````dart
import 'dart:async';
import 'dart:io' show Platform;
import 'package:flutter/foundation.dart';
import 'package:google_sign_in/google_sign_in.dart';
import '../../../../shared/services/logger_service.dart';

/// Service class that manages Google Sign In using the singleton pattern.
/// 
/// This service wraps the GoogleSignIn singleton instance and provides
/// a centralized way to manage authentication with Google.
/// 
/// In google_sign_in 7.x:
/// - GoogleSignIn is now a singleton (GoogleSignIn.instance)
/// - Must call initialize() before any other operations
/// - signIn() → authenticate()
/// - signInSilently() → attemptLightweightAuthentication()
/// - currentUser getter → authenticationEvents stream
/// - Authentication (ID tokens) and Authorization (access tokens) are separate
class GoogleSignInService {
  // Private constructor for singleton pattern
  GoogleSignInService._internal();

  // Static instance
  static final GoogleSignInService _instance = GoogleSignInService._internal();

  // Factory constructor to return the singleton instance
  factory GoogleSignInService() {
    return _instance;
  }

  // Track initialization status
  bool _isInitialized = false;
  
  // Current user from the authentication events stream
  GoogleSignInAccount? _currentUser;
  
  // Stream subscription for authentication events
  StreamSubscription<GoogleSignInAuthenticationEvent>? _authEventSubscription;
  
  /// Whether the service has been initialized
  bool get isInitialized => _isInitialized;
  
  /// Check if the current platform supports google_sign_in
  bool get isPlatformSupported {
    if (kIsWeb) return true;
    if (Platform.isAndroid || Platform.isIOS || Platform.isMacOS) return true;
    // Windows and Linux are not supported by google_sign_in
    return false;
  }

  /// Initialize the GoogleSignIn instance.
  /// 
  /// This must be called once before using any other methods.
  /// Typically called from main() or during app initialization.
  /// 
  /// In google_sign_in 7.x, this calls GoogleSignIn.instance.initialize()
  /// Note: On Windows/Linux, this is a no-op as google_sign_in is not supported
  Future<void> initialize() async {
    if (_isInitialized) {
      LoggerService.debug('GoogleSignInService already initialized', tag: 'GoogleSignInService');
      return;
    }

    // Check platform support
    if (!isPlatformSupported) {
      LoggerService.debug('Platform not supported for google_sign_in. Will use Firebase Auth OAuth flow.', tag: 'GoogleSignInService');
      _isInitialized = true; // Mark as initialized even on unsupported platforms
      return;
    }

    try {
      // Initialize the GoogleSignIn singleton
      await GoogleSignIn.instance.initialize();
      
      // Listen to authentication events to track current user
      // In 7.x, GoogleSignInAuthenticationEvent is a sealed class
      _authEventSubscription = GoogleSignIn.instance.authenticationEvents.listen((event) {
        // Use pattern matching to handle the sealed class
        _currentUser = switch (event) {
          GoogleSignInAuthenticationEventSignIn() => event.user,
          GoogleSignInAuthenticationEventSignOut() => null,
        };
        
        LoggerService.debug('Google Sign In auth event: ${_currentUser?.email ?? "signed out"}', tag: 'GoogleSignInService');
      });
      
      _isInitialized = true;
      
      LoggerService.debug('GoogleSignInService initialized', tag: 'GoogleSignInService');
    } catch (e) {
      LoggerService.error('GoogleSignInService initialization error', tag: 'GoogleSignInService', error: e);
      rethrow;
    }
  }

  /// Sign in with Google interactively.
  /// 
  /// Triggers the Google sign-in flow and returns the signed-in account.
  /// Returns null if the user cancels the sign-in.
  /// 
  /// In google_sign_in 7.x, this uses authenticate() instead of signIn()
  /// On unsupported platforms (Windows/Linux), returns null - use Firebase Auth instead
  Future<GoogleSignInAccount?> signIn() async {
    if (!_isInitialized) {
      throw StateError('GoogleSignInService not initialized. Call initialize() first.');
    }
    
    if (!isPlatformSupported) {
      LoggerService.debug('Google sign in not supported on this platform. Use Firebase Auth OAuth flow instead.', tag: 'GoogleSignInService');
      return null;
    }
    
    try {
      final account = await GoogleSignIn.instance.authenticate();
      return account;
    } catch (e) {
      LoggerService.error('Google sign in error', tag: 'GoogleSignInService', error: e);
      rethrow;
    }
  }

  /// Sign out from Google.
  /// 
  /// Signs out the current Google user.
  /// In 7.x, this returns Future&lt;void&gt; instead of Future&lt;GoogleSignInAccount?&gt;
  /// On unsupported platforms (Windows/Linux), this is a no-op
  Future<void> signOut() async {
    if (!_isInitialized) {
      throw StateError('GoogleSignInService not initialized. Call initialize() first.');
    }
    
    if (!isPlatformSupported) {
      LoggerService.debug('Google sign out not needed on this platform (handled by Firebase Auth)', tag: 'GoogleSignInService');
      return;
    }
    
    try {
      await GoogleSignIn.instance.signOut();
    } catch (e) {
      LoggerService.error('Google sign out error', tag: 'GoogleSignInService', error: e);
      rethrow;
    }
  }

  /// Disconnect from Google.
  /// 
  /// Signs out and disconnects the Google account, clearing cached authentication.
  /// In 7.x, this returns Future&lt;void&gt; instead of Future&lt;GoogleSignInAccount?&gt;
  /// On unsupported platforms (Windows/Linux), this is a no-op
  Future<void> disconnect() async {
    if (!_isInitialized) {
      throw StateError('GoogleSignInService not initialized. Call initialize() first.');
    }
    
    if (!isPlatformSupported) {
      LoggerService.debug('Google disconnect not needed on this platform (handled by Firebase Auth)', tag: 'GoogleSignInService');
      return;
    }
    
    try {
      await GoogleSignIn.instance.disconnect();
    } catch (e) {
      LoggerService.error('Google disconnect error', tag: 'GoogleSignInService', error: e);
      rethrow;
    }
  }

  /// Attempt lightweight authentication (silent sign in).
  /// 
  /// Attempts to sign in a previously authenticated user without interaction.
  /// Returns null if no previously authenticated user is available.
  /// 
  /// In google_sign_in 7.x, this uses attemptLightweightAuthentication()
  /// instead of signInSilently()
  /// On unsupported platforms (Windows/Linux), returns null
  Future<GoogleSignInAccount?> signInSilently() async {
    if (!_isInitialized) {
      throw StateError('GoogleSignInService not initialized. Call initialize() first.');
    }
    
    if (!isPlatformSupported) {
      LoggerService.debug('Google silent sign in not supported on this platform', tag: 'GoogleSignInService');
      return null;
    }
    
    try {
      final account = await GoogleSignIn.instance.attemptLightweightAuthentication();
      return account;
    } catch (e) {
      LoggerService.error('Google silent sign in error', tag: 'GoogleSignInService', error: e);
      rethrow;
    }
  }

  /// Get the current signed-in account.
  /// 
  /// Returns null if no user is signed in.
  /// In 7.x, currentUser is tracked via authenticationEvents stream
  GoogleSignInAccount? get currentUser {
    if (!_isInitialized) {
      return null;
    }
    return _currentUser;
  }

  /// Check if a user is currently signed in.
  bool get isSignedIn {
    return currentUser != null;
  }

  /// Request scopes from the user.
  /// 
  /// This is needed for accessing Google APIs beyond basic profile.
  /// In google_sign_in 7.x, scopes should be requested during sign-in
  /// by configuring them in GoogleSignIn.instance before authentication.
  /// 
  /// If you need additional scopes after sign-in, you may need to
  /// re-authenticate the user with the new scopes.
  /// On unsupported platforms (Windows/Linux), returns false
  Future<bool> requestScopes(List<String> scopes) async {
    if (!_isInitialized) {
      throw StateError('GoogleSignInService not initialized. Call initialize() first.');
    }
    
    if (!isPlatformSupported) {
      LoggerService.debug('Google scope request not supported on this platform', tag: 'GoogleSignInService');
      return false;
    }
    
    try {
      // In 7.x, scopes are configured before authentication
      // To request new scopes, typically need to sign out and sign in again
      // with the updated scopes configuration
      LoggerService.debug('Note: In google_sign_in 7.x, scopes should be configured before authentication', tag: 'GoogleSignInService');
      return false;
    } catch (e) {
      LoggerService.error('Request scopes error', tag: 'GoogleSignInService', error: e);
      rethrow;
    }
  }

  /// Clean up resources
  void dispose() {
    _authEventSubscription?.cancel();
    _authEventSubscription = null;
  }
}
````

## File: lib/features/auth/data/services/web_auth_helper_interface.dart
````dart
// Conditional import for web auth helper
export 'web_auth_helper_stub.dart'
    if (dart.library.html) 'web_auth_helper.dart';
````

## File: lib/features/auth/data/services/web_auth_helper_stub.dart
````dart
import 'dart:async';

/// Stub implementation for non-web platforms
class WebAuthHelper {
  static final WebAuthHelper _instance = WebAuthHelper._internal();
  factory WebAuthHelper() => _instance;
  WebAuthHelper._internal();

  void initialize() {
    // No-op on non-web platforms
  }

  Stream<Map<String, dynamic>>? get authMessages => null;

  void injectPopupHelper(dynamic popup) {
    // No-op on non-web platforms
  }

  void dispose() {
    // No-op on non-web platforms
  }
}
````

## File: lib/features/auth/data/services/web_auth_helper.dart
````dart
import 'package:web/web.dart' as web;
import 'dart:js_interop';
import 'dart:async';
import 'dart:convert';
import 'package:flutter/foundation.dart';
import '../../../../shared/services/logger_service.dart';

/// Web-specific helper for handling authentication popups
/// This eliminates COOP (Cross-Origin-Opener-Policy) warnings
class WebAuthHelper {
  static final WebAuthHelper _instance = WebAuthHelper._internal();
  factory WebAuthHelper() => _instance;
  WebAuthHelper._internal();

  StreamController<Map<String, dynamic>>? _messageController;
  StreamSubscription? _messageSubscription;

  /// Initialize the postMessage listener for auth popups
  void initialize() {
    if (!kIsWeb) return;

    // Clean up any existing listener
    dispose();

    _messageController = StreamController<Map<String, dynamic>>.broadcast();

    // Listen for postMessage events from auth popups
    _messageSubscription = web.window.onMessage.listen((event) {
      // Security: Validate the origin
      final allowedOrigins = [
        'https://accounts.google.com',
        'https://apis.google.com',
        'https://teacher-dashboard-flutterfire.firebaseapp.com',
        'http://localhost:3000',
        'http://localhost:8080',
        'http://localhost:49896',
        'http://localhost:62290',
        // Add other OAuth provider origins as needed
      ];

      if (!allowedOrigins.contains(event.origin)) {
        LoggerService.debug('Ignored message from untrusted origin: ${event.origin}', tag: 'WebAuthHelper');
        return;
      }

      // Handle the message safely using js_interop_utils for proper JS interop
      if (kIsWeb) {
        try {
          final data = event.data;
          if (data != null) {
            // Use dart:js_interop for safe JS-to-Dart conversion
            String dataString;
            Map<String, dynamic>? parsedData;
            
            // Convert JS object to Dart safely using dart:js_interop
            try {
              // Try to convert as JSString first
              final jsString = data as JSString;
              dataString = jsString.toDart;  // Safe JS-to-Dart conversion
            } catch (e) {
              // Fallback to string conversion for other JS types
              dataString = data.toString();
            }
            
            LoggerService.debug('Received auth message: $dataString', tag: 'WebAuthHelper');

            // Try to parse as JSON if it looks like structured data
            try {
              if (dataString.startsWith('{') && dataString.endsWith('}')) {
                final Map<dynamic, dynamic> decoded = json.decode(dataString);
                parsedData = decoded.cast<String, dynamic>();
              }
            } catch (jsonError) {
              // Not JSON, treat as plain string data
              parsedData = {'message': dataString};
            }

            // Convert to message format
            final messageData = <String, dynamic>{
              'origin': event.origin,
              'data': parsedData ?? {'raw': dataString},
              'timestamp': DateTime.now().millisecondsSinceEpoch,
            };

            // Notify listeners
            _messageController?.add(messageData);

            // Handle specific auth events
            if (dataString.contains('auth-complete') || dataString.contains('success')) {
              // Auth completed successfully
              _handleAuthComplete(messageData);
            }
          }
        } catch (e) {
          LoggerService.debug('Error processing auth message: $e', tag: 'WebAuthHelper');
        }
      }
    });

    LoggerService.debug('Initialized postMessage listener', tag: 'WebAuthHelper');
  }

  /// Handle auth completion
  void _handleAuthComplete(Map data) {
    LoggerService.debug('Auth completed with data: $data', tag: 'WebAuthHelper');

    // The popup should close itself, but we can't access window.close
    // due to COOP restrictions. The postMessage approach allows the
    // popup to notify us it's done without needing window.closed checks.
  }

  /// Stream of auth messages
  Stream<Map<String, dynamic>>? get authMessages => _messageController?.stream;

  /// Inject helper script into auth popups if possible
  /// This is called when opening OAuth popups
  void injectPopupHelper(web.Window? popup) {
    if (popup == null || !kIsWeb) return;

    // We can't directly access the popup due to COOP, but we can
    // set up our listener to receive messages from it
    LoggerService.debug('Ready to receive messages from auth popup', tag: 'WebAuthHelper');
  }

  /// Clean up resources
  void dispose() {
    _messageSubscription?.cancel();
    _messageController?.close();
    _messageSubscription = null;
    _messageController = null;
  }
}
````

## File: lib/features/auth/presentation/providers/auth_provider.dart
````dart
/// Authentication state management provider.
/// 
/// This module manages authentication state and user sessions for the
/// education platform. It provides a centralized authentication interface
/// that handles email/password and Google sign-in flows, role selection,
/// and profile management.
library;

import 'dart:async';
import 'package:flutter/foundation.dart';
import 'package:firebase_auth/firebase_auth.dart';
import '../../../../shared/models/user_model.dart';
import '../../domain/repositories/auth_repository.dart';
import '../../../../shared/core/service_locator.dart';
import '../../../student/data/services/presence_service.dart';
import '../../../../shared/services/logger_service.dart';

/// Enumeration of possible authentication states.
/// 
/// Tracks the current authentication status throughout
/// the application lifecycle:
/// - uninitialized: Initial state before auth check
/// - authenticated: User is fully authenticated with role
/// - authenticating: User authenticated but needs role selection
/// - unauthenticated: No authenticated user
/// - error: Authentication error occurred
enum AuthStatus {
  uninitialized,
  authenticated,
  authenticating,
  unauthenticated,
  error,
}

/// Provider managing authentication state and user operations.
/// 
/// This provider serves as the central authentication manager,
/// coordinating between Firebase Auth and Firestore user profiles.
/// Key features:
/// - Real-time auth state monitoring
/// - Email and Google authentication flows
/// - Two-step registration for role selection
/// - Profile management and updates
/// - Error handling and loading states
/// - Automatic session persistence
/// 
/// The provider distinguishes between Firebase Auth users and
/// complete user profiles with roles in Firestore.
class AuthProvider extends ChangeNotifier {
  /// Repository for authentication operations.
  AuthRepository? _authRepository;
  
  /// Presence service for online status tracking.
  final PresenceService _presenceService = PresenceService();
  
  /// Current authentication status.
  AuthStatus _status = AuthStatus.uninitialized;
  
  /// Complete user profile with role information.
  UserModel? _userModel;
  
  /// Latest error message for UI display.
  String? _errorMessage;
  
  /// Loading state for async operations.
  bool _isLoading = false;
  
  /// Auth state subscription
  StreamSubscription<User?>? _authStateSubscription;

  // Getters
  
  /// Current authentication status.
  AuthStatus get status => _status;
  
  /// Complete user profile or null if not authenticated.
  UserModel? get userModel => _userModel;
  
  /// Latest error message or null if no error.
  String? get errorMessage => _errorMessage;
  
  /// Whether an authentication operation is in progress.
  bool get isLoading => _isLoading;
  
  /// Whether user is fully authenticated with role.
  bool get isAuthenticated => _status == AuthStatus.authenticated;
  
  /// Firebase Auth user instance.
  User? get firebaseUser => _authRepository?.currentUser;

  /// Creates auth provider and initializes auth state monitoring.
  /// 
  /// Retrieves the auth repository from dependency injection
  /// and sets up real-time auth state listeners.
  AuthProvider() {
    try {
      _authRepository = getIt<AuthRepository>();
      _initializeAuth();
    } catch (e, stackTrace) {
      // If getIt fails, catch it to prevent provider creation failure
      LoggerService.error('AuthProvider initialization failed', tag: 'AuthProvider', error: e, stackTrace: stackTrace);
      _status = AuthStatus.error;
      _errorMessage = 'Failed to initialize authentication service. Please restart the app.';
      // Don't call notifyListeners() in constructor
    }
  }

  /// Sets up Firebase Auth state monitoring.
  /// 
  /// Listens to auth state changes and synchronizes with
  /// Firestore user profiles. Handles three scenarios:
  /// 1. No user - sets unauthenticated state
  /// 2. User with profile - sets authenticated state
  /// 3. User without profile - needs role selection
  /// 
  /// Falls back gracefully if Firebase is not initialized.
  void _initializeAuth() {
    if (_authRepository == null) {
      // Repository initialization failed, already in error state
      return;
    }
    
    try {
      _authStateSubscription = _authRepository!.authStateChanges.listen((User? user) async {
        if (user == null) {
          _status = AuthStatus.unauthenticated;
          _userModel = null;
          // Clean up presence when user logs out
          await _presenceService.cleanupPresence();
        } else {
          // Try to get user model from Firestore
          final userModel = await _authRepository!.getCurrentUserModel();
          if (userModel != null) {
            _userModel = userModel;
            _status = AuthStatus.authenticated;
            // Initialize presence for ALL authenticated users with their role
            _presenceService.initializePresence(userRole: userModel.role?.name ?? 'student');
          } else {
            // User exists in Auth but not in Firestore (Google sign-in needs role)
            _status = AuthStatus.authenticating;
          }
        }
        notifyListeners();
      });
    } catch (e) {
      // Firebase not initialized - set to unauthenticated for development
      LoggerService.debug('Firebase Auth not available', tag: 'AuthProvider');
      _status = AuthStatus.unauthenticated;
      _userModel = null;
      notifyListeners();
    }
  }

  /// Creates Firebase Auth user without Firestore profile.
  /// 
  /// First step of two-step registration process. Creates
  /// authentication credentials but not the full user profile.
  /// User must select role after this step.
  /// 
  /// @param email User's email address
  /// @param password Secure password
  /// @param displayName Full display name
  /// @param firstName User's first name
  /// @param lastName User's last name
  /// @return true if auth user created successfully
  Future<bool> signUpWithEmailOnly({
    required String email,
    required String password,
    required String displayName,
    required String firstName,
    required String lastName,
  }) async {
    if (_authRepository == null) {
      _setError('Authentication service not available.');
      return false;
    }
    
    try {
      _setLoading(true);
      _clearError();

      final user = await _authRepository!.signUpWithEmailOnly(
        email: email,
        password: password,
        displayName: displayName,
        firstName: firstName,
        lastName: lastName,
      );

      if (user != null) {
        // User needs to select role
        _status = AuthStatus.authenticating;
        notifyListeners();
        return true;
      }
      return false;
    } catch (e) {
      _setError(e.toString());
      return false;
    } finally {
      _setLoading(false);
    }
  }

  /// Creates complete user account with role.
  /// 
  /// Full registration process that creates both Firebase Auth
  /// user and Firestore profile with role information.
  /// 
  /// @param email User's email address
  /// @param password Secure password
  /// @param displayName Full display name
  /// @param role User role (teacher/student/parent/admin)
  /// @param parentEmail Parent's email (for student accounts)
  /// @param gradeLevel Student's grade level
  /// @return true if account created successfully
  Future<bool> signUpWithEmail({
    required String email,
    required String password,
    required String displayName,
    required UserRole role,
    String? parentEmail,
    int? gradeLevel,
  }) async {
    try {
      _setLoading(true);
      _clearError();

      final userModel = await _authRepository!.signUpWithEmail(
        email: email,
        password: password,
        displayName: displayName,
        role: role,
        parentEmail: parentEmail,
        gradeLevel: gradeLevel,
      );

      if (userModel != null) {
        _userModel = userModel;
        _status = AuthStatus.authenticated;
        notifyListeners();
        return true;
      }
      return false;
    } catch (e) {
      _setError(e.toString());
      return false;
    } finally {
      _setLoading(false);
    }
  }

  /// Authenticates user with email and password.
  /// 
  /// Verifies credentials and loads complete user profile
  /// from Firestore. Sets authenticated state on success.
  /// 
  /// @param email User's email address
  /// @param password Account password
  /// @return true if sign in successful
  Future<bool> signInWithEmail({
    required String email,
    required String password,
  }) async {
    try {
      _setLoading(true);
      _clearError();

      final userModel = await _authRepository!.signInWithEmail(
        email: email,
        password: password,
      );

      if (userModel != null) {
        _userModel = userModel;
        _status = AuthStatus.authenticated;
        // Update presence with role when signing in
        await _presenceService.updateUserPresence(true, userRole: userModel.role?.toString().split('.').last);
        notifyListeners();
        return true;
      }
      return false;
    } catch (e) {
      _setError(e.toString());
      return false;
    } finally {
      _setLoading(false);
    }
  }

  /// Authenticates user with Google OAuth.
  /// 
  /// Handles two scenarios:
  /// 1. Existing user - loads profile and authenticates
  /// 2. New user - sets authenticating state for role selection
  /// 
  /// @return true if Google sign in successful
  Future<bool> signInWithGoogle() async {
    if (_authRepository == null) {
      _setError('Authentication service not available.');
      return false;
    }
    
    try {
      _setLoading(true);
      _clearError();

      final userModel = await _authRepository!.signInWithGoogle();

      if (userModel != null) {
        _userModel = userModel;
        _status = AuthStatus.authenticated;
        // Update presence with role when signing in with Google
        await _presenceService.updateUserPresence(true, userRole: userModel.role?.toString().split('.').last);
        notifyListeners();
        return true;
      } else if (firebaseUser != null) {
        // User needs to select role
        _status = AuthStatus.authenticating;
        notifyListeners();
        return true;
      }
      return false;
    } catch (e) {
      _setError(e.toString());
      return false;
    } finally {
      _setLoading(false);
    }
  }

  /// Completes Google sign-up by creating user profile.
  /// 
  /// Second step for new Google users. Creates Firestore
  /// profile with selected role and additional information.
  /// 
  /// @param role Selected user role
  /// @param parentEmail Parent's email (for students)
  /// @param gradeLevel Student's grade level
  /// @return true if profile created successfully
  Future<bool> completeGoogleSignUp({
    required UserRole role,
    String? parentEmail,
    int? gradeLevel,
  }) async {
    try {
      _setLoading(true);
      _clearError();

      final userModel = await _authRepository!.completeGoogleSignUp(
        role: role,
        parentEmail: parentEmail,
        gradeLevel: gradeLevel,
      );

      if (userModel != null) {
        _userModel = userModel;
        _status = AuthStatus.authenticated;
        notifyListeners();
        return true;
      }
      return false;
    } catch (e) {
      _setError(e.toString());
      return false;
    } finally {
      _setLoading(false);
    }
  }

  /// Signs out the current user.
  /// 
  /// Clears authentication state and user profile.
  /// Triggers navigation to login screen through
  /// state change notifications.
  /// 
  /// @throws Exception if sign out fails
  Future<void> signOut() async {
    try {
      _setLoading(true);
      await _authRepository!.signOut();
      _userModel = null;
      _status = AuthStatus.unauthenticated;
      notifyListeners();
    } catch (e) {
      _setError(e.toString());
    } finally {
      _setLoading(false);
    }
  }

  /// Sends password reset email to user.
  /// 
  /// Initiates Firebase Auth password reset flow.
  /// User receives email with reset link.
  /// 
  /// @param email Account email address
  /// @return true if reset email sent successfully
  Future<bool> resetPassword(String email) async {
    try {
      _setLoading(true);
      _clearError();
      await _authRepository!.resetPassword(email);
      return true;
    } catch (e) {
      _setError(e.toString());
      return false;
    } finally {
      _setLoading(false);
    }
  }

  /// Updates user profile information.
  /// 
  /// Modifies both Firebase Auth profile and Firestore
  /// user document. Refreshes cached user model after update.
  /// 
  /// @param displayName New display name
  /// @param firstName New first name
  /// @param lastName New last name
  /// @param photoURL New profile photo URL
  /// @param updatePhoto Whether to update photo
  /// @return true if profile updated successfully
  Future<bool> updateProfile({
    String? displayName,
    String? firstName,
    String? lastName,
    String? photoURL,
    bool updatePhoto = false,
  }) async {
    try {
      _setLoading(true);
      _clearError();

      await _authRepository!.updateProfile(
        displayName: displayName,
        firstName: firstName,
        lastName: lastName,
        photoURL: photoURL,
        updatePhoto: updatePhoto,
      );

      // Refresh user model
      _userModel = await _authRepository!.getCurrentUserModel();
      notifyListeners();
      return true;
    } catch (e) {
      _setError(e.toString());
      return false;
    } finally {
      _setLoading(false);
    }
  }

  /// Updates user role after initial authentication.
  /// 
  /// Convenience method for role selection screen.
  /// Creates Firestore profile for authenticated users
  /// who don't have one yet (Google sign-in flow).
  /// 
  /// @param role Selected user role
  /// @return true if role updated successfully
  Future<bool> updateUserRole(UserRole role) async {
    try {
      _setLoading(true);
      _clearError();

      final userModel = await _authRepository!.completeGoogleSignUp(
        role: role,
      );

      if (userModel != null) {
        _userModel = userModel;
        _status = AuthStatus.authenticated;
        notifyListeners();
        return true;
      }
      return false;
    } catch (e) {
      _setError(e.toString());
      return false;
    } finally {
      _setLoading(false);
    }
  }

  /// Sets loading state and notifies listeners.
  /// 
  /// @param value New loading state
  void _setLoading(bool value) {
    _isLoading = value;
    notifyListeners();
  }

  /// Sets error state with message.
  /// 
  /// Updates status to error and stores message
  /// for UI display.
  /// 
  /// @param message Error description
  void _setError(String message) {
    _errorMessage = message;
    _status = AuthStatus.error;
    notifyListeners();
  }

  /// Clears error message internally.
  /// 
  /// Does not notify listeners.
  void _clearError() {
    _errorMessage = null;
  }

  /// Clears error message and notifies UI.
  /// 
  /// Public method for UI to dismiss error messages
  /// after user acknowledgment.
  void clearError() {
    _clearError();
    notifyListeners();
  }
  
  /// Properly dispose of resources when provider is removed.
  /// 
  /// Cancels auth state subscription and cleans up presence tracking
  /// to prevent memory leaks and ensure proper resource cleanup.
  @override
  void dispose() {
    // Cancel auth state subscription
    _authStateSubscription?.cancel();
    _authStateSubscription = null;
    
    // Clean up presence tracking
    _presenceService.cleanupPresence();
    
    // Call parent dispose
    super.dispose();
  }
}
````

## File: lib/features/auth/presentation/screens/forgot_password_screen.dart
````dart
import 'package:flutter/material.dart';
import 'package:firebase_auth/firebase_auth.dart';

class ForgotPasswordScreen extends StatefulWidget {
  const ForgotPasswordScreen({super.key});

  @override
  State<ForgotPasswordScreen> createState() => _ForgotPasswordScreenState();
}

class _ForgotPasswordScreenState extends State<ForgotPasswordScreen> {
  final _emailController = TextEditingController();
  final _formKey = GlobalKey<FormState>();
  bool _isLoading = false;
  bool _emailSent = false;

  @override
  void dispose() {
    _emailController.dispose();
    super.dispose();
  }

  Future<void> _resetPassword() async {
    if (!_formKey.currentState!.validate()) return;

    setState(() => _isLoading = true);

    try {
      await FirebaseAuth.instance.sendPasswordResetEmail(
        email: _emailController.text.trim(),
      );
      
      setState(() => _emailSent = true);
    } on FirebaseAuthException catch (e) {
      String message = 'An error occurred';
      if (e.code == 'user-not-found') {
        message = 'No user found with this email address';
      } else if (e.code == 'invalid-email') {
        message = 'Invalid email address';
      }
      
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(content: Text(message)),
        );
      }
    } finally {
      if (mounted) {
        setState(() => _isLoading = false);
      }
    }
  }

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    
    return Scaffold(
      appBar: AppBar(
        title: const Text('Reset Password'),
      ),
      body: Padding(
        padding: const EdgeInsets.all(24.0),
        child: _emailSent ? _buildSuccessMessage(theme) : _buildForm(theme),
      ),
    );
  }

  Widget _buildForm(ThemeData theme) {
    return Form(
      key: _formKey,
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.stretch,
        children: [
          const SizedBox(height: 32),
          
          Icon(
            Icons.lock_reset,
            size: 64,
            color: theme.colorScheme.primary,
          ),
          const SizedBox(height: 24),
          
          Text(
            'Forgot Password?',
            style: theme.textTheme.headlineMedium?.copyWith(
              fontWeight: FontWeight.bold,
            ),
            textAlign: TextAlign.center,
          ),
          const SizedBox(height: 8),
          
          Text(
            'Enter your email address and we\'ll send you a link to reset your password.',
            style: theme.textTheme.bodyLarge?.copyWith(
              color: theme.colorScheme.onSurfaceVariant,
            ),
            textAlign: TextAlign.center,
          ),
          const SizedBox(height: 32),

          TextFormField(
            controller: _emailController,
            decoration: const InputDecoration(
              labelText: 'Email',
              hintText: 'Enter your email address',
              prefixIcon: Icon(Icons.email_outlined),
            ),
            keyboardType: TextInputType.emailAddress,
            validator: (value) {
              if (value == null || value.isEmpty) {
                return 'Please enter your email';
              }
              if (!value.contains('@')) {
                return 'Please enter a valid email';
              }
              return null;
            },
          ),
          const SizedBox(height: 24),

          FilledButton(
            onPressed: _isLoading ? null : _resetPassword,
            style: FilledButton.styleFrom(
              minimumSize: const Size.fromHeight(56),
            ),
            child: _isLoading
                ? const SizedBox(
                    height: 20,
                    width: 20,
                    child: CircularProgressIndicator(strokeWidth: 2),
                  )
                : const Text('Send Reset Link'),
          ),
        ],
      ),
    );
  }

  Widget _buildSuccessMessage(ThemeData theme) {
    return Column(
      mainAxisAlignment: MainAxisAlignment.center,
      children: [
        Icon(
          Icons.check_circle,
          size: 64,
          color: theme.colorScheme.primary,
        ),
        const SizedBox(height: 24),
        
        Text(
          'Email Sent!',
          style: theme.textTheme.headlineMedium?.copyWith(
            fontWeight: FontWeight.bold,
          ),
          textAlign: TextAlign.center,
        ),
        const SizedBox(height: 8),
        
        Text(
          'We\'ve sent a password reset link to ${_emailController.text}',
          style: theme.textTheme.bodyLarge?.copyWith(
            color: theme.colorScheme.onSurfaceVariant,
          ),
          textAlign: TextAlign.center,
        ),
        const SizedBox(height: 32),

        OutlinedButton(
          onPressed: () => Navigator.of(context).pop(),
          style: OutlinedButton.styleFrom(
            minimumSize: const Size.fromHeight(56),
          ),
          child: const Text('Back to Login'),
        ),
      ],
    );
  }
}
````

## File: lib/features/auth/presentation/widgets/auth_text_field.dart
````dart
import 'package:flutter/material.dart';

class AuthTextField extends StatelessWidget {
  final TextEditingController controller;
  final String label;
  final bool obscureText;
  final TextInputType? keyboardType;
  final IconData? prefixIcon;
  final Widget? suffixIcon;
  final String? Function(String?)? validator;
  final bool enabled;
  final int? maxLines;

  const AuthTextField({
    super.key,
    required this.controller,
    required this.label,
    this.obscureText = false,
    this.keyboardType,
    this.prefixIcon,
    this.suffixIcon,
    this.validator,
    this.enabled = true,
    this.maxLines = 1,
  });

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    
    return TextFormField(
      controller: controller,
      obscureText: obscureText,
      keyboardType: keyboardType,
      enabled: enabled,
      maxLines: obscureText ? 1 : maxLines,
      validator: validator,
      decoration: InputDecoration(
        labelText: label,
        prefixIcon: prefixIcon != null ? Icon(prefixIcon) : null,
        suffixIcon: suffixIcon,
        border: OutlineInputBorder(
          borderRadius: BorderRadius.circular(12),
        ),
        enabledBorder: OutlineInputBorder(
          borderRadius: BorderRadius.circular(12),
          borderSide: BorderSide(
            color: theme.colorScheme.outline,
          ),
        ),
        focusedBorder: OutlineInputBorder(
          borderRadius: BorderRadius.circular(12),
          borderSide: BorderSide(
            color: theme.colorScheme.primary,
            width: 2,
          ),
        ),
        errorBorder: OutlineInputBorder(
          borderRadius: BorderRadius.circular(12),
          borderSide: BorderSide(
            color: theme.colorScheme.error,
          ),
        ),
        focusedErrorBorder: OutlineInputBorder(
          borderRadius: BorderRadius.circular(12),
          borderSide: BorderSide(
            color: theme.colorScheme.error,
            width: 2,
          ),
        ),
        filled: true,
        fillColor: enabled
            ? theme.colorScheme.surface
            : theme.colorScheme.surfaceContainerHighest.withValues(alpha: 0.5),
      ),
    );
  }
}
````

## File: lib/features/auth/presentation/widgets/google_sign_in_button_web.dart
````dart
import 'package:flutter/material.dart';
import 'package:flutter/foundation.dart';
import 'package:google_sign_in_web/web_only.dart' as web;

/// Builds the Google Sign-In button for web platform
Widget buildGoogleSignInButtonWeb() {
  if (!kIsWeb) {
    return const SizedBox.shrink();
  }
  
  // Use the web-only renderButton method
  try {
    return web.renderButton();
  } catch (e) {
    // Fallback if platform is not properly initialized
    return const Center(
      child: Text('Google Sign-In not available'),
    );
  }
}
````

## File: lib/features/calendar/data/repositories/calendar_repository_impl.dart
````dart
/// Concrete implementation of the calendar repository.
/// 
/// This module implements the CalendarRepository interface using
/// Firebase Firestore for data persistence, providing full CRUD
/// operations for calendar events with recurrence support.
library;

import 'package:cloud_firestore/cloud_firestore.dart';
import '../../domain/models/calendar_event.dart';
import '../../domain/repositories/calendar_repository.dart';

/// Firebase implementation of CalendarRepository.
/// 
/// Manages calendar events in Firestore with support for:
/// - Multiple event types (classes, assignments, meetings, etc.)
/// - Recurrence patterns for repeating events
/// - Participant management
/// - Date-based queries with recurrence calculation
class CalendarRepositoryImpl implements CalendarRepository {
  final FirebaseFirestore _firestore;
  static const String _collection = 'calendar_events';
  
  /// Creates repository with Firestore instance.
  CalendarRepositoryImpl(this._firestore);
  
  @override
  Future<CalendarEvent> createEvent(CalendarEvent event) async {
    final docRef = await _firestore.collection(_collection).add(
      event.toFirestore(),
    );
    
    return event.copyWith(id: docRef.id);
  }
  
  @override
  Future<CalendarEvent> updateEvent(CalendarEvent event) async {
    await _firestore.collection(_collection).doc(event.id).update(
      event.copyWith(updatedAt: DateTime.now()).toFirestore(),
    );
    
    return event.copyWith(updatedAt: DateTime.now());
  }
  
  @override
  Future<void> deleteEvent(String eventId) async {
    await _firestore.collection(_collection).doc(eventId).delete();
  }
  
  @override
  Future<CalendarEvent?> getEvent(String eventId) async {
    final doc = await _firestore.collection(_collection).doc(eventId).get();
    
    if (!doc.exists) return null;
    
    return CalendarEvent.fromFirestore(doc);
  }
  
  @override
  Stream<List<CalendarEvent>> getUserEvents(String userId) {
    // Get events where user is creator or participant
    return _firestore
        .collection(_collection)
        .where('isActive', isEqualTo: true)
        .where(
          Filter.or(
            Filter('createdBy', isEqualTo: userId),
            Filter('participantIds', arrayContains: userId),
          ),
        )
        .orderBy('startTime')
        .snapshots()
        .map((snapshot) => snapshot.docs
            .map((doc) => CalendarEvent.fromFirestore(doc))
            .toList());
  }
  
  @override
  Stream<List<CalendarEvent>> getEventsByDateRange(
    String userId,
    DateTime startDate,
    DateTime endDate,
  ) {
    // Get all user events and filter by date range including recurrence
    return getUserEvents(userId).map((events) {
      return events.where((event) {
        // Check if event or its recurrences fall within range
        if (event.recurrence == RecurrenceType.none) {
          // Single event - check if it's in range
          return event.startTime.isAfter(startDate.subtract(const Duration(days: 1))) &&
                 event.startTime.isBefore(endDate.add(const Duration(days: 1)));
        } else {
          // Recurring event - check if any instance is in range
          final eventEnd = event.recurrenceEndDate ?? endDate;
          
          // Event starts before range end and ends after range start
          return event.startTime.isBefore(endDate.add(const Duration(days: 1))) &&
                 eventEnd.isAfter(startDate.subtract(const Duration(days: 1)));
        }
      }).toList();
    });
  }
  
  @override
  Stream<List<CalendarEvent>> getClassEvents(String classId) {
    return _firestore
        .collection(_collection)
        .where('classId', isEqualTo: classId)
        .where('isActive', isEqualTo: true)
        .orderBy('startTime')
        .snapshots()
        .map((snapshot) => snapshot.docs
            .map((doc) => CalendarEvent.fromFirestore(doc))
            .toList());
  }
  
  @override
  Stream<List<CalendarEvent>> getEventsByType(
    String userId,
    EventType type,
  ) {
    return getUserEvents(userId).map((events) =>
        events.where((event) => event.type == type).toList());
  }
  
  @override
  Stream<List<CalendarEvent>> getUpcomingEvents(
    String userId,
    int daysAhead,
  ) {
    final now = DateTime.now();
    final endDate = now.add(Duration(days: daysAhead));
    
    return getEventsByDateRange(userId, now, endDate);
  }
  
  @override
  Future<List<CalendarEvent>> getEventsForDate(
    String userId,
    DateTime date,
  ) async {
    // Get all user events
    final snapshot = await _firestore
        .collection(_collection)
        .where('isActive', isEqualTo: true)
        .where(
          Filter.or(
            Filter('createdBy', isEqualTo: userId),
            Filter('participantIds', arrayContains: userId),
          ),
        )
        .get();
    
    final events = snapshot.docs
        .map((doc) => CalendarEvent.fromFirestore(doc))
        .toList();
    
    // Filter events that occur on the specified date
    return events.where((event) => event.occursOn(date)).toList();
  }
  
  @override
  Future<void> addParticipant(String eventId, String participantId) async {
    await _firestore.collection(_collection).doc(eventId).update({
      'participantIds': FieldValue.arrayUnion([participantId]),
      'updatedAt': FieldValue.serverTimestamp(),
    });
  }
  
  @override
  Future<void> removeParticipant(String eventId, String participantId) async {
    await _firestore.collection(_collection).doc(eventId).update({
      'participantIds': FieldValue.arrayRemove([participantId]),
      'updatedAt': FieldValue.serverTimestamp(),
    });
  }
  
  @override
  Future<List<String>> getEventParticipants(String eventId) async {
    final doc = await _firestore.collection(_collection).doc(eventId).get();
    
    if (!doc.exists) return [];
    
    final data = doc.data() as Map<String, dynamic>;
    return List<String>.from(data['participantIds'] ?? []);
  }
  
  @override
  Future<bool> canEditEvent(String userId, String eventId) async {
    final event = await getEvent(eventId);
    
    if (event == null) return false;
    
    // User can edit if they are the creator
    return event.createdBy == userId;
  }
  
  @override
  Stream<List<CalendarEvent>> getEventsNeedingReminders(
    DateTime fromTime,
    DateTime toTime,
  ) {
    return _firestore
        .collection(_collection)
        .where('hasReminder', isEqualTo: true)
        .where('isActive', isEqualTo: true)
        .where('startTime', isGreaterThan: Timestamp.fromDate(fromTime))
        .where('startTime', isLessThanOrEqualTo: Timestamp.fromDate(toTime))
        .snapshots()
        .map((snapshot) => snapshot.docs
            .map((doc) => CalendarEvent.fromFirestore(doc))
            .where((event) {
              if (event.reminderMinutes == null) return false;
              
              final reminderTime = event.startTime.subtract(
                Duration(minutes: event.reminderMinutes!),
              );
              
              return reminderTime.isAfter(fromTime) &&
                     reminderTime.isBefore(toTime);
            })
            .toList());
  }
}
````

## File: lib/features/calendar/data/services/device_calendar_service_factory.dart
````dart
import 'device_calendar_service_interface.dart';

// Conditional imports - Dart will choose the correct one at compile time
import 'device_calendar_service_stub.dart'
    if (dart.library.io) 'device_calendar_service_mobile.dart'
    if (dart.library.html) 'device_calendar_service_web.dart';

/// Factory for creating platform-specific DeviceCalendarService instances
abstract class DeviceCalendarServiceFactory {
  static DeviceCalendarServiceInterface create() {
    return getDeviceCalendarService();
  }
}
````

## File: lib/features/calendar/data/services/device_calendar_service_stub.dart
````dart
import 'device_calendar_service_interface.dart';
import 'device_calendar_service_web.dart';

/// Stub implementation - this will be replaced by platform-specific imports
DeviceCalendarServiceInterface getDeviceCalendarService() {
  return DeviceCalendarServiceWeb();
}
````

## File: lib/features/calendar/domain/models/calendar_event.dart
````dart
/// Calendar event model for educational scheduling.
/// 
/// This module defines the event structure for calendar functionality,
/// supporting various educational event types like classes, assignments,
/// meetings, and exams with Firebase integration.
library;

import 'package:cloud_firestore/cloud_firestore.dart';

/// Enumeration of available event types.
enum EventType {
  /// Regular class sessions
  class_('Class'),
  
  /// Assignment deadlines
  assignment('Assignment'),
  
  /// Meetings with parents, staff, or students
  meeting('Meeting'),
  
  /// Exams and assessments
  exam('Exam'),
  
  /// Personal reminders and events
  personal('Personal'),
  
  /// School-wide events
  school('School'),
  
  /// Other event types
  other('Other');

  /// Display name for the event type
  final String displayName;
  
  const EventType(this.displayName);
  
  /// Creates EventType from string value
  static EventType fromString(String value) {
    return EventType.values.firstWhere(
      (type) => type.name == value.toLowerCase(),
      orElse: () => EventType.other,
    );
  }
}

/// Enumeration of event recurrence patterns.
enum RecurrenceType {
  /// One-time event
  none,
  
  /// Repeats daily
  daily,
  
  /// Repeats weekly on same day
  weekly,
  
  /// Repeats monthly on same date
  monthly,
  
  /// Repeats yearly on same date
  yearly,
  
  /// Custom recurrence pattern
  custom;
  
  /// Creates RecurrenceType from string value
  static RecurrenceType fromString(String value) {
    return RecurrenceType.values.firstWhere(
      (type) => type.name == value.toLowerCase(),
      orElse: () => RecurrenceType.none,
    );
  }
}

/// Calendar event model representing scheduled activities.
/// 
/// This model supports various educational events with features:
/// - Multiple event types (classes, assignments, meetings, etc.)
/// - Recurrence patterns for repeating events
/// - Participant tracking for meetings and classes
/// - Color coding for visual organization
/// - Rich metadata for event details
/// 
/// Events can be associated with classes, assignments, or standalone
/// activities in the educational platform.
class CalendarEvent {
  /// Unique identifier for the event
  final String id;
  
  /// Event title/name
  final String title;
  
  /// Detailed event description (optional)
  final String? description;
  
  /// Event category type
  final EventType type;
  
  /// Event start date and time
  final DateTime startTime;
  
  /// Event end date and time (optional)
  final DateTime? endTime;
  
  /// Whether this is an all-day event
  final bool isAllDay;
  
  /// Event location or room (optional)
  final String? location;
  
  /// Creator's user ID (teacher or admin)
  final String createdBy;
  
  /// Creator's display name for quick reference
  final String createdByName;
  
  /// Associated class ID (optional)
  final String? classId;
  
  /// Associated assignment ID (optional)
  final String? assignmentId;
  
  /// List of participant user IDs (optional)
  final List<String>? participantIds;
  
  /// List of participant emails for external attendees (optional)
  final List<String>? participantEmails;
  
  /// Event color for calendar display (hex string)
  final String? colorHex;
  
  /// Recurrence pattern for repeating events
  final RecurrenceType recurrence;
  
  /// End date for recurring events (optional)
  final DateTime? recurrenceEndDate;
  
  /// Custom recurrence pattern details (optional)
  final Map<String, dynamic>? recurrenceDetails;
  
  /// Whether to send reminders for this event
  final bool hasReminder;
  
  /// Reminder time in minutes before event
  final int? reminderMinutes;
  
  /// Additional metadata for extensibility
  final Map<String, dynamic>? metadata;
  
  /// Creation timestamp
  final DateTime createdAt;
  
  /// Last update timestamp
  final DateTime updatedAt;
  
  /// Whether the event is active (not cancelled)
  final bool isActive;

  /// Creates a calendar event instance.
  CalendarEvent({
    required this.id,
    required this.title,
    this.description,
    required this.type,
    required this.startTime,
    this.endTime,
    this.isAllDay = false,
    this.location,
    required this.createdBy,
    required this.createdByName,
    this.classId,
    this.assignmentId,
    this.participantIds,
    this.participantEmails,
    this.colorHex,
    this.recurrence = RecurrenceType.none,
    this.recurrenceEndDate,
    this.recurrenceDetails,
    this.hasReminder = false,
    this.reminderMinutes,
    this.metadata,
    required this.createdAt,
    required this.updatedAt,
    this.isActive = true,
  });

  /// Creates a CalendarEvent from Firestore document.
  factory CalendarEvent.fromFirestore(DocumentSnapshot doc) {
    final data = doc.data() as Map<String, dynamic>;
    
    return CalendarEvent(
      id: doc.id,
      title: data['title'] ?? '',
      description: data['description'],
      type: EventType.fromString(data['type'] ?? 'other'),
      startTime: (data['startTime'] as Timestamp).toDate(),
      endTime: data['endTime'] != null 
          ? (data['endTime'] as Timestamp).toDate() 
          : null,
      isAllDay: data['isAllDay'] ?? false,
      location: data['location'],
      createdBy: data['createdBy'] ?? '',
      createdByName: data['createdByName'] ?? '',
      classId: data['classId'],
      assignmentId: data['assignmentId'],
      participantIds: data['participantIds'] != null
          ? List<String>.from(data['participantIds'])
          : null,
      participantEmails: data['participantEmails'] != null
          ? List<String>.from(data['participantEmails'])
          : null,
      colorHex: data['colorHex'],
      recurrence: RecurrenceType.fromString(data['recurrence'] ?? 'none'),
      recurrenceEndDate: data['recurrenceEndDate'] != null
          ? (data['recurrenceEndDate'] as Timestamp).toDate()
          : null,
      recurrenceDetails: data['recurrenceDetails'],
      hasReminder: data['hasReminder'] ?? false,
      reminderMinutes: data['reminderMinutes'],
      metadata: data['metadata'],
      createdAt: (data['createdAt'] as Timestamp).toDate(),
      updatedAt: (data['updatedAt'] as Timestamp).toDate(),
      isActive: data['isActive'] ?? true,
    );
  }

  /// Converts CalendarEvent to Firestore document format.
  Map<String, dynamic> toFirestore() {
    return {
      'title': title,
      'description': description,
      'type': type.name,
      'startTime': Timestamp.fromDate(startTime),
      'endTime': endTime != null ? Timestamp.fromDate(endTime!) : null,
      'isAllDay': isAllDay,
      'location': location,
      'createdBy': createdBy,
      'createdByName': createdByName,
      'classId': classId,
      'assignmentId': assignmentId,
      'participantIds': participantIds,
      'participantEmails': participantEmails,
      'colorHex': colorHex,
      'recurrence': recurrence.name,
      'recurrenceEndDate': recurrenceEndDate != null 
          ? Timestamp.fromDate(recurrenceEndDate!) 
          : null,
      'recurrenceDetails': recurrenceDetails,
      'hasReminder': hasReminder,
      'reminderMinutes': reminderMinutes,
      'metadata': metadata,
      'createdAt': Timestamp.fromDate(createdAt),
      'updatedAt': Timestamp.fromDate(updatedAt),
      'isActive': isActive,
    };
  }

  /// Creates a copy with optional field updates.
  CalendarEvent copyWith({
    String? id,
    String? title,
    String? description,
    EventType? type,
    DateTime? startTime,
    DateTime? endTime,
    bool? isAllDay,
    String? location,
    String? createdBy,
    String? createdByName,
    String? classId,
    String? assignmentId,
    List<String>? participantIds,
    List<String>? participantEmails,
    String? colorHex,
    RecurrenceType? recurrence,
    DateTime? recurrenceEndDate,
    Map<String, dynamic>? recurrenceDetails,
    bool? hasReminder,
    int? reminderMinutes,
    Map<String, dynamic>? metadata,
    DateTime? createdAt,
    DateTime? updatedAt,
    bool? isActive,
  }) {
    return CalendarEvent(
      id: id ?? this.id,
      title: title ?? this.title,
      description: description ?? this.description,
      type: type ?? this.type,
      startTime: startTime ?? this.startTime,
      endTime: endTime ?? this.endTime,
      isAllDay: isAllDay ?? this.isAllDay,
      location: location ?? this.location,
      createdBy: createdBy ?? this.createdBy,
      createdByName: createdByName ?? this.createdByName,
      classId: classId ?? this.classId,
      assignmentId: assignmentId ?? this.assignmentId,
      participantIds: participantIds ?? this.participantIds,
      participantEmails: participantEmails ?? this.participantEmails,
      colorHex: colorHex ?? this.colorHex,
      recurrence: recurrence ?? this.recurrence,
      recurrenceEndDate: recurrenceEndDate ?? this.recurrenceEndDate,
      recurrenceDetails: recurrenceDetails ?? this.recurrenceDetails,
      hasReminder: hasReminder ?? this.hasReminder,
      reminderMinutes: reminderMinutes ?? this.reminderMinutes,
      metadata: metadata ?? this.metadata,
      createdAt: createdAt ?? this.createdAt,
      updatedAt: updatedAt ?? this.updatedAt,
      isActive: isActive ?? this.isActive,
    );
  }

  /// Checks if the event occurs on a specific date.
  /// 
  /// Takes into account recurrence patterns to determine
  /// if the event should appear on the given date.
  bool occursOn(DateTime date) {
    final dateOnly = DateTime(date.year, date.month, date.day);
    final eventDateOnly = DateTime(startTime.year, startTime.month, startTime.day);
    
    // Check if it's the original event date
    if (dateOnly == eventDateOnly) return true;
    
    // Check recurrence
    if (recurrence == RecurrenceType.none) return false;
    
    // Check if date is before event start or after recurrence end
    if (dateOnly.isBefore(eventDateOnly)) return false;
    if (recurrenceEndDate != null && dateOnly.isAfter(recurrenceEndDate!)) {
      return false;
    }
    
    switch (recurrence) {
      case RecurrenceType.daily:
        return true;
        
      case RecurrenceType.weekly:
        return date.weekday == startTime.weekday;
        
      case RecurrenceType.monthly:
        return date.day == startTime.day;
        
      case RecurrenceType.yearly:
        return date.month == startTime.month && date.day == startTime.day;
        
      case RecurrenceType.custom:
        // Handle custom recurrence logic based on recurrenceDetails
        return _checkCustomRecurrence(date);
        
      case RecurrenceType.none:
        return false;
    }
  }
  
  /// Checks custom recurrence pattern.
  bool _checkCustomRecurrence(DateTime date) {
    if (recurrenceDetails == null) return false;
    
    // Example custom patterns:
    // - Every other week
    // - First Monday of each month
    // - Every weekday
    // Implementation depends on specific requirements
    
    return false;
  }
  
  /// Gets the event duration.
  Duration? get duration {
    if (endTime == null) return null;
    return endTime!.difference(startTime);
  }
  
  /// Checks if the event is in the past.
  bool get isPast => endTime?.isBefore(DateTime.now()) ?? 
                     startTime.isBefore(DateTime.now());
  
  /// Checks if the event is happening now.
  bool get isHappeningNow {
    final now = DateTime.now();
    if (endTime != null) {
      return now.isAfter(startTime) && now.isBefore(endTime!);
    }
    return false;
  }
  
  /// Gets a display color for the event type.
  String get displayColor {
    if (colorHex != null) return colorHex!;
    
    switch (type) {
      case EventType.class_:
        return '#2196F3'; // Blue
      case EventType.assignment:
        return '#F44336'; // Red
      case EventType.meeting:
        return '#4CAF50'; // Green
      case EventType.exam:
        return '#FF9800'; // Orange
      case EventType.personal:
        return '#9C27B0'; // Purple
      case EventType.school:
        return '#00BCD4'; // Cyan
      case EventType.other:
        return '#607D8B'; // Blue Grey
    }
  }
}
````

## File: lib/features/calendar/domain/repositories/calendar_repository.dart
````dart
/// Abstract repository interface for calendar operations.
/// 
/// This module defines the contract for calendar data operations,
/// providing methods for managing calendar events in the educational
/// platform with support for various event types and recurrence patterns.
library;

import '../models/calendar_event.dart';

/// Repository interface for calendar event operations.
/// 
/// Provides abstract methods for CRUD operations on calendar events,
/// including support for filtering by date ranges, event types,
/// and participant associations.
abstract class CalendarRepository {
  /// Creates a new calendar event.
  /// 
  /// Returns the created event with assigned ID.
  Future<CalendarEvent> createEvent(CalendarEvent event);
  
  /// Updates an existing calendar event.
  /// 
  /// Returns the updated event.
  Future<CalendarEvent> updateEvent(CalendarEvent event);
  
  /// Deletes a calendar event by ID.
  Future<void> deleteEvent(String eventId);
  
  /// Gets a single event by ID.
  Future<CalendarEvent?> getEvent(String eventId);
  
  /// Gets all events for a specific user.
  /// 
  /// Returns events where the user is either the creator
  /// or a participant.
  Stream<List<CalendarEvent>> getUserEvents(String userId);
  
  /// Gets events for a specific date range.
  /// 
  /// Returns events that occur within the specified date range,
  /// including recurring events that have instances in the range.
  Stream<List<CalendarEvent>> getEventsByDateRange(
    String userId,
    DateTime startDate,
    DateTime endDate,
  );
  
  /// Gets events for a specific class.
  Stream<List<CalendarEvent>> getClassEvents(String classId);
  
  /// Gets events by type for a user.
  Stream<List<CalendarEvent>> getEventsByType(
    String userId,
    EventType type,
  );
  
  /// Gets upcoming events for a user.
  /// 
  /// Returns events occurring within the next specified number of days.
  Stream<List<CalendarEvent>> getUpcomingEvents(
    String userId,
    int daysAhead,
  );
  
  /// Gets events for a specific date.
  /// 
  /// Takes into account recurring events that occur on this date.
  Future<List<CalendarEvent>> getEventsForDate(
    String userId,
    DateTime date,
  );
  
  /// Adds a participant to an event.
  Future<void> addParticipant(String eventId, String participantId);
  
  /// Removes a participant from an event.
  Future<void> removeParticipant(String eventId, String participantId);
  
  /// Gets all participants for an event.
  Future<List<String>> getEventParticipants(String eventId);
  
  /// Checks if a user has permission to edit an event.
  Future<bool> canEditEvent(String userId, String eventId);
  
  /// Gets events that need reminders.
  /// 
  /// Returns events with reminders that should be sent within
  /// the specified time window.
  Stream<List<CalendarEvent>> getEventsNeedingReminders(
    DateTime fromTime,
    DateTime toTime,
  );
}
````

## File: lib/features/calendar/presentation/providers/calendar_provider.dart
````dart
/// State management for calendar functionality.
/// 
/// This module provides the calendar provider using ChangeNotifier
/// pattern, managing calendar events state and coordinating with
/// the calendar service for UI updates.
library;

import 'dart:async';
import 'package:flutter/material.dart';
import '../../domain/models/calendar_event.dart';
import '../../data/services/calendar_service.dart';
import '../../../../shared/core/service_locator.dart';

/// Provider for managing calendar state.
/// 
/// Handles:
/// - Loading and caching calendar events
/// - Managing selected dates and view modes
/// - Filtering events by type
/// - Real-time updates via streams
/// - Event creation/update/deletion
class CalendarProvider with ChangeNotifier {
  
  // State variables
  DateTime _selectedDate = DateTime.now();
  DateTime _focusedDate = DateTime.now();
  CalendarView _currentView = CalendarView.month;
  EventType? _filterType;
  
  // Events data
  List<CalendarEvent> _allEvents = [];
  Map<DateTime, List<CalendarEvent>> _eventsByDate = {};
  StreamSubscription<Map<DateTime, List<CalendarEvent>>>? _eventsSubscription;
  
  // Loading states
  bool _isLoading = false;
  String? _error;
  
  // User context
  String? _currentUserId;
  
  CalendarService? _calendarService;
  
  /// Gets the calendar service lazily.
  CalendarService get calendarService {
    if (_calendarService == null) {
      try {
        _calendarService = getIt<CalendarService>();
      } catch (e) {
        // Error getting CalendarService
        throw Exception('CalendarService not registered. Make sure setupServiceLocator() is called before using CalendarProvider. Error: $e');
      }
    }
    return _calendarService!;
  }
  
  /// Creates provider with calendar service.
  CalendarProvider() {
    // CalendarProvider initialized
  }
  
  // Getters
  DateTime get selectedDate => _selectedDate;
  DateTime get focusedDate => _focusedDate;
  CalendarView get currentView => _currentView;
  EventType? get filterType => _filterType;
  List<CalendarEvent> get allEvents => _allEvents;
  Map<DateTime, List<CalendarEvent>> get eventsByDate => _eventsByDate;
  bool get isLoading => _isLoading;
  String? get error => _error;
  
  /// Gets events for a specific date.
  List<CalendarEvent> getEventsForDate(DateTime date) {
    final dateKey = DateTime(date.year, date.month, date.day);
    return _eventsByDate[dateKey] ?? [];
  }
  
  /// Gets filtered events.
  List<CalendarEvent> get filteredEvents {
    if (_filterType == null) return _allEvents;
    return _allEvents.where((event) => event.type == _filterType).toList();
  }
  
  /// Initializes provider for a user.
  Future<void> initialize(String userId) async {
    _currentUserId = userId;
    await loadUserEvents();
  }
  
  /// Loads events for the current user.
  Future<void> loadUserEvents() async {
    if (_currentUserId == null) return;
    
    _isLoading = true;
    _error = null;
    notifyListeners();
    
    try {
      // Cancel previous subscription
      await _eventsSubscription?.cancel();
      
      // Subscribe to user events
      _eventsSubscription = calendarService
          .getEventsGroupedByDate(
            _currentUserId!,
            DateTime.now().subtract(const Duration(days: 365)),
            DateTime.now().add(const Duration(days: 365)),
          )
          .listen((grouped) {
        _eventsByDate = grouped;
        _allEvents = grouped.values.expand((events) => events).toList();
        _isLoading = false;
        notifyListeners();
      }, onError: (error) {
        _error = error.toString();
        _isLoading = false;
        notifyListeners();
      });
    } catch (e) {
      _error = e.toString();
      _isLoading = false;
      notifyListeners();
    }
  }
  
  /// Sets the selected date.
  void setSelectedDate(DateTime date) {
    _selectedDate = date;
    notifyListeners();
  }
  
  /// Sets the focused date (month/week view).
  void setFocusedDate(DateTime date) {
    _focusedDate = date;
    notifyListeners();
  }
  
  /// Changes the calendar view.
  void setView(CalendarView view) {
    _currentView = view;
    notifyListeners();
  }
  
  /// Sets event type filter.
  void setFilterType(EventType? type) {
    _filterType = type;
    notifyListeners();
  }
  
  /// Creates a new event.
  Future<void> createEvent({
    required String title,
    required EventType type,
    required DateTime startTime,
    DateTime? endTime,
    String? description,
    String? location,
    String? classId,
    String? assignmentId,
    List<String>? participantIds,
    bool isAllDay = false,
    RecurrenceType recurrence = RecurrenceType.none,
    DateTime? recurrenceEndDate,
    bool hasReminder = false,
    int? reminderMinutes,
    String? colorHex,
    bool syncToDeviceCalendar = false,
  }) async {
    if (_currentUserId == null) return;
    
    try {
      await calendarService.createEvent(
        title: title,
        createdBy: _currentUserId!,
        type: type,
        startTime: startTime,
        endTime: endTime,
        description: description,
        location: location,
        classId: classId,
        assignmentId: assignmentId,
        participantIds: participantIds,
        isAllDay: isAllDay,
        recurrence: recurrence,
        recurrenceEndDate: recurrenceEndDate,
        hasReminder: hasReminder,
        reminderMinutes: reminderMinutes,
        colorHex: colorHex ?? calendarService.getSuggestedColor(type),
        syncToDeviceCalendar: syncToDeviceCalendar,
      );
      
      // Events will update via stream
    } catch (e) {
      _error = e.toString();
      notifyListeners();
      rethrow;
    }
  }
  
  /// Updates an existing event.
  Future<void> updateEvent(CalendarEvent event) async {
    if (_currentUserId == null) return;
    
    try {
      await calendarService.updateEvent(_currentUserId!, event);
      // Events will update via stream
    } catch (e) {
      _error = e.toString();
      notifyListeners();
      rethrow;
    }
  }
  
  /// Deletes an event.
  Future<void> deleteEvent(String eventId) async {
    if (_currentUserId == null) return;
    
    try {
      await calendarService.deleteEvent(_currentUserId!, eventId);
      // Events will update via stream
    } catch (e) {
      _error = e.toString();
      notifyListeners();
      rethrow;
    }
  }
  
  /// Checks for conflicts with a proposed event time.
  Future<List<CalendarEvent>> checkConflicts(
    DateTime startTime,
    DateTime endTime,
  ) async {
    if (_currentUserId == null) return [];
    
    return await calendarService.checkConflicts(
      _currentUserId!,
      startTime,
      endTime,
    );
  }
  
  /// Gets events for export/sharing.
  String exportEventsToICS() {
    // TODO: Implement iCalendar format export
    return '';
  }
  
  /// Navigates to previous period based on view.
  void navigatePrevious() {
    switch (_currentView) {
      case CalendarView.month:
        _focusedDate = DateTime(
          _focusedDate.year,
          _focusedDate.month - 1,
        );
        break;
      case CalendarView.week:
        _focusedDate = _focusedDate.subtract(const Duration(days: 7));
        break;
      case CalendarView.agenda:
        _focusedDate = DateTime(
          _focusedDate.year,
          _focusedDate.month - 1,
        );
        break;
    }
    notifyListeners();
  }
  
  /// Navigates to next period based on view.
  void navigateNext() {
    switch (_currentView) {
      case CalendarView.month:
        _focusedDate = DateTime(
          _focusedDate.year,
          _focusedDate.month + 1,
        );
        break;
      case CalendarView.week:
        _focusedDate = _focusedDate.add(const Duration(days: 7));
        break;
      case CalendarView.agenda:
        _focusedDate = DateTime(
          _focusedDate.year,
          _focusedDate.month + 1,
        );
        break;
    }
    notifyListeners();
  }
  
  /// Goes to today.
  void goToToday() {
    _selectedDate = DateTime.now();
    _focusedDate = DateTime.now();
    notifyListeners();
  }
  
  @override
  void dispose() {
    _eventsSubscription?.cancel();
    super.dispose();
  }
}

/// Enumeration of calendar view modes.
enum CalendarView {
  month,
  week,
  agenda,
}
````

## File: lib/features/chat/data/repositories/chat_repository_impl.dart
````dart
/// Concrete implementation of the chat repository.
/// 
/// This module implements the ChatRepository interface using
/// Firebase Firestore as the data source. It provides comprehensive
/// chat functionality with real-time messaging and status tracking.
library;

import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:firebase_auth/firebase_auth.dart';
import '../../domain/models/message.dart';
import '../../domain/models/chat_room.dart';
import '../../../../shared/services/firestore_service.dart';
import '../../../../shared/services/logger_service.dart';
import '../../domain/repositories/chat_repository.dart';
import '../../../../shared/repositories/firestore_repository.dart';

/// Firestore-based implementation of ChatRepository.
/// 
/// This class extends FirestoreRepository to leverage common
/// CRUD operations while implementing chat-specific features:
/// - Direct and group chat creation with participant management
/// - Real-time messaging with delivery/read status tracking
/// - Message editing and deletion with audit trails
/// - Typing indicators and unread message counts
/// - Message search and chat room discovery
/// - Batch operations for performance optimization
/// 
/// Uses Firebase Auth for user identification and role detection.
/// Messages are stored as a subcollection under each chat room.
class ChatRepositoryImpl extends FirestoreRepository<ChatRoom> implements ChatRepository {
  /// Logger tag for this repository.
  static const String _tag = 'ChatRepository';
  
  /// Firestore instance for direct database operations.
  final FirebaseFirestore _firestore;
  
  /// Firebase Auth for user identification.
  final FirebaseAuth _auth;

  /// Creates a chat repository with Firestore and Auth integration.
  /// 
  /// Initializes the parent FirestoreRepository with chat-specific
  /// configuration and sets up authentication integration.
  /// 
  /// @param _firestore Firestore database instance
  /// @param _auth Firebase Auth instance
  ChatRepositoryImpl(this._firestore, this._auth)
      : super(
          firestore: _firestore,
          collectionPath: 'chat_rooms',
          fromFirestore: (doc) => ChatRoom.fromFirestore(doc),
          toFirestore: (chatRoom) => chatRoom.toFirestore(),
          logTag: _tag,
        );

  /// Gets the current user's ID from Firebase Auth.
  /// 
  /// Returns empty string if no user is authenticated.
  String get _currentUserId => _auth.currentUser?.uid ?? '';

  /// Creates a new chat room with automatic timestamps.
  /// 
  /// Sets creation and update timestamps to current time.
  /// The chat room ID is generated by Firestore for uniqueness.
  /// 
  /// @param chatRoom Chat room configuration with participants
  /// @return Generated unique chat room ID
  /// @throws Exception if creation fails
  @override
  Future<String> createChatRoom(ChatRoom chatRoom) async {
    try {
      final chatRoomToCreate = chatRoom.copyWith(
        createdAt: DateTime.now(),
        updatedAt: DateTime.now(),
      );
      return await create(chatRoomToCreate);
    } catch (e) {
      LoggerService.error('Failed to create chat room', tag: _tag, error: e);
      rethrow;
    }
  }

  /// Retrieves a chat room by its unique identifier.
  /// 
  /// Delegates to parent repository for consistent error handling.
  /// 
  /// @param id Unique chat room identifier
  /// @return Chat room instance or null if not found
  @override
  Future<ChatRoom?> getChatRoom(String id) => read(id);

  /// Updates an existing chat room with new timestamp.
  /// 
  /// Automatically updates the modification timestamp while
  /// preserving other metadata like creation date.
  /// 
  /// @param id Chat room ID to update
  /// @param chatRoom Updated chat room information
  /// @throws Exception if update fails
  @override
  Future<void> updateChatRoom(String id, ChatRoom chatRoom) async {
    try {
      final chatRoomToUpdate = chatRoom.copyWith(
        updatedAt: DateTime.now(),
      );
      await update(id, chatRoomToUpdate);
    } catch (e) {
      LoggerService.error('Failed to update chat room', tag: _tag, error: e);
      rethrow;
    }
  }

  /// Permanently deletes a chat room and all messages.
  /// 
  /// This operation cannot be undone. Consider archiving
  /// for recoverable operations.
  /// 
  /// @param id Chat room ID to delete
  /// @throws Exception if deletion fails
  @override
  Future<void> deleteChatRoom(String id) => delete(id);

  /// Creates or retrieves an existing direct chat.
  /// 
  /// Intelligent chat handling:
  /// - Checks for existing direct chat between users
  /// - Returns existing chat if found
  /// - Creates new direct chat if none exists
  /// 
  /// This ensures users don't create duplicate direct chats.
  /// Direct chats are named after the other participant.
  /// 
  /// @param otherUserId ID of the other participant
  /// @param otherUserName Display name of other participant
  /// @param otherUserRole Role of other participant
  /// @return Created or existing chat room
  /// @throws Exception if operation fails
  @override
  Future<ChatRoom> createOrGetDirectChat(
    String otherUserId,
    String otherUserName,
    String otherUserRole,
  ) async {
    try {
      // Check if direct chat already exists
      final existing = await findDirectChat(_currentUserId, otherUserId);
      if (existing != null) {
        return existing;
      }

      // Create new direct chat
      final participants = [
        ParticipantInfo(
          id: _currentUserId,
          name: _auth.currentUser?.displayName ?? 'User',
          role: 'user', // This should be fetched from user profile
        ),
        ParticipantInfo(
          id: otherUserId,
          name: otherUserName,
          role: otherUserRole,
        ),
      ];

      final chatRoom = ChatRoom(
        id: '',
        name: otherUserName,
        type: 'direct',
        participantIds: [_currentUserId, otherUserId],
        participants: participants,
        createdBy: _currentUserId,
        createdAt: DateTime.now(),
        updatedAt: DateTime.now(),
      );

      final id = await createChatRoom(chatRoom);
      return chatRoom.copyWith(id: id);
    } catch (e) {
      LoggerService.error('Failed to create or get direct chat', tag: _tag, error: e);
      rethrow;
    }
  }

  /// Creates a new group chat room.
  /// 
  /// Supports different group types:
  /// - 'group': General purpose groups
  /// - 'class': Class-specific discussions
  /// - 'announcement': Broadcast channels
  /// 
  /// Automatically adds the creator as a participant.
  /// 
  /// @param name Display name for the group
  /// @param type Group type identifier
  /// @param participantIds List of participant user IDs
  /// @param participants List of participant info objects
  /// @param classId Optional class association
  /// @return Created group chat room
  /// @throws Exception if creation fails
  @override
  Future<ChatRoom> createGroupChat({
    required String name,
    required String type,
    required List<String> participantIds,
    required List<ParticipantInfo> participants,
    String? classId,
  }) async {
    try {
      final chatRoom = ChatRoom(
        id: '',
        name: name,
        type: type,
        participantIds: participantIds,
        participants: participants,
        classId: classId,
        createdBy: _currentUserId,
        createdAt: DateTime.now(),
        updatedAt: DateTime.now(),
      );

      final id = await createChatRoom(chatRoom);
      return chatRoom.copyWith(id: id);
    } catch (e) {
      LoggerService.error('Failed to create group chat', tag: _tag, error: e);
      rethrow;
    }
  }

  /// Sends a message to a chat room.
  /// 
  /// Process:
  /// 1. Creates message with sender info and timestamp
  /// 2. Adds to messages subcollection
  /// 3. Updates chat room's last message info
  /// 4. Increments unread counts for other participants
  /// 
  /// Supports text messages and attachments.
  /// 
  /// @param chatRoomId Target chat room
  /// @param content Message text content
  /// @param attachmentUrl Optional file attachment URL
  /// @param attachmentType Optional attachment MIME type
  /// @return Generated message ID
  /// @throws Exception if sending fails
  @override
  Future<String> sendMessage({
    required String chatRoomId,
    required String content,
    String? attachmentUrl,
    String? attachmentType,
  }) async {
    try {
      final message = Message(
        id: '',
        senderId: _currentUserId,
        senderName: _auth.currentUser?.displayName ?? 'User',
        senderRole: _auth.currentUser?.email?.endsWith('@teacher.edu') == true ? 'teacher' : 'student',
        content: content,
        attachmentUrl: attachmentUrl,
        attachmentType: attachmentType,
        timestamp: DateTime.now(),
      );

      // Add message to subcollection
      final ref = _firestore
          .collection('chat_rooms')
          .doc(chatRoomId)
          .collection('messages')
          .doc();
      
      final messageWithId = message.copyWith(id: ref.id);
      await ref.set(messageWithId.toFirestore());

      // Update last message in chat room
      await updateLastMessage(chatRoomId, messageWithId);

      LoggerService.info('Message sent to chat room $chatRoomId', tag: _tag);
      return ref.id;
    } catch (e) {
      LoggerService.error('Failed to send message', tag: _tag, error: e);
      rethrow;
    }
  }

  /// Deletes a message from a chat room.
  /// 
  /// Permanently removes the message. Consider soft deletion
  /// by updating message content for audit trails.
  /// 
  /// @param chatRoomId Chat room containing the message
  /// @param messageId Message to delete
  /// @throws Exception if deletion fails
  @override
  Future<void> deleteMessage(String chatRoomId, String messageId) async {
    try {
      await _firestore
          .collection('chat_rooms')
          .doc(chatRoomId)
          .collection('messages')
          .doc(messageId)
          .delete();
      
      LoggerService.info('Message $messageId deleted from chat room $chatRoomId', tag: _tag);
    } catch (e) {
      LoggerService.error('Failed to delete message', tag: _tag, error: e);
      rethrow;
    }
  }

  /// Edits an existing message content.
  /// 
  /// Updates the message content and marks it as edited
  /// with an edit timestamp for transparency.
  /// 
  /// @param chatRoomId Chat room containing the message
  /// @param messageId Message to edit
  /// @param newContent Updated message content
  /// @throws Exception if edit fails
  @override
  Future<void> editMessage(String chatRoomId, String messageId, String newContent) async {
    try {
      await _firestore
          .collection('chat_rooms')
          .doc(chatRoomId)
          .collection('messages')
          .doc(messageId)
          .update({
            'content': newContent,
            'isEdited': true,
            'editedAt': FieldValue.serverTimestamp(),
          });
      
      LoggerService.info('Message $messageId edited in chat room $chatRoomId', tag: _tag);
    } catch (e) {
      LoggerService.error('Failed to edit message', tag: _tag, error: e);
      rethrow;
    }
  }

  /// Streams all chat rooms for the current user.
  /// 
  /// Returns real-time updates of chat rooms where the user
  /// is a participant, ordered by most recent activity.
  /// 
  /// @return Stream of user's chat room lists
  @override
  Stream<List<ChatRoom>> getUserChatRooms() {
    return stream(
      conditions: [
        QueryCondition(field: 'participantIds', arrayContains: _currentUserId),
      ],
      orderBy: [OrderBy(field: 'updatedAt', descending: true)],
    );
  }

  /// Streams messages for a specific chat room.
  /// 
  /// Returns real-time updates of the latest 100 messages,
  /// ordered by most recent first for chat UI display.
  /// 
  /// @param chatRoomId Chat room to monitor
  /// @return Stream of message lists
  @override
  Stream<List<Message>> getChatMessages(String chatRoomId) {
    return _firestore
        .collection('chat_rooms')
        .doc(chatRoomId)
        .collection('messages')
        .orderBy('timestamp', descending: true)
        .limit(100)
        .snapshots()
        .map((snapshot) => snapshot.docs
            .map((doc) => Message.fromFirestore(doc))
            .toList());
  }

  /// Adds a participant to a chat room.
  /// 
  /// Updates both the participant ID list and participant
  /// info array. Uses arrayUnion to prevent duplicates.
  /// 
  /// @param chatRoomId Chat room to update
  /// @param userId New participant's user ID
  /// @param participantInfo New participant's info
  /// @throws Exception if addition fails
  @override
  Future<void> addParticipant(String chatRoomId, String userId, ParticipantInfo participantInfo) async {
    try {
      await _firestore.collection('chat_rooms').doc(chatRoomId).update({
        'participantIds': FieldValue.arrayUnion([userId]),
        'participants': FieldValue.arrayUnion([participantInfo.toMap()]),
        'updatedAt': FieldValue.serverTimestamp(),
      });
      
      LoggerService.info('Participant $userId added to chat room $chatRoomId', tag: _tag);
    } catch (e) {
      LoggerService.error('Failed to add participant', tag: _tag, error: e);
      rethrow;
    }
  }

  /// Removes a participant from a chat room.
  /// 
  /// Retrieves participant info to ensure complete removal
  /// from both ID and info arrays.
  /// 
  /// @param chatRoomId Chat room to update
  /// @param userId Participant to remove
  /// @throws Exception if removal fails
  @override
  Future<void> removeParticipant(String chatRoomId, String userId) async {
    try {
      // Get chat room to find participant info
      final chatRoom = await getChatRoom(chatRoomId);
      if (chatRoom == null) return;

      final participant = chatRoom.participants.firstWhere(
        (p) => p.id == userId,
        orElse: () => ParticipantInfo(id: userId, name: '', role: ''),
      );

      await _firestore.collection('chat_rooms').doc(chatRoomId).update({
        'participantIds': FieldValue.arrayRemove([userId]),
        'participants': FieldValue.arrayRemove([participant.toMap()]),
        'updatedAt': FieldValue.serverTimestamp(),
      });
      
      LoggerService.info('Participant $userId removed from chat room $chatRoomId', tag: _tag);
    } catch (e) {
      LoggerService.error('Failed to remove participant', tag: _tag, error: e);
      rethrow;
    }
  }

  /// Removes the current user from a chat room.
  /// 
  /// Convenience method that removes the authenticated
  /// user as a participant.
  /// 
  /// @param chatRoomId Chat room to leave
  /// @throws Exception if leaving fails
  @override
  Future<void> leaveChatRoom(String chatRoomId) async {
    try {
      await removeParticipant(chatRoomId, _currentUserId);
    } catch (e) {
      LoggerService.error('Failed to leave chat room', tag: _tag, error: e);
      rethrow;
    }
  }

  /// Updates the chat room's last message metadata.
  /// 
  /// Stores message preview information for chat list display.
  /// Updates modification timestamp for proper ordering.
  /// 
  /// @param chatRoomId Chat room to update
  /// @param message Latest message sent
  /// @throws Exception if update fails
  @override
  Future<void> updateLastMessage(String chatRoomId, Message message) async {
    try {
      await _firestore.collection('chat_rooms').doc(chatRoomId).update({
        'lastMessage': message.content,
        'lastMessageTime': message.timestamp,
        'lastMessageSenderId': message.senderId,
        'lastMessageSenderName': message.senderName,
        'updatedAt': FieldValue.serverTimestamp(),
      });
    } catch (e) {
      LoggerService.error('Failed to update last message', tag: _tag, error: e);
      rethrow;
    }
  }

  /// Marks all unread messages in a chat as read.
  /// 
  /// Process:
  /// 1. Queries unread messages from other users
  /// 2. Batch updates status to 'read'
  /// 3. Resets unread count for current user
  /// 
  /// Uses batch operations for efficiency with many messages.
  /// 
  /// @param chatRoomId Chat room to mark as read
  /// @throws Exception if marking fails
  @override
  Future<void> markMessagesAsRead(String chatRoomId) async {
    try {
      // Get all delivered messages and filter in memory to avoid complex index
      final deliveredMessages = await _firestore
          .collection('chat_rooms')
          .doc(chatRoomId)
          .collection('messages')
          .where('status', isEqualTo: MessageStatus.delivered.name)
          .get();
          
      // Filter out current user's messages
      final unreadMessages = deliveredMessages.docs
          .where((doc) => doc.data()['senderId'] != _currentUserId)
          .toList();

      // Batch update to read status
      final batch = _firestore.batch();
      for (final doc in unreadMessages) {
        batch.update(doc.reference, {
          'status': MessageStatus.read.name,
          'readAt': FieldValue.serverTimestamp(),
        });
      }
      
      await batch.commit();
      
      // Update unread count in chat room
      await _firestore.collection('chat_rooms').doc(chatRoomId).update({
        'unreadCounts.$_currentUserId': 0,
      });
      
      LoggerService.info('Marked ${unreadMessages.length} messages as read', tag: _tag);
    } catch (e) {
      LoggerService.error('Failed to mark messages as read', tag: _tag, error: e);
      rethrow;
    }
  }

  /// Marks a single message as delivered.
  /// 
  /// Updates message status and records delivery timestamp.
  /// Typically called when message appears in recipient's UI.
  /// 
  /// @param chatRoomId Chat room containing the message
  /// @param messageId Message to mark as delivered
  /// @throws Exception if marking fails
  @override
  Future<void> markMessageAsDelivered(String chatRoomId, String messageId) async {
    try {
      await _firestore
          .collection('chat_rooms')
          .doc(chatRoomId)
          .collection('messages')
          .doc(messageId)
          .update({
            'status': MessageStatus.delivered.name,
            'deliveredAt': FieldValue.serverTimestamp(),
          });
    } catch (e) {
      LoggerService.error('Failed to mark message as delivered', tag: _tag, error: e);
      rethrow;
    }
  }

  /// Searches for messages containing specific text.
  /// 
  /// Performs case-insensitive search through message content.
  /// Current implementation loads all messages and filters
  /// client-side. For production with large message volumes,
  /// consider implementing server-side search with:
  /// - Firestore composite indexes
  /// - External search services (Algolia, Elasticsearch)
  /// - Pagination for large result sets
  /// 
  /// @param chatRoomId Chat room to search within
  /// @param query Search terms to match
  /// @return List of matching messages
  /// @throws Exception if search fails
  @override
  Future<List<Message>> searchMessages(String chatRoomId, String query) async {
    try {
      // Note: This is a simple implementation. For better search,
      // consider using a search service like Algolia
      final messages = await _firestore
          .collection('chat_rooms')
          .doc(chatRoomId)
          .collection('messages')
          .get();
      
      final lowercaseQuery = query.toLowerCase();
      return messages.docs
          .map((doc) => Message.fromFirestore(doc))
          .where((message) => message.content.toLowerCase().contains(lowercaseQuery))
          .toList();
    } catch (e) {
      LoggerService.error('Failed to search messages', tag: _tag, error: e);
      rethrow;
    }
  }

  /// Searches for chat rooms by name.
  /// 
  /// Performs case-insensitive search through chat room names
  /// where the user is a participant. Client-side filtering
  /// approach suitable for moderate chat room counts.
  /// 
  /// @param query Search terms to match room names
  /// @return List of matching chat rooms
  /// @throws Exception if search fails
  @override
  Future<List<ChatRoom>> searchChatRooms(String query) async {
    try {
      final chatRooms = await list(
        conditions: [
          QueryCondition(field: 'participantIds', arrayContains: _currentUserId),
        ],
      );
      
      final lowercaseQuery = query.toLowerCase();
      return chatRooms.where((room) => 
        room.name.toLowerCase().contains(lowercaseQuery)
      ).toList();
    } catch (e) {
      LoggerService.error('Failed to search chat rooms', tag: _tag, error: e);
      rethrow;
    }
  }

  /// Finds an existing direct chat between two users.
  /// 
  /// Searches for a direct chat room containing exactly the
  /// specified two users. Used to prevent duplicate direct
  /// chat creation.
  /// 
  /// @param userId1 First user's ID
  /// @param userId2 Second user's ID
  /// @return Existing chat room or null if none found
  /// @throws Exception if search fails
  @override
  Future<ChatRoom?> findDirectChat(String userId1, String userId2) async {
    try {
      final chatRooms = await list(
        conditions: [
          QueryCondition(field: 'type', isEqualTo: 'direct'),
          QueryCondition(field: 'participantIds', arrayContains: userId1),
        ],
      );
      
      return chatRooms.firstWhere(
        (room) => room.participantIds.contains(userId2) && room.participantIds.length == 2,
        orElse: () => null as dynamic,
      );
    } catch (e) {
      LoggerService.error('Failed to find direct chat', tag: _tag, error: e);
      rethrow;
    }
  }

  /// Updates the current user's typing status.
  /// 
  /// Sets or clears typing indicator for real-time feedback.
  /// Status is stored per-user in the chat room document.
  /// 
  /// @param chatRoomId Chat room where typing occurs
  /// @param isTyping true if typing, false when stopped
  /// @throws Exception if status update fails
  @override
  Future<void> setTypingStatus(String chatRoomId, bool isTyping) async {
    try {
      await _firestore.collection('chat_rooms').doc(chatRoomId).update({
        'typingUsers.$_currentUserId': isTyping,
      });
    } catch (e) {
      LoggerService.error('Failed to set typing status', tag: _tag, error: e);
      rethrow;
    }
  }

  /// Streams real-time typing status for all users.
  /// 
  /// Returns a map of user IDs to typing status (true/false).
  /// Updates in real-time as users start or stop typing.
  /// Empty map returned if no typing data available.
  /// 
  /// @param chatRoomId Chat room to monitor
  /// @return Stream of user typing statuses
  @override
  Stream<Map<String, bool>> getTypingStatuses(String chatRoomId) {
    return _firestore
        .collection('chat_rooms')
        .doc(chatRoomId)
        .snapshots()
        .map((snapshot) {
          final data = snapshot.data();
          if (data != null && data['typingUsers'] != null) {
            return Map<String, bool>.from(data['typingUsers'] as Map);
          }
          return {};
        });
  }

  /// Gets unread message count for current user.
  /// 
  /// Retrieves the cached unread count from the chat room
  /// document. Returns 0 if no count found or on error.
  /// Count is updated when new messages arrive.
  /// 
  /// @param chatRoomId Chat room to check
  /// @return Number of unread messages
  @override
  Future<int> getUnreadCount(String chatRoomId) async {
    try {
      final chatRoom = await getChatRoom(chatRoomId);
      if (chatRoom?.unreadCounts != null) {
        return chatRoom!.unreadCounts![_currentUserId] ?? 0;
      }
      return 0;
    } catch (e) {
      LoggerService.error('Failed to get unread count', tag: _tag, error: e);
      return 0;
    }
  }

  /// Gets unread counts across all user's chat rooms.
  /// 
  /// Aggregates unread message counts from all chat rooms
  /// where the user is a participant. Useful for:
  /// - Badge counts in navigation
  /// - Notification summaries
  /// - Priority sorting of chats
  /// 
  /// @return Map of chat room ID to unread count
  @override
  Future<Map<String, int>> getAllUnreadCounts() async {
    try {
      final chatRooms = await list(
        conditions: [
          QueryCondition(field: 'participantIds', arrayContains: _currentUserId),
        ],
      );
      
      final unreadCounts = <String, int>{};
      for (final room in chatRooms) {
        if (room.unreadCounts != null && room.unreadCounts![_currentUserId] != null) {
          unreadCounts[room.id] = room.unreadCounts![_currentUserId]!;
        }
      }
      
      return unreadCounts;
    } catch (e) {
      LoggerService.error('Failed to get all unread counts', tag: _tag, error: e);
      return {};
    }
  }

  /// Deletes multiple messages in one atomic operation.
  /// 
  /// Efficient bulk deletion for:
  /// - Message cleanup
  /// - Moderation actions
  /// - Storage management
  /// 
  /// All deletions succeed or fail together.
  /// 
  /// @param chatRoomId Chat room containing messages
  /// @param messageIds List of message IDs to delete
  /// @throws Exception if batch deletion fails
  @override
  Future<void> batchDeleteMessages(String chatRoomId, List<String> messageIds) async {
    try {
      final batch = _firestore.batch();
      
      for (final messageId in messageIds) {
        final ref = _firestore
            .collection('chat_rooms')
            .doc(chatRoomId)
            .collection('messages')
            .doc(messageId);
        batch.delete(ref);
      }
      
      await batch.commit();
      LoggerService.info('Batch deleted ${messageIds.length} messages', tag: _tag);
    } catch (e) {
      LoggerService.error('Failed to batch delete messages', tag: _tag, error: e);
      rethrow;
    }
  }

  /// Updates multiple message statuses in one atomic operation.
  /// 
  /// Efficient bulk status update for:
  /// - Marking multiple messages as delivered
  /// - Batch marking as read
  /// - Status synchronization
  /// 
  /// Automatically sets appropriate timestamps:
  /// - deliveredAt for delivered status
  /// - readAt for read status
  /// 
  /// @param chatRoomId Chat room containing messages
  /// @param messageIds List of message IDs to update
  /// @param status New status to apply
  /// @throws Exception if batch update fails
  @override
  Future<void> batchUpdateMessageStatus(String chatRoomId, List<String> messageIds, MessageStatus status) async {
    try {
      final batch = _firestore.batch();
      final now = DateTime.now();
      
      for (final messageId in messageIds) {
        final ref = _firestore
            .collection('chat_rooms')
            .doc(chatRoomId)
            .collection('messages')
            .doc(messageId);
        
        final updates = <String, dynamic>{
          'status': status.name,
        };
        
        if (status == MessageStatus.delivered) {
          updates['deliveredAt'] = now;
        } else if (status == MessageStatus.read) {
          updates['readAt'] = now;
        }
        
        batch.update(ref, updates);
      }
      
      await batch.commit();
      LoggerService.info('Batch updated ${messageIds.length} messages to status ${status.name}', tag: _tag);
    } catch (e) {
      LoggerService.error('Failed to batch update message status', tag: _tag, error: e);
      rethrow;
    }
  }
}
````

## File: lib/features/chat/data/services/chat_service.dart
````dart
/// Chat service for managing real-time messaging in the education platform.
/// 
/// This service provides comprehensive chat functionality including
/// direct messages, group chats, and class-wide communication channels.
library;

import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:firebase_auth/firebase_auth.dart';
import '../../domain/models/message.dart';
import '../../domain/models/chat_room.dart';

/// Core service for managing chat rooms and messages in Firestore.
/// 
/// This service handles:
/// - Direct messaging between users
/// - Group chat creation and management
/// - Real-time message streaming
/// - Read receipts and unread counts
/// - Message search functionality
/// - Chat room lifecycle management
/// 
/// All operations require authentication and enforce
/// user-specific access controls.
class ChatService {
  /// Firestore instance for database operations.
  final FirebaseFirestore _firestore = FirebaseFirestore.instance;
  
  /// Firebase Auth instance for user authentication.
  final FirebaseAuth _auth = FirebaseAuth.instance;

  /// Gets the current authenticated user's ID.
  /// 
  /// Returns null if no user is signed in.
  /// 
  /// @return Current user's UID or null
  String? get currentUserId => _auth.currentUser?.uid;

  /// Creates or retrieves a direct chat room between two users.
  /// 
  /// For direct chats, generates a consistent room ID by sorting
  /// user IDs alphabetically. This ensures the same room is used
  /// regardless of who initiates the chat.
  /// 
  /// If the room doesn't exist, creates it with both participants'
  /// information. The current user's role is hardcoded as 'teacher'
  /// (TODO: fetch from user profile).
  /// 
  /// @param otherUserId ID of the other participant
  /// @param otherUserName Display name of the other participant
  /// @param otherUserRole Role of the other participant (teacher/student)
  /// @return ChatRoom instance for the direct chat
  /// @throws Exception if user is not authenticated
  Future<ChatRoom> createOrGetDirectChat(String otherUserId, String otherUserName, String otherUserRole) async {
    final currentUser = _auth.currentUser;
    if (currentUser == null) throw Exception('User not authenticated');

    // Sort user IDs to ensure consistent chat room ID
    final List<String> userIds = [currentUser.uid, otherUserId]..sort();
    final chatRoomId = '${userIds[0]}_${userIds[1]}';

    // Check if chat room already exists
    final chatRoomDoc = await _firestore.collection('chat_rooms').doc(chatRoomId).get();
    
    if (chatRoomDoc.exists) {
      return ChatRoom.fromFirestore(chatRoomDoc);
    }

    // Create new chat room
    final newChatRoom = {
      'name': otherUserName,
      'type': 'direct',
      'participantIds': userIds,
      'participants': [
        {
          'id': currentUser.uid,
          'name': currentUser.displayName ?? 'Unknown',
          'role': 'teacher', // This should be fetched from user profile
          'photoUrl': currentUser.photoURL,
        },
        {
          'id': otherUserId,
          'name': otherUserName,
          'role': otherUserRole,
          'photoUrl': null, // This should be fetched from user profile
        },
      ],
      'createdAt': FieldValue.serverTimestamp(),
      'lastMessage': null,
      'lastMessageTime': null,
      'lastMessageSenderId': null,
      'unreadCount': 0,
    };

    await _firestore.collection('chat_rooms').doc(chatRoomId).set(newChatRoom);
    final newDoc = await _firestore.collection('chat_rooms').doc(chatRoomId).get();
    return ChatRoom.fromFirestore(newDoc);
  }

  /// Creates a new group or class chat room.
  /// 
  /// Supports creating chat rooms for:
  /// - Groups of users (custom participant lists)
  /// - Class-wide communication (linked to a class ID)
  /// 
  /// The creator must be authenticated and will automatically
  /// be included in the participant list.
  /// 
  /// @param name Display name for the chat room
  /// @param type Chat type ('group' or 'class')
  /// @param participantIds List of user IDs who can access the chat
  /// @param participants List of participant info objects
  /// @param classId Optional class ID for class-specific chats
  /// @return Created ChatRoom instance
  /// @throws Exception if user is not authenticated
  Future<ChatRoom> createGroupChat({
    required String name,
    required String type,
    required List<String> participantIds,
    required List<ParticipantInfo> participants,
    String? classId,
  }) async {
    final currentUser = _auth.currentUser;
    if (currentUser == null) throw Exception('User not authenticated');

    final chatRoomRef = _firestore.collection('chat_rooms').doc();
    
    final chatRoomData = {
      'name': name,
      'type': type,
      'participantIds': participantIds,
      'participants': participants.map((p) => p.toMap()).toList(),
      'classId': classId,
      'createdAt': FieldValue.serverTimestamp(),
      'lastMessage': null,
      'lastMessageTime': null,
      'lastMessageSenderId': null,
      'unreadCount': 0,
    };

    await chatRoomRef.set(chatRoomData);
    final newDoc = await chatRoomRef.get();
    return ChatRoom.fromFirestore(newDoc);
  }

  /// Streams all chat rooms for the current user.
  /// 
  /// Returns a real-time stream of chat rooms where the
  /// current user is a participant. Rooms are ordered by
  /// last message time (most recent first).
  /// 
  /// Returns empty stream if user is not authenticated.
  /// 
  /// @return Stream of ChatRoom lists, updated in real-time
  Stream<List<ChatRoom>> getUserChatRooms() {
    final currentUser = _auth.currentUser;
    if (currentUser == null) return Stream.value([]);

    return _firestore
        .collection('chat_rooms')
        .where('participantIds', arrayContains: currentUser.uid)
        .orderBy('lastMessageTime', descending: true)
        .snapshots()
        .map((snapshot) => snapshot.docs
            .map((doc) => ChatRoom.fromFirestore(doc))
            .toList());
  }

  /// Streams messages for a specific chat room.
  /// 
  /// Returns a real-time stream of messages ordered by
  /// timestamp (newest first). This stream updates automatically
  /// when new messages are added or existing messages change.
  /// 
  /// @param chatRoomId ID of the chat room to get messages from
  /// @return Stream of Message lists, updated in real-time
  Stream<List<Message>> getChatMessages(String chatRoomId) {
    return _firestore
        .collection('chat_rooms')
        .doc(chatRoomId)
        .collection('messages')
        .orderBy('timestamp', descending: true)
        .snapshots()
        .map((snapshot) => snapshot.docs
            .map((doc) => Message.fromFirestore(doc))
            .toList());
  }

  /// Sends a new message to a chat room.
  /// 
  /// Creates a message with the current user as sender and
  /// adds it to the chat room's messages subcollection.
  /// Also updates the chat room's last message metadata.
  /// 
  /// The sender's role is hardcoded as 'teacher'
  /// (TODO: fetch from user profile).
  /// 
  /// @param chatRoomId Target chat room ID
  /// @param content Text content of the message
  /// @param attachmentUrl Optional URL for file attachments
  /// @param attachmentType Optional attachment MIME type
  /// @throws Exception if user is not authenticated
  Future<void> sendMessage({
    required String chatRoomId,
    required String content,
    String? attachmentUrl,
    String? attachmentType,
  }) async {
    final currentUser = _auth.currentUser;
    if (currentUser == null) throw Exception('User not authenticated');

    final messageData = {
      'senderId': currentUser.uid,
      'senderName': currentUser.displayName ?? 'Unknown',
      'senderRole': 'teacher', // This should be fetched from user profile
      'content': content,
      'timestamp': FieldValue.serverTimestamp(),
      'isRead': false,
      'attachmentUrl': attachmentUrl,
      'attachmentType': attachmentType,
    };

    // Add message to subcollection
    await _firestore
        .collection('chat_rooms')
        .doc(chatRoomId)
        .collection('messages')
        .add(messageData);

    // Update chat room with last message info
    await _firestore.collection('chat_rooms').doc(chatRoomId).update({
      'lastMessage': content,
      'lastMessageTime': FieldValue.serverTimestamp(),
      'lastMessageSenderId': currentUser.uid,
    });
  }

  /// Marks all unread messages in a chat room as read.
  /// 
  /// Updates all messages that:
  /// - Are marked as unread
  /// - Were not sent by the current user
  /// 
  /// Also resets the unread count for the chat room.
  /// Uses batch operations for efficiency.
  /// 
  /// @param chatRoomId Chat room to mark messages in
  Future<void> markMessagesAsRead(String chatRoomId) async {
    final currentUser = _auth.currentUser;
    if (currentUser == null) return;

    final batch = _firestore.batch();
    
    // Get all unread messages and filter in memory to avoid complex index
    final allUnreadMessages = await _firestore
        .collection('chat_rooms')
        .doc(chatRoomId)
        .collection('messages')
        .where('isRead', isEqualTo: false)
        .get();
        
    // Filter out current user's messages
    final unreadMessages = allUnreadMessages.docs
        .where((doc) => doc.data()['senderId'] != currentUser.uid)
        .toList();

    for (final doc in unreadMessages) {
      batch.update(doc.reference, {'isRead': true});
    }

    // Reset unread count for current user
    batch.update(
      _firestore.collection('chat_rooms').doc(chatRoomId),
      {'unreadCount': 0},
    );

    await batch.commit();
  }

  /// Deletes a specific message from a chat room.
  /// 
  /// Permanently removes the message from Firestore.
  /// This operation cannot be undone.
  /// 
  /// @param chatRoomId Chat room containing the message
  /// @param messageId ID of the message to delete
  Future<void> deleteMessage(String chatRoomId, String messageId) async {
    await _firestore
        .collection('chat_rooms')
        .doc(chatRoomId)
        .collection('messages')
        .doc(messageId)
        .delete();
  }

  /// Removes the current user from a chat room.
  /// 
  /// For group chats only - removes the user from both
  /// the participantIds array and the participants list.
  /// The user's role is hardcoded as 'teacher'
  /// (TODO: fetch from user profile).
  /// 
  /// Direct chats should not use this method.
  /// 
  /// @param chatRoomId ID of the chat room to leave
  Future<void> leaveChatRoom(String chatRoomId) async {
    final currentUser = _auth.currentUser;
    if (currentUser == null) return;

    await _firestore.collection('chat_rooms').doc(chatRoomId).update({
      'participantIds': FieldValue.arrayRemove([currentUser.uid]),
      'participants': FieldValue.arrayRemove([
        {
          'id': currentUser.uid,
          'name': currentUser.displayName ?? 'Unknown',
          'role': 'teacher', // This should be fetched from user profile
          'photoUrl': currentUser.photoURL,
        }
      ]),
    });
  }

  /// Searches for messages within a chat room.
  /// 
  /// Performs a case-insensitive search on:
  /// - Message content
  /// - Sender names
  /// 
  /// Results are sorted by timestamp (newest first).
  /// Note: This implementation loads all messages into memory,
  /// which may not scale well for large chat histories.
  /// 
  /// @param chatRoomId Chat room to search in
  /// @param query Search term to match
  /// @return List of matching messages
  Future<List<Message>> searchMessages(String chatRoomId, String query) async {
    final querySnapshot = await _firestore
        .collection('chat_rooms')
        .doc(chatRoomId)
        .collection('messages')
        .get();

    final messages = querySnapshot.docs
        .map((doc) => Message.fromFirestore(doc))
        .where((message) => 
            message.content.toLowerCase().contains(query.toLowerCase()) ||
            message.senderName.toLowerCase().contains(query.toLowerCase()))
        .toList();

    messages.sort((a, b) => b.timestamp.compareTo(a.timestamp));
    return messages;
  }
}
````

## File: lib/features/chat/data/services/scheduled_messages_service.dart
````dart
/// Service for managing scheduled messages in the education platform.
/// 
/// This service enables users to schedule messages for future delivery,
/// manage scheduled messages, and track scheduled message status within
/// the chat system.
library;

import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:firebase_auth/firebase_auth.dart';
import '../../domain/models/message.dart';
import '../../../../shared/services/logger_service.dart';

/// Core service for scheduling and managing future message delivery.
/// 
/// This service provides:
/// - Message scheduling for future timestamps
/// - Scheduled message retrieval and monitoring
/// - Cancellation and update capabilities
/// - User-specific scheduled message management
/// - Integration with the chat messaging system
/// 
/// Scheduled messages are stored separately from regular messages
/// until their scheduled time, when they should be processed by
/// a background job or cloud function.
class ScheduledMessagesService {
  /// Logging tag for this service.
  static const String _tag = 'ScheduledMessagesService';
  
  /// Firestore instance for database operations.
  final FirebaseFirestore _firestore;
  
  /// Firebase Auth instance for user authentication.
  final FirebaseAuth _auth;

  /// Creates a ScheduledMessagesService instance.
  /// 
  /// Accepts optional dependencies for testing:
  /// @param firestore Optional Firestore instance
  /// @param auth Optional Firebase Auth instance
  ScheduledMessagesService({
    FirebaseFirestore? firestore,
    FirebaseAuth? auth,
  })  : _firestore = firestore ?? FirebaseFirestore.instance,
        _auth = auth ?? FirebaseAuth.instance;

  /// Gets the current authenticated user's ID.
  /// 
  /// Returns empty string if no user is authenticated.
  String get _currentUserId => _auth.currentUser?.uid ?? '';

  /// Schedules a message for future delivery.
  /// 
  /// Creates a scheduled message entry that will be processed
  /// at the specified future time. The message is stored in
  /// a separate collection until its scheduled delivery time.
  /// 
  /// @param chatRoomId Target chat room for the message
  /// @param content Message text content
  /// @param scheduledFor Future timestamp for delivery
  /// @param attachmentUrl Optional file attachment URL
  /// @param attachmentType Optional attachment MIME type
  /// @return Document ID of the scheduled message
  /// @throws Exception if scheduled time is in the past
  Future<String> scheduleMessage({
    required String chatRoomId,
    required String content,
    required DateTime scheduledFor,
    String? attachmentUrl,
    String? attachmentType,
  }) async {
    try {
      if (scheduledFor.isBefore(DateTime.now())) {
        throw Exception('Scheduled time must be in the future');
      }

      final message = Message(
        id: '',
        senderId: _currentUserId,
        senderName: _auth.currentUser?.displayName ?? 'User',
        senderRole: _auth.currentUser?.email?.endsWith('@teacher.edu') == true 
            ? 'teacher' 
            : 'student',
        content: content,
        timestamp: DateTime.now(),
        scheduledFor: scheduledFor,
        isScheduled: true,
        status: MessageStatus.sent,
        attachmentUrl: attachmentUrl,
        attachmentType: attachmentType,
      );

      // Store in scheduled_messages collection
      final ref = _firestore.collection('scheduled_messages').doc();
      
      await ref.set({
        'chatRoomId': chatRoomId,
        'message': message.toFirestore(),
        'createdAt': FieldValue.serverTimestamp(),
      });

      LoggerService.info(
        'Message scheduled for ${scheduledFor.toIso8601String()}',
        tag: _tag,
      );
      
      return ref.id;
    } catch (e) {
      LoggerService.error('Failed to schedule message', tag: _tag, error: e);
      rethrow;
    }
  }

  /// Streams scheduled messages for a specific chat room.
  /// 
  /// Returns a real-time stream of scheduled messages that:
  /// - Belong to the specified chat room
  /// - Were created by the current user
  /// - Have future scheduled delivery times
  /// - Are sorted by scheduled time (earliest first)
  /// 
  /// Past scheduled messages are automatically filtered out.
  /// 
  /// @param chatRoomId Chat room to get scheduled messages for
  /// @return Stream of scheduled messages list
  Stream<List<ScheduledMessage>> getScheduledMessages(String chatRoomId) {
    return _firestore
        .collection('scheduled_messages')
        .where('chatRoomId', isEqualTo: chatRoomId)
        .where('message.senderId', isEqualTo: _currentUserId)
        .snapshots()
        .map((snapshot) {
          final now = DateTime.now();
          return snapshot.docs
              .map((doc) => ScheduledMessage.fromFirestore(doc))
              .where((msg) => msg.message.scheduledFor?.isAfter(now) ?? false)
              .toList()
            ..sort((a, b) => a.message.scheduledFor!.compareTo(b.message.scheduledFor!));
        });
  }

  /// Cancels a scheduled message before delivery.
  /// 
  /// Permanently deletes the scheduled message from the queue.
  /// This operation cannot be undone and the message will not
  /// be delivered at its scheduled time.
  /// 
  /// @param scheduledMessageId ID of the scheduled message to cancel
  /// @throws Exception if cancellation fails
  Future<void> cancelScheduledMessage(String scheduledMessageId) async {
    try {
      await _firestore
          .collection('scheduled_messages')
          .doc(scheduledMessageId)
          .delete();
      
      LoggerService.info(
        'Scheduled message $scheduledMessageId cancelled',
        tag: _tag,
      );
    } catch (e) {
      LoggerService.error('Failed to cancel scheduled message', tag: _tag, error: e);
      rethrow;
    }
  }

  /// Updates an existing scheduled message.
  /// 
  /// Allows modification of message content and/or scheduled
  /// delivery time. Only future messages can be updated.
  /// 
  /// @param scheduledMessageId ID of the message to update
  /// @param content New message content (optional)
  /// @param scheduledFor New scheduled time (optional)
  /// @throws Exception if new scheduled time is in the past
  Future<void> updateScheduledMessage({
    required String scheduledMessageId,
    String? content,
    DateTime? scheduledFor,
  }) async {
    try {
      final updates = <String, dynamic>{};
      
      if (content != null) {
        updates['message.content'] = content;
      }
      
      if (scheduledFor != null) {
        if (scheduledFor.isBefore(DateTime.now())) {
          throw Exception('Scheduled time must be in the future');
        }
        updates['message.scheduledFor'] = Timestamp.fromDate(scheduledFor);
      }
      
      await _firestore
          .collection('scheduled_messages')
          .doc(scheduledMessageId)
          .update(updates);
      
      LoggerService.info(
        'Scheduled message $scheduledMessageId updated',
        tag: _tag,
      );
    } catch (e) {
      LoggerService.error('Failed to update scheduled message', tag: _tag, error: e);
      rethrow;
    }
  }

  /// Streams all scheduled messages for the current user.
  /// 
  /// Returns a real-time stream of all scheduled messages
  /// created by the current user across all chat rooms.
  /// Messages are:
  /// - Filtered to show only future deliveries
  /// - Sorted by scheduled time (earliest first)
  /// 
  /// Useful for displaying a user's scheduled message overview.
  /// 
  /// @return Stream of all user's scheduled messages
  Stream<List<ScheduledMessage>> getAllScheduledMessages() {
    return _firestore
        .collection('scheduled_messages')
        .where('message.senderId', isEqualTo: _currentUserId)
        .snapshots()
        .map((snapshot) {
          final now = DateTime.now();
          return snapshot.docs
              .map((doc) => ScheduledMessage.fromFirestore(doc))
              .where((msg) => msg.message.scheduledFor?.isAfter(now) ?? false)
              .toList()
            ..sort((a, b) => a.message.scheduledFor!.compareTo(b.message.scheduledFor!));
        });
  }
}

/// Model representing a scheduled message in the system.
/// 
/// Wraps a regular Message with scheduling metadata including
/// the target chat room and creation timestamp. Used for
/// managing messages scheduled for future delivery.
class ScheduledMessage {
  /// Unique identifier for the scheduled message.
  final String id;
  
  /// ID of the chat room where message will be delivered.
  final String chatRoomId;
  
  /// The actual message content and metadata.
  final Message message;
  
  /// Timestamp when the scheduled message was created.
  final DateTime createdAt;

  /// Creates a ScheduledMessage instance.
  /// 
  /// @param id Unique identifier
  /// @param chatRoomId Target chat room ID
  /// @param message Message to be delivered
  /// @param createdAt Creation timestamp
  ScheduledMessage({
    required this.id,
    required this.chatRoomId,
    required this.message,
    required this.createdAt,
  });

  /// Factory constructor to create ScheduledMessage from Firestore.
  /// 
  /// Parses the Firestore document structure including:
  /// - Chat room reference
  /// - Embedded message data
  /// - Creation timestamp with null safety
  /// 
  /// @param doc Firestore document containing scheduled message
  /// @return Parsed ScheduledMessage instance
  factory ScheduledMessage.fromFirestore(DocumentSnapshot doc) {
    final data = doc.data() as Map<String, dynamic>;
    final messageData = data['message'] as Map<String, dynamic>;
    return ScheduledMessage(
      id: doc.id,
      chatRoomId: data['chatRoomId'] ?? '',
      message: Message.fromMap(doc.id, messageData),
      createdAt: (data['createdAt'] as Timestamp?)?.toDate() ?? DateTime.now(),
    );
  }
}
````

## File: lib/features/chat/data/services/webrtc_service.dart
````dart
import 'dart:async';
import 'package:flutter_webrtc/flutter_webrtc.dart';
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:firebase_auth/firebase_auth.dart';
import 'package:rxdart/rxdart.dart';
import 'package:permission_handler/permission_handler.dart';
import '../../domain/models/call.dart';
import '../../../../shared/services/logger_service.dart';

class WebRTCService {
  static const String _tag = 'WebRTCService';
  
  final FirebaseFirestore _firestore = FirebaseFirestore.instance;
  final FirebaseAuth _auth = FirebaseAuth.instance;
  
  // WebRTC configuration with Unified Plan semantics
  final Map<String, dynamic> _configuration = {
    'iceServers': [
      // STUN servers for discovering public IP
      {'urls': 'stun:stun.l.google.com:19302'},
      {'urls': 'stun:stun1.l.google.com:19302'},
      {'urls': 'stun:stun2.l.google.com:19302'},
      // TURN servers for NAT traversal (essential for ~20-30% of users)
      {
        'urls': [
          'turn:openrelay.metered.ca:80',
          'turn:openrelay.metered.ca:443',
          'turn:openrelay.metered.ca:443?transport=tcp',
        ],
        'username': 'openrelayproject',
        'credential': 'openrelayproject',
      },
      // TODO: Replace with your own TURN server for production
      // Example: Twilio, Xirsys, or self-hosted coturn
    ],
    'sdpSemantics': 'unified-plan', // Use modern Unified Plan semantics
    'iceCandidatePoolSize': 10, // Pre-gather candidates for faster connection
  };

  final Map<String, dynamic> _offerSdpConstraints = {
    'mandatory': {
      'OfferToReceiveAudio': true,
      'OfferToReceiveVideo': true,
    },
    'optional': [],
  };

  // WebRTC components
  RTCPeerConnection? _peerConnection;
  MediaStream? _localStream;
  MediaStream? _remoteStream;
  RTCVideoRenderer? _localRenderer;
  RTCVideoRenderer? _remoteRenderer;
  
  // Getters for backward compatibility
  RTCVideoRenderer get localRenderer => _localRenderer ??= RTCVideoRenderer();
  RTCVideoRenderer get remoteRenderer => _remoteRenderer ??= RTCVideoRenderer();
  
  // Call state
  String? _currentCallId;
  Call? _currentCall;
  bool _isCaller = false;
  bool _isEndingCall = false;
  
  // Callbacks
  Function(MediaStream stream)? onLocalStream;
  Function(MediaStream stream)? onRemoteStream;
  Function(Call call)? onCallStateChanged;
  
  // Stream controllers
  final BehaviorSubject<Call?> _callStateController = BehaviorSubject<Call?>();
  Stream<Call?> get callStateStream => _callStateController.stream;
  Call? get currentCallState => _callStateController.value;

  String get currentUserId => _auth.currentUser?.uid ?? '';
  String get currentUserName => _auth.currentUser?.displayName ?? 'Unknown';
  String get currentUserPhoto => _auth.currentUser?.photoURL ?? '';

  Future<void> initialize() async {
    // Don't initialize renderers here - will do it conditionally based on call type
    LoggerService.debug('WebRTC service initialized', tag: _tag);
    
    // Clean up any stale calls on startup
    await _cleanupStaleCalls();
  }
  
  // Clean up stale calls that were never ended properly
  Future<void> _cleanupStaleCalls() async {
    try {
      // Find all calls where the current user is involved and still ringing
      final staleCalls = await _firestore
          .collection('calls')
          .where('status', isEqualTo: CallStatus.ringing.name)
          .get();
      
      for (final doc in staleCalls.docs) {
        final callData = doc.data();
        final callId = doc.id;
        
        // Check if this call involves the current user
        if (callData['callerId'] == currentUserId || callData['receiverId'] == currentUserId) {
          // Check if call is stale (older than 60 seconds)
          final startedAt = (callData['startedAt'] as Timestamp?)?.toDate();
          if (startedAt != null) {
            final callAge = DateTime.now().difference(startedAt).inSeconds;
            if (callAge > 60) {
              // Mark as missed/ended
              await doc.reference.update({
                'status': CallStatus.ended.name,
                'endedAt': FieldValue.serverTimestamp(),
                'endReason': 'stale_cleanup',
              });
              LoggerService.info('Cleaned up stale call: $callId (${callAge}s old)', tag: _tag);
            }
          }
        }
      }
    } catch (e) {
      LoggerService.error('Failed to cleanup stale calls', tag: _tag, error: e);
    }
  }
  
  Future<void> _initializeRenderersForVideo() async {
    if (_localRenderer == null) {
      _localRenderer = RTCVideoRenderer();
      await _localRenderer!.initialize();
    }
    if (_remoteRenderer == null) {
      _remoteRenderer = RTCVideoRenderer();
      await _remoteRenderer!.initialize();
    }
    LoggerService.debug('Video renderers initialized', tag: _tag);
  }

  Future<void> dispose() async {
    await _cleanUp();
    await _disposeRenderers();
    await _callStateController.close();
    LoggerService.debug('WebRTC service disposed', tag: _tag);
  }
  
  Future<void> _disposeRenderers() async {
    if (_localRenderer != null) {
      _localRenderer!.srcObject = null;
      await _localRenderer!.dispose();
      _localRenderer = null;
    }
    if (_remoteRenderer != null) {
      _remoteRenderer!.srcObject = null;
      await _remoteRenderer!.dispose();
      _remoteRenderer = null;
    }
    LoggerService.debug('Video renderers disposed', tag: _tag);
  }

  Future<MediaStream> _getUserMedia(bool isVideoCall) async {
    // Request permissions before accessing media
    final permissions = await _requestMediaPermissions(isVideoCall);
    if (!permissions) {
      throw Exception('Media permissions denied');
    }
    
    // Optimize audio constraints for voice calls
    final Map<String, dynamic> audioConstraints = {
      'echoCancellation': true,
      'noiseSuppression': true,
      'autoGainControl': true,
      'sampleRate': 48000,
      'channelCount': 1, // Mono audio for bandwidth efficiency
    };
    
    final Map<String, dynamic> mediaConstraints = {
      'audio': isVideoCall ? true : audioConstraints, // Use optimized settings for voice-only
      'video': isVideoCall
          ? {
              'facingMode': 'user',
              'width': {'ideal': 1280},
              'height': {'ideal': 720},
            }
          : false,
    };

    try {
      final stream = await navigator.mediaDevices.getUserMedia(mediaConstraints);
      return stream;
    } catch (e) {
      LoggerService.error('Failed to get user media', tag: _tag, error: e);
      throw Exception('Failed to access camera/microphone: ${e.toString()}');
    }
  }
  
  Future<bool> _requestMediaPermissions(bool isVideoCall) async {
    try {
      // Request microphone permission (always needed)
      var micStatus = await Permission.microphone.status;
      if (!micStatus.isGranted) {
        micStatus = await Permission.microphone.request();
        if (!micStatus.isGranted) {
          LoggerService.error('Microphone permission denied', tag: _tag);
          return false;
        }
      }
      
      // Request camera permission if video call
      if (isVideoCall) {
        var cameraStatus = await Permission.camera.status;
        if (!cameraStatus.isGranted) {
          cameraStatus = await Permission.camera.request();
          if (!cameraStatus.isGranted) {
            LoggerService.error('Camera permission denied', tag: _tag);
            return false;
          }
        }
      }
      
      LoggerService.info('Media permissions granted for ${isVideoCall ? "video" : "voice"} call', tag: _tag);
      return true;
    } catch (e) {
      LoggerService.error('Failed to request media permissions', error: e, tag: _tag);
      return false;
    }
  }

  Future<void> _createPeerConnection() async {
    try {
      // Create configuration optimized for call type
      final config = Map<String, dynamic>.from(_configuration);
      
      // For voice-only calls, optimize bandwidth and CPU usage
      if (_currentCall?.type == CallType.voice) {
        config['bundlePolicy'] = 'max-bundle'; // Bundle all media in a single transport
        config['rtcpMuxPolicy'] = 'require'; // Reduce port usage
      }
      
      _peerConnection = await createPeerConnection(config);
      
      _peerConnection!.onIceCandidate = (RTCIceCandidate candidate) {
        if (_currentCallId != null) {
          _firestore
              .collection('calls')
              .doc(_currentCallId)
              .collection('candidates')
              .doc(_isCaller ? 'caller' : 'receiver')
              .collection('candidates')
              .add(candidate.toMap());
        }
      };

      // Use modern onTrack instead of deprecated onAddStream
      _peerConnection!.onTrack = (RTCTrackEvent event) {
        if (event.track.kind == 'video' || event.track.kind == 'audio') {
          if (event.streams.isNotEmpty) {
            _remoteStream = event.streams[0];
            // Only set srcObject if this is a video call and renderer is initialized
            if (_currentCall?.type == CallType.video && _remoteRenderer != null) {
              _remoteRenderer!.srcObject = _remoteStream;
            }
            onRemoteStream?.call(_remoteStream!);
          }
        }
      };

      _peerConnection!.onConnectionState = (RTCPeerConnectionState state) {
        LoggerService.debug('Connection state: $state', tag: _tag);
        if (state == RTCPeerConnectionState.RTCPeerConnectionStateDisconnected ||
            state == RTCPeerConnectionState.RTCPeerConnectionStateFailed) {
          endCall();
        }
      };

      LoggerService.debug('Peer connection created', tag: _tag);
    } catch (e) {
      LoggerService.error('Failed to create peer connection', tag: _tag, error: e);
      rethrow;
    }
  }

  Future<String> startCall({
    required String receiverId,
    required String receiverName,
    required String receiverPhotoUrl,
    required bool isVideoCall,
    String? chatRoomId,
  }) async {
    try {
      _isCaller = true;
      
      // Initialize renderers if video call
      if (isVideoCall) {
        await _initializeRenderersForVideo();
      }
      
      // Get user media
      _localStream = await _getUserMedia(isVideoCall);
      if (isVideoCall && _localRenderer != null) {
        _localRenderer!.srcObject = _localStream;
      }
      onLocalStream?.call(_localStream!);
      
      // Create peer connection
      await _createPeerConnection();
      
      // Add tracks individually (modern approach for Unified Plan)
      _localStream!.getTracks().forEach((track) {
        _peerConnection!.addTrack(track, _localStream!);
      });
      
      // Create call document
      final callRef = _firestore.collection('calls').doc();
      _currentCallId = callRef.id;
      
      final now = DateTime.now();
      final call = Call(
        id: _currentCallId!,
        callerId: currentUserId,
        callerName: currentUserName,
        callerPhotoUrl: currentUserPhoto,
        receiverId: receiverId,
        receiverName: receiverName,
        receiverPhotoUrl: receiverPhotoUrl,
        type: isVideoCall ? CallType.video : CallType.voice,
        status: CallStatus.ringing,
        startedAt: now,
        chatRoomId: chatRoomId,
        expireAt: now.add(const Duration(hours: 1)), // TTL: auto-cleanup after 1 hour
      );
      
      await callRef.set(call.toMap());
      _currentCall = call;
      if (!_callStateController.isClosed) {
        _callStateController.add(call);
      }
      onCallStateChanged?.call(call);
      
      // Create offer
      final offer = await _peerConnection!.createOffer(_offerSdpConstraints);
      
      // For voice calls, prefer Opus codec for better quality
      if (!isVideoCall) {
        offer.sdp = _preferOpusCodec(offer.sdp!);
      }
      
      await _peerConnection!.setLocalDescription(offer);
      
      await callRef.update({
        'offer': offer.toMap(),
      });
      
      // Listen for answer
      callRef.snapshots().listen((snapshot) async {
        if (snapshot.exists) {
          final data = snapshot.data() as Map<String, dynamic>;
          
          if (data['answer'] != null && _peerConnection != null) {
            final answer = RTCSessionDescription(
              data['answer']['sdp'],
              data['answer']['type'],
            );
            await _peerConnection!.setRemoteDescription(answer);
          }
          
          if (data['status'] != null) {
            final status = CallStatus.values.firstWhere(
              (e) => e.name == data['status'],
              orElse: () => CallStatus.ended,
            );
            
            if (_currentCall != null) {
              _currentCall = _currentCall!.copyWith(status: status);
              if (!_callStateController.isClosed) {
                _callStateController.add(_currentCall);
              }
              onCallStateChanged?.call(_currentCall!);
              
              if (status == CallStatus.rejected || status == CallStatus.ended) {
                await endCall();
              }
            }
          }
        }
      });
      
      // Listen for ICE candidates
      _listenForRemoteCandidates();
      
      LoggerService.debug('Call started: $_currentCallId', tag: _tag);
      return _currentCallId!;
    } catch (e) {
      LoggerService.error('Failed to start call', tag: _tag, error: e);
      await _cleanUp();
      rethrow;
    }
  }

  Future<void> acceptCall(String callId) async {
    try {
      _isCaller = false;
      _currentCallId = callId;
      
      // Get call document
      final callDoc = await _firestore.collection('calls').doc(callId).get();
      if (!callDoc.exists) {
        throw Exception('Call not found');
      }
      
      _currentCall = Call.fromMap(callDoc.data()!, callId);
      
      // Initialize renderers if video call
      final isVideoCall = _currentCall!.type == CallType.video;
      if (isVideoCall) {
        await _initializeRenderersForVideo();
      }
      
      // Get user media
      _localStream = await _getUserMedia(isVideoCall);
      if (isVideoCall && _localRenderer != null) {
        _localRenderer!.srcObject = _localStream;
      }
      onLocalStream?.call(_localStream!);
      
      // Create peer connection
      await _createPeerConnection();
      
      // Add tracks individually (modern approach for Unified Plan)
      _localStream!.getTracks().forEach((track) {
        _peerConnection!.addTrack(track, _localStream!);
      });
      
      // Set remote description from offer
      final offer = RTCSessionDescription(
        callDoc.data()!['offer']['sdp'],
        callDoc.data()!['offer']['type'],
      );
      await _peerConnection!.setRemoteDescription(offer);
      
      // Create answer
      final answer = await _peerConnection!.createAnswer();
      
      // For voice calls, prefer Opus codec for better quality
      if (!isVideoCall) {
        answer.sdp = _preferOpusCodec(answer.sdp!);
      }
      
      await _peerConnection!.setLocalDescription(answer);
      
      // Update call document
      await _firestore.collection('calls').doc(callId).update({
        'answer': answer.toMap(),
        'status': CallStatus.accepted.name,
      });
      
      _currentCall = _currentCall!.copyWith(status: CallStatus.accepted);
      if (!_callStateController.isClosed) {
        _callStateController.add(_currentCall);
      }
      onCallStateChanged?.call(_currentCall!);
      
      // Listen for ICE candidates
      _listenForRemoteCandidates();
      
      LoggerService.debug('Call accepted: $callId', tag: _tag);
    } catch (e) {
      LoggerService.error('Failed to accept call', tag: _tag, error: e);
      await _cleanUp();
      rethrow;
    }
  }

  Future<void> rejectCall(String callId) async {
    try {
      await _firestore.collection('calls').doc(callId).update({
        'status': CallStatus.rejected.name,
        'endedAt': FieldValue.serverTimestamp(),
        'endReason': 'rejected',
        'expireAt': FieldValue.serverTimestamp(), // Immediate cleanup for rejected calls
      });
      
      await _cleanUp();
      LoggerService.debug('Call rejected: $callId', tag: _tag);
    } catch (e) {
      LoggerService.error('Failed to reject call', tag: _tag, error: e);
    }
  }

  Future<void> endCall() async {
    // Prevent duplicate executions
    if (_isEndingCall) {
      return;
    }
    _isEndingCall = true;
    
    try {
      if (_currentCallId != null) {
        final endTime = DateTime.now();
        final duration = _currentCall?.startedAt != null
            ? endTime.difference(_currentCall!.startedAt).inSeconds
            : 0;
        
        await _firestore.collection('calls').doc(_currentCallId).update({
          'status': CallStatus.ended.name,
          'endedAt': FieldValue.serverTimestamp(),
          'duration': duration,
          'endReason': 'user_ended',
          'expireAt': FieldValue.serverTimestamp(), // Immediate cleanup for ended calls
        });
      }
      
      await _cleanUp();
      LoggerService.debug('Call ended', tag: _tag);
    } catch (e) {
      LoggerService.error('Failed to end call', tag: _tag, error: e);
    } finally {
      _isEndingCall = false;
    }
  }

  Future<void> toggleMute() async {
    if (_localStream != null) {
      final audioTracks = _localStream!.getAudioTracks();
      for (final track in audioTracks) {
        track.enabled = !track.enabled;
      }
    }
  }

  Future<void> toggleVideo() async {
    if (_localStream != null) {
      final videoTracks = _localStream!.getVideoTracks();
      for (final track in videoTracks) {
        track.enabled = !track.enabled;
      }
    }
  }

  Future<void> switchCamera() async {
    if (_localStream != null) {
      final videoTracks = _localStream!.getVideoTracks();
      for (final track in videoTracks) {
        // This method is platform-specific
        Helper.switchCamera(track);
      }
    }
  }

  void _listenForRemoteCandidates() {
    if (_currentCallId == null) return;
    
    final candidatesCollection = _firestore
        .collection('calls')
        .doc(_currentCallId)
        .collection('candidates')
        .doc(_isCaller ? 'receiver' : 'caller')
        .collection('candidates');
    
    candidatesCollection.snapshots().listen((snapshot) {
      for (final change in snapshot.docChanges) {
        if (change.type == DocumentChangeType.added) {
          final data = change.doc.data()!;
          final candidate = RTCIceCandidate(
            data['candidate'],
            data['sdpMid'],
            data['sdpMLineIndex'],
          );
          _peerConnection?.addCandidate(candidate);
        }
      }
    });
  }

  Future<void> _cleanUp() async {
    try {
      _localStream?.getTracks().forEach((track) {
        track.stop();
      });
      _localStream?.dispose();
      _localStream = null;
      
      _remoteStream?.getTracks().forEach((track) {
        track.stop();
      });
      _remoteStream?.dispose();
      _remoteStream = null;
      
      await _peerConnection?.close();
      _peerConnection = null;
      
      // Dispose renderers after call ends
      await _disposeRenderers();
      
      _currentCallId = null;
      _currentCall = null;
      _isCaller = false;
      _isEndingCall = false;
      
      // Only emit event if controller is not closed
      if (!_callStateController.isClosed) {
        _callStateController.add(null);
      }
    } catch (e) {
      LoggerService.error('Error during cleanup', tag: _tag, error: e);
    }
  }

  // Check for incoming calls
  Stream<Call> getIncomingCalls() {
    return _firestore
        .collection('calls')
        .where('receiverId', isEqualTo: currentUserId)
        .where('status', isEqualTo: CallStatus.ringing.name)
        .snapshots()
        .map((snapshot) => snapshot.docs
            .map((doc) => Call.fromMap(doc.data(), doc.id))
            .where((call) {
              // Filter out stale calls (older than 60 seconds)
              final callAge = DateTime.now().difference(call.startedAt).inSeconds;
              if (callAge > 60) {
                LoggerService.debug('Filtering out stale call: ${call.id} (${callAge}s old)', tag: _tag);
                // Mark stale call as missed
                _markCallAsMissed(call.id);
                return false;
              }
              return true;
            })
            .toList())
        .expand((calls) => calls);
  }
  
  // Mark stale call as missed
  Future<void> _markCallAsMissed(String callId) async {
    try {
      await _firestore.collection('calls').doc(callId).update({
        'status': CallStatus.ended.name,
        'endedAt': FieldValue.serverTimestamp(),
        'endReason': 'missed',
        'expireAt': FieldValue.serverTimestamp(), // Immediate cleanup for missed calls
      });
      LoggerService.debug('Marked stale call as missed: $callId', tag: _tag);
    } catch (e) {
      LoggerService.error('Failed to mark call as missed', tag: _tag, error: e);
    }
  }
  
  // Prefer Opus codec for better voice quality
  String _preferOpusCodec(String sdp) {
    // Extract Opus codec line
    final lines = sdp.split('\r\n');
    int opusPayload = -1;
    
    // Find Opus codec payload type
    for (final line in lines) {
      if (line.contains('opus/48000')) {
        final match = RegExp(r'a=rtpmap:(\d+)').firstMatch(line);
        if (match != null) {
          opusPayload = int.parse(match.group(1)!);
          break;
        }
      }
    }
    
    if (opusPayload == -1) return sdp; // Opus not found
    
    // Reorder m=audio line to prefer Opus
    final newLines = <String>[];
    for (final line in lines) {
      if (line.startsWith('m=audio')) {
        final parts = line.split(' ');
        final payloads = parts.sublist(3);
        
        // Move Opus to front
        payloads.remove(opusPayload.toString());
        payloads.insert(0, opusPayload.toString());
        
        newLines.add('${parts[0]} ${parts[1]} ${parts[2]} ${payloads.join(' ')}');
      } else {
        newLines.add(line);
      }
    }
    
    return newLines.join('\r\n');
  }
}
````

## File: lib/features/chat/domain/models/call.dart
````dart
import 'package:cloud_firestore/cloud_firestore.dart';

enum CallType { voice, video }
enum CallStatus { ringing, accepted, rejected, ended, missed }

class Call {
  final String id;
  final String callerId;
  final String callerName;
  final String callerPhotoUrl;
  final String receiverId;
  final String receiverName;
  final String receiverPhotoUrl;
  final CallType type;
  final CallStatus status;
  final DateTime startedAt;
  final DateTime? endedAt;
  final int? duration; // in seconds
  final String? chatRoomId;
  final DateTime? expireAt; // TTL field for automatic cleanup

  Call({
    required this.id,
    required this.callerId,
    required this.callerName,
    required this.callerPhotoUrl,
    required this.receiverId,
    required this.receiverName,
    required this.receiverPhotoUrl,
    required this.type,
    required this.status,
    required this.startedAt,
    this.endedAt,
    this.duration,
    this.chatRoomId,
    this.expireAt,
  });

  factory Call.fromMap(Map<String, dynamic> map, String id) {
    return Call(
      id: id,
      callerId: map['callerId'] ?? '',
      callerName: map['callerName'] ?? '',
      callerPhotoUrl: map['callerPhotoUrl'] ?? '',
      receiverId: map['receiverId'] ?? '',
      receiverName: map['receiverName'] ?? '',
      receiverPhotoUrl: map['receiverPhotoUrl'] ?? '',
      type: CallType.values.firstWhere(
        (e) => e.name == map['type'],
        orElse: () => CallType.voice,
      ),
      status: CallStatus.values.firstWhere(
        (e) => e.name == map['status'],
        orElse: () => CallStatus.ended,
      ),
      startedAt: (map['startedAt'] as Timestamp).toDate(),
      endedAt: map['endedAt'] != null 
          ? (map['endedAt'] as Timestamp).toDate() 
          : null,
      duration: map['duration'],
      chatRoomId: map['chatRoomId'],
      expireAt: map['expireAt'] != null 
          ? (map['expireAt'] as Timestamp).toDate() 
          : null,
    );
  }

  Map<String, dynamic> toMap() {
    return {
      'callerId': callerId,
      'callerName': callerName,
      'callerPhotoUrl': callerPhotoUrl,
      'receiverId': receiverId,
      'receiverName': receiverName,
      'receiverPhotoUrl': receiverPhotoUrl,
      'type': type.name,
      'status': status.name,
      'startedAt': Timestamp.fromDate(startedAt),
      'endedAt': endedAt != null ? Timestamp.fromDate(endedAt!) : null,
      'duration': duration,
      'chatRoomId': chatRoomId,
      'expireAt': expireAt != null ? Timestamp.fromDate(expireAt!) : null,
    };
  }

  // Convenience getters for compatibility
  bool get isVideo => type == CallType.video;
  String get calleeId => receiverId;
  String? get callerPhotoURL => callerPhotoUrl;

  Call copyWith({
    String? id,
    String? callerId,
    String? callerName,
    String? callerPhotoUrl,
    String? receiverId,
    String? receiverName,
    String? receiverPhotoUrl,
    CallType? type,
    CallStatus? status,
    DateTime? startedAt,
    DateTime? endedAt,
    int? duration,
    String? chatRoomId,
    DateTime? expireAt,
  }) {
    return Call(
      id: id ?? this.id,
      callerId: callerId ?? this.callerId,
      callerName: callerName ?? this.callerName,
      callerPhotoUrl: callerPhotoUrl ?? this.callerPhotoUrl,
      receiverId: receiverId ?? this.receiverId,
      receiverName: receiverName ?? this.receiverName,
      receiverPhotoUrl: receiverPhotoUrl ?? this.receiverPhotoUrl,
      type: type ?? this.type,
      status: status ?? this.status,
      startedAt: startedAt ?? this.startedAt,
      endedAt: endedAt ?? this.endedAt,
      duration: duration ?? this.duration,
      chatRoomId: chatRoomId ?? this.chatRoomId,
      expireAt: expireAt ?? this.expireAt,
    );
  }
}
````

## File: lib/features/chat/domain/models/chat_room.dart
````dart
/// Chat room model for managing messaging channels in the education platform.
/// 
/// This module contains data models for chat rooms and participant information,
/// supporting various communication types between teachers, students, and groups.
library;

import 'package:cloud_firestore/cloud_firestore.dart';

/// Core chat room model representing a messaging channel.
/// 
/// This model supports different types of chat rooms:
/// - Direct messages between two users
/// - Group chats with multiple participants
/// - Class-based channels for educational discussions
/// 
/// Features include:
/// - Participant management with role information
/// - Unread message tracking (global and per-user)
/// - Last message preview for list displays
/// - Class association for academic context
class ChatRoom {
  /// Unique identifier for the chat room
  final String id;
  
  /// Display name of the chat room
  final String name;
  
  /// Type of chat room: 'direct', 'group', or 'class'
  final String type; // 'direct', 'group', 'class'
  
  /// List of user IDs participating in this chat
  final List<String> participantIds;
  
  /// Detailed participant information including names and roles
  final List<ParticipantInfo> participants;
  
  /// Preview text of the most recent message
  final String? lastMessage;
  
  /// Timestamp of the most recent message
  final DateTime? lastMessageTime;
  
  /// User ID of the last message sender
  final String? lastMessageSenderId;
  
  /// Total unread message count (deprecated, use unreadCounts)
  final int unreadCount;
  
  /// Per-user unread message counts (userId -> count)
  final Map<String, int>? unreadCounts; // Per-user unread counts
  
  /// Associated class ID for class-based chat rooms
  final String? classId; // For class-based chats
  
  /// Timestamp when the chat room was created
  final DateTime createdAt;
  
  /// Timestamp of last modification
  final DateTime? updatedAt;
  
  /// User ID who created the chat room
  final String? createdBy;

  /// List of user IDs who have muted this chat
  final List<String> mutedUsers;

  ChatRoom({
    required this.id,
    required this.name,
    required this.type,
    required this.participantIds,
    required this.participants,
    this.lastMessage,
    this.lastMessageTime,
    this.lastMessageSenderId,
    this.unreadCount = 0,
    this.unreadCounts,
    this.classId,
    required this.createdAt,
    this.updatedAt,
    this.createdBy,
    this.mutedUsers = const [],
  });

  /// Factory constructor to create ChatRoom from Firestore document.
  /// 
  /// Handles complex data parsing including:
  /// - Nested participant information objects
  /// - Timestamp conversions for dates
  /// - Map casting for unread counts
  /// - Null safety with appropriate defaults
  /// 
  /// @param doc Firestore document snapshot containing chat room data
  /// @return Parsed ChatRoom instance
  factory ChatRoom.fromFirestore(DocumentSnapshot doc) {
    final data = doc.data() as Map<String, dynamic>;
    return ChatRoom(
      id: doc.id,
      name: data['name'] ?? '',
      type: data['type'] ?? 'direct',
      participantIds: List<String>.from(data['participantIds'] ?? []),
      participants: (data['participants'] as List<dynamic>?)
          ?.map((p) => ParticipantInfo.fromMap(p))
          .toList() ?? [],
      lastMessage: data['lastMessage'],
      lastMessageTime: data['lastMessageTime'] != null
          ? (data['lastMessageTime'] as Timestamp).toDate()
          : null,
      lastMessageSenderId: data['lastMessageSenderId'],
      unreadCount: data['unreadCount'] ?? 0,
      unreadCounts: data['unreadCounts'] != null
          ? Map<String, int>.from(data['unreadCounts'])
          : null,
      classId: data['classId'],
      createdAt: (data['createdAt'] as Timestamp).toDate(),
      updatedAt: data['updatedAt'] != null
          ? (data['updatedAt'] as Timestamp).toDate()
          : null,
      createdBy: data['createdBy'],
      mutedUsers: List<String>.from(data['mutedUsers'] ?? []),
    );
  }

  /// Converts the ChatRoom instance to a Map for Firestore storage.
  /// 
  /// Serializes all chat room data including:
  /// - Converting participant objects to maps
  /// - DateTime fields to Firestore Timestamps
  /// - Preserving null values for optional fields
  /// 
  /// @return Map containing all chat room data for Firestore
  Map<String, dynamic> toFirestore() {
    return {
      'name': name,
      'type': type,
      'participantIds': participantIds,
      'participants': participants.map((p) => p.toMap()).toList(),
      'lastMessage': lastMessage,
      'lastMessageTime': lastMessageTime != null
          ? Timestamp.fromDate(lastMessageTime!)
          : null,
      'lastMessageSenderId': lastMessageSenderId,
      'unreadCount': unreadCount,
      'unreadCounts': unreadCounts,
      'classId': classId,
      'createdAt': Timestamp.fromDate(createdAt),
      'updatedAt': updatedAt != null 
          ? Timestamp.fromDate(updatedAt!)
          : null,
      'createdBy': createdBy,
      'mutedUsers': mutedUsers,
    };
  }

  /// Gets the display name for this chat room from the perspective of a specific user.
  /// 
  /// For direct chats, this returns the name of the OTHER participant.
  /// For group and class chats, this returns the chat room's name.
  /// 
  /// @param currentUserId The ID of the user viewing the chat
  /// @return The display name for the chat room
  String getDisplayName(String currentUserId) {
    if (type == 'direct' && participants.length >= 2) {
      // For direct chats, show the other participant's name
      final otherParticipant = participants.firstWhere(
        (p) => p.id != currentUserId,
        orElse: () => participants.first,
      );
      return otherParticipant.name;
    }
    
    // For group and class chats, use the chat room name
    return name;
  }

  /// Gets the display photo URL for this chat room from the perspective of a specific user.
  /// 
  /// For direct chats, this returns the photo URL of the OTHER participant.
  /// For group and class chats, this returns null (groups don't have photos).
  /// 
  /// @param currentUserId The ID of the user viewing the chat
  /// @return The photo URL for the chat room, or null
  String? getDisplayPhotoUrl(String currentUserId) {
    if (type == 'direct' && participants.length >= 2) {
      // For direct chats, show the other participant's photo
      final otherParticipant = participants.firstWhere(
        (p) => p.id != currentUserId,
        orElse: () => participants.first,
      );
      return otherParticipant.photoUrl;
    }
    
    // Group and class chats don't have individual photos
    return null;
  }

  /// Creates a copy of the ChatRoom with updated fields.
  /// 
  /// Follows immutable data pattern for state management.
  /// Useful for:
  /// - Updating last message information
  /// - Managing participant lists
  /// - Tracking unread counts
  /// - Modifying room metadata
  /// 
  /// All parameters are optional - only provided fields will be updated.
  /// 
  /// @return New ChatRoom instance with updated fields
  ChatRoom copyWith({
    String? id,
    String? name,
    String? type,
    List<String>? participantIds,
    List<ParticipantInfo>? participants,
    String? lastMessage,
    DateTime? lastMessageTime,
    String? lastMessageSenderId,
    int? unreadCount,
    Map<String, int>? unreadCounts,
    String? classId,
    DateTime? createdAt,
    DateTime? updatedAt,
    String? createdBy,
    List<String>? mutedUsers,
  }) {
    return ChatRoom(
      id: id ?? this.id,
      name: name ?? this.name,
      type: type ?? this.type,
      participantIds: participantIds ?? this.participantIds,
      participants: participants ?? this.participants,
      lastMessage: lastMessage ?? this.lastMessage,
      lastMessageTime: lastMessageTime ?? this.lastMessageTime,
      lastMessageSenderId: lastMessageSenderId ?? this.lastMessageSenderId,
      unreadCount: unreadCount ?? this.unreadCount,
      unreadCounts: unreadCounts ?? this.unreadCounts,
      classId: classId ?? this.classId,
      createdAt: createdAt ?? this.createdAt,
      updatedAt: updatedAt ?? this.updatedAt,
      createdBy: createdBy ?? this.createdBy,
      mutedUsers: mutedUsers ?? this.mutedUsers,
    );
  }
}

/// Information about a chat room participant.
/// 
/// This model stores detailed information about each participant
/// in a chat room, including their identity and role. This allows
/// for rich participant displays without requiring additional
/// database lookups.
class ParticipantInfo {
  /// User ID of the participant
  final String id;
  
  /// Display name of the participant
  final String name;
  
  /// Role of the participant (e.g., 'teacher', 'student')
  final String role;
  
  /// Optional URL to participant's profile photo
  final String? photoUrl;

  ParticipantInfo({
    required this.id,
    required this.name,
    required this.role,
    this.photoUrl,
  });

  /// Factory constructor to create ParticipantInfo from a Map.
  /// 
  /// Used when deserializing participant data from Firestore
  /// documents. Provides safe defaults for all required fields.
  /// 
  /// @param map Map containing participant data
  /// @return Parsed ParticipantInfo instance
  factory ParticipantInfo.fromMap(Map<String, dynamic> map) {
    return ParticipantInfo(
      id: map['id'] ?? '',
      name: map['name'] ?? '',
      role: map['role'] ?? '',
      photoUrl: map['photoUrl'],
    );
  }

  /// Converts the ParticipantInfo instance to a Map.
  /// 
  /// Used for serializing participant data when storing
  /// chat rooms in Firestore.
  /// 
  /// @return Map containing all participant information
  Map<String, dynamic> toMap() {
    return {
      'id': id,
      'name': name,
      'role': role,
      'photoUrl': photoUrl,
    };
  }
}
````

## File: lib/features/chat/domain/models/message.dart
````dart
/// Message model for real-time chat functionality.
/// 
/// This module contains the data model for messages used in
/// chat rooms and direct messaging within the education platform.
library;

import 'package:cloud_firestore/cloud_firestore.dart';

/// Core message model representing individual chat messages.
/// 
/// Messages support various features for educational communication:
/// - Text content with sender identification
/// - File attachments (images, documents)
/// - Scheduled message delivery
/// - Read receipts and delivery status
/// - Message editing with history tracking
/// - Role-based sender identification
/// 
/// Messages can be sent immediately or scheduled for future delivery,
/// supporting asynchronous teacher-student communication.
class Message {
  /// Unique identifier for the message
  final String id;
  
  /// User ID of the message sender
  final String senderId;
  
  /// Cached name of the sender for display
  final String senderName;
  
  /// Role of the sender ('teacher' or 'student')
  final String senderRole;
  
  /// Text content of the message
  final String content;
  
  /// Timestamp when the message was sent/created
  final DateTime timestamp;
  
  /// Whether the message has been read by recipient
  final bool isRead;
  
  /// Optional URL to attached file
  final String? attachmentUrl;
  
  /// Type of attachment ('image', 'document', 'video', etc.)
  final String? attachmentType;
  
  /// Future timestamp for scheduled messages
  final DateTime? scheduledFor;
  
  /// Whether this is a scheduled message
  final bool isScheduled;
  
  /// Current status of the message
  final MessageStatus status;
  
  /// Whether the message has been edited
  final bool isEdited;
  
  /// Timestamp of last edit (null if never edited)
  final DateTime? editedAt;

  Message({
    required this.id,
    required this.senderId,
    required this.senderName,
    required this.senderRole,
    required this.content,
    required this.timestamp,
    this.isRead = false,
    this.attachmentUrl,
    this.attachmentType,
    this.scheduledFor,
    this.isScheduled = false,
    this.status = MessageStatus.sent,
    this.isEdited = false,
    this.editedAt,
  });

  /// Factory constructor to create Message from Firestore document.
  /// 
  /// Handles data parsing with comprehensive defaults:
  /// - Timestamp conversions for all date fields
  /// - Status enum parsing with fallback to 'sent'
  /// - Null safety for optional fields
  /// - Default values for boolean flags
  /// 
  /// @param doc Firestore document snapshot containing message data
  /// @return Parsed Message instance
  factory Message.fromFirestore(DocumentSnapshot doc) {
    final data = doc.data() as Map<String, dynamic>;
    return Message(
      id: doc.id,
      senderId: data['senderId'] ?? '',
      senderName: data['senderName'] ?? '',
      senderRole: data['senderRole'] ?? '',
      content: data['content'] ?? '',
      timestamp: (data['timestamp'] as Timestamp).toDate(),
      isRead: data['isRead'] ?? false,
      attachmentUrl: data['attachmentUrl'],
      attachmentType: data['attachmentType'],
      scheduledFor: data['scheduledFor'] != null 
          ? (data['scheduledFor'] as Timestamp).toDate() 
          : null,
      isScheduled: data['isScheduled'] ?? false,
      status: data['status'] != null 
          ? MessageStatus.values.firstWhere(
              (s) => s.name == data['status'],
              orElse: () => MessageStatus.sent,
            )
          : MessageStatus.sent,
      isEdited: data['isEdited'] ?? false,
      editedAt: data['editedAt'] != null 
          ? (data['editedAt'] as Timestamp).toDate() 
          : null,
    );
  }

  /// Alternative factory constructor to create Message from Map data.
  /// 
  /// Similar to fromFirestore but accepts ID separately, useful for:
  /// - Creating messages from cached data
  /// - Testing with mock data
  /// - Data transformations
  /// 
  /// Includes additional safety with fallback to current timestamp
  /// when timestamp data is missing.
  /// 
  /// @param id Message identifier
  /// @param data Map containing message fields
  /// @return Parsed Message instance
  factory Message.fromMap(String id, Map<String, dynamic> data) {
    return Message(
      id: id,
      senderId: data['senderId'] ?? '',
      senderName: data['senderName'] ?? '',
      senderRole: data['senderRole'] ?? 'student',
      content: data['content'] ?? '',
      timestamp: data['timestamp'] != null 
          ? (data['timestamp'] as Timestamp).toDate() 
          : DateTime.now(),
      isRead: data['isRead'] ?? false,
      attachmentUrl: data['attachmentUrl'],
      attachmentType: data['attachmentType'],
      scheduledFor: data['scheduledFor'] != null 
          ? (data['scheduledFor'] as Timestamp).toDate() 
          : null,
      isScheduled: data['isScheduled'] ?? false,
      status: data['status'] != null
          ? MessageStatus.values.firstWhere(
              (e) => e.name == data['status'],
              orElse: () => MessageStatus.sent,
            )
          : MessageStatus.sent,
      isEdited: data['isEdited'] ?? false,
      editedAt: data['editedAt'] != null 
          ? (data['editedAt'] as Timestamp).toDate() 
          : null,
    );
  }

  /// Converts the Message instance to a Map for Firestore storage.
  /// 
  /// Serializes all message data including:
  /// - DateTime fields to Firestore Timestamps
  /// - Status enum to string using .name property
  /// - Conditional serialization of optional fields
  /// - Attachment metadata preservation
  /// 
  /// @return Map containing all message data for Firestore
  Map<String, dynamic> toFirestore() {
    return {
      'senderId': senderId,
      'senderName': senderName,
      'senderRole': senderRole,
      'content': content,
      'timestamp': Timestamp.fromDate(timestamp),
      'isRead': isRead,
      'attachmentUrl': attachmentUrl,
      'attachmentType': attachmentType,
      'scheduledFor': scheduledFor != null 
          ? Timestamp.fromDate(scheduledFor!) 
          : null,
      'isScheduled': isScheduled,
      'status': status.name,
      'isEdited': isEdited,
      'editedAt': editedAt != null 
          ? Timestamp.fromDate(editedAt!) 
          : null,
    };
  }

  /// Creates a copy of the Message with updated fields.
  /// 
  /// Follows immutable data pattern for state management.
  /// Useful for:
  /// - Marking messages as read
  /// - Updating delivery status
  /// - Adding edit timestamps
  /// - Changing scheduled delivery times
  /// 
  /// All parameters are optional - only provided fields will be updated.
  /// 
  /// @return New Message instance with updated fields
  Message copyWith({
    String? id,
    String? senderId,
    String? senderName,
    String? senderRole,
    String? content,
    DateTime? timestamp,
    bool? isRead,
    String? attachmentUrl,
    String? attachmentType,
    DateTime? scheduledFor,
    bool? isScheduled,
    MessageStatus? status,
    bool? isEdited,
    DateTime? editedAt,
  }) {
    return Message(
      id: id ?? this.id,
      senderId: senderId ?? this.senderId,
      senderName: senderName ?? this.senderName,
      senderRole: senderRole ?? this.senderRole,
      content: content ?? this.content,
      timestamp: timestamp ?? this.timestamp,
      isRead: isRead ?? this.isRead,
      attachmentUrl: attachmentUrl ?? this.attachmentUrl,
      attachmentType: attachmentType ?? this.attachmentType,
      scheduledFor: scheduledFor ?? this.scheduledFor,
      isScheduled: isScheduled ?? this.isScheduled,
      status: status ?? this.status,
      isEdited: isEdited ?? this.isEdited,
      editedAt: editedAt ?? this.editedAt,
    );
  }
}

/// Enumeration representing message delivery states.
/// 
/// Messages progress through these states:
/// - [sent]: Message created and sent to server
/// - [delivered]: Message received by recipient's device
/// - [read]: Message viewed by recipient
/// - [failed]: Message delivery failed
/// 
/// Status tracking enables delivery confirmation and
/// read receipts for better communication awareness.
enum MessageStatus {
  sent,
  delivered,
  read,
  failed,
}
````

## File: lib/features/chat/domain/repositories/chat_repository.dart
````dart
/// Chat repository interface for messaging functionality.
/// 
/// This module defines the contract for chat operations in the
/// education platform, supporting real-time messaging between
/// teachers, students, and parents.
library;

import '../models/message.dart';
import '../models/chat_room.dart';
import '../../../../shared/repositories/base_repository.dart';

/// Abstract repository defining chat and messaging operations.
/// 
/// This interface provides a comprehensive contract for chat
/// implementations, supporting:
/// - Chat room creation and management
/// - Real-time message sending and receiving
/// - Direct and group chat functionality
/// - Message status tracking and read receipts
/// - Typing indicators and presence
/// - Search capabilities
/// - Unread message counting
/// - Batch operations for efficiency
/// 
/// Concrete implementations handle the actual messaging
/// infrastructure and real-time synchronization.
abstract class ChatRepository extends BaseRepository {
  // Chat room operations
  
  /// Creates a new chat room.
  /// 
  /// Initializes a chat room with participants and settings.
  /// Returns the generated chat room ID.
  /// 
  /// @param chatRoom Chat room model to create
  /// @return Generated chat room ID
  /// @throws Exception if creation fails
  Future<String> createChatRoom(ChatRoom chatRoom);
  
  /// Retrieves a chat room by ID.
  /// 
  /// Fetches complete chat room details including participants
  /// and metadata. Returns null if not found.
  /// 
  /// @param id Chat room identifier
  /// @return Chat room instance or null
  /// @throws Exception if retrieval fails
  Future<ChatRoom?> getChatRoom(String id);
  
  /// Updates chat room information.
  /// 
  /// Modifies chat room details such as name, participants,
  /// or settings. Cannot change room type after creation.
  /// 
  /// @param id Chat room identifier
  /// @param chatRoom Updated chat room model
  /// @throws Exception if update fails
  Future<void> updateChatRoom(String id, ChatRoom chatRoom);
  
  /// Deletes a chat room and all messages.
  /// 
  /// Permanently removes the chat room and message history.
  /// This operation cannot be undone.
  /// 
  /// @param id Chat room identifier
  /// @throws Exception if deletion fails
  Future<void> deleteChatRoom(String id);
  
  // Create or get direct chat
  
  /// Creates or retrieves a direct chat between two users.
  /// 
  /// If a direct chat already exists between the current user
  /// and the specified user, returns the existing chat room.
  /// Otherwise, creates a new direct chat room.
  /// 
  /// @param otherUserId ID of the other participant
  /// @param otherUserName Display name of the other user
  /// @param otherUserRole Role of the other user
  /// @return Created or existing chat room
  /// @throws Exception if operation fails
  Future<ChatRoom> createOrGetDirectChat(
    String otherUserId,
    String otherUserName,
    String otherUserRole,
  );
  
  // Create group chat
  
  /// Creates a new group chat room.
  /// 
  /// Initializes a group chat with multiple participants.
  /// Can be class-specific or general purpose group.
  /// 
  /// @param name Display name for the group
  /// @param type Chat room type (group/class/announcement)
  /// @param participantIds List of user IDs to include
  /// @param participants Detailed participant information
  /// @param classId Optional class association
  /// @return Created group chat room
  /// @throws Exception if creation fails
  Future<ChatRoom> createGroupChat({
    required String name,
    required String type,
    required List<String> participantIds,
    required List<ParticipantInfo> participants,
    String? classId,
  });
  
  // Message operations
  
  /// Sends a message to a chat room.
  /// 
  /// Creates and delivers a message with optional attachments.
  /// Updates last message and unread counts automatically.
  /// 
  /// @param chatRoomId Target chat room ID
  /// @param content Message text content
  /// @param attachmentUrl Optional file attachment URL
  /// @param attachmentType Optional attachment MIME type
  /// @return Generated message ID
  /// @throws Exception if sending fails
  Future<String> sendMessage({
    required String chatRoomId,
    required String content,
    String? attachmentUrl,
    String? attachmentType,
  });
  
  /// Deletes a message from a chat room.
  /// 
  /// Removes the message for all participants. May show
  /// as "deleted message" depending on implementation.
  /// 
  /// @param chatRoomId Chat room containing the message
  /// @param messageId Message to delete
  /// @throws Exception if deletion fails
  Future<void> deleteMessage(String chatRoomId, String messageId);
  
  /// Edits an existing message.
  /// 
  /// Updates message content and marks as edited with
  /// timestamp. Original sender only can edit.
  /// 
  /// @param chatRoomId Chat room containing the message
  /// @param messageId Message to edit
  /// @param newContent Updated message content
  /// @throws Exception if edit fails
  Future<void> editMessage(String chatRoomId, String messageId, String newContent);
  
  // Streams
  
  /// Streams chat rooms for the current user.
  /// 
  /// Returns real-time updates of all chat rooms where
  /// the user is a participant. Includes unread counts
  /// and last message information.
  /// 
  /// @return Stream of user's chat room lists
  Stream<List<ChatRoom>> getUserChatRooms();
  
  /// Streams messages for a specific chat room.
  /// 
  /// Returns real-time message updates ordered by timestamp.
  /// Includes new messages, edits, and deletions.
  /// 
  /// @param chatRoomId Chat room to monitor
  /// @return Stream of message lists
  Stream<List<Message>> getChatMessages(String chatRoomId);
  
  // Chat room management
  
  /// Adds a participant to a group chat.
  /// 
  /// Only admins can add participants to existing groups.
  /// Updates participant list and sends system message.
  /// 
  /// @param chatRoomId Target chat room
  /// @param userId User to add
  /// @param participantInfo User's participant details
  /// @throws Exception if addition fails
  Future<void> addParticipant(String chatRoomId, String userId, ParticipantInfo participantInfo);
  
  /// Removes a participant from a group chat.
  /// 
  /// Only admins can remove other participants.
  /// Sends system message about removal.
  /// 
  /// @param chatRoomId Target chat room
  /// @param userId User to remove
  /// @throws Exception if removal fails
  Future<void> removeParticipant(String chatRoomId, String userId);
  
  /// Leaves a chat room.
  /// 
  /// Current user voluntarily exits the chat room.
  /// Cannot leave direct chats, only groups.
  /// 
  /// @param chatRoomId Chat room to leave
  /// @throws Exception if leaving fails
  Future<void> leaveChatRoom(String chatRoomId);
  
  /// Updates the last message in a chat room.
  /// 
  /// Internal method to maintain chat room metadata.
  /// Called automatically when messages are sent.
  /// 
  /// @param chatRoomId Chat room to update
  /// @param message Latest message
  /// @throws Exception if update fails
  Future<void> updateLastMessage(String chatRoomId, Message message);
  
  // Message status
  
  /// Marks all messages in a chat as read.
  /// 
  /// Updates read status for all unread messages from
  /// other participants. Resets unread count to zero.
  /// 
  /// @param chatRoomId Chat room to mark as read
  /// @throws Exception if marking fails
  Future<void> markMessagesAsRead(String chatRoomId);
  
  /// Marks a specific message as delivered.
  /// 
  /// Updates delivery status when message reaches recipient.
  /// Usually called automatically by the messaging system.
  /// 
  /// @param chatRoomId Chat room containing message
  /// @param messageId Message to mark delivered
  /// @throws Exception if update fails
  Future<void> markMessageAsDelivered(String chatRoomId, String messageId);
  
  // Search and query
  
  /// Searches messages within a chat room.
  /// 
  /// Performs text search on message content.
  /// Returns matching messages ordered by relevance.
  /// 
  /// @param chatRoomId Chat room to search
  /// @param query Search terms
  /// @return List of matching messages
  /// @throws Exception if search fails
  Future<List<Message>> searchMessages(String chatRoomId, String query);
  
  /// Searches across all user's chat rooms.
  /// 
  /// Searches chat room names and participant names.
  /// Useful for finding specific conversations.
  /// 
  /// @param query Search terms
  /// @return List of matching chat rooms
  /// @throws Exception if search fails
  Future<List<ChatRoom>> searchChatRooms(String query);
  
  /// Finds existing direct chat between two users.
  /// 
  /// Checks if a direct chat exists between specified users.
  /// Order of user IDs doesn't matter.
  /// 
  /// @param userId1 First user ID
  /// @param userId2 Second user ID
  /// @return Existing chat room or null
  /// @throws Exception if search fails
  Future<ChatRoom?> findDirectChat(String userId1, String userId2);
  
  // Typing indicators
  
  /// Sets typing status for current user.
  /// 
  /// Updates real-time typing indicator shown to other
  /// participants. Should be called on text input changes.
  /// 
  /// @param chatRoomId Chat room where typing
  /// @param isTyping Whether user is currently typing
  /// @throws Exception if update fails
  Future<void> setTypingStatus(String chatRoomId, bool isTyping);
  
  /// Streams typing statuses for a chat room.
  /// 
  /// Returns real-time updates of which users are typing.
  /// Map keys are user IDs, values are typing status.
  /// 
  /// @param chatRoomId Chat room to monitor
  /// @return Stream of typing status maps
  Stream<Map<String, bool>> getTypingStatuses(String chatRoomId);
  
  // Unread counts
  
  /// Gets unread message count for a chat room.
  /// 
  /// Returns number of messages received since last read.
  /// Used for notification badges.
  /// 
  /// @param chatRoomId Chat room to check
  /// @return Number of unread messages
  /// @throws Exception if count fails
  Future<int> getUnreadCount(String chatRoomId);
  
  /// Gets unread counts for all user's chats.
  /// 
  /// Returns map of chat room IDs to unread counts.
  /// Efficient way to get all badges at once.
  /// 
  /// @return Map of chat room IDs to unread counts
  /// @throws Exception if retrieval fails
  Future<Map<String, int>> getAllUnreadCounts();
  
  // Batch operations
  
  /// Deletes multiple messages in one operation.
  /// 
  /// Efficiently removes multiple messages using batch writes.
  /// All deletions succeed or fail together.
  /// 
  /// @param chatRoomId Chat room containing messages
  /// @param messageIds List of messages to delete
  /// @throws Exception if batch deletion fails
  Future<void> batchDeleteMessages(String chatRoomId, List<String> messageIds);
  
  /// Updates status for multiple messages.
  /// 
  /// Batch updates message status (delivered/read) for efficiency.
  /// Commonly used when marking multiple messages as read.
  /// 
  /// @param chatRoomId Chat room containing messages
  /// @param messageIds List of messages to update
  /// @param status New status to apply
  /// @throws Exception if batch update fails
  Future<void> batchUpdateMessageStatus(String chatRoomId, List<String> messageIds, MessageStatus status);
}
````

## File: lib/features/chat/presentation/providers/call_provider.dart
````dart
import 'package:flutter/material.dart';
import 'dart:async';
import '../../data/services/webrtc_service.dart';
import '../../domain/models/call.dart';
import '../../../../shared/services/logger_service.dart';
import '../../../notifications/data/services/notification_service.dart';
import '../../../notifications/data/services/firebase_messaging_service.dart';

class CallProvider extends ChangeNotifier {
  static const String _tag = 'CallProvider';
  
  final WebRTCService _webrtcService = WebRTCService();
  
  Call? _currentCall;
  Call? _incomingCall;
  StreamSubscription? _incomingCallSubscription;
  bool _isNavigationInProgress = false;
  
  Call? get currentCall => _currentCall;
  Call? get incomingCall => _incomingCall;
  bool get hasIncomingCall => _incomingCall != null;
  bool get isNavigationInProgress => _isNavigationInProgress;

  CallProvider() {
    _initialize();
  }

  Future<void> _initialize() async {
    try {
      await _webrtcService.initialize();
      _listenForIncomingCalls();
      _setupNotificationHandlers();
      _setupFirebaseMessagingHandlers();
    } catch (e) {
      LoggerService.error('Failed to initialize call provider', tag: _tag, error: e);
    }
  }

  void _listenForIncomingCalls() {
    _incomingCallSubscription = _webrtcService.getIncomingCalls().listen(
      (call) {
        LoggerService.info('Incoming call from ${call.callerName}', tag: _tag);
        _incomingCall = call;
        notifyListeners();
      },
      onError: (error) {
        LoggerService.error('Error listening for incoming calls', tag: _tag, error: error);
      },
    );
  }

  Future<String> startCall({
    required String receiverId,
    required String receiverName,
    required String receiverPhotoUrl,
    required bool isVideoCall,
    String? chatRoomId,
  }) async {
    try {
      final callId = await _webrtcService.startCall(
        receiverId: receiverId,
        receiverName: receiverName,
        receiverPhotoUrl: receiverPhotoUrl,
        isVideoCall: isVideoCall,
        chatRoomId: chatRoomId,
      );
      
      _currentCall = _webrtcService.currentCallState;
      notifyListeners();
      
      return callId;
    } catch (e) {
      LoggerService.error('Failed to start call', tag: _tag, error: e);
      rethrow;
    }
  }

  Future<void> acceptCall(String callId) async {
    try {
      await _webrtcService.acceptCall(callId);
      _currentCall = _webrtcService.currentCallState;
      _incomingCall = null;
      _isNavigationInProgress = false;
      notifyListeners();
    } catch (e) {
      LoggerService.error('Failed to accept call', tag: _tag, error: e);
      rethrow;
    }
  }

  Future<void> rejectCall(String callId) async {
    try {
      await _webrtcService.rejectCall(callId);
      _incomingCall = null;
      _isNavigationInProgress = false;
      notifyListeners();
    } catch (e) {
      LoggerService.error('Failed to reject call', tag: _tag, error: e);
      rethrow;
    }
  }

  Future<void> endCall() async {
    try {
      await _webrtcService.endCall();
      _currentCall = null;
      notifyListeners();
    } catch (e) {
      LoggerService.error('Failed to end call', tag: _tag, error: e);
      rethrow;
    }
  }

  void dismissIncomingCall() {
    _incomingCall = null;
    _isNavigationInProgress = false;
    notifyListeners();
  }

  void setNavigationInProgress(bool inProgress) {
    _isNavigationInProgress = inProgress;
    notifyListeners();
  }

  WebRTCService get webrtcService => _webrtcService;

  void _setupNotificationHandlers() {
    final notificationService = NotificationService();
    
    // Handle call accepted from notification
    notificationService.onCallAccepted = (callId) {
      LoggerService.info('Call accepted from notification: $callId', tag: _tag);
      acceptCall(callId);
    };
    
    // Handle call declined from notification
    notificationService.onCallDeclined = (callId) {
      LoggerService.info('Call declined from notification: $callId', tag: _tag);
      rejectCall(callId);
    };
  }
  
  void _setupFirebaseMessagingHandlers() {
    final messagingService = FirebaseMessagingService();
    
    // Handle incoming VoIP call from FCM
    messagingService.onIncomingCall = (call) {
      LoggerService.info('Incoming VoIP call from FCM: ${call.callerName}', tag: _tag);
      _incomingCall = call;
      notifyListeners();
      
      // Show notification
      final notificationService = NotificationService();
      notificationService.showIncomingCall(call);
    };
  }
  
  Future<String> startCallWithNotification({
    required String receiverId,
    required String receiverName,
    required String receiverPhotoUrl,
    required bool isVideoCall,
    String? chatRoomId,
  }) async {
    try {
      // Start the call
      final callId = await startCall(
        receiverId: receiverId,
        receiverName: receiverName,
        receiverPhotoUrl: receiverPhotoUrl,
        isVideoCall: isVideoCall,
        chatRoomId: chatRoomId,
      );
      
      // Send push notification to receiver
      final messagingService = FirebaseMessagingService();
      await messagingService.sendCallNotification(
        receiverId: receiverId,
        callId: callId,
        callerName: _webrtcService.currentUserName,
        isVideo: isVideoCall,
        callerPhotoUrl: _webrtcService.currentUserPhoto,
        chatRoomId: chatRoomId,
      );
      
      return callId;
    } catch (e) {
      LoggerService.error('Failed to start call with notification', tag: _tag, error: e);
      rethrow;
    }
  }

  @override
  void dispose() {
    _incomingCallSubscription?.cancel();
    _webrtcService.dispose();
    super.dispose();
  }
}
````

## File: lib/features/chat/presentation/screens/call_screen.dart
````dart
import 'package:flutter/material.dart';
import 'package:flutter_webrtc/flutter_webrtc.dart';
import 'package:go_router/go_router.dart';
import 'package:permission_handler/permission_handler.dart';
import 'package:cached_network_image/cached_network_image.dart';
import '../../data/services/webrtc_service.dart';
import '../../domain/models/call.dart';
import 'dart:async';

class CallScreen extends StatefulWidget {
  final String? callId; // For incoming calls
  final String? receiverId; // For outgoing calls
  final String? receiverName;
  final String? receiverPhotoUrl;
  final bool isVideoCall;
  final String? chatRoomId;

  const CallScreen({
    super.key,
    this.callId,
    this.receiverId,
    this.receiverName,
    this.receiverPhotoUrl,
    required this.isVideoCall,
    this.chatRoomId,
  });

  @override
  State<CallScreen> createState() => _CallScreenState();
}

class _CallScreenState extends State<CallScreen> {
  final WebRTCService _webrtcService = WebRTCService();
  final RTCVideoRenderer _localRenderer = RTCVideoRenderer();
  final RTCVideoRenderer _remoteRenderer = RTCVideoRenderer();
  
  bool _isMuted = false;
  bool _isVideoEnabled = true;
  bool _isSpeakerOn = false;
  bool _isConnecting = true;
  bool _renderersInitialized = false;
  Timer? _callTimer;
  Duration _callDuration = Duration.zero;

  @override
  void initState() {
    super.initState();
    _initRenderers();
  }
  
  Future<void> _initRenderers() async {
    try {
      await _localRenderer.initialize();
      await _remoteRenderer.initialize();
      setState(() {
        _renderersInitialized = true;
      });
      _initCall();
    } catch (e) {
      debugPrint('Renderer init failed: $e');
      if (mounted) {
        context.pop();
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(content: Text('Failed to initialize video renderers')),
        );
      }
    }
  }

  @override
  void dispose() {
    _callTimer?.cancel();
    _localRenderer.dispose();
    _remoteRenderer.dispose();
    _webrtcService.dispose();
    super.dispose();
  }

  Future<void> _initCall() async {
    // Request permissions
    final permissions = [
      Permission.camera,
      Permission.microphone,
    ];
    
    final statuses = await permissions.request();
    
    if (!mounted) return;

    if (statuses[Permission.microphone]!.isDenied ||
        (widget.isVideoCall && statuses[Permission.camera]!.isDenied)) {
      context.pop();
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(
          content: Text('Camera and microphone permissions are required for calls'),
        ),
      );
      return;
    }

    // Initialize WebRTC
    await _webrtcService.initialize();
    
    // Set up callbacks
    _webrtcService.onLocalStream = (stream) {
      if (!mounted || !_renderersInitialized) return;
      setState(() {
        _localRenderer.srcObject = stream;
      });
    };
    
    _webrtcService.onRemoteStream = (stream) {
      if (!mounted || !_renderersInitialized) return;
      setState(() {
        _remoteRenderer.srcObject = stream;
        _isConnecting = false;
      });
    };
    
    _webrtcService.onCallStateChanged = (call) {
      if (!mounted) return;
      setState(() {
        if (call.status == CallStatus.accepted && _callTimer == null) {
          _startCallTimer();
        } else if (call.status == CallStatus.ended || 
                   call.status == CallStatus.rejected) {
          _callTimer?.cancel();
          // Navigation is handled in _endCall() method to prevent double pop
        }
      });
    };

    // Start or accept call
    if (widget.callId != null) {
      // Incoming call - accept it
      await _webrtcService.acceptCall(widget.callId!);
    } else if (widget.receiverId != null) {
      // Outgoing call - start it
      await _webrtcService.startCall(
        receiverId: widget.receiverId!,
        receiverName: widget.receiverName!,
        receiverPhotoUrl: widget.receiverPhotoUrl!,
        isVideoCall: widget.isVideoCall,
        chatRoomId: widget.chatRoomId,
      );
    }
  }

  void _startCallTimer() {
    _callTimer = Timer.periodic(const Duration(seconds: 1), (timer) {
      if (!mounted) {
        timer.cancel();
        return;
      }
      setState(() {
        _callDuration = Duration(seconds: _callDuration.inSeconds + 1);
      });
    });
  }

  void _toggleMute() async {
    await _webrtcService.toggleMute();
    if (!mounted) return;
    setState(() {
      _isMuted = !_isMuted;
    });
  }

  void _toggleVideo() async {
    await _webrtcService.toggleVideo();
    if (!mounted) return;
    setState(() {
      _isVideoEnabled = !_isVideoEnabled;
    });
  }

  void _toggleSpeaker() {
    setState(() {
      _isSpeakerOn = !_isSpeakerOn;
    });
    // TODO: Implement speaker toggle
  }

  void _switchCamera() async {
    await _webrtcService.switchCamera();
  }

  void _endCall() async {
    // Cancel timer immediately to prevent further updates
    _callTimer?.cancel();
    
    // End the call and wait for cleanup
    await _webrtcService.endCall();
    
    // Navigate back using GoRouter
    if (!mounted) return;
    context.pop();
  }

  String _formatDuration(Duration duration) {
    String twoDigits(int n) => n.toString().padLeft(2, '0');
    String twoDigitMinutes = twoDigits(duration.inMinutes.remainder(60));
    String twoDigitSeconds = twoDigits(duration.inSeconds.remainder(60));
    return "${twoDigits(duration.inHours)}:$twoDigitMinutes:$twoDigitSeconds";
  }

  @override
  Widget build(BuildContext context) {
    final isVideoCall = widget.isVideoCall;
    
    return Scaffold(
      backgroundColor: Colors.black,
      body: Stack(
        children: [
          // Remote video/avatar
          if (isVideoCall)
            Positioned.fill(
              child: _renderersInitialized 
                ? RTCVideoView(
                    _remoteRenderer,
                    objectFit: RTCVideoViewObjectFit.RTCVideoViewObjectFitCover,
                    placeholderBuilder: (context) => Center(
                      child: _buildUserAvatar(
                        widget.receiverName ?? 'User',
                        widget.receiverPhotoUrl,
                        size: 120,
                      ),
                    ),
                  )
                : Center(
                    child: _buildUserAvatar(
                      widget.receiverName ?? 'User',
                      widget.receiverPhotoUrl,
                      size: 120,
                    ),
                  ),
            )
          else
            Center(
              child: _buildUserAvatar(
                widget.receiverName ?? 'User',
                widget.receiverPhotoUrl,
                size: 120,
              ),
            ),
          
          // Local video (PiP)
          if (isVideoCall && _isVideoEnabled)
            Positioned(
              top: 80,
              right: 20,
              width: 120,
              height: 160,
              child: ClipRRect(
                borderRadius: BorderRadius.circular(12),
                child: _renderersInitialized
                  ? RTCVideoView(
                      _localRenderer,
                      objectFit: RTCVideoViewObjectFit.RTCVideoViewObjectFitCover,
                      mirror: true,
                    )
                  : Container(
                      color: Colors.black54,
                      child: const Center(
                        child: CircularProgressIndicator(color: Colors.white),
                      ),
                    ),
              ),
            ),
          
          // Top bar with call info
          Positioned(
            top: 0,
            left: 0,
            right: 0,
            child: Container(
              decoration: BoxDecoration(
                gradient: LinearGradient(
                  begin: Alignment.topCenter,
                  end: Alignment.bottomCenter,
                  colors: [
                    Colors.black.withAlpha(179),
                    Colors.transparent,
                  ],
                ),
              ),
              child: SafeArea(
                child: Padding(
                  padding: const EdgeInsets.all(16.0),
                  child: Column(
                    children: [
                      Text(
                        widget.receiverName ?? 'Unknown',
                        style: const TextStyle(
                          color: Colors.white,
                          fontSize: 24,
                          fontWeight: FontWeight.bold,
                        ),
                      ),
                      const SizedBox(height: 8),
                      Text(
                        _isConnecting
                            ? 'Connecting...'
                            : _formatDuration(_callDuration),
                        style: const TextStyle(
                          color: Colors.white70,
                          fontSize: 16,
                        ),
                      ),
                    ],
                  ),
                ),
              ),
            ),
          ),
          
          // Bottom controls
          Positioned(
            bottom: 0,
            left: 0,
            right: 0,
            child: Container(
              decoration: BoxDecoration(
                gradient: LinearGradient(
                  begin: Alignment.bottomCenter,
                  end: Alignment.topCenter,
                  colors: [
                    Colors.black.withAlpha(179),
                    Colors.transparent,
                  ],
                ),
              ),
              child: SafeArea(
                child: Padding(
                  padding: const EdgeInsets.all(24.0),
                  child: Row(
                    mainAxisAlignment: MainAxisAlignment.spaceEvenly,
                    children: [
                      // Speaker button (voice calls only)
                      if (!isVideoCall)
                        _buildControlButton(
                          icon: _isSpeakerOn ? Icons.volume_up : Icons.volume_down,
                          onPressed: _toggleSpeaker,
                          backgroundColor: _isSpeakerOn ? Colors.white : Colors.white24,
                          iconColor: _isSpeakerOn ? Colors.black : Colors.white,
                        ),
                      
                      // Video toggle (video calls only)
                      if (isVideoCall)
                        _buildControlButton(
                          icon: _isVideoEnabled ? Icons.videocam : Icons.videocam_off,
                          onPressed: _toggleVideo,
                          backgroundColor: _isVideoEnabled ? Colors.white24 : Colors.white,
                          iconColor: _isVideoEnabled ? Colors.white : Colors.black,
                        ),
                      
                      // Mute button
                      _buildControlButton(
                        icon: _isMuted ? Icons.mic_off : Icons.mic,
                        onPressed: _toggleMute,
                        backgroundColor: _isMuted ? Colors.white : Colors.white24,
                        iconColor: _isMuted ? Colors.black : Colors.white,
                      ),
                      
                      // End call button
                      _buildControlButton(
                        icon: Icons.call_end,
                        onPressed: _endCall,
                        backgroundColor: Colors.red,
                        iconColor: Colors.white,
                        size: 72,
                      ),
                      
                      // Switch camera (video calls only)
                      if (isVideoCall)
                        _buildControlButton(
                          icon: Icons.cameraswitch,
                          onPressed: _switchCamera,
                          backgroundColor: Colors.white24,
                          iconColor: Colors.white,
                        ),
                    ],
                  ),
                ),
              ),
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildUserAvatar(String name, String? photoUrl, {double size = 48}) {
    return CircleAvatar(
      radius: size / 2,
      backgroundColor: Theme.of(context).primaryColor,
      backgroundImage: photoUrl != null && photoUrl.isNotEmpty
          ? CachedNetworkImageProvider(photoUrl)
          : null,
      child: photoUrl == null || photoUrl.isEmpty
          ? Text(
              name.isNotEmpty ? name[0].toUpperCase() : '?',
              style: TextStyle(
                fontSize: size / 2,
                color: Colors.white,
                fontWeight: FontWeight.bold,
              ),
            )
          : null,
    );
  }

  Widget _buildControlButton({
    required IconData icon,
    required VoidCallback onPressed,
    required Color backgroundColor,
    required Color iconColor,
    double size = 56,
  }) {
    return Container(
      width: size,
      height: size,
      decoration: BoxDecoration(
        shape: BoxShape.circle,
        color: backgroundColor,
      ),
      child: IconButton(
        icon: Icon(icon),
        color: iconColor,
        iconSize: size * 0.5,
        onPressed: onPressed,
      ),
    );
  }
}
````

## File: lib/features/chat/presentation/screens/chat_detail_screen.dart
````dart
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'package:firebase_auth/firebase_auth.dart';
import 'package:firebase_storage/firebase_storage.dart';
import 'package:intl/intl.dart';
import 'package:image_picker/image_picker.dart';
import 'package:go_router/go_router.dart';
import 'package:video_compress/video_compress.dart';
import 'package:video_player/video_player.dart';
import 'dart:io';
import '../providers/chat_provider.dart';
import '../../domain/models/message.dart';
import '../../data/services/scheduled_messages_service.dart';
import '../../../auth/presentation/providers/auth_provider.dart' as app_auth;

class ChatDetailScreen extends StatefulWidget {
  final String chatRoomId;

  const ChatDetailScreen({
    super.key,
    required this.chatRoomId,
  });

  @override
  State<ChatDetailScreen> createState() => _ChatDetailScreenState();
}

class _ChatDetailScreenState extends State<ChatDetailScreen> {
  final TextEditingController _messageController = TextEditingController();
  final ScrollController _scrollController = ScrollController();
  final FocusNode _focusNode = FocusNode();
  final ImagePicker _imagePicker = ImagePicker();
  bool _isUploading = false;
  double _uploadProgress = 0.0;
  late final ScheduledMessagesService _scheduledMessagesService;

  @override
  void initState() {
    super.initState();
    _scheduledMessagesService = ScheduledMessagesService();
    // Load chat room and messages when screen opens
    WidgetsBinding.instance.addPostFrameCallback((_) async {
      final chatProvider = context.read<ChatProvider>();
      
      try {
        // Find the chat room from the list
        final chatRoom = chatProvider.chatRooms.firstWhere(
          (room) => room.id == widget.chatRoomId,
        );
        chatProvider.setCurrentChatRoom(chatRoom);
      } catch (e) {
        // Try to fetch the chat room directly if not in the list
        try {
          final chatRoom = await chatProvider.getChatRoom(widget.chatRoomId);
          if (chatRoom != null) {
            chatProvider.setCurrentChatRoom(chatRoom);
          }
        } catch (e2) {
          // Failed to load chat room
        }
      }
    });
  }

  @override
  void dispose() {
    _messageController.dispose();
    _scrollController.dispose();
    _focusNode.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        leading: IconButton(
          icon: const Icon(Icons.arrow_back),
          onPressed: () {
            // Use GoRouter to ensure proper navigation
            if (context.canPop()) {
              context.pop();
            } else {
              // Navigate to messages list if can't pop
              context.go('/messages');
            }
          },
        ),
        title: Consumer<ChatProvider>(
          builder: (context, chatProvider, child) {
            final chatRoom = chatProvider.currentChatRoom;
            final authProvider = context.read<app_auth.AuthProvider>();
            final currentUserId = authProvider.userModel?.uid ?? '';
            
            final displayName = chatRoom?.getDisplayName(currentUserId) ?? 'Chat';
            
            return Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Text(displayName),
                if (chatRoom != null && chatRoom.type != 'direct')
                  Text(
                    '${chatRoom.participantIds.length} participants',
                    style: Theme.of(context).textTheme.bodySmall,
                  ),
              ],
            );
          },
        ),
        actions: [
          IconButton(
            icon: const Icon(Icons.phone),
            onPressed: () => _startCall(context, false),
            tooltip: 'Voice Call',
          ),
          IconButton(
            icon: const Icon(Icons.videocam),
            onPressed: () => _startCall(context, true),
            tooltip: 'Video Call',
          ),
          IconButton(
            icon: const Icon(Icons.info_outline),
            onPressed: () => _showChatInfo(context),
          ),
          PopupMenuButton<String>(
            onSelected: (value) {
              switch (value) {
                case 'search':
                  final chatProvider = context.read<ChatProvider>();
                  showSearch(
                    context: context,
                    delegate: ChatSearchDelegate(messages: chatProvider.currentMessages),
                  );
                  break;
                case 'mute':
                  // TODO: Implement mute notifications
                  break;
                case 'leave':
                  _leaveChatRoom(context);
                  break;
              }
            },
            itemBuilder: (context) => [
              const PopupMenuItem(
                value: 'search',
                child: Text('Search in chat'),
              ),
              const PopupMenuItem(
                value: 'mute',
                child: Text('Mute notifications'),
              ),
              if (context.read<ChatProvider>().currentChatRoom?.type !=
                  'direct')
                const PopupMenuItem(
                  value: 'leave',
                  child: Text('Leave chat'),
                ),
            ],
          ),
        ],
      ),
      body: Column(
        children: [
          Expanded(
            child: Consumer<ChatProvider>(
              builder: (context, chatProvider, child) {
                final messages = chatProvider.currentMessages;
                final error = chatProvider.error;

                if (error != null) {
                  return Center(
                    child: Column(
                      mainAxisAlignment: MainAxisAlignment.center,
                      children: [
                        const Icon(Icons.error_outline, size: 48, color: Colors.red),
                        const SizedBox(height: 16),
                        Text('Error: $error'),
                        const SizedBox(height: 16),
                        ElevatedButton(
                          onPressed: () {
                            chatProvider.loadChatMessages(widget.chatRoomId);
                          },
                          child: const Text('Retry'),
                        ),
                      ],
                    ),
                  );
                }

                if (messages.isEmpty) {
                  return const Center(
                    child: Text('No messages yet. Start the conversation!'),
                  );
                }

                return ListView.builder(
                  controller: _scrollController,
                  reverse: true,
                  padding: const EdgeInsets.all(16),
                  itemCount: messages.length,
                  itemBuilder: (context, index) {
                    final message = messages[index];
                    final previousMessage = index < messages.length - 1
                        ? messages[index + 1]
                        : null;

                    final showDate = previousMessage == null ||
                        !_isSameDay(
                            message.timestamp, previousMessage.timestamp);

                    return Column(
                      children: [
                        if (showDate) _buildDateDivider(message.timestamp),
                        _buildMessageBubble(context, message),
                      ],
                    );
                  },
                );
              },
            ),
          ),
          if (_isUploading)
            LinearProgressIndicator(
              value: _uploadProgress,
              backgroundColor:
                  Theme.of(context).colorScheme.surfaceContainerHighest,
            ),
          _buildMessageInput(context),
        ],
      ),
    );
  }

  Widget _buildDateDivider(DateTime date) {
    final now = DateTime.now();
    final difference = now.difference(date);
    String dateText;

    if (difference.inDays == 0) {
      dateText = 'Today';
    } else if (difference.inDays == 1) {
      dateText = 'Yesterday';
    } else {
      dateText = DateFormat('EEEE, MMMM d').format(date);
    }

    return Padding(
      padding: const EdgeInsets.symmetric(vertical: 16),
      child: Row(
        children: [
          const Expanded(child: Divider()),
          Padding(
            padding: const EdgeInsets.symmetric(horizontal: 16),
            child: Text(
              dateText,
              style: TextStyle(
                fontSize: 12,
                color: Theme.of(context).colorScheme.onSurfaceVariant,
              ),
            ),
          ),
          const Expanded(child: Divider()),
        ],
      ),
    );
  }

  Widget _buildMessageBubble(BuildContext context, Message message) {
    final currentUserId = FirebaseAuth.instance.currentUser?.uid;
    final isMe = message.senderId == currentUserId;
    final theme = Theme.of(context);

    return Align(
      alignment: isMe ? Alignment.centerRight : Alignment.centerLeft,
      child: Container(
        margin: const EdgeInsets.symmetric(vertical: 4),
        constraints: BoxConstraints(
          maxWidth: MediaQuery.of(context).size.width * 0.75,
        ),
        child: Column(
          crossAxisAlignment:
              isMe ? CrossAxisAlignment.end : CrossAxisAlignment.start,
          children: [
            if (!isMe)
              Padding(
                padding: const EdgeInsets.only(left: 12, bottom: 4),
                child: Text(
                  message.senderName,
                  style: TextStyle(
                    fontSize: 12,
                    color: theme.colorScheme.onSurfaceVariant,
                    fontWeight: FontWeight.w500,
                  ),
                ),
              ),
            Container(
              padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 10),
              decoration: BoxDecoration(
                color: isMe
                    ? theme.colorScheme.primary
                    : theme.colorScheme.surfaceContainerHighest,
                borderRadius: BorderRadius.only(
                  topLeft: const Radius.circular(20),
                  topRight: const Radius.circular(20),
                  bottomLeft: Radius.circular(isMe ? 20 : 4),
                  bottomRight: Radius.circular(isMe ? 4 : 20),
                ),
              ),
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  if (message.attachmentUrl != null) _buildAttachment(message),
                  Text(
                    message.content,
                    style: TextStyle(
                      color: isMe
                          ? theme.colorScheme.onPrimary
                          : theme.colorScheme.onSurfaceVariant,
                    ),
                  ),
                ],
              ),
            ),
            Padding(
              padding: const EdgeInsets.only(top: 4, left: 12, right: 12),
              child: Text(
                DateFormat('HH:mm').format(message.timestamp),
                style: TextStyle(
                  fontSize: 11,
                  color: theme.colorScheme.onSurfaceVariant,
                ),
              ),
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildAttachment(Message message) {
    if (message.attachmentType == 'image' && message.attachmentUrl != null) {
      return GestureDetector(
        onTap: () => _viewFullScreenImage(message.attachmentUrl!),
        child: Container(
          margin: const EdgeInsets.only(bottom: 8),
          constraints: const BoxConstraints(
            maxHeight: 200,
            maxWidth: 200,
          ),
          child: ClipRRect(
            borderRadius: BorderRadius.circular(12),
            child: Image.network(
              message.attachmentUrl!,
              fit: BoxFit.cover,
              loadingBuilder: (context, child, loadingProgress) {
                if (loadingProgress == null) return child;
                return Container(
                  height: 100,
                  width: 100,
                  color: Colors.grey[300],
                  child: Center(
                    child: CircularProgressIndicator(
                      value: loadingProgress.expectedTotalBytes != null
                          ? loadingProgress.cumulativeBytesLoaded /
                              loadingProgress.expectedTotalBytes!
                          : null,
                    ),
                  ),
                );
              },
              errorBuilder: (context, error, stackTrace) {
                return Container(
                  height: 100,
                  width: 100,
                  color: Colors.grey[300],
                  child: const Icon(Icons.error_outline),
                );
              },
            ),
          ),
        ),
      );
    }
    
    if (message.attachmentType == 'video' && message.attachmentUrl != null) {
      return GestureDetector(
        onTap: () => _viewFullScreenVideo(message.attachmentUrl!),
        child: Container(
          margin: const EdgeInsets.only(bottom: 8),
          constraints: const BoxConstraints(
            maxHeight: 200,
            maxWidth: 300,
          ),
          child: Stack(
            alignment: Alignment.center,
            children: [
              // Video thumbnail placeholder
              Container(
                decoration: BoxDecoration(
                  color: Colors.black87,
                  borderRadius: BorderRadius.circular(12),
                ),
                child: AspectRatio(
                  aspectRatio: 16 / 9,
                  child: Center(
                    child: Icon(
                      Icons.video_library,
                      color: Colors.white.withValues(alpha: 0.5),
                      size: 48,
                    ),
                  ),
                ),
              ),
              // Play button
              Container(
                decoration: BoxDecoration(
                  color: Colors.black.withValues(alpha: 0.5),
                  shape: BoxShape.circle,
                ),
                padding: const EdgeInsets.all(8),
                child: const Icon(
                  Icons.play_arrow,
                  color: Colors.white,
                  size: 32,
                ),
              ),
            ],
          ),
        ),
      );
    }

    // Fallback for non-image/video attachments
    return Container(
      margin: const EdgeInsets.only(bottom: 8),
      padding: const EdgeInsets.all(8),
      decoration: BoxDecoration(
        color: Colors.white.withValues(alpha: 0.2),
        borderRadius: BorderRadius.circular(8),
      ),
      child: Row(
        mainAxisSize: MainAxisSize.min,
        children: [
          Icon(
            _getAttachmentIcon(message.attachmentType),
            size: 20,
          ),
          const SizedBox(width: 8),
          const Text('Attachment'),
        ],
      ),
    );
  }

  IconData _getAttachmentIcon(String? type) {
    switch (type) {
      case 'image':
        return Icons.image;
      case 'video':
        return Icons.videocam;
      default:
        return Icons.attach_file;
    }
  }

  Widget _buildMessageInput(BuildContext context) {
    return Container(
      padding: const EdgeInsets.all(16),
      decoration: BoxDecoration(
        color: Theme.of(context).colorScheme.surface,
        boxShadow: [
          BoxShadow(
            offset: const Offset(0, -2),
            blurRadius: 4,
            color: Colors.black.withValues(alpha: 0.1),
          ),
        ],
      ),
      child: Row(
        children: [
          IconButton(
            icon: const Icon(Icons.attach_file),
            onPressed: _isUploading ? null : _showAttachmentOptions,
          ),
          Expanded(
            child: TextField(
              controller: _messageController,
              focusNode: _focusNode,
              decoration: InputDecoration(
                hintText: 'Type a message...',
                border: OutlineInputBorder(
                  borderRadius: BorderRadius.circular(24),
                  borderSide: BorderSide.none,
                ),
                filled: true,
                fillColor:
                    Theme.of(context).colorScheme.surfaceContainerHighest,
                contentPadding: const EdgeInsets.symmetric(
                  horizontal: 20,
                  vertical: 10,
                ),
              ),
              textCapitalization: TextCapitalization.sentences,
              maxLines: null,
              textInputAction: TextInputAction.send,
              onSubmitted: (_) => _sendMessage(),
            ),
          ),
          const SizedBox(width: 8),
          PopupMenuButton<String>(
            onSelected: (value) {
              if (value == 'send') {
                _sendMessage();
              } else if (value == 'schedule') {
                _showScheduleMessageDialog();
              }
            },
            itemBuilder: (context) => [
              const PopupMenuItem(
                value: 'send',
                child: ListTile(
                  leading: Icon(Icons.send),
                  title: Text('Send now'),
                  contentPadding: EdgeInsets.zero,
                ),
              ),
              const PopupMenuItem(
                value: 'schedule',
                child: ListTile(
                  leading: Icon(Icons.schedule_send),
                  title: Text('Schedule send'),
                  contentPadding: EdgeInsets.zero,
                ),
              ),
            ],
            child: Container(
              padding: const EdgeInsets.all(8),
              decoration: BoxDecoration(
                color: Theme.of(context).colorScheme.primary,
                shape: BoxShape.circle,
              ),
              child: Icon(
                Icons.send,
                color: Theme.of(context).colorScheme.onPrimary,
              ),
            ),
          ),
        ],
      ),
    );
  }

  void _sendMessage() async {
    final message = _messageController.text.trim();
    if (message.isEmpty) return;

    _messageController.clear();

    try {
      await context.read<ChatProvider>().sendMessage(content: message);
    } catch (e) {
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(content: Text('Failed to send message: $e')),
        );
      }
    }
  }

  bool _isSameDay(DateTime date1, DateTime date2) {
    return date1.year == date2.year &&
        date1.month == date2.month &&
        date1.day == date2.day;
  }

  void _showChatInfo(BuildContext context) {
    final chatRoom = context.read<ChatProvider>().currentChatRoom;
    if (chatRoom == null) return;

    showModalBottomSheet(
      context: context,
      builder: (context) => Container(
        padding: const EdgeInsets.all(16),
        child: Column(
          mainAxisSize: MainAxisSize.min,
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(
              chatRoom.name,
              style: Theme.of(context).textTheme.headlineSmall,
            ),
            const SizedBox(height: 8),
            Text('Type: ${chatRoom.type}'),
            Text('Participants: ${chatRoom.participantIds.length}'),
            if (chatRoom.classId != null) Text('Class ID: ${chatRoom.classId}'),
            const SizedBox(height: 16),
            const Text(
              'Participants:',
              style: TextStyle(fontWeight: FontWeight.bold),
            ),
            const SizedBox(height: 8),
            ...chatRoom.participants.map((participant) => ListTile(
                  leading: CircleAvatar(
                    child: Text(participant.name[0].toUpperCase()),
                  ),
                  title: Text(participant.name),
                  subtitle: Text(participant.role),
                )),
          ],
        ),
      ),
    );
  }

  void _startCall(BuildContext context, bool isVideoCall) {
    final chatProvider = context.read<ChatProvider>();
    final chatRoom = chatProvider.currentChatRoom;
    
    if (chatRoom == null) return;
    
    // For direct chats, find the other participant
    if (chatRoom.type == 'direct') {
      final otherParticipant = chatRoom.participants.firstWhere(
        (p) => p.id != FirebaseAuth.instance.currentUser?.uid,
      );
      
      // Navigate to call screen
      context.push(
        '/call',
        extra: {
          'receiverId': otherParticipant.id,
          'receiverName': otherParticipant.name,
          'receiverPhotoUrl': '', // TODO: Get photo URL from user profile
          'isVideoCall': isVideoCall,
          'chatRoomId': chatRoom.id,
        },
      );
    } else {
      // For group calls, show participant selection or use a different approach
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(
          content: Text('Group calls are not supported yet'),
        ),
      );
    }
  }

  void _leaveChatRoom(BuildContext context) {
    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        title: const Text('Leave Chat'),
        content: const Text('Are you sure you want to leave this chat?'),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(context),
            child: const Text('Cancel'),
          ),
          TextButton(
            onPressed: () async {
              // Close dialog
              Navigator.pop(context);
              // Navigate back to messages list
              context.go('/messages');
              await context
                  .read<ChatProvider>()
                  .leaveChatRoom(widget.chatRoomId);
            },
            child: const Text('Leave'),
          ),
        ],
      ),
    );
  }

  void _showAttachmentOptions() {
    showModalBottomSheet(
      context: context,
      builder: (context) => Container(
        padding: const EdgeInsets.all(16),
        child: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            ListTile(
              leading: const Icon(Icons.image),
              title: const Text('Photo from Gallery'),
              onTap: () {
                Navigator.pop(context);
                _pickImage(ImageSource.gallery);
              },
            ),
            ListTile(
              leading: const Icon(Icons.camera_alt),
              title: const Text('Take Photo'),
              onTap: () {
                Navigator.pop(context);
                _pickImage(ImageSource.camera);
              },
            ),
            const Divider(),
            ListTile(
              leading: const Icon(Icons.video_library),
              title: const Text('Video from Gallery'),
              onTap: () {
                Navigator.pop(context);
                _pickVideo(ImageSource.gallery);
              },
            ),
            ListTile(
              leading: const Icon(Icons.videocam),
              title: const Text('Record Video'),
              onTap: () {
                Navigator.pop(context);
                _pickVideo(ImageSource.camera);
              },
            ),
          ],
        ),
      ),
    );
  }

  Future<void> _pickImage(ImageSource source) async {
    try {
      final XFile? image = await _imagePicker.pickImage(
        source: source,
        maxWidth: 1800,
        maxHeight: 1800,
        imageQuality: 85,
      );

      if (image != null) {
        await _uploadAndSendImage(File(image.path));
      }
    } catch (e) {
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(content: Text('Error picking image: $e')),
        );
      }
    }
  }

  Future<void> _uploadAndSendImage(File imageFile) async {
    // Validate file size (10MB limit)
    const int maxSizeBytes = 10 * 1024 * 1024;
    if (imageFile.lengthSync() > maxSizeBytes) {
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(
              content: Text('Image is too large. Maximum size is 10MB')),
        );
      }
      return;
    }

    setState(() {
      _isUploading = true;
      _uploadProgress = 0.0;
    });

    try {
      // Create unique filename
      final String fileName =
          '${DateTime.now().millisecondsSinceEpoch}_${imageFile.path.split('/').last}';

      // Upload to Firebase Storage
      final Reference storageRef = FirebaseStorage.instance
          .ref()
          .child('chat_media')
          .child(widget.chatRoomId)
          .child(fileName);

      final UploadTask uploadTask = storageRef.putFile(imageFile);

      // Monitor upload progress
      uploadTask.snapshotEvents.listen((TaskSnapshot snapshot) {
        setState(() {
          _uploadProgress = snapshot.bytesTransferred / snapshot.totalBytes;
        });
      });

      // Wait for upload to complete
      final TaskSnapshot taskSnapshot = await uploadTask;
      final String downloadUrl = await taskSnapshot.ref.getDownloadURL();

      // Send message with image attachment
      if (mounted) {
        await context.read<ChatProvider>().sendMessage(
              content: _messageController.text.trim().isEmpty
                  ? 'Sent an image'
                  : _messageController.text.trim(),
              attachmentUrl: downloadUrl,
              attachmentType: 'image',
            );

        _messageController.clear();
      }
    } catch (e) {
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(content: Text('Failed to upload image: $e')),
        );
      }
    } finally {
      setState(() {
        _isUploading = false;
        _uploadProgress = 0.0;
      });
    }
  }

  Future<void> _pickVideo(ImageSource source) async {
    try {
      final XFile? video = await _imagePicker.pickVideo(
        source: source,
        maxDuration: const Duration(minutes: 10),
      );

      if (video != null) {
        await _uploadAndSendVideo(File(video.path));
      }
    } catch (e) {
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(content: Text('Error picking video: $e')),
        );
      }
    }
  }

  Future<void> _uploadAndSendVideo(File videoFile) async {
    // Validate file size (100MB limit)
    const int maxSizeBytes = 100 * 1024 * 1024;
    if (videoFile.lengthSync() > maxSizeBytes) {
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(
              content: Text('Video is too large. Maximum size is 100MB')),
        );
      }
      return;
    }

    setState(() {
      _isUploading = true;
      _uploadProgress = 0.0;
    });

    try {
      // Compress video
      await VideoCompress.setLogLevel(0);
      final MediaInfo? compressedVideo = await VideoCompress.compressVideo(
        videoFile.path,
        quality: VideoQuality.MediumQuality,
        deleteOrigin: false,
        includeAudio: true,
      );

      if (compressedVideo == null || compressedVideo.file == null) {
        throw Exception('Video compression failed');
      }

      final File compressedFile = compressedVideo.file!;

      // Create unique filename
      final String fileName =
          '${DateTime.now().millisecondsSinceEpoch}_${compressedFile.path.split('/').last}';

      // Upload to Firebase Storage
      final Reference storageRef = FirebaseStorage.instance
          .ref()
          .child('chat_media')
          .child(widget.chatRoomId)
          .child(fileName);

      final UploadTask uploadTask = storageRef.putFile(compressedFile);

      // Monitor upload progress
      uploadTask.snapshotEvents.listen((TaskSnapshot snapshot) {
        setState(() {
          _uploadProgress = snapshot.bytesTransferred / snapshot.totalBytes;
        });
      });

      // Wait for upload to complete
      final TaskSnapshot taskSnapshot = await uploadTask;
      final String downloadUrl = await taskSnapshot.ref.getDownloadURL();

      // Send message with video attachment
      if (mounted) {
        await context.read<ChatProvider>().sendMessage(
              content: _messageController.text.trim().isEmpty
                  ? 'Sent a video'
                  : _messageController.text.trim(),
              attachmentUrl: downloadUrl,
              attachmentType: 'video',
            );

        _messageController.clear();
      }
    } catch (e) {
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(content: Text('Failed to upload video: $e')),
        );
      }
    } finally {
      setState(() {
        _isUploading = false;
        _uploadProgress = 0.0;
      });
    }
  }

  void _viewFullScreenImage(String imageUrl) {
    showDialog(
      context: context,
      builder: (context) => Dialog(
        child: Stack(
          children: [
            Center(
              child: InteractiveViewer(
                child: Image.network(
                  imageUrl,
                  fit: BoxFit.contain,
                ),
              ),
            ),
            Positioned(
              top: 16,
              right: 16,
              child: IconButton(
                icon: const Icon(Icons.close, color: Colors.white),
                onPressed: () => Navigator.pop(context),
              ),
            ),
          ],
        ),
      ),
    );
  }

  void _viewFullScreenVideo(String videoUrl) {
    Navigator.push(
      context,
      MaterialPageRoute(
        builder: (context) => _VideoPlayerScreen(videoUrl: videoUrl),
      ),
    );
  }

  void _showScheduleMessageDialog() {
    final message = _messageController.text.trim();
    if (message.isEmpty) {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(
          content: Text('Please type a message first'),
        ),
      );
      return;
    }

    DateTime selectedDate = DateTime.now().add(const Duration(hours: 1));
    TimeOfDay selectedTime = TimeOfDay.fromDateTime(selectedDate);

    showDialog(
      context: context,
      builder: (context) => StatefulBuilder(
        builder: (context, setState) => AlertDialog(
          title: const Text('Schedule Message'),
          content: Column(
            mainAxisSize: MainAxisSize.min,
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Text(
                'Message: "$message"',
                style: Theme.of(context).textTheme.bodyMedium,
              ),
              const SizedBox(height: 16),
              const Text('Select date and time:'),
              const SizedBox(height: 8),
              Row(
                children: [
                  Expanded(
                    child: OutlinedButton.icon(
                      onPressed: () async {
                        final date = await showDatePicker(
                          context: context,
                          initialDate: selectedDate,
                          firstDate: DateTime.now(),
                          lastDate: DateTime.now().add(const Duration(days: 365)),
                        );
                        if (date != null) {
                          setState(() {
                            selectedDate = DateTime(
                              date.year,
                              date.month,
                              date.day,
                              selectedTime.hour,
                              selectedTime.minute,
                            );
                          });
                        }
                      },
                      icon: const Icon(Icons.calendar_today),
                      label: Text(
                        DateFormat('MMM d, yyyy').format(selectedDate),
                      ),
                    ),
                  ),
                  const SizedBox(width: 8),
                  Expanded(
                    child: OutlinedButton.icon(
                      onPressed: () async {
                        final time = await showTimePicker(
                          context: context,
                          initialTime: selectedTime,
                        );
                        if (time != null) {
                          setState(() {
                            selectedTime = time;
                            selectedDate = DateTime(
                              selectedDate.year,
                              selectedDate.month,
                              selectedDate.day,
                              time.hour,
                              time.minute,
                            );
                          });
                        }
                      },
                      icon: const Icon(Icons.access_time),
                      label: Text(selectedTime.format(context)),
                    ),
                  ),
                ],
              ),
              const SizedBox(height: 8),
              Text(
                'Will be sent: ${DateFormat('MMM d, yyyy at h:mm a').format(selectedDate)}',
                style: Theme.of(context).textTheme.bodySmall,
              ),
            ],
          ),
          actions: [
            TextButton(
              onPressed: () => Navigator.pop(context),
              child: const Text('Cancel'),
            ),
            FilledButton(
              onPressed: () async {
                Navigator.pop(context);
                await _scheduleMessage(selectedDate);
              },
              child: const Text('Schedule'),
            ),
          ],
        ),
      ),
    );
  }

  Future<void> _scheduleMessage(DateTime scheduledFor) async {
    final message = _messageController.text.trim();
    if (message.isEmpty) return;

    try {
      await _scheduledMessagesService.scheduleMessage(
        chatRoomId: widget.chatRoomId,
        content: message,
        scheduledFor: scheduledFor,
      );

      _messageController.clear();

      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text(
              'Message scheduled for ${DateFormat('MMM d, h:mm a').format(scheduledFor)}',
            ),
            action: SnackBarAction(
              label: 'View scheduled',
              onPressed: _showScheduledMessages,
            ),
          ),
        );
      }
    } catch (e) {
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(content: Text('Failed to schedule message: $e')),
        );
      }
    }
  }

  void _showScheduledMessages() {
    showModalBottomSheet(
      context: context,
      isScrollControlled: true,
      builder: (context) => DraggableScrollableSheet(
        initialChildSize: 0.5,
        minChildSize: 0.25,
        maxChildSize: 0.9,
        expand: false,
        builder: (context, scrollController) => Column(
          children: [
            Padding(
              padding: const EdgeInsets.all(16),
              child: Row(
                mainAxisAlignment: MainAxisAlignment.spaceBetween,
                children: [
                  Text(
                    'Scheduled Messages',
                    style: Theme.of(context).textTheme.headlineSmall,
                  ),
                  IconButton(
                    icon: const Icon(Icons.close),
                    onPressed: () => Navigator.pop(context),
                  ),
                ],
              ),
            ),
            const Divider(),
            Expanded(
              child: StreamBuilder<List<ScheduledMessage>>(
                stream: _scheduledMessagesService.getScheduledMessages(widget.chatRoomId),
                builder: (context, snapshot) {
                  if (snapshot.connectionState == ConnectionState.waiting) {
                    return const Center(child: CircularProgressIndicator());
                  }

                  final scheduledMessages = snapshot.data ?? [];

                  if (scheduledMessages.isEmpty) {
                    return const Center(
                      child: Text('No scheduled messages'),
                    );
                  }

                  return ListView.builder(
                    controller: scrollController,
                    itemCount: scheduledMessages.length,
                    itemBuilder: (context, index) {
                      final scheduled = scheduledMessages[index];
                      final message = scheduled.message;

                      return ListTile(
                        title: Text(message.content),
                        subtitle: Text(
                          'Scheduled for: ${DateFormat('MMM d, h:mm a').format(message.scheduledFor!)}',
                        ),
                        trailing: IconButton(
                          icon: const Icon(Icons.delete_outline),
                          onPressed: () async {
                            final messenger = ScaffoldMessenger.of(context);
                            await _scheduledMessagesService.cancelScheduledMessage(
                              scheduled.id,
                            );
                            if (mounted) {
                              messenger.showSnackBar(
                                const SnackBar(
                                  content: Text('Scheduled message cancelled'),
                                ),
                              );
                            }
                          },
                        ),
                      );
                    },
                  );
                },
              ),
            ),
          ],
        ),
      ),
    );
  }
}

class _VideoPlayerScreen extends StatefulWidget {
  final String videoUrl;

  const _VideoPlayerScreen({required this.videoUrl});

  @override
  State<_VideoPlayerScreen> createState() => _VideoPlayerScreenState();
}

class _VideoPlayerScreenState extends State<_VideoPlayerScreen> {
  late VideoPlayerController _controller;
  bool _isInitialized = false;

  @override
  void initState() {
    super.initState();
    _controller = VideoPlayerController.networkUrl(Uri.parse(widget.videoUrl))
      ..initialize().then((_) {
        setState(() {
          _isInitialized = true;
          _controller.play();
        });
      });
  }

  @override
  void dispose() {
    _controller.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      backgroundColor: Colors.black,
      appBar: AppBar(
        backgroundColor: Colors.transparent,
        elevation: 0,
        leading: IconButton(
          icon: const Icon(Icons.close, color: Colors.white),
          onPressed: () => Navigator.pop(context),
        ),
      ),
      body: Center(
        child: _isInitialized
            ? AspectRatio(
                aspectRatio: _controller.value.aspectRatio,
                child: Stack(
                  alignment: Alignment.bottomCenter,
                  children: [
                    VideoPlayer(_controller),
                    _VideoControlsOverlay(controller: _controller),
                    VideoProgressIndicator(
                      _controller,
                      allowScrubbing: true,
                      padding: const EdgeInsets.all(16),
                    ),
                  ],
                ),
              )
            : const CircularProgressIndicator(),
      ),
    );
  }
}

class _VideoControlsOverlay extends StatelessWidget {
  final VideoPlayerController controller;

  const _VideoControlsOverlay({required this.controller});

  @override
  Widget build(BuildContext context) {
    return GestureDetector(
      behavior: HitTestBehavior.opaque,
      onTap: () {
        controller.value.isPlaying ? controller.pause() : controller.play();
      },
      child: Stack(
        children: [
          AnimatedSwitcher(
            duration: const Duration(milliseconds: 50),
            reverseDuration: const Duration(milliseconds: 200),
            child: controller.value.isPlaying
                ? const SizedBox.shrink()
                : Container(
                    color: Colors.black26,
                    child: const Center(
                      child: Icon(
                        Icons.play_arrow,
                        color: Colors.white,
                        size: 100.0,
                        semanticLabel: 'Play',
                      ),
                    ),
                  ),
          ),
          Positioned(
            bottom: 50,
            left: 16,
            right: 16,
            child: Row(
              children: [
                ValueListenableBuilder(
                  valueListenable: controller,
                  builder: (context, VideoPlayerValue value, child) {
                    return Text(
                      _formatDuration(value.position),
                      style: const TextStyle(color: Colors.white),
                    );
                  },
                ),
                const Spacer(),
                ValueListenableBuilder(
                  valueListenable: controller,
                  builder: (context, VideoPlayerValue value, child) {
                    return Text(
                      _formatDuration(value.duration),
                      style: const TextStyle(color: Colors.white),
                    );
                  },
                ),
              ],
            ),
          ),
        ],
      ),
    );
  }

  String _formatDuration(Duration duration) {
    String twoDigits(int n) => n.toString().padLeft(2, '0');
    final hours = twoDigits(duration.inHours);
    final minutes = twoDigits(duration.inMinutes.remainder(60));
    final seconds = twoDigits(duration.inSeconds.remainder(60));
    return duration.inHours > 0 ? '$hours:$minutes:$seconds' : '$minutes:$seconds';
  }
}

class ChatSearchDelegate extends SearchDelegate<Message?> {
  final List<Message> messages;

  ChatSearchDelegate({required this.messages});

  @override
  List<Widget> buildActions(BuildContext context) {
    return [
      IconButton(
        icon: const Icon(Icons.clear),
        onPressed: () {
          query = '';
        },
      ),
    ];
  }

  @override
  Widget buildLeading(BuildContext context) {
    return IconButton(
      icon: const Icon(Icons.arrow_back),
      onPressed: () {
        close(context, null);
      },
    );
  }

  @override
  Widget buildResults(BuildContext context) {
    return _buildSearchResults();
  }

  @override
  Widget buildSuggestions(BuildContext context) {
    return _buildSearchResults();
  }

  Widget _buildSearchResults() {
    final results = messages.where((message) =>
        message.content.toLowerCase().contains(query.toLowerCase())).toList();

    return ListView.builder(
      itemCount: results.length,
      itemBuilder: (context, index) {
        final message = results[index];
        return ListTile(
          title: Text(message.content),
          subtitle: Text(DateFormat('MMM d, h:mm a').format(message.timestamp)),
          onTap: () {
            close(context, message);
          },
        );
      },
    );
  }
}
````

## File: lib/features/chat/presentation/screens/incoming_call_screen.dart
````dart
import 'package:flutter/material.dart';
import 'package:go_router/go_router.dart';
import 'package:cached_network_image/cached_network_image.dart';
import '../../domain/models/call.dart';
import '../../data/services/webrtc_service.dart';

class IncomingCallScreen extends StatefulWidget {
  final Call call;

  const IncomingCallScreen({
    super.key,
    required this.call,
  });

  @override
  State<IncomingCallScreen> createState() => _IncomingCallScreenState();
}

class _IncomingCallScreenState extends State<IncomingCallScreen>
    with SingleTickerProviderStateMixin {
  late AnimationController _animationController;
  late Animation<double> _scaleAnimation;
  final WebRTCService _webrtcService = WebRTCService();

  @override
  void initState() {
    super.initState();
    _animationController = AnimationController(
      duration: const Duration(seconds: 1),
      vsync: this,
    )..repeat(reverse: true);
    
    _scaleAnimation = Tween<double>(
      begin: 0.95,
      end: 1.05,
    ).animate(CurvedAnimation(
      parent: _animationController,
      curve: Curves.easeInOut,
    ));
  }

  @override
  void dispose() {
    _animationController.dispose();
    super.dispose();
  }

  void _acceptCall() {
    context.pushReplacement(
      '/call',
      extra: {
        'callId': widget.call.id,
        'isVideoCall': widget.call.type == CallType.video,
        'receiverName': widget.call.callerName,
        'receiverPhotoUrl': widget.call.callerPhotoUrl,
        'chatRoomId': widget.call.chatRoomId,
      },
    );
  }

  void _rejectCall() async {
    await _webrtcService.rejectCall(widget.call.id);
    if (!mounted) return;
    Navigator.pop(context);
  }

  @override
  Widget build(BuildContext context) {
    final isVideoCall = widget.call.type == CallType.video;
    
    return Scaffold(
      body: Container(
        decoration: BoxDecoration(
          gradient: LinearGradient(
            begin: Alignment.topCenter,
            end: Alignment.bottomCenter,
            colors: [
              Theme.of(context).primaryColor.withAlpha(204),
              Theme.of(context).primaryColor,
            ],
          ),
        ),
        child: SafeArea(
          child: Column(
            mainAxisAlignment: MainAxisAlignment.spaceEvenly,
            children: [
              // Call type
              Column(
                children: [
                  Icon(
                    isVideoCall ? Icons.videocam : Icons.phone,
                    color: Colors.white,
                    size: 48,
                  ),
                  const SizedBox(height: 16),
                  Text(
                    'Incoming ${isVideoCall ? 'Video' : 'Voice'} Call',
                    style: const TextStyle(
                      color: Colors.white70,
                      fontSize: 20,
                    ),
                  ),
                ],
              ),
              
              // Caller info
              Column(
                children: [
                  ScaleTransition(
                    scale: _scaleAnimation,
                    child: CircleAvatar(
                      radius: 80,
                      backgroundColor: Colors.white24,
                      backgroundImage: widget.call.callerPhotoUrl.isNotEmpty
                          ? CachedNetworkImageProvider(widget.call.callerPhotoUrl)
                          : null,
                      child: widget.call.callerPhotoUrl.isEmpty
                          ? Text(
                              widget.call.callerName.isNotEmpty
                                  ? widget.call.callerName[0].toUpperCase()
                                  : '?',
                              style: const TextStyle(
                                fontSize: 48,
                                color: Colors.white,
                                fontWeight: FontWeight.bold,
                              ),
                            )
                          : null,
                    ),
                  ),
                  const SizedBox(height: 24),
                  Text(
                    widget.call.callerName,
                    style: const TextStyle(
                      color: Colors.white,
                      fontSize: 32,
                      fontWeight: FontWeight.bold,
                    ),
                  ),
                ],
              ),
              
              // Action buttons
              Row(
                mainAxisAlignment: MainAxisAlignment.spaceEvenly,
                children: [
                  // Reject button
                  Container(
                    width: 80,
                    height: 80,
                    decoration: const BoxDecoration(
                      shape: BoxShape.circle,
                      color: Colors.red,
                    ),
                    child: IconButton(
                      icon: const Icon(Icons.call_end),
                      color: Colors.white,
                      iconSize: 40,
                      onPressed: _rejectCall,
                    ),
                  ),
                  
                  // Accept button
                  Container(
                    width: 80,
                    height: 80,
                    decoration: const BoxDecoration(
                      shape: BoxShape.circle,
                      color: Colors.green,
                    ),
                    child: IconButton(
                      icon: const Icon(Icons.call),
                      color: Colors.white,
                      iconSize: 40,
                      onPressed: _acceptCall,
                    ),
                  ),
                ],
              ),
            ],
          ),
        ),
      ),
    );
  }
}
````

## File: lib/features/classes/data/repositories/class_repository_impl.dart
````dart
/// Concrete implementation of the class repository.
/// 
/// This module implements the ClassRepository interface using
/// Firebase Firestore as the data source. It provides full
/// CRUD operations and specialized queries for academic
/// class management.
library;

import 'dart:math';
import 'package:cloud_firestore/cloud_firestore.dart';
import '../../domain/models/class_model.dart';
import '../../../../shared/models/user_model.dart';
import '../../../../shared/services/firestore_service.dart';
import '../../../../shared/services/logger_service.dart';
import '../../domain/repositories/class_repository.dart';
import '../../../../shared/repositories/firestore_repository.dart';

/// Firestore-based implementation of ClassRepository.
/// 
/// This class extends FirestoreRepository to leverage common
/// CRUD operations while implementing class-specific features:
/// - Student enrollment management with batch operations
/// - Teacher-class associations and filtering
/// - Active/archive state management
/// - Statistical analysis of class data
/// - Capacity tracking and enrollment limits
/// - Academic year organization
/// 
/// All operations include comprehensive logging for debugging
/// and audit trails.
class ClassRepositoryImpl extends FirestoreRepository<ClassModel> 
    implements ClassRepository {
  /// Firestore instance for direct database operations.
  final FirebaseFirestore _firestore;
  
  /// Creates a class repository with Firestore backend.
  /// 
  /// Initializes the parent FirestoreRepository with class-specific
  /// configuration including collection path and serialization.
  /// 
  /// @param _firestore Firestore database instance
  ClassRepositoryImpl(this._firestore)
      : super(
          firestore: _firestore,
          collectionPath: 'classes',
          fromFirestore: (doc) => ClassModel.fromFirestore(doc),
          toFirestore: (classModel) => classModel.toFirestore(),
          logTag: 'ClassRepository',
        );
  
  /// Creates a new academic class with initial metadata.
  /// 
  /// Automatically sets creation/update timestamps and initializes
  /// an empty student list. The class ID is generated by Firestore.
  /// 
  /// @param classModel Class details including name, teacher, schedule
  /// @return Generated unique class ID
  /// @throws Exception if class creation fails
  @override
  Future<String> createClass(ClassModel classModel) async {
    try {
      // Generate unique enrollment code
      String? enrollmentCode;
      if (classModel.enrollmentCode == null) {
        enrollmentCode = await _generateUniqueEnrollmentCode();
      }
      
      final classWithTimestamp = classModel.copyWith(
        createdAt: DateTime.now(),
        updatedAt: DateTime.now(),
        studentIds: [],
        enrollmentCode: enrollmentCode ?? classModel.enrollmentCode,
      );
      return await create(classWithTimestamp);
    } catch (e) {
      LoggerService.error('Failed to create class', tag: tag, error: e);
      rethrow;
    }
  }
  
  /// Generates a unique enrollment code for a new class.
  /// 
  /// Internal helper method that creates codes without
  /// updating existing classes.
  /// 
  /// @return A unique 6-character enrollment code
  /// @throws Exception if unable to generate unique code
  Future<String> _generateUniqueEnrollmentCode() async {
    const chars = 'ABCDEFGHJKLMNPQRSTUVWXYZ23456789';
    const codeLength = 6;
    const maxAttempts = 100;
    
    for (int attempt = 0; attempt < maxAttempts; attempt++) {
      final random = Random();
      final code = String.fromCharCodes(
        Iterable.generate(
          codeLength,
          (_) => chars.codeUnitAt(random.nextInt(chars.length)),
        ),
      );
      
      // Check if code already exists
      final existing = await getClassByEnrollmentCode(code);
      if (existing == null) {
        return code;
      }
    }
    
    throw Exception('Unable to generate unique enrollment code');
  }  
  /// Retrieves a class by its unique identifier.
  /// 
  /// Delegates to the parent repository's read method for
  /// consistent error handling and logging.
  /// 
  /// @param classId Unique class identifier
  /// @return Class instance or null if not found
  @override
  Future<ClassModel?> getClass(String classId) => read(classId);
  
  /// Updates class information with automatic timestamp.
  /// 
  /// Ensures the class ID remains consistent and updates
  /// the modification timestamp. Only modifiable fields
  /// are updated; immutable fields like teacherId are preserved.
  /// 
  /// @param classId ID of the class to update
  /// @param classModel Updated class information
  /// @throws Exception if update fails or class not found
  @override
  Future<void> updateClass(String classId, ClassModel classModel) async {
    try {
      final updatedClass = classModel.copyWith(
        id: classId,
        updatedAt: DateTime.now(),
      );
      await update(classId, updatedClass);
    } catch (e) {
      LoggerService.error('Failed to update class', tag: tag, error: e);
      rethrow;
    }
  }
  
  /// Permanently deletes a class and all associated data.
  /// 
  /// This is a destructive operation that cannot be undone.
  /// Consider using archiveClass for recoverable removal.
  /// 
  /// @param classId ID of the class to delete
  /// @throws Exception if deletion fails
  @override
  Future<void> deleteClass(String classId) => delete(classId);
  
  /// Streams all classes taught by a specific teacher.
  /// 
  /// Returns real-time updates of classes where the teacher
  /// is the instructor, sorted alphabetically by name.
  /// Includes both active and archived classes.
  /// 
  /// @param teacherId Teacher's unique identifier
  /// @return Stream of teacher's class list
  @override
  Stream<List<ClassModel>> getTeacherClasses(String teacherId) {
    return stream(
      conditions: [
        QueryCondition(field: 'teacherId', isEqualTo: teacherId),
      ],
      orderBy: [
        OrderBy(field: 'name', descending: false),
      ],
    );
  }  
  /// Streams active classes a student is enrolled in.
  /// 
  /// Filters to only active classes where the student ID
  /// appears in the studentIds array. Updates in real-time
  /// as enrollment changes.
  /// 
  /// @param studentId Student's unique identifier
  /// @return Stream of student's enrolled classes
  @override
  Stream<List<ClassModel>> getStudentClasses(String studentId) {
    return stream(
      conditions: [
        QueryCondition(field: 'studentIds', arrayContains: studentId),
        QueryCondition(field: 'isActive', isEqualTo: true),
      ],
      orderBy: [
        OrderBy(field: 'name', descending: false),
      ],
    );
  }
  
  /// Adds a student to a class roster.
  /// 
  /// Uses Firestore's arrayUnion to safely add the student ID
  /// without duplicates. Updates the modification timestamp
  /// using server time for consistency.
  /// 
  /// @param classId Target class identifier
  /// @param studentId Student to enroll
  /// @throws Exception if enrollment fails
  @override
  Future<void> addStudent(String classId, String studentId) async {
    try {
      await _firestore.collection('classes').doc(classId).update({
        'studentIds': FieldValue.arrayUnion([studentId]),
        'updatedAt': FieldValue.serverTimestamp(),
      });
      LoggerService.info('Added student $studentId to class $classId', tag: tag);
    } catch (e) {
      LoggerService.error('Failed to add student to class', tag: tag, error: e);
      rethrow;
    }
  }  
  /// Removes a student from a class roster.
  /// 
  /// Uses Firestore's arrayRemove to safely remove the student ID.
  /// Updates the modification timestamp for audit trail.
  /// 
  /// @param classId Target class identifier
  /// @param studentId Student to unenroll
  /// @throws Exception if removal fails
  @override
  Future<void> removeStudent(String classId, String studentId) async {
    try {
      await _firestore.collection('classes').doc(classId).update({
        'studentIds': FieldValue.arrayRemove([studentId]),
        'updatedAt': FieldValue.serverTimestamp(),
      });
      LoggerService.info('Removed student $studentId from class $classId', tag: tag);
    } catch (e) {
      LoggerService.error('Failed to remove student from class', tag: tag, error: e);
      rethrow;
    }
  }
  
  /// Retrieves complete profiles for all enrolled students.
  /// 
  /// Performs a two-step query:
  /// 1. Fetches the class to get student IDs
  /// 2. Batch fetches user profiles for all students
  /// 
  /// Filters results to ensure only student role users are
  /// returned, providing an additional safety check.
  /// 
  /// @param classId Class to get students for
  /// @return List of student user profiles
  /// @throws Exception if retrieval fails
  @override
  Future<List<UserModel>> getClassStudents(String classId) async {
    try {
      final classModel = await getClass(classId);
      if (classModel == null || classModel.studentIds.isEmpty) {
        return [];
      }
      
      final studentDocs = await _firestore
          .collection('users')
          .where(FieldPath.documentId, whereIn: classModel.studentIds)
          .get();
      
      return studentDocs.docs
          .map((doc) => UserModel.fromFirestore(doc))
          .where((user) => user.role == UserRole.student)
          .toList();
    } catch (e) {
      LoggerService.error('Failed to get class students', tag: tag, error: e);
      rethrow;
    }
  }  
  /// Checks if a student is enrolled in a specific class.
  /// 
  /// Efficient enrollment verification without loading all
  /// student profiles. Returns false if class doesn't exist.
  /// 
  /// @param classId Class to check
  /// @param studentId Student to verify
  /// @return true if enrolled, false otherwise
  /// @throws Exception if check fails
  @override
  Future<bool> isStudentEnrolled(String classId, String studentId) async {
    try {
      final classModel = await getClass(classId);
      return classModel?.studentIds.contains(studentId) ?? false;
    } catch (e) {
      LoggerService.error('Failed to check student enrollment', tag: tag, error: e);
      rethrow;
    }
  }
  
  /// Calculates comprehensive statistics for a class.
  /// 
  /// Aggregates data from multiple sources:
  /// - Student enrollment metrics from class document
  /// - Assignment count from assignments collection
  /// - Capacity and active status
  /// 
  /// Note: This is a basic implementation. Can be extended
  /// to include grades, attendance, and submission rates.
  /// 
  /// @param classId Class to analyze
  /// @return Map containing statistical data
  /// @throws Exception if calculation fails
  @override
  Future<Map<String, dynamic>> getClassStats(String classId) async {
    try {
      final classModel = await getClass(classId);
      if (classModel == null) {
        return {};
      }
      
      // Get assignment count
      final assignmentCount = await _firestore
          .collection('assignments')
          .where('classId', isEqualTo: classId)
          .count()
          .get();
      
      // Get average grade (if grades are available)
      // This is a simplified version - you might want to implement more complex logic
      
      return {
        'studentCount': classModel.studentCount,
        'assignmentCount': assignmentCount.count,
        'isActive': classModel.isActive,
        'isFull': classModel.isFull,
        'capacity': classModel.maxStudents ?? 'Unlimited',
      };
    } catch (e) {
      LoggerService.error('Failed to get class stats', tag: tag, error: e);
      rethrow;
    }
  }  
  /// Archives a class at the end of term or year.
  /// 
  /// Sets the isActive flag to false, hiding the class from
  /// active lists while preserving all data. The class can
  /// be restored later if needed.
  /// 
  /// @param classId ID of class to archive
  /// @throws Exception if archiving fails
  @override
  Future<void> archiveClass(String classId) async {
    try {
      await _firestore.collection('classes').doc(classId).update({
        'isActive': false,
        'updatedAt': FieldValue.serverTimestamp(),
      });
      LoggerService.info('Archived class $classId', tag: tag);
    } catch (e) {
      LoggerService.error('Failed to archive class', tag: tag, error: e);
      rethrow;
    }
  }
  
  /// Retrieves active classes for a specific academic year.
  /// 
  /// Filters classes by teacher, academic year, and active status.
  /// Useful for term-based views and academic year transitions.
  /// Results are sorted alphabetically by class name.
  /// 
  /// @param teacherId Teacher's unique identifier
  /// @param academicYear Year string (e.g., "2023-2024")
  /// @return List of active classes for the year
  /// @throws Exception if retrieval fails
  @override
  Future<List<ClassModel>> getActiveClasses(String teacherId, String academicYear) async {
    return await list(
      conditions: [
        QueryCondition(field: 'teacherId', isEqualTo: teacherId),
        QueryCondition(field: 'academicYear', isEqualTo: academicYear),
        QueryCondition(field: 'isActive', isEqualTo: true),
      ],
      orderBy: [
        OrderBy(field: 'name', descending: false),
      ],
    );
  }
  
  /// Restores an archived class to active status.
  /// 
  /// Reverses the archiving process by setting isActive to true.
  /// The class becomes visible in active lists again.
  /// 
  /// @param classId ID of class to restore
  /// @throws Exception if restoration fails
  @override
  Future<void> restoreClass(String classId) async {
    try {
      await _firestore.collection('classes').doc(classId).update({
        'isActive': true,
        'updatedAt': FieldValue.serverTimestamp(),
      });
      LoggerService.info('Restored class $classId', tag: tag);
    } catch (e) {
      LoggerService.error('Failed to restore class', tag: tag, error: e);
      rethrow;
    }
  }
  
  /// Enrolls a student in a class (alias for addStudent).
  /// 
  /// Provides semantic clarity for enrollment operations.
  /// Delegates to addStudent for actual implementation.
  /// 
  /// @param classId Target class identifier  
  /// @param studentId Student to enroll
  /// @throws Exception if enrollment fails
  @override
  Future<void> enrollStudent(String classId, String studentId) async {
    try {
      await addStudent(classId, studentId);
    } catch (e) {
      LoggerService.error('Failed to enroll student', tag: tag, error: e);
      rethrow;
    }
  }
  
  /// Unenrolls a student from a class (alias for removeStudent).
  /// 
  /// Provides semantic clarity for unenrollment operations.
  /// Delegates to removeStudent for actual implementation.
  /// 
  /// @param classId Target class identifier
  /// @param studentId Student to unenroll
  /// @throws Exception if unenrollment fails
  @override
  Future<void> unenrollStudent(String classId, String studentId) async {
    try {
      await removeStudent(classId, studentId);
    } catch (e) {
      LoggerService.error('Failed to unenroll student', tag: tag, error: e);
      rethrow;
    }
  }
  
  /// Enrolls multiple students in a single batch operation.
  /// 
  /// Uses Firestore batch writes for atomicity - all enrollments
  /// succeed or fail together. Updates both the class roster
  /// and each student's enrolled classes list.
  /// 
  /// This is more efficient than individual enrollments and
  /// ensures data consistency across documents.
  /// 
  /// @param classId Target class identifier
  /// @param studentIds List of students to enroll
  /// @throws Exception if batch enrollment fails
  @override
  Future<void> enrollMultipleStudents(String classId, List<String> studentIds) async {
    try {
      final batch = _firestore.batch();
      
      // Update class document
      final classRef = _firestore.collection('classes').doc(classId);
      batch.update(classRef, {
        'studentIds': FieldValue.arrayUnion(studentIds),
        'studentCount': FieldValue.increment(studentIds.length),
        'updatedAt': FieldValue.serverTimestamp(),
      });
      
      // Update each student document
      for (final studentId in studentIds) {
        final studentRef = _firestore.collection('students').doc(studentId);
        batch.update(studentRef, {
          'classIds': FieldValue.arrayUnion([classId]),
          'updatedAt': FieldValue.serverTimestamp(),
        });
      }
      
      await batch.commit();
      LoggerService.info('Enrolled ${studentIds.length} students in class $classId', tag: tag);
    } catch (e) {
      LoggerService.error('Failed to enroll multiple students', tag: tag, error: e);
      rethrow;
    }
  }
  
  /// Finds a class by its enrollment code.
  /// 
  /// Searches for active classes with the specified enrollment code.
  /// Enrollment codes are unique across all active classes.
  /// 
  /// @param enrollmentCode The enrollment code to search for
  /// @return Class instance or null if not found
  /// @throws Exception if search fails
  @override
  Future<ClassModel?> getClassByEnrollmentCode(String enrollmentCode) async {
    try {
      final querySnapshot = await _firestore
          .collection('classes')
          .where('enrollmentCode', isEqualTo: enrollmentCode)
          .where('isActive', isEqualTo: true)
          .limit(1)
          .get();
      
      if (querySnapshot.docs.isEmpty) {
        return null;
      }
      
      return ClassModel.fromFirestore(querySnapshot.docs.first);
    } catch (e) {
      LoggerService.error('Failed to get class by enrollment code', tag: tag, error: e);
      rethrow;
    }
  }
  
  /// Enrolls a student using an enrollment code.
  /// 
  /// Validates the enrollment code, checks class capacity,
  /// and adds the student to the class if allowed.
  /// 
  /// @param studentId Student to enroll
  /// @param enrollmentCode Class enrollment code
  /// @return The enrolled class model
  /// @throws Exception if enrollment fails
  @override
  Future<ClassModel> enrollWithCode(String studentId, String enrollmentCode) async {
    try {
      // Find class by enrollment code
      final classModel = await getClassByEnrollmentCode(enrollmentCode);
      
      if (classModel == null) {
        throw Exception('Invalid enrollment code');
      }
      
      // Check if student is already enrolled
      if (classModel.studentIds.contains(studentId)) {
        throw Exception('Student is already enrolled in this class');
      }
      
      // Check if class is full
      if (classModel.isFull) {
        throw Exception('Class is at maximum capacity');
      }
      
      // Enroll the student
      await addStudent(classModel.id, studentId);
      
      // Return updated class model
      final updatedClass = await getClass(classModel.id);
      if (updatedClass == null) {
        throw Exception('Failed to retrieve updated class');
      }
      
      LoggerService.info('Enrolled student $studentId in class ${classModel.name} via code', tag: tag);
      return updatedClass;
      
    } catch (e) {
      LoggerService.error('Failed to enroll with code', tag: tag, error: e);
      rethrow;
    }
  }
  
  /// Generates a new enrollment code for a class.
  /// 
  /// Creates a unique 6-character alphanumeric code
  /// and updates the class record. Ensures uniqueness
  /// by checking against existing codes.
  /// 
  /// @param classId Class to generate code for
  /// @return The new enrollment code
  /// @throws Exception if generation fails
  @override
  Future<String> regenerateEnrollmentCode(String classId) async {
    try {
      const chars = 'ABCDEFGHJKLMNPQRSTUVWXYZ23456789'; // Exclude ambiguous characters
      const codeLength = 6;
      const maxAttempts = 100;
      
      String? newCode;
      bool isUnique = false;
      
      // Generate unique code
      for (int attempt = 0; attempt < maxAttempts && !isUnique; attempt++) {
        // Generate random code
        final random = Random();
        newCode = String.fromCharCodes(
          Iterable.generate(
            codeLength,
            (_) => chars.codeUnitAt(random.nextInt(chars.length)),
          ),
        );
        
        // Check if code already exists
        final existing = await getClassByEnrollmentCode(newCode);
        isUnique = existing == null;
      }
      
      if (!isUnique || newCode == null) {
        throw Exception('Unable to generate unique enrollment code');
      }
      
      // Update class with new code
      await _firestore.collection('classes').doc(classId).update({
        'enrollmentCode': newCode,
        'updatedAt': FieldValue.serverTimestamp(),
      });
      
      LoggerService.info('Generated new enrollment code for class $classId', tag: tag);
      return newCode;
      
    } catch (e) {
      LoggerService.error('Failed to regenerate enrollment code', tag: tag, error: e);
      rethrow;
    }
  }
}
````

## File: lib/features/classes/data/services/class_service_enhanced.dart
````dart
/// Enhanced ClassService with performance monitoring integration.
/// 
/// This service extends the original ClassService with comprehensive
/// performance monitoring, caching, and error handling improvements.
library;

import 'dart:math';
import 'package:cloud_firestore/cloud_firestore.dart';
import '../../domain/models/class_model.dart';
import '../../../../shared/services/logger_service.dart';
import '../../../../shared/services/performance_service.dart';
import '../../../../shared/services/cache_service.dart';
import '../../../../shared/services/retry_service.dart';
import '../../../../shared/services/validation_service.dart';

/// Enhanced service class for managing educational classes with performance monitoring.
/// 
/// Provides all the functionality of the original ClassService with additional:
/// - Performance monitoring and metrics
/// - Intelligent caching for frequently accessed data
/// - Retry mechanisms for network operations
/// - Input validation and sanitization
/// - Comprehensive error handling
class ClassServiceEnhanced {
  final FirebaseFirestore _firestore = FirebaseFirestore.instance;
  final CacheService _cache = CacheService();
  final PerformanceService _performance = PerformanceService();
  
  /// Collection reference for classes in Firestore
  CollectionReference<Map<String, dynamic>> get _classesCollection => 
      _firestore.collection('classes');

  /// Creates a new class with performance monitoring and validation.
  /// 
  /// Includes automatic performance tracking, input validation,
  /// and caching of the created class.
  /// 
  /// @param classModel Class data to create
  /// @return Created class with assigned ID and enrollment code
  /// @throws Exception if validation fails or creation fails
  Future<ClassModel> createClass(ClassModel classModel) async {
    return await _performance.timeOperation(
      'create_class',
      () async {
        try {
          // Validate input data
          _validateClassModel(classModel);
          
          // Generate unique enrollment code with retry
          final enrollmentCode = await RetryService.withRetry(
            () => _generateUniqueEnrollmentCode(),
            config: RetryConfigs.standard,
          );
          
          // Create class with enrollment code
          final classWithCode = classModel.copyWith(
            enrollmentCode: enrollmentCode,
            createdAt: DateTime.now(),
            updatedAt: DateTime.now(),
          );
          
          // Add to Firestore with retry
          final docRef = await RetryService.withRetry(
            () => _classesCollection.add(classWithCode.toFirestore()),
            config: RetryConfigs.standard,
          );
          
          // Return class with generated ID
          final createdClass = classWithCode.copyWith(id: docRef.id);
          
          // Cache the created class
          await _cache.set(
            'class_${docRef.id}',
            createdClass.toFirestore(),
            ttl: const Duration(hours: 2),
          );
          
          // Cache enrollment code for quick lookup
          await _cache.set(
            'enrollment_code_$enrollmentCode',
            createdClass.toFirestore(),
            ttl: const Duration(hours: 24),
          );
          
          // Record custom metrics
          _performance.recordMetric('class_created', 1);
          _performance.recordMetric('enrollment_codes_generated', 1);
          
          LoggerService.info(
            'Created class: ${createdClass.name} with enrollment code: $enrollmentCode (ID: ${createdClass.id}, Teacher: ${createdClass.teacherId})',
          );
          
          return createdClass;
          
        } catch (e) {
          LoggerService.error(
            'Error creating class: ${classModel.name}',
            error: e,
          );
          rethrow;
        }
      },
      attributes: {
        'class_name': classModel.name,
        'teacher_id': classModel.teacherId,
        'operation': 'create',
      },
    );
  }

  /// Updates an existing class with performance monitoring.
  /// 
  /// Includes cache invalidation and performance tracking.
  /// 
  /// @param classModel Updated class data
  /// @return Updated class model
  Future<ClassModel> updateClass(ClassModel classModel) async {
    return await _performance.timeOperation(
      'update_class',
      () async {
        try {
          // Validate input data
          _validateClassModel(classModel);
          
          final updatedClass = classModel.copyWith(
            updatedAt: DateTime.now(),
          );
          
          // Update in Firestore with retry
          await RetryService.withRetry(
            () => _classesCollection
                .doc(classModel.id)
                .update(updatedClass.toFirestore()),
            config: RetryConfigs.standard,
          );
          
          // Update cache
          await _cache.set(
            'class_${classModel.id}',
            updatedClass.toFirestore(),
            ttl: const Duration(hours: 2),
          );
          
          // Invalidate related caches
          await _cache.clearPattern('teacher_classes_${classModel.teacherId}');
          await _cache.clearPattern('class_stats_${classModel.id}');
          
          // Record metrics
          _performance.recordMetric('class_updated', 1);
          
          LoggerService.info(
            'Updated class: ${classModel.name} (ID: ${classModel.id})',
          );
          
          return updatedClass;
          
        } catch (e) {
          LoggerService.error(
            'Error updating class (ID: ${classModel.id})',
            error: e,
          );
          rethrow;
        }
      },
      attributes: {
        'class_id': classModel.id,
        'class_name': classModel.name,
        'operation': 'update',
      },
    );
  }

  /// Retrieves a class by ID with caching and performance monitoring.
  /// 
  /// Checks cache first, then Firestore if not found.
  /// 
  /// @param classId ID of the class to retrieve
  /// @return Class model if found, null otherwise
  Future<ClassModel?> getClassById(String classId) async {
    return await _performance.timeOperation(
      'get_class_by_id',
      () async {
        try {
          // Check cache first
          final cachedClass = await _cache.get<Map<String, dynamic>>('class_$classId');
          if (cachedClass != null) {
            _performance.recordMetric('cache_hit_class_by_id', 1);
            // Create ClassModel directly from cached data
            return ClassModel(
              id: classId,
              teacherId: cachedClass['teacherId'] ?? '',
              name: cachedClass['name'] ?? '',
              subject: cachedClass['subject'] ?? '',
              description: cachedClass['description'],
              gradeLevel: cachedClass['gradeLevel'] ?? '',
              room: cachedClass['room'],
              schedule: cachedClass['schedule'],
              studentIds: List<String>.from(cachedClass['studentIds'] ?? []),
              maxStudents: cachedClass['maxStudents'],
              enrollmentCode: cachedClass['enrollmentCode'],
              isActive: cachedClass['isActive'] ?? true,
              academicYear: cachedClass['academicYear'] ?? '',
              semester: cachedClass['semester'] ?? '',
              createdAt: cachedClass['createdAt'] is String 
                ? DateTime.parse(cachedClass['createdAt'])
                : cachedClass['createdAt']?.toDate() ?? DateTime.now(),
              updatedAt: cachedClass['updatedAt'] is String 
                ? DateTime.parse(cachedClass['updatedAt'])
                : cachedClass['updatedAt']?.toDate(),
              settings: cachedClass['settings'] != null 
                ? Map<String, dynamic>.from(cachedClass['settings']) 
                : null,
            );
          }
          
          // Get from Firestore with retry
          final doc = await RetryService.withRetry(
            () => _classesCollection.doc(classId).get(),
            config: RetryConfigs.fast,
          );
          
          if (!doc.exists) {
            _performance.recordMetric('class_not_found', 1);
            return null;
          }
          
          final classModel = ClassModel.fromFirestore(doc);
          
          // Cache the result
          await _cache.set(
            'class_$classId',
            classModel.toFirestore(),
            ttl: const Duration(hours: 2),
          );
          
          _performance.recordMetric('class_retrieved', 1);
          return classModel;
          
        } catch (e) {
          LoggerService.error(
            'Error getting class by ID: $classId',
            error: e,
          );
          rethrow;
        }
      },
      attributes: {
        'class_id': classId,
        'operation': 'get_by_id',
      },
    );
  }

  /// Retrieves a class by enrollment code with caching.
  /// 
  /// Uses cached enrollment code lookups for performance.
  /// 
  /// @param enrollmentCode The enrollment code to search for
  /// @return Class model if found, null otherwise
  Future<ClassModel?> getClassByEnrollmentCode(String enrollmentCode) async {
    return await _performance.timeOperation(
      'get_class_by_enrollment_code',
      () async {
        try {
          // Validate enrollment code format
          final codeValidation = ValidationService.validateClassCode(enrollmentCode);
          if (codeValidation != null) {
            throw Exception('Invalid enrollment code format: $codeValidation');
          }
          
          // Check cache first
          final cachedClass = await _cache.get<Map<String, dynamic>>(
            'enrollment_code_$enrollmentCode',
          );
          if (cachedClass != null) {
            _performance.recordMetric('cache_hit_enrollment_code', 1);
            // Create ClassModel directly from cached data
            return ClassModel(
              id: cachedClass['id'] ?? 'cached_class',
              teacherId: cachedClass['teacherId'] ?? '',
              name: cachedClass['name'] ?? '',
              subject: cachedClass['subject'] ?? '',
              description: cachedClass['description'],
              gradeLevel: cachedClass['gradeLevel'] ?? '',
              room: cachedClass['room'],
              schedule: cachedClass['schedule'],
              studentIds: List<String>.from(cachedClass['studentIds'] ?? []),
              maxStudents: cachedClass['maxStudents'],
              enrollmentCode: cachedClass['enrollmentCode'],
              isActive: cachedClass['isActive'] ?? true,
              academicYear: cachedClass['academicYear'] ?? '',
              semester: cachedClass['semester'] ?? '',
              createdAt: cachedClass['createdAt'] is String 
                ? DateTime.parse(cachedClass['createdAt'])
                : cachedClass['createdAt']?.toDate() ?? DateTime.now(),
              updatedAt: cachedClass['updatedAt'] is String 
                ? DateTime.parse(cachedClass['updatedAt'])
                : cachedClass['updatedAt']?.toDate(),
              settings: cachedClass['settings'] != null 
                ? Map<String, dynamic>.from(cachedClass['settings']) 
                : null,
            );
          }
          
          // Query Firestore with retry
          final querySnapshot = await RetryService.withRetry(
            () => _classesCollection
                .where('enrollmentCode', isEqualTo: enrollmentCode)
                .where('isActive', isEqualTo: true)
                .limit(1)
                .get(),
            config: RetryConfigs.standard,
          );
          
          if (querySnapshot.docs.isEmpty) {
            _performance.recordMetric('enrollment_code_not_found', 1);
            return null;
          }
          
          final classModel = ClassModel.fromFirestore(querySnapshot.docs.first);
          
          // Cache the result
          await _cache.set(
            'enrollment_code_$enrollmentCode',
            classModel.toFirestore(),
            ttl: const Duration(hours: 24),
          );
          
          _performance.recordMetric('enrollment_code_found', 1);
          return classModel;
          
        } catch (e) {
          LoggerService.error(
            'Error getting class by enrollment code: $enrollmentCode',
            error: e,
          );
          rethrow;
        }
      },
      attributes: {
        'enrollment_code': enrollmentCode,
        'operation': 'get_by_enrollment_code',
      },
    );
  }

  /// Enrolls a student in a class with comprehensive validation and monitoring.
  /// 
  /// Includes capacity checking, duplicate enrollment prevention,
  /// and performance tracking.
  /// 
  /// @param studentId ID of the student to enroll
  /// @param enrollmentCode The enrollment code for the class
  /// @return The class the student was enrolled in
  /// @throws Exception if enrollment fails
  Future<ClassModel> enrollStudent(String studentId, String enrollmentCode) async {
    return await _performance.timeOperation(
      'enroll_student',
      () async {
        try {
          // Validate inputs
          final studentIdValidation = ValidationService.validateUsername(studentId);
          if (studentIdValidation != null) {
            throw Exception('Invalid student ID: $studentIdValidation');
          }
          
          // Find class by enrollment code
          final classModel = await getClassByEnrollmentCode(enrollmentCode);
          
          if (classModel == null) {
            _performance.recordMetric('enrollment_failed_invalid_code', 1);
            throw Exception('Invalid enrollment code');
          }
          
          // Check if student is already enrolled
          if (classModel.studentIds.contains(studentId)) {
            _performance.recordMetric('enrollment_failed_already_enrolled', 1);
            throw Exception('Student is already enrolled in this class');
          }
          
          // Check if class is full
          if (classModel.isFull) {
            _performance.recordMetric('enrollment_failed_class_full', 1);
            throw Exception('Class is at maximum capacity');
          }
          
          // Add student to class with retry
          final updatedStudentIds = [...classModel.studentIds, studentId];
          
          await RetryService.withRetry(
            () => _classesCollection.doc(classModel.id).update({
              'studentIds': updatedStudentIds,
              'updatedAt': Timestamp.fromDate(DateTime.now()),
            }),
            config: RetryConfigs.standard,
          );
          
          final updatedClass = classModel.copyWith(
            studentIds: updatedStudentIds,
            updatedAt: DateTime.now(),
          );
          
          // Update caches
          await _cache.set(
            'class_${classModel.id}',
            updatedClass.toFirestore(),
            ttl: const Duration(hours: 2),
          );
          
          // Invalidate related caches
          await _cache.clearPattern('student_classes_$studentId');
          await _cache.clearPattern('class_stats_${classModel.id}');
          
          // Record metrics
          _performance.recordMetric('student_enrolled', 1);
          _performance.recordMetric('class_enrollment_count', updatedStudentIds.length.toDouble());
          
          LoggerService.info(
            'Enrolled student $studentId in class ${classModel.name} (ID: ${classModel.id}, Count: ${updatedStudentIds.length})',
          );
          
          return updatedClass;
          
        } catch (e) {
          LoggerService.error(
            'Error enrolling student $studentId with code $enrollmentCode',
            error: e,
          );
          rethrow;
        }
      },
      attributes: {
        'student_id': studentId,
        'enrollment_code': enrollmentCode,
        'operation': 'enroll_student',
      },
    );
  }

  /// Gets teacher class statistics with caching and performance monitoring.
  /// 
  /// Caches results for 30 minutes to improve performance.
  /// 
  /// @param teacherId ID of the teacher
  /// @return Map containing comprehensive class statistics
  Future<Map<String, dynamic>> getTeacherClassStats(String teacherId) async {
    return await _performance.timeOperation(
      'get_teacher_class_stats',
      () async {
        try {
          // Check cache first
          final cacheKey = 'teacher_stats_$teacherId';
          final cachedStats = await _cache.get<Map<String, dynamic>>(cacheKey);
          if (cachedStats != null) {
            _performance.recordMetric('cache_hit_teacher_stats', 1);
            return cachedStats;
          }
          
          // Query Firestore with retry
          final snapshot = await RetryService.withRetry(
            () => _classesCollection
                .where('teacherId', isEqualTo: teacherId)
                .where('isActive', isEqualTo: true)
                .get(),
            config: RetryConfigs.standard,
          );
          
          final classes = snapshot.docs
              .map((doc) => ClassModel.fromFirestore(doc))
              .toList();
          
          // Calculate comprehensive stats
          int totalStudents = 0;
          int totalCapacity = 0;
          double totalUtilization = 0;
          
          for (final classModel in classes) {
            totalStudents += classModel.studentCount;
            totalCapacity += classModel.maxStudents ?? 0;
            if (classModel.maxStudents != null && classModel.maxStudents! > 0) {
              totalUtilization += (classModel.studentCount / classModel.maxStudents!) * 100;
            }
          }
          
          final stats = {
            'totalClasses': classes.length,
            'totalStudents': totalStudents,
            'totalCapacity': totalCapacity,
            'averageClassSize': classes.isEmpty 
                ? 0 
                : (totalStudents / classes.length).round(),
            'averageUtilization': classes.isEmpty 
                ? 0 
                : (totalUtilization / classes.length).round(),
            'utilizationPercentage': totalCapacity > 0 
                ? ((totalStudents / totalCapacity) * 100).round() 
                : 0,
            'lastUpdated': DateTime.now().toIso8601String(),
          };
          
          // Cache the results
          await _cache.set(
            cacheKey,
            stats,
            ttl: const Duration(minutes: 30),
          );
          
          // Record metrics
          _performance.recordMetric('teacher_stats_calculated', 1);
          _performance.recordMetric('teacher_total_classes', classes.length.toDouble());
          _performance.recordMetric('teacher_total_students', totalStudents.toDouble());
          
          return stats;
          
        } catch (e) {
          LoggerService.error(
            'Error getting teacher class stats for teacher: $teacherId',
            error: e,
          );
          rethrow;
        }
      },
      attributes: {
        'teacher_id': teacherId,
        'operation': 'get_teacher_stats',
      },
    );
  }

  /// Validates class model data.
  void _validateClassModel(ClassModel classModel) {
    if (classModel.name.isEmpty) {
      throw Exception('Class name cannot be empty');
    }
    
    if (classModel.teacherId.isEmpty) {
      throw Exception('Teacher ID cannot be empty');
    }
    
    if (classModel.maxStudents != null && classModel.maxStudents! < 1) {
      throw Exception('Maximum students must be at least 1');
    }
    
    // Validate using ValidationService
    final nameValidation = ValidationService.validateTextLength(
      classModel.name,
      fieldName: 'Class name',
      minLength: 1,
      maxLength: 100,
    );
    if (nameValidation != null) {
      throw Exception('Invalid class name: $nameValidation');
    }
  }

  /// Generates a unique enrollment code with performance monitoring.
  Future<String> _generateUniqueEnrollmentCode() async {
    return await _performance.timeOperation(
      'generate_enrollment_code',
      () async {
        const chars = 'ABCDEFGHJKLMNPQRSTUVWXYZ23456789';
        const codeLength = 6;
        const maxAttempts = 100;
        
        final random = Random();
        
        for (int attempt = 0; attempt < maxAttempts; attempt++) {
          // Generate random code
          final code = String.fromCharCodes(
            Iterable.generate(
              codeLength,
              (_) => chars.codeUnitAt(random.nextInt(chars.length)),
            ),
          );
          
          // Check if code already exists
          final existing = await getClassByEnrollmentCode(code);
          if (existing == null) {
            _performance.recordMetric('enrollment_code_generation_attempts', attempt + 1.0);
            return code;
          }
        }
        
        _performance.recordMetric('enrollment_code_generation_failed', 1);
        throw Exception('Unable to generate unique enrollment code');
      },
      attributes: {
        'operation': 'generate_code',
      },
    );
  }

  /// Clears all caches related to classes.
  /// 
  /// Useful for testing or when data consistency is critical.
  Future<void> clearAllCaches() async {
    await _cache.clearPattern('class_');
    await _cache.clearPattern('enrollment_code_');
    await _cache.clearPattern('teacher_stats_');
    await _cache.clearPattern('student_classes_');
    await _cache.clearPattern('class_stats_');
    
    LoggerService.info('All class-related caches cleared');
  }

  /// Gets performance metrics for the service.
  Map<String, dynamic> getPerformanceMetrics() {
    return _performance.getPerformanceStats();
  }

}
````

## File: lib/features/classes/data/services/class_service.dart
````dart
/// Service for managing educational classes in Firebase Firestore.
/// 
/// This service handles all CRUD operations for classes, including
/// enrollment management, class queries, and enrollment code generation.
library;

import 'dart:math';
import 'package:cloud_firestore/cloud_firestore.dart';
import '../../domain/models/class_model.dart';
import '../../../../shared/services/logger_service.dart';

/// Service class for managing educational classes in Firestore.
/// 
/// Provides functionality for:
/// - Creating and managing classes
/// - Generating unique enrollment codes
/// - Managing student enrollment
/// - Querying classes by various criteria
/// - Handling class updates and archival
class ClassService {
  final FirebaseFirestore _firestore = FirebaseFirestore.instance;
  
  /// Collection reference for classes in Firestore
  CollectionReference<Map<String, dynamic>> get _classesCollection => 
      _firestore.collection('classes');

  /// Creates a new class in Firestore with a unique enrollment code.
  /// 
  /// Generates a 6-character alphanumeric enrollment code and ensures
  /// it's unique across all classes before creating the class.
  /// 
  /// @param classModel Class data to create
  /// @return Created class with assigned ID and enrollment code
  /// @throws Exception if enrollment code generation fails after max attempts
  Future<ClassModel> createClass(ClassModel classModel) async {
    try {
      // Generate unique enrollment code
      final enrollmentCode = await _generateUniqueEnrollmentCode();
      
      // Create class with enrollment code
      final classWithCode = classModel.copyWith(
        enrollmentCode: enrollmentCode,
        createdAt: DateTime.now(),
      );
      
      // Add to Firestore
      final docRef = await _classesCollection.add(classWithCode.toFirestore());
      
      // Return class with generated ID
      final createdClass = classWithCode.copyWith(id: docRef.id);
      
      LoggerService.info('Created class: ${createdClass.name} with enrollment code: $enrollmentCode');
      return createdClass;
      
    } catch (e) {
      LoggerService.error('Error creating class', error: e);
      rethrow;
    }
  }

  /// Updates an existing class in Firestore.
  /// 
  /// Preserves the enrollment code unless explicitly changed.
  /// Updates the updatedAt timestamp automatically.
  /// 
  /// @param classModel Updated class data
  /// @return Updated class model
  Future<ClassModel> updateClass(ClassModel classModel) async {
    try {
      final updatedClass = classModel.copyWith(
        updatedAt: DateTime.now(),
      );
      
      await _classesCollection
          .doc(classModel.id)
          .update(updatedClass.toFirestore());
      
      LoggerService.info('Updated class: ${classModel.name}');
      return updatedClass;
      
    } catch (e) {
      LoggerService.error('Error updating class', error: e);
      rethrow;
    }
  }

  /// Deletes a class from Firestore.
  /// 
  /// Consider implementing soft delete by setting isActive to false
  /// instead of hard delete to preserve historical data.
  /// 
  /// @param classId ID of the class to delete
  Future<void> deleteClass(String classId) async {
    try {
      await _classesCollection.doc(classId).delete();
      LoggerService.info('Deleted class: $classId');
    } catch (e) {
      LoggerService.error('Error deleting class', error: e);
      rethrow;
    }
  }

  /// Archives a class by setting isActive to false.
  /// 
  /// Preferred over deletion to maintain historical records
  /// and allow for potential restoration.
  /// 
  /// @param classId ID of the class to archive
  Future<void> archiveClass(String classId) async {
    try {
      await _classesCollection.doc(classId).update({
        'isActive': false,
        'updatedAt': Timestamp.fromDate(DateTime.now()),
      });
      LoggerService.info('Archived class: $classId');
    } catch (e) {
      LoggerService.error('Error archiving class', error: e);
      rethrow;
    }
  }

  /// Retrieves a single class by ID.
  /// 
  /// @param classId ID of the class to retrieve
  /// @return Class model if found, null otherwise
  Future<ClassModel?> getClassById(String classId) async {
    try {
      final doc = await _classesCollection.doc(classId).get();
      
      if (!doc.exists) {
        return null;
      }
      
      return ClassModel.fromFirestore(doc);
    } catch (e) {
      LoggerService.error('Error getting class by ID', error: e);
      rethrow;
    }
  }

  /// Retrieves a class by its enrollment code.
  /// 
  /// Used for student enrollment via code entry.
  /// 
  /// @param enrollmentCode The enrollment code to search for
  /// @return Class model if found, null otherwise
  Future<ClassModel?> getClassByEnrollmentCode(String enrollmentCode) async {
    try {
      final querySnapshot = await _classesCollection
          .where('enrollmentCode', isEqualTo: enrollmentCode)
          .where('isActive', isEqualTo: true)
          .limit(1)
          .get();
      
      if (querySnapshot.docs.isEmpty) {
        return null;
      }
      
      return ClassModel.fromFirestore(querySnapshot.docs.first);
    } catch (e) {
      LoggerService.error('Error getting class by enrollment code', error: e);
      rethrow;
    }
  }

  /// Gets all classes for a specific teacher.
  /// 
  /// @param teacherId ID of the teacher
  /// @param includeArchived Whether to include archived classes
  /// @return Stream of classes for the teacher
  Stream<List<ClassModel>> getClassesByTeacher(
    String teacherId, {
    bool includeArchived = false,
  }) {
    try {
      Query<Map<String, dynamic>> query = _classesCollection
          .where('teacherId', isEqualTo: teacherId);
      
      if (!includeArchived) {
        query = query.where('isActive', isEqualTo: true);
      }
      
      return query
          .orderBy('createdAt', descending: true)
          .snapshots()
          .map((snapshot) => snapshot.docs
              .map((doc) => ClassModel.fromFirestore(doc))
              .toList());
    } catch (e) {
      LoggerService.error('Error getting classes by teacher', error: e);
      rethrow;
    }
  }

  /// Gets all classes a student is enrolled in.
  /// 
  /// @param studentId ID of the student
  /// @param includeArchived Whether to include archived classes
  /// @return Stream of classes the student is enrolled in
  Stream<List<ClassModel>> getClassesByStudent(
    String studentId, {
    bool includeArchived = false,
  }) {
    try {
      Query<Map<String, dynamic>> query = _classesCollection
          .where('studentIds', arrayContains: studentId);
      
      if (!includeArchived) {
        query = query.where('isActive', isEqualTo: true);
      }
      
      return query
          .orderBy('name')
          .snapshots()
          .map((snapshot) => snapshot.docs
              .map((doc) => ClassModel.fromFirestore(doc))
              .toList());
    } catch (e) {
      LoggerService.error('Error getting classes by student', error: e);
      rethrow;
    }
  }

  /// Enrolls a student in a class using an enrollment code.
  /// 
  /// Validates the enrollment code and checks if the class
  /// has capacity before adding the student.
  /// 
  /// @param studentId ID of the student to enroll
  /// @param enrollmentCode The enrollment code for the class
  /// @return The class the student was enrolled in
  /// @throws Exception if enrollment fails
  Future<ClassModel> enrollStudent(String studentId, String enrollmentCode) async {
    try {
      // Find class by enrollment code
      final classModel = await getClassByEnrollmentCode(enrollmentCode);
      
      if (classModel == null) {
        throw Exception('Invalid enrollment code');
      }
      
      // Check if student is already enrolled
      if (classModel.studentIds.contains(studentId)) {
        throw Exception('Student is already enrolled in this class');
      }
      
      // Check if class is full
      if (classModel.isFull) {
        throw Exception('Class is at maximum capacity');
      }
      
      // Add student to class
      final updatedStudentIds = [...classModel.studentIds, studentId];
      final updatedClass = classModel.copyWith(
        studentIds: updatedStudentIds,
        updatedAt: DateTime.now(),
      );
      
      await _classesCollection
          .doc(classModel.id)
          .update({'studentIds': updatedStudentIds});
      
      LoggerService.info('Enrolled student $studentId in class ${classModel.name}');
      return updatedClass;
      
    } catch (e) {
      LoggerService.error('Error enrolling student', error: e);
      rethrow;
    }
  }

  /// Removes a student from a class.
  /// 
  /// @param classId ID of the class
  /// @param studentId ID of the student to remove
  Future<void> unenrollStudent(String classId, String studentId) async {
    try {
      final classModel = await getClassById(classId);
      
      if (classModel == null) {
        throw Exception('Class not found');
      }
      
      final updatedStudentIds = classModel.studentIds
          .where((id) => id != studentId)
          .toList();
      
      await _classesCollection.doc(classId).update({
        'studentIds': updatedStudentIds,
        'updatedAt': Timestamp.fromDate(DateTime.now()),
      });
      
      LoggerService.info('Unenrolled student $studentId from class ${classModel.name}');
    } catch (e) {
      LoggerService.error('Error unenrolling student', error: e);
      rethrow;
    }
  }

  /// Generates a new unique enrollment code for a class.
  /// 
  /// @param classId ID of the class to generate code for
  /// @return The new enrollment code
  Future<String> regenerateEnrollmentCode(String classId) async {
    try {
      final newCode = await _generateUniqueEnrollmentCode();
      
      await _classesCollection.doc(classId).update({
        'enrollmentCode': newCode,
        'updatedAt': Timestamp.fromDate(DateTime.now()),
      });
      
      LoggerService.info('Regenerated enrollment code for class $classId');
      return newCode;
      
    } catch (e) {
      LoggerService.error('Error regenerating enrollment code', error: e);
      rethrow;
    }
  }

  /// Generates a unique 6-character alphanumeric enrollment code.
  /// 
  /// Ensures uniqueness by checking against existing codes.
  /// Uses uppercase letters and numbers, excluding ambiguous characters.
  /// 
  /// @return Unique enrollment code
  /// @throws Exception if unable to generate unique code after max attempts
  Future<String> _generateUniqueEnrollmentCode() async {
    const chars = 'ABCDEFGHJKLMNPQRSTUVWXYZ23456789'; // Exclude I, O, 0, 1
    const codeLength = 6;
    const maxAttempts = 100;
    
    final random = Random();
    
    for (int attempt = 0; attempt < maxAttempts; attempt++) {
      // Generate random code
      final code = String.fromCharCodes(
        Iterable.generate(
          codeLength,
          (_) => chars.codeUnitAt(random.nextInt(chars.length)),
        ),
      );
      
      // Check if code already exists
      final existing = await getClassByEnrollmentCode(code);
      if (existing == null) {
        return code;
      }
    }
    
    throw Exception('Unable to generate unique enrollment code');
  }

  /// Gets statistics for a teacher's classes.
  /// 
  /// @param teacherId ID of the teacher
  /// @return Map containing total classes, total students, and average class size
  Future<Map<String, dynamic>> getTeacherClassStats(String teacherId) async {
    try {
      final snapshot = await _classesCollection
          .where('teacherId', isEqualTo: teacherId)
          .where('isActive', isEqualTo: true)
          .get();
      
      final classes = snapshot.docs
          .map((doc) => ClassModel.fromFirestore(doc))
          .toList();
      
      int totalStudents = 0;
      for (final classModel in classes) {
        totalStudents += classModel.studentCount;
      }
      
      return {
        'totalClasses': classes.length,
        'totalStudents': totalStudents,
        'averageClassSize': classes.isEmpty 
            ? 0 
            : (totalStudents / classes.length).round(),
      };
      
    } catch (e) {
      LoggerService.error('Error getting teacher class stats', error: e);
      rethrow;
    }
  }
}
````

## File: lib/features/classes/domain/models/class_model.dart
````dart
/// Class model for managing educational classes and courses.
/// 
/// This module contains the data model for classes, representing
/// the courses taught by teachers and attended by students in
/// the education management system.
library;

import 'package:cloud_firestore/cloud_firestore.dart';

/// Core class model representing an educational class or course.
/// 
/// This model encapsulates all data related to a class, including:
/// - Basic information (name, subject, grade level)
/// - Teacher and student associations
/// - Scheduling and location details
/// - Academic period information
/// - Configuration settings
/// 
/// Classes serve as the primary organizational unit for:
/// - Assignment distribution
/// - Grade tracking
/// - Student enrollment
/// - Communication channels
class ClassModel {
  /// Unique identifier for the class
  final String id;
  
  /// ID of the teacher who manages this class
  final String teacherId;
  
  /// Display name of the class (e.g., "Advanced Mathematics")
  final String name;
  
  /// Subject area of the class (e.g., "Mathematics", "Science")
  final String subject;
  
  /// Optional detailed description of the class content and objectives
  final String? description;
  
  /// Grade level for the class (e.g., "10", "11-12", "AP")
  final String gradeLevel;
  
  /// Physical classroom location (e.g., "Room 201", "Lab A")
  final String? room;
  
  /// Class meeting schedule (e.g., "MWF 10:00-11:00 AM")
  final String? schedule;
  
  /// List of student IDs enrolled in this class
  final List<String> studentIds;
  
  /// Optional URL to the class syllabus document
  final String? syllabusUrl;
  
  /// Timestamp when the class was created
  final DateTime createdAt;
  
  /// Timestamp of last modification (null if never updated)
  final DateTime? updatedAt;
  
  /// Whether the class is currently active
  final bool isActive;
  
  /// Academic year for the class (e.g., "2023-2024")
  final String academicYear;
  
  /// Semester or term (e.g., "Fall", "Spring", "Q1")
  final String semester;
  
  /// Optional maximum number of students allowed in the class
  final int? maxStudents;
  
  /// Unique enrollment code for students to join the class
  final String? enrollmentCode;
  
  /// Flexible settings map for class-specific configurations
  final Map<String, dynamic>? settings;

  ClassModel({
    required this.id,
    required this.teacherId,
    required this.name,
    required this.subject,
    this.description,
    required this.gradeLevel,
    this.room,
    this.schedule,
    required this.studentIds,
    this.syllabusUrl,
    required this.createdAt,
    this.updatedAt,
    required this.isActive,
    required this.academicYear,
    required this.semester,
    this.maxStudents,
    this.enrollmentCode,
    this.settings,
  });

  /// Factory constructor to create ClassModel from Firestore document.
  /// 
  /// Handles data parsing and type conversions including:
  /// - Timestamp to DateTime conversions
  /// - List casting for student IDs
  /// - Null safety for optional fields
  /// - Default values for required fields
  /// 
  /// @param doc Firestore document snapshot containing class data
  /// @return Parsed ClassModel instance
  factory ClassModel.fromFirestore(DocumentSnapshot doc) {
    final data = doc.data() as Map<String, dynamic>;
    return ClassModel(
      id: doc.id,
      teacherId: data['teacherId'] ?? '',
      name: data['name'] ?? '',
      subject: data['subject'] ?? '',
      description: data['description'],
      gradeLevel: data['gradeLevel'] ?? '',
      room: data['room'],
      schedule: data['schedule'],
      studentIds: List<String>.from(data['studentIds'] ?? []),
      syllabusUrl: data['syllabusUrl'],
      createdAt: (data['createdAt'] as Timestamp).toDate(),
      updatedAt: data['updatedAt'] != null 
          ? (data['updatedAt'] as Timestamp).toDate() 
          : null,
      isActive: data['isActive'] ?? true,
      academicYear: data['academicYear'] ?? '',
      semester: data['semester'] ?? '',
      maxStudents: data['maxStudents'],
      enrollmentCode: data['enrollmentCode'],
      settings: data['settings'],
    );
  }

  /// Converts the ClassModel instance to a Map for Firestore storage.
  /// 
  /// Serializes all class data for persistence, including:
  /// - DateTime fields to Firestore Timestamps
  /// - Null checks for optional fields
  /// - Direct storage of complex types (lists, maps)
  /// 
  /// @return Map containing all class data ready for Firestore
  Map<String, dynamic> toFirestore() {
    return {
      'teacherId': teacherId,
      'name': name,
      'subject': subject,
      'description': description,
      'gradeLevel': gradeLevel,
      'room': room,
      'schedule': schedule,
      'studentIds': studentIds,
      'syllabusUrl': syllabusUrl,
      'createdAt': Timestamp.fromDate(createdAt),
      'updatedAt': updatedAt != null ? Timestamp.fromDate(updatedAt!) : null,
      'isActive': isActive,
      'academicYear': academicYear,
      'semester': semester,
      'maxStudents': maxStudents,
      'enrollmentCode': enrollmentCode,
      'settings': settings,
    };
  }

  /// Creates a copy of the ClassModel with updated fields.
  /// 
  /// Follows the immutable data pattern, allowing selective field updates
  /// while preserving all other values. Useful for:
  /// - Updating class details
  /// - Adding/removing students
  /// - Changing scheduling information
  /// - Modifying settings
  /// 
  /// All parameters are optional - only provided fields will be updated.
  /// 
  /// @return New ClassModel instance with updated fields
  ClassModel copyWith({
    String? id,
    String? teacherId,
    String? name,
    String? subject,
    String? description,
    String? gradeLevel,
    String? room,
    String? schedule,
    List<String>? studentIds,
    String? syllabusUrl,
    DateTime? createdAt,
    DateTime? updatedAt,
    bool? isActive,
    String? academicYear,
    String? semester,
    int? maxStudents,
    String? enrollmentCode,
    Map<String, dynamic>? settings,
  }) {
    return ClassModel(
      id: id ?? this.id,
      teacherId: teacherId ?? this.teacherId,
      name: name ?? this.name,
      subject: subject ?? this.subject,
      description: description ?? this.description,
      gradeLevel: gradeLevel ?? this.gradeLevel,
      room: room ?? this.room,
      schedule: schedule ?? this.schedule,
      studentIds: studentIds ?? this.studentIds,
      syllabusUrl: syllabusUrl ?? this.syllabusUrl,
      createdAt: createdAt ?? this.createdAt,
      updatedAt: updatedAt ?? this.updatedAt,
      isActive: isActive ?? this.isActive,
      academicYear: academicYear ?? this.academicYear,
      semester: semester ?? this.semester,
      maxStudents: maxStudents ?? this.maxStudents,
      enrollmentCode: enrollmentCode ?? this.enrollmentCode,
      settings: settings ?? this.settings,
    );
  }
  
  /// Gets the current number of students enrolled in the class.
  /// @return Count of students in the studentIds list
  int get studentCount => studentIds.length;
  
  /// Checks if the class has reached its maximum capacity.
  /// @return true if class is at or above max capacity, false otherwise
  bool get isFull => maxStudents != null && studentCount >= maxStudents!;
}
````

## File: lib/features/classes/presentation/providers/class_provider.dart
````dart
/// Class management state provider.
/// 
/// This module manages class (course) state for the education platform,
/// handling teacher and student class listings, enrollment operations,
/// and real-time updates through stream subscriptions.
library;

import 'dart:async';
import 'package:flutter/material.dart';
import '../../domain/models/class_model.dart';
import '../../../student/domain/models/student.dart';
import '../../domain/repositories/class_repository.dart';
import '../../../student/domain/repositories/student_repository.dart';
import '../../../../shared/core/service_locator.dart';

/// Provider managing class state and enrollment operations.
/// 
/// This provider serves as the central state manager for classes,
/// coordinating between class and student repositories. Key features:
/// - Real-time class list updates for teachers and students
/// - Student enrollment and unenrollment management
/// - Class archiving and restoration
/// - Academic year filtering
/// - Student search for enrollment
/// - Bulk enrollment operations
/// 
/// Maintains separate lists for teacher-owned and student-enrolled
/// classes with automatic stream management.
class ClassProvider with ChangeNotifier {
  /// Repository for class data operations.
  late final ClassRepository _classRepository;
  
  /// Repository for student data operations.
  late final StudentRepository _studentRepository;
  
  // State variables
  
  /// Classes taught by the current teacher.
  List<ClassModel> _teacherClasses = [];
  
  /// Classes enrolled by the current student.
  List<ClassModel> _studentClasses = [];
  
  /// Students enrolled in the selected class.
  List<Student> _classStudents = [];
  
  /// Loading state for async operations.
  bool _isLoading = false;
  
  /// Latest error message for UI display.
  String? _error;
  
  /// Currently selected class for detail views.
  ClassModel? _selectedClass;
  
  // Stream subscriptions
  
  /// Subscription for teacher's class list updates.
  StreamSubscription<List<ClassModel>>? _teacherClassesSubscription;
  
  /// Subscription for student's class list updates.
  StreamSubscription<List<ClassModel>>? _studentClassesSubscription;
  
  /// Subscription for class student list updates.
  StreamSubscription<List<Student>>? _classStudentsSubscription;
  
  /// Creates class provider with repository dependencies.
  /// 
  /// Retrieves repositories from dependency injection container.
  ClassProvider() {
    _classRepository = getIt<ClassRepository>();
    _studentRepository = getIt<StudentRepository>();
  }
  
  // Getters
  
  /// List of classes taught by current teacher.
  List<ClassModel> get teacherClasses => _teacherClasses;
  
  /// List of classes enrolled by current student.
  List<ClassModel> get studentClasses => _studentClasses;
  
  /// Students enrolled in selected class.
  List<Student> get classStudents => _classStudents;
  
  /// Whether an operation is in progress.
  bool get isLoading => _isLoading;
  
  /// Latest error message or null.
  String? get error => _error;
  
  /// Currently selected class or null.
  ClassModel? get selectedClass => _selectedClass;
  
  /// Filters teacher's classes to show only active ones.
  /// 
  /// Active classes accept new enrollments and assignments.
  List<ClassModel> get activeClasses {
    return _teacherClasses.where((c) => c.isActive).toList();
  }
  
  /// Filters teacher's classes to show only archived ones.
  /// 
  /// Archived classes are read-only historical records.
  List<ClassModel> get archivedClasses {
    return _teacherClasses.where((c) => !c.isActive).toList();
  }
  
  /// Filters classes by academic year.
  /// 
  /// Useful for year-specific views and reports.
  /// 
  /// @param academicYear Year to filter by (e.g., "2023-2024")
  /// @return List of classes from specified year
  List<ClassModel> getClassesByAcademicYear(String academicYear) {
    return _teacherClasses.where((c) => c.academicYear == academicYear).toList();
  }
  
  /// Loads and subscribes to teacher's class list.
  /// 
  /// Sets up real-time stream for class updates.
  /// Cancels any existing subscription before creating new one.
  /// 
  /// @param teacherId Teacher's unique identifier
  /// @throws Exception if loading fails
  Future<void> loadTeacherClasses(String teacherId) async {
    _setLoading(true);
    notifyListeners();  // Safe here, as it's before async
    
    try {
      _teacherClassesSubscription?.cancel();
      
      _teacherClassesSubscription = _classRepository.getTeacherClasses(teacherId).listen(
        (classList) {
          _teacherClasses = classList;
          _setLoading(false);
          WidgetsBinding.instance.addPostFrameCallback((_) {
            notifyListeners();
          });
        },
        onError: (error) {
          _setError(error.toString());
          _setLoading(false);
          WidgetsBinding.instance.addPostFrameCallback((_) {
            notifyListeners();
          });
        },
      );
    } catch (e) {
      _setError(e.toString());
      _setLoading(false);
      notifyListeners();  // Safe here
    }
  }
  
  /// Loads and subscribes to student's enrolled classes.
  /// 
  /// Sets up real-time stream for enrollment updates.
  /// Cancels any existing subscription before creating new one.
  /// 
  /// @param studentId Student's unique identifier
  /// @throws Exception if loading fails
  Future<void> loadStudentClasses(String studentId) async {
    _setLoading(true);
    notifyListeners();
    
    try {
      _studentClassesSubscription?.cancel();
      
      _studentClassesSubscription = _classRepository.getStudentClasses(studentId).listen(
        (classList) {
          _studentClasses = classList;
          _setLoading(false);
          WidgetsBinding.instance.addPostFrameCallback((_) {
            notifyListeners();
          });
        },
        onError: (error) {
          _setError(error.toString());
          _setLoading(false);
          WidgetsBinding.instance.addPostFrameCallback((_) {
            notifyListeners();
          });
        },
      );
    } catch (e) {
      _setError(e.toString());
      _setLoading(false);
      notifyListeners();
    }
  }
  
  /// Loads and subscribes to class student roster.
  /// 
  /// Sets up real-time stream for enrollment changes.
  /// Students are ordered alphabetically by name.
  /// 
  /// @param classId Class identifier
  /// @throws Exception if loading fails
  Future<void> loadClassStudents(String classId) async {
    _setLoading(true);
    notifyListeners();
    
    try {
      _classStudentsSubscription?.cancel();
      
      _classStudentsSubscription = _studentRepository.getClassStudents(classId).listen(
        (studentList) {
          _classStudents = studentList;
          _setLoading(false);
          WidgetsBinding.instance.addPostFrameCallback((_) {
            notifyListeners();
          });
        },
        onError: (error) {
          _setError(error.toString());
          _setLoading(false);
          WidgetsBinding.instance.addPostFrameCallback((_) {
            notifyListeners();
          });
        },
      );
    } catch (e) {
      _setError(e.toString());
      _setLoading(false);
      notifyListeners();
    }
  }
  
  /// Creates a new class in the system.
  /// 
  /// Adds class to Firestore and updates local state
  /// through stream subscription.
  /// 
  /// @param classModel Class data to create
  /// @return true if creation successful
  Future<bool> createClass(ClassModel classModel) async {
    _setLoading(true);
    notifyListeners();
    try {
      await _classRepository.createClass(classModel);
      _setLoading(false);
      notifyListeners();
      return true;
    } catch (e) {
      _setError(e.toString());
      _setLoading(false);
      notifyListeners();
      return false;
    }
  }
  
  /// Creates a new class with individual parameters.
  /// 
  /// Convenience method that builds a ClassModel from parameters.
  /// 
  /// @return true if creation successful
  Future<bool> createClassFromParams({
    required String name,
    required String subject,
    required String gradeLevel,
    String? description,
    String? room,
    String? schedule,
    required String academicYear,
    required String semester,
    int? maxStudents,
    required String teacherId,
  }) async {
    if (teacherId.isEmpty) {
      _setError('No teacher ID found');
      return false;
    }
    
    final classModel = ClassModel(
      id: '', // Will be generated by Firestore
      name: name,
      subject: subject,
      gradeLevel: gradeLevel,
      teacherId: teacherId,
      studentIds: [],
      description: description,
      room: room,
      schedule: schedule,
      academicYear: academicYear,
      semester: semester,
      maxStudents: maxStudents,
      isActive: true,
      createdAt: DateTime.now(),
      updatedAt: DateTime.now(),
    );
    
    return createClass(classModel);
  }
  
  /// Updates existing class information.
  /// 
  /// Modifies class in Firestore and updates local cache
  /// for immediate UI response.
  /// 
  /// @param classId Class to update
  /// @param classModel Updated class data
  /// @return true if update successful
  Future<bool> updateClass(String classId, ClassModel classModel) async {
    _setLoading(true);
    try {
      await _classRepository.updateClass(classId, classModel);
      
      // Update local list
      final index = _teacherClasses.indexWhere((c) => c.id == classId);
      if (index != -1) {
        _teacherClasses[index] = classModel;
        notifyListeners();
      }
      
      _setLoading(false);
      notifyListeners();
      return true;
    } catch (e) {
      _setError(e.toString());
      _setLoading(false);
      notifyListeners();
      return false;
    }
  }
  
  /// Permanently deletes a class.
  /// 
  /// Removes class from Firestore and local cache.
  /// This operation cannot be undone.
  /// 
  /// @param classId Class to delete
  /// @return true if deletion successful
  Future<bool> deleteClass(String classId) async {
    _setLoading(true);
    try {
      await _classRepository.deleteClass(classId);
      
      // Remove from local list
      _teacherClasses.removeWhere((c) => c.id == classId);
      notifyListeners();
      
      _setLoading(false);
      return true;
    } catch (e) {
      _setError(e.toString());
      _setLoading(false);
      return false;
    }
  }
  
  /// Archives an active class.
  /// 
  /// Archived classes become read-only and don't accept
  /// new enrollments or assignments. Updates local cache
  /// for immediate UI response.
  /// 
  /// @param classId Class to archive
  /// @return true if archiving successful
  Future<bool> archiveClass(String classId) async {
    _setLoading(true);
    try {
      await _classRepository.archiveClass(classId);
      
      // Update local list
      final index = _teacherClasses.indexWhere((c) => c.id == classId);
      if (index != -1) {
        _teacherClasses[index] = _teacherClasses[index].copyWith(
          isActive: false,
          updatedAt: DateTime.now(),
        );
        notifyListeners();
      }
      
      _setLoading(false);
      return true;
    } catch (e) {
      _setError(e.toString());
      _setLoading(false);
      return false;
    }
  }
  
  /// Restores an archived class to active status.
  /// 
  /// Reactivates class for new enrollments and assignments.
  /// Updates local cache for immediate UI response.
  /// 
  /// @param classId Class to restore
  /// @return true if restoration successful
  Future<bool> restoreClass(String classId) async {
    _setLoading(true);
    try {
      await _classRepository.restoreClass(classId);
      
      // Update local list
      final index = _teacherClasses.indexWhere((c) => c.id == classId);
      if (index != -1) {
        _teacherClasses[index] = _teacherClasses[index].copyWith(
          isActive: true,
          updatedAt: DateTime.now(),
        );
        notifyListeners();
      }
      
      _setLoading(false);
      return true;
    } catch (e) {
      _setError(e.toString());
      _setLoading(false);
      return false;
    }
  }
  
  /// Enrolls a student in a class.
  /// 
  /// Updates both class roster and student's enrollment list.
  /// Maintains bidirectional relationship in Firestore.
  /// Updates local state if class is currently selected.
  /// 
  /// @param classId Target class
  /// @param studentId Student to enroll
  /// @return true if enrollment successful
  Future<bool> enrollStudent(String classId, String studentId) async {
    _setLoading(true);
    try {
      await _classRepository.enrollStudent(classId, studentId);
      await _studentRepository.enrollInClass(studentId, classId);
      
      // Update local class if selected
      if (_selectedClass?.id == classId) {
        final updatedStudentIds = List<String>.from(_selectedClass!.studentIds)..add(studentId);
        _selectedClass = _selectedClass!.copyWith(
          studentIds: updatedStudentIds,
          updatedAt: DateTime.now(),
        );
        notifyListeners();
      }
      
      _setLoading(false);
      return true;
    } catch (e) {
      _setError(e.toString());
      _setLoading(false);
      return false;
    }
  }
  
  /// Removes a student from class enrollment.
  /// 
  /// Updates both class roster and student's enrollment list.
  /// Removes from local cache for immediate UI update.
  /// 
  /// @param classId Class to unenroll from
  /// @param studentId Student to remove
  /// @return true if unenrollment successful
  Future<bool> unenrollStudent(String classId, String studentId) async {
    _setLoading(true);
    try {
      await _classRepository.unenrollStudent(classId, studentId);
      await _studentRepository.unenrollFromClass(studentId, classId);
      
      // Update local class if selected
      if (_selectedClass?.id == classId) {
        final updatedStudentIds = List<String>.from(_selectedClass!.studentIds)..remove(studentId);
        _selectedClass = _selectedClass!.copyWith(
          studentIds: updatedStudentIds,
          updatedAt: DateTime.now(),
        );
        notifyListeners();
      }
      
      // Remove from local student list
      _classStudents.removeWhere((s) => s.id == studentId);
      notifyListeners();
      
      _setLoading(false);
      return true;
    } catch (e) {
      _setError(e.toString());
      _setLoading(false);
      return false;
    }
  }
  
  /// Enrolls multiple students in a class at once.
  /// 
  /// Efficient bulk enrollment for class setup.
  /// Updates both class and student records.
  /// Removes duplicates automatically.
  /// 
  /// @param classId Target class
  /// @param studentIds List of students to enroll
  /// @return true if bulk enrollment successful
  Future<bool> enrollMultipleStudents(String classId, List<String> studentIds) async {
    _setLoading(true);
    try {
      await _classRepository.enrollMultipleStudents(classId, studentIds);
      
      // Enroll each student in their student record
      for (final studentId in studentIds) {
        await _studentRepository.enrollInClass(studentId, classId);
      }
      
      // Update local class if selected
      if (_selectedClass?.id == classId) {
        final updatedStudentIds = List<String>.from(_selectedClass!.studentIds)..addAll(studentIds);
        _selectedClass = _selectedClass!.copyWith(
          studentIds: updatedStudentIds.toSet().toList(), // Remove duplicates
          updatedAt: DateTime.now(),
        );
        notifyListeners();
      }
      
      _setLoading(false);
      return true;
    } catch (e) {
      _setError(e.toString());
      _setLoading(false);
      return false;
    }
  }
  
  /// Checks if a student is enrolled in a class.
  /// 
  /// Queries current enrollment status from repository.
  /// 
  /// @param classId Class to check
  /// @param studentId Student to verify
  /// @return true if student is enrolled
  Future<bool> isStudentEnrolled(String classId, String studentId) async {
    try {
      return await _classRepository.isStudentEnrolled(classId, studentId);
    } catch (e) {
      _setError(e.toString());
      return false;
    }
  }
  
  /// Sets the currently selected class.
  /// 
  /// Used for detail views and context-aware operations.
  /// 
  /// @param classModel Class to select or null to clear
  void setSelectedClass(ClassModel? classModel) {
    _selectedClass = classModel;
    notifyListeners();  // This is safe - called from user interaction
  }
  
  /// Searches for students not enrolled in selected class.
  /// 
  /// Filters search results to show only students available
  /// for enrollment. Useful for enrollment UI.
  /// 
  /// @param query Search terms (name or email)
  /// @return List of available students
  Future<List<Student>> searchAvailableStudents(String query) async {
    try {
      final allStudents = await _studentRepository.searchStudents(query);
      
      // Filter out students already enrolled in the selected class
      if (_selectedClass != null) {
        return allStudents.where((student) => 
          !_selectedClass!.studentIds.contains(student.id)
        ).toList();
      }
      
      return allStudents;
    } catch (e) {
      _setError(e.toString());
      return [];
    }
  }
  
  /// Enrolls a student using an enrollment code.
  /// 
  /// Students can use this to join classes by entering
  /// the class enrollment code.
  /// 
  /// @param studentId Student to enroll
  /// @param enrollmentCode Class enrollment code
  /// @return true if enrollment successful
  Future<bool> enrollWithCode(String studentId, String enrollmentCode) async {
    _setLoading(true);
    try {
      await _classRepository.enrollWithCode(
        studentId, 
        enrollmentCode.toUpperCase(),
      );
      
      // The class list will be automatically updated via the stream subscription
      // No need to manually add it here as that would cause duplicates
      
      _setLoading(false);
      return true;
    } catch (e) {
      _setError(e.toString());
      _setLoading(false);
      return false;
    }
  }
  
  /// Generates a new enrollment code for a class.
  /// 
  /// Teachers can use this to create new codes when needed,
  /// such as for security or at the start of a new term.
  /// 
  /// @param classId Class to generate code for
  /// @return The new enrollment code or null on failure
  Future<String?> regenerateEnrollmentCode(String classId) async {
    _setLoading(true);
    try {
      final newCode = await _classRepository.regenerateEnrollmentCode(classId);
      
      // Update local class if it's in our list
      final index = _teacherClasses.indexWhere((c) => c.id == classId);
      if (index != -1) {
        _teacherClasses[index] = _teacherClasses[index].copyWith(
          enrollmentCode: newCode,
          updatedAt: DateTime.now(),
        );
        
        if (_selectedClass?.id == classId) {
          _selectedClass = _selectedClass!.copyWith(
            enrollmentCode: newCode,
            updatedAt: DateTime.now(),
          );
        }
        
        notifyListeners();
      }
      
      _setLoading(false);
      return newCode;
    } catch (e) {
      _setError(e.toString());
      _setLoading(false);
      return null;
    }
  }
  
  // Helper methods
  
  /// Sets loading state and notifies listeners.
  /// 
  /// @param loading New loading state
  void _setLoading(bool loading) {
    _isLoading = loading;
    // Removed notifyListeners() here - will handle manually in sensitive areas
  }
  
  /// Sets error message and notifies listeners.
  /// 
  /// @param error Error description or null
  void _setError(String? error) {
    _error = error;
    // Removed notifyListeners() here - will handle manually in sensitive areas
  }
  
  /// Clears error message and notifies UI.
  /// 
  /// Called after user acknowledges error.
  void clearError() {
    _error = null;
    notifyListeners();  // This is safe - called by user interaction
  }
  
  /// Clears all cached data.
  /// 
  /// Resets provider to initial state.
  /// Useful for user logout or role switch.
  void clearData() {
    _teacherClasses = [];
    _studentClasses = [];
    _classStudents = [];
    _selectedClass = null;
    _isLoading = false;
    _error = null;
    notifyListeners();  // This is safe - called on logout
  }
  
  /// Cleans up resources when provider is disposed.
  /// 
  /// Cancels all stream subscriptions and disposes
  /// repositories to prevent memory leaks.
  @override
  void dispose() {
    // Cancel subscriptions
    _teacherClassesSubscription?.cancel();
    _studentClassesSubscription?.cancel();
    _classStudentsSubscription?.cancel();
    
    // Dispose repositories
    _classRepository.dispose();
    _studentRepository.dispose();
    
    super.dispose();
  }
}
````

## File: lib/features/classes/presentation/screens/student/courses_screen.dart
````dart
import 'package:flutter/material.dart';
import 'package:go_router/go_router.dart';
import 'package:provider/provider.dart';
import '../../../../../features/auth/presentation/providers/auth_provider.dart';
import '../../providers/class_provider.dart';
import '../../../domain/models/class_model.dart';
import '../../../../../shared/widgets/common/common_widgets.dart';
import '../../../../../shared/theme/app_theme.dart';

class StudentCoursesScreen extends StatefulWidget {
  const StudentCoursesScreen({super.key});

  @override
  State<StudentCoursesScreen> createState() => _StudentCoursesScreenState();
}

class _StudentCoursesScreenState extends State<StudentCoursesScreen> {
  String _searchQuery = '';
  String _selectedFilter = 'All';

  @override
  void initState() {
    super.initState();
    _loadStudentClasses();
  }

  void _loadStudentClasses() {
    final authProvider = context.read<AuthProvider>();
    final classProvider = context.read<ClassProvider>();
    final studentId = authProvider.userModel?.uid;
    
    if (studentId != null) {
      classProvider.loadStudentClasses(studentId);
    }
  }

  void _showSearchDialog() {
    ScaffoldMessenger.of(context).showSnackBar(
      const SnackBar(
        content: Text('Search functionality coming soon!'),
      ),
    );
  }

  void _showScheduleView() {
    ScaffoldMessenger.of(context).showSnackBar(
      SnackBar(
        content: const Text('Schedule view coming soon!'),
        action: SnackBarAction(
          label: 'OK',
          onPressed: () {},
        ),
      ),
    );
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('My Courses'),
        actions: [
          IconButton(
            icon: const Icon(Icons.search),
            onPressed: _showSearchDialog,
            tooltip: 'Search Courses',
          ),
          IconButton(
            icon: const Icon(Icons.calendar_today),
            onPressed: _showScheduleView,
            tooltip: 'Schedule View',
          ),
        ],
      ),
      body: Consumer<ClassProvider>(
        builder: (context, classProvider, child) {
          if (classProvider.isLoading) {
            return const Center(child: CircularProgressIndicator());
          }
          
          if (classProvider.error != null) {
            return Center(
              child: Column(
                mainAxisAlignment: MainAxisAlignment.center,
                children: [
                  const Icon(Icons.error_outline, size: 48, color: Colors.red),
                  const SizedBox(height: 16),
                  Text('Error: ${classProvider.error}'),
                  const SizedBox(height: 16),
                  FilledButton(
                    onPressed: _loadStudentClasses,
                    child: const Text('Retry'),
                  ),
                ],
              ),
            );
          }
          
          final enrolledClasses = classProvider.studentClasses;
          
          if (enrolledClasses.isEmpty) {
            return Center(
              child: EmptyState(
                icon: Icons.school,
                title: 'No Classes Yet',
                message: 'You are not enrolled in any classes.',
                actionLabel: 'Join a Class',
                onAction: () => context.push('/student/enroll'),
              ),
            );
          }
          
          return Column(
            children: [
              // Header with stats
              _buildStatsHeaderFirebase(enrolledClasses),
              
              // Search and filter bar
              _buildSearchAndFilterBar(),
              
              // Courses list
              Expanded(
                child: _buildCoursesListFirebase(enrolledClasses),
              ),
            ],
          );
        },
      ),
    );
  }

  Widget _buildStatsHeaderFirebase(List<ClassModel> classes) {
    final totalClasses = classes.length;
    final activeClasses = classes.where((c) => c.isActive).length;
    
    return Container(
      margin: const EdgeInsets.all(16),
      child: Row(
        children: [
          Expanded(
            child: _buildCompactStatCard(
              title: 'Courses',
              value: '$totalClasses',
              subtitle: 'Enrolled',
              icon: Icons.school,
            ),
          ),
          const SizedBox(width: 12),
          Expanded(
            child: _buildCompactStatCard(
              title: 'Active',
              value: '$activeClasses',
              subtitle: 'This semester',
              icon: Icons.play_circle,
            ),
          ),
          const SizedBox(width: 12),
          Expanded(
            child: _buildCompactStatCard(
              title: 'Teachers',
              value: '${classes.map((c) => c.teacherId).toSet().length}',
              subtitle: 'Instructors',
              icon: Icons.person,
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildCoursesListFirebase(List<ClassModel> classes) {
    // Apply search filter
    List<ClassModel> filtered = classes;
    if (_searchQuery.isNotEmpty) {
      filtered = filtered.where((course) {
        return course.name.toLowerCase().contains(_searchQuery.toLowerCase()) ||
               course.subject.toLowerCase().contains(_searchQuery.toLowerCase());
      }).toList();
    }
    
    // Apply status filter
    if (_selectedFilter != 'All') {
      if (_selectedFilter == 'Active') {
        filtered = filtered.where((c) => c.isActive).toList();
      } else if (_selectedFilter == 'Archived') {
        filtered = filtered.where((c) => !c.isActive).toList();
      }
    }
    
    if (filtered.isEmpty) {
      return _searchQuery.isNotEmpty
          ? EmptyState.noSearchResults(searchTerm: _searchQuery)
          : const EmptyState(
              icon: Icons.school,
              title: 'No Courses',
              message: 'No courses match your filter.',
            );
    }
    
    return ListView.builder(
      padding: const EdgeInsets.symmetric(horizontal: 16),
      itemCount: filtered.length,
      itemBuilder: (context, index) {
        final course = filtered[index];
        return _buildCourseCardFirebase(course);
      },
    );
  }

  Widget _buildCourseCardFirebase(ClassModel course) {
    final theme = Theme.of(context);
    final colorIndex = course.subject.hashCode % AppTheme.subjectColors.length;
    final color = AppTheme.subjectColors[colorIndex];
    
    return AppCard(
      onTap: () => _showCourseDetailsFirebase(course),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          // Header row with course name and status
          Row(
            children: [
              Container(
                width: 4,
                height: 40,
                decoration: BoxDecoration(
                  color: color,
                  borderRadius: BorderRadius.circular(2),
                ),
              ),
              const SizedBox(width: 12),
              Expanded(
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Text(
                      course.name,
                      style: theme.textTheme.titleLarge?.copyWith(
                        fontWeight: FontWeight.bold,
                      ),
                    ),
                    Text(
                      course.subject,
                      style: theme.textTheme.bodyMedium?.copyWith(
                        color: theme.colorScheme.onSurfaceVariant,
                      ),
                    ),
                  ],
                ),
              ),
              if (!course.isActive)
                StatusBadge.custom(
                  label: 'Archived',
                  color: theme.colorScheme.onSurfaceVariant,
                ),
            ],
          ),
          
          const SizedBox(height: 16),
          
          // Course info
          Wrap(
            spacing: 8.0,
            runSpacing: 8.0,
            children: [
              if (course.room != null)
                _buildInfoChip(Icons.room, course.room!),
              if (course.schedule != null)
                _buildInfoChip(Icons.schedule, course.schedule!),
              _buildInfoChip(Icons.school, 'Grade ${course.gradeLevel}'),
              _buildInfoChip(Icons.people, '${course.studentIds.length} students'),
            ],
          ),
          
          const SizedBox(height: 12),
          
          // Academic year and semester
          Row(
            children: [
              Icon(
                Icons.calendar_month,
                size: 16,
                color: theme.colorScheme.onSurfaceVariant,
              ),
              const SizedBox(width: 4),
              Text(
                '${course.academicYear} - ${course.semester}',
                style: theme.textTheme.bodySmall?.copyWith(
                  color: theme.colorScheme.onSurfaceVariant,
                ),
              ),
            ],
          ),
        ],
      ),
    );
  }

  void _showCourseDetailsFirebase(ClassModel course) {
    showModalBottomSheet(
      context: context,
      isScrollControlled: true,
      builder: (context) => CourseDetailSheetFirebase(course: course),
    );
  }

  Widget _buildCompactStatCard({
    required String title,
    required String value,
    required String subtitle,
    required IconData icon,
    Color? valueColor,
  }) {
    return Container(
      padding: const EdgeInsets.all(12),
      decoration: BoxDecoration(
        color: Theme.of(context).colorScheme.surfaceContainerLow,
        borderRadius: BorderRadius.circular(12),
        border: Border.all(
          color: Theme.of(context).colorScheme.outline.withValues(alpha: 0.2),
        ),
      ),
      child: Column(
        mainAxisSize: MainAxisSize.min,
        children: [
          Row(
            mainAxisAlignment: MainAxisAlignment.center,
            children: [
              Icon(
                icon,
                size: 16,
                color: Theme.of(context).colorScheme.primary,
              ),
              const SizedBox(width: 4),
              Flexible(
                child: Text(
                  title,
                  style: Theme.of(context).textTheme.labelSmall?.copyWith(
                    color: Theme.of(context).colorScheme.onSurfaceVariant,
                    fontWeight: FontWeight.w500,
                  ),
                  overflow: TextOverflow.ellipsis,
                  maxLines: 1,
                ),
              ),
            ],
          ),
          const SizedBox(height: 4),
          Text(
            value,
            style: Theme.of(context).textTheme.titleMedium?.copyWith(
              fontWeight: FontWeight.bold,
              color: valueColor,
            ),
            textAlign: TextAlign.center,
          ),
          Text(
            subtitle,
            style: Theme.of(context).textTheme.labelSmall?.copyWith(
              color: Theme.of(context).colorScheme.onSurfaceVariant,
            ),
            textAlign: TextAlign.center,
            overflow: TextOverflow.ellipsis,
          ),
        ],
      ),
    );
  }

  Widget _buildSearchAndFilterBar() {
    return Padding(
      padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
      child: Row(
        children: [
          Expanded(
            child: TextField(
              decoration: const InputDecoration(
                hintText: 'Search courses...',
                prefixIcon: Icon(Icons.search),
                border: OutlineInputBorder(),
              ),
              onChanged: (value) {
                setState(() {
                  _searchQuery = value;
                });
              },
            ),
          ),
          const SizedBox(width: 12),
          DropdownButton<String>(
            value: _selectedFilter,
            items: ['All', 'Active', 'Completed', 'Dropped']
                .map((filter) => DropdownMenuItem(
                      value: filter,
                      child: Text(filter),
                    ))
                .toList(),
            onChanged: (value) {
              setState(() {
                _selectedFilter = value ?? 'All';
              });
            },
          ),
        ],
      ),
    );
  }

  Widget _buildInfoChip(IconData icon, String text) {
    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
      decoration: BoxDecoration(
        color: Theme.of(context).colorScheme.surfaceContainerHighest,
        borderRadius: BorderRadius.circular(12),
      ),
      child: Row(
        mainAxisSize: MainAxisSize.min,
        children: [
          Icon(
            icon,
            size: 14,
            color: Theme.of(context).colorScheme.onSurfaceVariant,
          ),
          const SizedBox(width: 4),
          Text(
            text,
            style: Theme.of(context).textTheme.bodySmall?.copyWith(
              color: Theme.of(context).colorScheme.onSurfaceVariant,
            ),
          ),
        ],
      ),
    );
  }
}

// Firebase course detail modal sheet
class CourseDetailSheetFirebase extends StatelessWidget {
  final ClassModel course;

  const CourseDetailSheetFirebase({super.key, required this.course});

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final colorIndex = course.subject.hashCode % AppTheme.subjectColors.length;
    final color = AppTheme.subjectColors[colorIndex];
    
    return DraggableScrollableSheet(
      initialChildSize: 0.7,
      minChildSize: 0.5,
      maxChildSize: 0.95,
      expand: false,
      builder: (context, scrollController) {
        return Container(
          decoration: BoxDecoration(
            color: theme.colorScheme.surface,
            borderRadius: const BorderRadius.vertical(top: Radius.circular(16)),
          ),
          child: Column(
            children: [
              // Handle bar
              Container(
                margin: const EdgeInsets.only(top: 8),
                width: 40,
                height: 4,
                decoration: BoxDecoration(
                  color: theme.colorScheme.onSurfaceVariant,
                  borderRadius: BorderRadius.circular(2),
                ),
              ),
              
              // Header
              Padding(
                padding: const EdgeInsets.all(16),
                child: Row(
                  children: [
                    Container(
                      width: 6,
                      height: 50,
                      decoration: BoxDecoration(
                        color: color,
                        borderRadius: BorderRadius.circular(3),
                      ),
                    ),
                    const SizedBox(width: 16),
                    Expanded(
                      child: Column(
                        crossAxisAlignment: CrossAxisAlignment.start,
                        children: [
                          Text(
                            course.name,
                            style: theme.textTheme.headlineSmall?.copyWith(
                              fontWeight: FontWeight.bold,
                            ),
                          ),
                          Text(
                            course.subject,
                            style: theme.textTheme.titleMedium?.copyWith(
                              color: theme.colorScheme.onSurfaceVariant,
                            ),
                          ),
                        ],
                      ),
                    ),
                    if (!course.isActive)
                      StatusBadge.custom(
                        label: 'Archived',
                        color: theme.colorScheme.onSurfaceVariant,
                      ),
                  ],
                ),
              ),
              
              // Content
              Expanded(
                child: ListView(
                  controller: scrollController,
                  padding: const EdgeInsets.symmetric(horizontal: 16),
                  children: [
                    _buildDetailSection(
                      context,
                      'Course Information',
                      [
                        if (course.room != null)
                          _buildDetailRow(context, 'Room', course.room!),
                        if (course.schedule != null)
                          _buildDetailRow(context, 'Schedule', course.schedule!),
                        _buildDetailRow(context, 'Grade Level', course.gradeLevel),
                        _buildDetailRow(context, 'Academic Year', course.academicYear),
                        _buildDetailRow(context, 'Semester', course.semester),
                        _buildDetailRow(context, 'Students Enrolled', '${course.studentIds.length}${course.maxStudents != null ? ' / ${course.maxStudents}' : ''}'),
                      ],
                    ),
                    
                    if (course.description != null) ...[
                      const SizedBox(height: 24),
                      _buildDetailSection(
                        context,
                        'Description',
                        [
                          Text(
                            course.description!,
                            style: theme.textTheme.bodyMedium,
                          ),
                        ],
                      ),
                    ],
                    
                    const SizedBox(height: 24),
                    
                    _buildDetailSection(
                      context,
                      'Quick Actions',
                      [
                        ListTile(
                          leading: const Icon(Icons.assignment),
                          title: const Text('View Assignments'),
                          contentPadding: EdgeInsets.zero,
                          onTap: () {
                            Navigator.pop(context);
                            // TODO: Navigate to assignments
                          },
                        ),
                        ListTile(
                          leading: const Icon(Icons.grade),
                          title: const Text('View Grades'),
                          contentPadding: EdgeInsets.zero,
                          onTap: () {
                            Navigator.pop(context);
                            // TODO: Navigate to grades
                          },
                        ),
                        ListTile(
                          leading: const Icon(Icons.chat),
                          title: const Text('Class Discussion'),
                          contentPadding: EdgeInsets.zero,
                          onTap: () {
                            Navigator.pop(context);
                            // TODO: Navigate to discussion
                          },
                        ),
                      ],
                    ),
                  ],
                ),
              ),
              
              // Actions
              Padding(
                padding: const EdgeInsets.all(16),
                child: Row(
                  children: [
                    Expanded(
                      child: OutlinedButton(
                        onPressed: () => Navigator.pop(context),
                        child: const Text('Close'),
                      ),
                    ),
                  ],
                ),
              ),
            ],
          ),
        );
      },
    );
  }

  Widget _buildDetailSection(BuildContext context, String title, List<Widget> children) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Text(
          title,
          style: Theme.of(context).textTheme.titleMedium?.copyWith(
            fontWeight: FontWeight.bold,
          ),
        ),
        const SizedBox(height: 12),
        ...children,
      ],
    );
  }

  Widget _buildDetailRow(BuildContext context, String label, String value) {
    return Padding(
      padding: const EdgeInsets.symmetric(vertical: 4),
      child: Row(
        children: [
          SizedBox(
            width: 120,
            child: Text(
              label,
              style: Theme.of(context).textTheme.bodyMedium?.copyWith(
                color: Theme.of(context).colorScheme.onSurfaceVariant,
              ),
            ),
          ),
          Expanded(
            child: Text(
              value,
              style: Theme.of(context).textTheme.bodyMedium?.copyWith(
                fontWeight: FontWeight.w500,
              ),
            ),
          ),
        ],
      ),
    );
  }
}
````

## File: lib/features/classes/presentation/screens/student/enrollment_screen.dart
````dart
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import '../../../../../features/auth/presentation/providers/auth_provider.dart';
import '../../providers/class_provider.dart';
import '../../../../../shared/theme/app_spacing.dart';
import '../../../../../shared/widgets/common/adaptive_layout.dart';

/// Screen for students to enroll in classes using enrollment codes.
/// 
/// This screen provides a simple interface where students can enter
/// a 6-character enrollment code to join a class. It includes:
/// - Input field with proper formatting and validation
/// - Real-time feedback on enrollment status
/// - Error handling for invalid or expired codes
/// - Success confirmation with navigation options
class EnrollmentScreen extends StatefulWidget {
  const EnrollmentScreen({super.key});

  @override
  State<EnrollmentScreen> createState() => _EnrollmentScreenState();
}

class _EnrollmentScreenState extends State<EnrollmentScreen> {
  final _formKey = GlobalKey<FormState>();
  final _codeController = TextEditingController();
  bool _isEnrolling = false;
  String? _errorMessage;

  @override
  void dispose() {
    _codeController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    
    return AdaptiveLayout(
      title: 'Join a Class',
      showBackButton: true,
      body: Center(
        child: ConstrainedBox(
          constraints: const BoxConstraints(maxWidth: 400),
          child: SingleChildScrollView(
            padding: const EdgeInsets.all(AppSpacing.lg),
            child: Form(
              key: _formKey,
              child: Column(
                mainAxisAlignment: MainAxisAlignment.center,
                crossAxisAlignment: CrossAxisAlignment.stretch,
                children: [
                  // Header
                  Icon(
                    Icons.class_,
                    size: 64,
                    color: theme.colorScheme.primary,
                  ),
                  const SizedBox(height: AppSpacing.lg),
                  Text(
                    'Enter Enrollment Code',
                    style: theme.textTheme.headlineMedium?.copyWith(
                      fontWeight: FontWeight.bold,
                    ),
                    textAlign: TextAlign.center,
                  ),
                  const SizedBox(height: AppSpacing.sm),
                  Text(
                    'Ask your teacher for the 6-character class enrollment code',
                    style: theme.textTheme.bodyMedium?.copyWith(
                      color: theme.colorScheme.onSurfaceVariant,
                    ),
                    textAlign: TextAlign.center,
                  ),
                  const SizedBox(height: AppSpacing.xl),
                  
                  // Code input field
                  TextFormField(
                    controller: _codeController,
                    textCapitalization: TextCapitalization.characters,
                    textAlign: TextAlign.center,
                    style: theme.textTheme.headlineMedium?.copyWith(
                      letterSpacing: 8,
                      fontWeight: FontWeight.bold,
                    ),
                    decoration: InputDecoration(
                      hintText: 'XXXXXX',
                      hintStyle: theme.textTheme.headlineMedium?.copyWith(
                        letterSpacing: 8,
                        color: theme.colorScheme.onSurfaceVariant.withValues(alpha: 0.3),
                      ),
                      errorText: _errorMessage,
                      filled: true,
                      fillColor: theme.colorScheme.surfaceContainerHighest,
                      border: OutlineInputBorder(
                        borderRadius: BorderRadius.circular(AppSpacing.md),
                        borderSide: BorderSide.none,
                      ),
                      enabledBorder: OutlineInputBorder(
                        borderRadius: BorderRadius.circular(AppSpacing.md),
                        borderSide: BorderSide(
                          color: theme.colorScheme.outline.withValues(alpha: 0.2),
                        ),
                      ),
                      focusedBorder: OutlineInputBorder(
                        borderRadius: BorderRadius.circular(AppSpacing.md),
                        borderSide: BorderSide(
                          color: theme.colorScheme.primary,
                          width: 2,
                        ),
                      ),
                      errorBorder: OutlineInputBorder(
                        borderRadius: BorderRadius.circular(AppSpacing.md),
                        borderSide: BorderSide(
                          color: theme.colorScheme.error,
                        ),
                      ),
                      contentPadding: const EdgeInsets.symmetric(
                        horizontal: AppSpacing.lg,
                        vertical: AppSpacing.xl,
                      ),
                    ),
                    validator: (value) {
                      if (value == null || value.trim().isEmpty) {
                        return 'Please enter an enrollment code';
                      }
                      if (value.trim().length != 6) {
                        return 'Code must be exactly 6 characters';
                      }
                      // Check if it contains only valid characters
                      final validCode = RegExp(r'^[A-Z0-9]+$');
                      if (!validCode.hasMatch(value.trim().toUpperCase())) {
                        return 'Code can only contain letters and numbers';
                      }
                      return null;
                    },
                    onChanged: (value) {
                      // Clear error when user starts typing
                      if (_errorMessage != null) {
                        setState(() {
                          _errorMessage = null;
                        });
                      }
                      // Auto-capitalize and limit to 6 characters
                      if (value.length > 6) {
                        _codeController.text = value.substring(0, 6);
                        _codeController.selection = TextSelection.fromPosition(
                          TextPosition(offset: _codeController.text.length),
                        );
                      }
                    },
                    maxLength: 6,
                    buildCounter: (context, {required currentLength, required isFocused, required maxLength}) {
                      return Text(
                        '$currentLength / $maxLength',
                        style: theme.textTheme.bodySmall?.copyWith(
                          color: currentLength == maxLength 
                            ? theme.colorScheme.primary
                            : theme.colorScheme.onSurfaceVariant,
                        ),
                      );
                    },
                  ),
                  const SizedBox(height: AppSpacing.xl),
                  
                  // Enroll button
                  FilledButton(
                    onPressed: _isEnrolling ? null : _handleEnrollment,
                    style: FilledButton.styleFrom(
                      padding: const EdgeInsets.symmetric(
                        vertical: AppSpacing.lg,
                      ),
                    ),
                    child: _isEnrolling
                      ? const SizedBox(
                          height: 20,
                          width: 20,
                          child: CircularProgressIndicator(
                            strokeWidth: 2,
                            color: Colors.white,
                          ),
                        )
                      : const Text(
                          'Join Class',
                          style: TextStyle(fontSize: 16),
                        ),
                  ),
                  const SizedBox(height: AppSpacing.xl),
                  
                  // Info box
                  Container(
                    padding: const EdgeInsets.all(AppSpacing.md),
                    decoration: BoxDecoration(
                      color: theme.colorScheme.primaryContainer.withValues(alpha: 0.3),
                      borderRadius: BorderRadius.circular(AppSpacing.sm),
                      border: Border.all(
                        color: theme.colorScheme.primary.withValues(alpha: 0.2),
                      ),
                    ),
                    child: Row(
                      children: [
                        Icon(
                          Icons.info_outline,
                          color: theme.colorScheme.primary,
                        ),
                        const SizedBox(width: AppSpacing.sm),
                        Expanded(
                          child: Text(
                            'Enrollment codes are case-insensitive and expire after the semester ends',
                            style: theme.textTheme.bodySmall?.copyWith(
                              color: theme.colorScheme.onSurfaceVariant,
                            ),
                          ),
                        ),
                      ],
                    ),
                  ),
                ],
              ),
            ),
          ),
        ),
      ),
    );
  }

  Future<void> _handleEnrollment() async {
    if (!_formKey.currentState!.validate()) {
      return;
    }

    setState(() {
      _isEnrolling = true;
      _errorMessage = null;
    });

    try {
      final authProvider = context.read<AuthProvider>();
      final classProvider = context.read<ClassProvider>();
      final studentId = authProvider.userModel?.uid;

      if (studentId == null) {
        throw Exception('No student ID found');
      }

      final success = await classProvider.enrollWithCode(
        studentId,
        _codeController.text.trim().toUpperCase(),
      );

      if (!mounted) return;

      if (success) {
        // Show success dialog
        showDialog(
          context: context,
          barrierDismissible: false,
          builder: (context) => AlertDialog(
            icon: const Icon(
              Icons.check_circle,
              color: Colors.green,
              size: 48,
            ),
            title: const Text('Successfully Enrolled!'),
            content: const Text(
              'You have been enrolled in the class. You can now access all class materials and assignments.',
            ),
            actions: [
              TextButton(
                onPressed: () {
                  Navigator.of(context).pop(); // Close dialog
                  Navigator.of(context).pop(); // Go back to previous screen
                },
                child: const Text('OK'),
              ),
            ],
          ),
        );
      } else {
        setState(() {
          _errorMessage = classProvider.error ?? 'Failed to enroll in class';
        });
      }
    } catch (e) {
      setState(() {
        _errorMessage = e.toString().contains('not found')
          ? 'Invalid enrollment code. Please check and try again.'
          : e.toString().contains('already enrolled')
          ? 'You are already enrolled in this class.'
          : e.toString().contains('capacity')
          ? 'This class is full and cannot accept new enrollments.'
          : 'An error occurred. Please try again.';
      });
    } finally {
      if (mounted) {
        setState(() {
          _isEnrolling = false;
        });
      }
    }
  }
}
````

## File: lib/features/classes/presentation/screens/teacher/classes_screen.dart
````dart
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:go_router/go_router.dart';
import 'package:provider/provider.dart';
import '../../../../../shared/widgets/common/common_widgets.dart';
import '../../widgets/create_class_dialog.dart';
import '../../../../../shared/theme/app_theme.dart';
import '../../../domain/models/class_model.dart';
import '../../providers/class_provider.dart';
import '../../../../../features/auth/presentation/providers/auth_provider.dart';

class ClassesScreen extends StatefulWidget {
  const ClassesScreen({super.key});

  @override
  State<ClassesScreen> createState() => _ClassesScreenState();
}

class _ClassesScreenState extends State<ClassesScreen> {
  String _searchQuery = '';
  
  @override
  void initState() {
    super.initState();
    // Load classes when the screen initializes
    WidgetsBinding.instance.addPostFrameCallback((_) {
      _loadClasses();
    });
  }
  
  Future<void> _loadClasses() async {
    final authProvider = context.read<AuthProvider>();
    final classProvider = context.read<ClassProvider>();
    
    if (authProvider.userModel != null) {
      await classProvider.loadTeacherClasses(authProvider.userModel!.uid);
    }
  }

  Color _getSubjectColor(String subject) {
    // Map subjects to consistent colors
    final subjectMap = {
      'Mathematics': AppTheme.subjectColors[0],
      'Science': AppTheme.subjectColors[1],
      'Biology': AppTheme.subjectColors[1],
      'Chemistry': AppTheme.subjectColors[1],
      'Physics': AppTheme.subjectColors[1],
      'English': AppTheme.subjectColors[2],
      'Social Studies': AppTheme.subjectColors[3],
      'History': AppTheme.subjectColors[3],
      'Computer Science': AppTheme.subjectColors[4],
      'Art': AppTheme.subjectColors[5],
      'Music': AppTheme.subjectColors[6],
      'Physical Education': AppTheme.subjectColors[7],
    };
    
    return subjectMap[subject] ?? AppTheme.subjectColors[0];
  }

  List<ClassModel> _getFilteredClasses(List<ClassModel> classes) {
    if (_searchQuery.isEmpty) return classes;
    return classes.where((classModel) {
      return classModel.name.toLowerCase().contains(_searchQuery.toLowerCase()) ||
             classModel.subject.toLowerCase().contains(_searchQuery.toLowerCase()) ||
             classModel.gradeLevel.toLowerCase().contains(_searchQuery.toLowerCase());
    }).toList();
  }

  @override
  Widget build(BuildContext context) {
    return Consumer<ClassProvider>(
      builder: (context, classProvider, _) {
        final filteredClasses = _getFilteredClasses(classProvider.teacherClasses);
        
        return Scaffold(
          appBar: AppBar(
            leading: IconButton(
              icon: const Icon(Icons.arrow_back),
              onPressed: () => context.go('/dashboard'),
              tooltip: 'Back to Dashboard',
            ),
            title: const Text('My Classes'),
            actions: [
              IconButton(
                icon: const Icon(Icons.add),
                onPressed: _showCreateClassDialog,
                tooltip: 'Add Class',
              ),
            ],
          ),
          body: Column(
            children: [
              // Header with stats
              _buildStatsHeader(classProvider),
              
              // Search bar
              _buildSearchBar(),
              
              // Classes list
              Expanded(
                child: classProvider.isLoading
                    ? const EmptyState(
                        icon: Icons.class_,
                        title: 'Loading Classes',
                        message: 'Please wait...',
                        isLoading: true,
                      )
                    : filteredClasses.isEmpty
                        ? _searchQuery.isNotEmpty
                            ? EmptyState.noSearchResults(searchTerm: _searchQuery)
                            : const EmptyState.noClasses()
                        : _buildClassesList(filteredClasses),
              ),
            ],
          ),
          floatingActionButton: FloatingActionButton(
            onPressed: _showCreateClassDialog,
            child: const Icon(Icons.add),
          ),
        );
      },
    );
  }

  Widget _buildStatsHeader(ClassProvider classProvider) {
    final classes = classProvider.teacherClasses;
    final totalStudents = classes.fold<int>(0, (sum, classModel) => sum + classModel.studentCount);
    // For now, we'll use a placeholder for average grade since we don't have grade data yet
    const avgGrade = 'B+';
    
    return Padding(
      padding: const EdgeInsets.all(16),
      child: Row(
        children: [
          Expanded(
            child: StatCard(
              title: 'Classes',
              value: '${classes.length}',
              icon: Icons.class_,
              subtitle: 'Active',
            ),
          ),
          const SizedBox(width: 12),
          Expanded(
            child: StatCard(
              title: 'Students',
              value: '$totalStudents',
              icon: Icons.people,
              subtitle: 'Total',
            ),
          ),
          const SizedBox(width: 12),
          Expanded(
            child: StatCard(
              title: 'Avg Grade',
              value: avgGrade,
              icon: Icons.grade,
              valueColor: AppTheme.getGradeColor(avgGrade),
              subtitle: 'Overall',
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildSearchBar() {
    return Padding(
      padding: const EdgeInsets.fromLTRB(16, 0, 16, 8),
      child: TextField(
        decoration: InputDecoration(
          hintText: 'Search classes...',
          hintStyle: Theme.of(context).textTheme.bodyMedium,
          prefixIcon: const Icon(Icons.search, size: 20),
          filled: true,
          fillColor: Theme.of(context).colorScheme.surfaceContainerHighest,
          border: OutlineInputBorder(
            borderRadius: BorderRadius.circular(12),
            borderSide: BorderSide.none,
          ),
          enabledBorder: OutlineInputBorder(
            borderRadius: BorderRadius.circular(12),
            borderSide: BorderSide.none,
          ),
          focusedBorder: OutlineInputBorder(
            borderRadius: BorderRadius.circular(12),
            borderSide: BorderSide(
              color: Theme.of(context).colorScheme.primary,
              width: 1,
            ),
          ),
          contentPadding: const EdgeInsets.symmetric(horizontal: 16, vertical: 12),
        ),
        style: Theme.of(context).textTheme.bodyMedium,
        onChanged: (value) {
          setState(() {
            _searchQuery = value;
          });
        },
      ),
    );
  }

  Widget _buildClassesList(List<ClassModel> classes) {
    return ListView.builder(
      padding: const EdgeInsets.symmetric(horizontal: 16),
      itemCount: classes.length,
      itemBuilder: (context, index) {
        final classModel = classes[index];
        return _buildClassCard(classModel);
      },
    );
  }

  Widget _buildClassCard(ClassModel classModel) {
    return AppCard(
      onTap: () => _navigateToClassDetail(classModel),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          // Header row with class name and grade
          Row(
            children: [
              Container(
                width: 4,
                height: 40,
                decoration: BoxDecoration(
                  color: _getSubjectColor(classModel.subject),
                  borderRadius: BorderRadius.circular(2),
                ),
              ),
              const SizedBox(width: 12),
              Expanded(
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Text(
                      classModel.name,
                      style: Theme.of(context).textTheme.titleLarge?.copyWith(
                        fontWeight: FontWeight.bold,
                      ),
                    ),
                    Text(
                      '${classModel.subject} • ${classModel.gradeLevel}',
                      style: Theme.of(context).textTheme.bodyMedium?.copyWith(
                        color: Theme.of(context).colorScheme.onSurfaceVariant,
                      ),
                    ),
                  ],
                ),
              ),
              // Enrollment code badge
              Container(
                padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
                decoration: BoxDecoration(
                  color: Theme.of(context).colorScheme.primaryContainer,
                  borderRadius: BorderRadius.circular(12),
                ),
                child: Row(
                  mainAxisSize: MainAxisSize.min,
                  children: [
                    Icon(
                      Icons.qr_code,
                      size: 16,
                      color: Theme.of(context).colorScheme.onPrimaryContainer,
                    ),
                    const SizedBox(width: 4),
                    Text(
                      classModel.enrollmentCode ?? 'No Code',
                      style: Theme.of(context).textTheme.bodySmall?.copyWith(
                        color: Theme.of(context).colorScheme.onPrimaryContainer,
                        fontWeight: FontWeight.bold,
                      ),
                    ),
                  ],
                ),
              ),
            ],
          ),
          
          const SizedBox(height: 16),
          
          // Info row
          Wrap(
            spacing: 8,
            runSpacing: 8,
            children: [
              _buildInfoChip(Icons.people, '${classModel.studentCount} students'),
              if (classModel.room != null) _buildInfoChip(Icons.room, classModel.room!),
              if (classModel.schedule != null) _buildInfoChip(Icons.schedule, classModel.schedule!),
            ],
          ),
          
          const SizedBox(height: 12),
          
          // Action buttons row
          Row(
            mainAxisAlignment: MainAxisAlignment.end,
            children: [
              TextButton.icon(
                onPressed: () => _copyEnrollmentCode(classModel.enrollmentCode ?? ''),
                icon: const Icon(Icons.copy, size: 16),
                label: const Text('Copy Code'),
                style: TextButton.styleFrom(
                  foregroundColor: Theme.of(context).colorScheme.primary,
                ),
              ),
              const SizedBox(width: 8),
              FilledButton.tonal(
                onPressed: () => _navigateToClassDetail(classModel),
                child: const Text('View Details'),
              ),
            ],
          ),
        ],
      ),
    );
  }

  Widget _buildInfoChip(IconData icon, String text) {
    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
      decoration: BoxDecoration(
        color: Theme.of(context).colorScheme.surfaceContainerHighest,
        borderRadius: BorderRadius.circular(12),
      ),
      child: Row(
        mainAxisSize: MainAxisSize.min,
        children: [
          Icon(
            icon,
            size: 14,
            color: Theme.of(context).colorScheme.onSurfaceVariant,
          ),
          const SizedBox(width: 4),
          Text(
            text,
            style: Theme.of(context).textTheme.bodySmall?.copyWith(
              color: Theme.of(context).colorScheme.onSurfaceVariant,
            ),
          ),
        ],
      ),
    );
  }

  void _copyEnrollmentCode(String code) {
    if (code.isEmpty) return;
    
    Clipboard.setData(ClipboardData(text: code));
    ScaffoldMessenger.of(context).showSnackBar(
      SnackBar(
        content: Text('Enrollment code $code copied to clipboard'),
        duration: const Duration(seconds: 2),
      ),
    );
  }

  void _navigateToClassDetail(ClassModel classModel) {
    // TODO: Navigate to class detail screen
    // For now, we'll show a snackbar
    ScaffoldMessenger.of(context).showSnackBar(
      SnackBar(
        content: Text('Opening ${classModel.name}...'),
        action: SnackBarAction(
          label: 'OK',
          onPressed: () {},
        ),
      ),
    );
  }

  void _showCreateClassDialog() {
    showDialog(
      context: context,
      builder: (context) => const CreateClassDialog(),
    ).then((result) {
      if (result == true) {
        // Class was created successfully, reload data
        _loadClasses();
      }
    });
  }
}
````

## File: lib/features/discussions/data/repositories/discussion_repository_impl.dart
````dart
/// Concrete implementation of the discussion repository.
/// 
/// This module implements the DiscussionRepository interface using
/// Firebase Firestore as the data source. It provides full forum
/// functionality with threaded discussions and real-time updates.
library;

import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:firebase_auth/firebase_auth.dart';
import '../../domain/models/discussion_board.dart';
import '../../../../shared/services/logger_service.dart';
import '../../../../shared/services/firestore_service.dart';
import '../../domain/repositories/discussion_repository.dart';
import '../../../../shared/repositories/firestore_repository.dart';

/// Firestore-based implementation of DiscussionRepository.
/// 
/// This class extends FirestoreRepository to leverage common
/// CRUD operations while implementing forum-specific features:
/// - Hierarchical data structure (boards -> threads -> replies)
/// - Like/unlike functionality with user tracking
/// - Pin and lock features for moderation
/// - Real-time streaming of discussions
/// - Full-text search across threads
/// - Automatic metadata management
/// 
/// Uses Firebase Auth for user identification and role detection.
class DiscussionRepositoryImpl extends FirestoreRepository<DiscussionBoard> 
    implements DiscussionRepository {
  /// Logger tag for this repository.
  static const String _tag = 'DiscussionRepository';
  
  /// Firestore instance for direct database operations.
  final FirebaseFirestore _firestore;
  
  /// Firebase Auth for user identification.
  final FirebaseAuth _auth;

  /// Creates a discussion repository with Firestore backend.
  /// 
  /// Initializes the parent FirestoreRepository with board-specific
  /// configuration and sets up authentication integration.
  /// 
  /// @param _firestore Firestore database instance
  /// @param _auth Firebase Auth instance
  DiscussionRepositoryImpl(this._firestore, this._auth)
      : super(
          firestore: _firestore,
          collectionPath: 'discussion_boards',
          fromFirestore: (doc) => DiscussionBoard.fromFirestore(doc),
          toFirestore: (board) => board.toFirestore(),
          logTag: _tag,
        );

  /// Gets the current user's ID from Firebase Auth.
  String get _currentUserId => _auth.currentUser?.uid ?? '';
  
  /// Gets the current user's display name.
  String get _currentUserName => _auth.currentUser?.displayName ?? 'User';
  
  /// Determines user role based on email domain.
  /// 
  /// Simple role detection: teachers have @teacher.edu emails,
  /// all others are considered students. This is a placeholder
  /// implementation that should be replaced with proper role lookup.
  String get _currentUserRole => 
      _auth.currentUser?.email?.endsWith('@teacher.edu') == true 
          ? 'teacher' 
          : 'student';

  /// Creates a new discussion board with automatic metadata.
  /// 
  /// Sets creation timestamp, creator information, and ensures
  /// the creator is included in participants. Board ID is
  /// generated by Firestore.
  /// 
  /// @param board Board configuration with title and settings
  /// @return Generated unique board ID
  /// @throws Exception if board creation fails
  @override
  Future<String> createBoard(DiscussionBoard board) async {
    try {
      final boardToCreate = board.copyWith(
        createdAt: DateTime.now(),
        updatedAt: DateTime.now(),
        createdBy: _currentUserId,
        createdByName: _currentUserName,
        participantIds: board.participantIds.isEmpty 
            ? [_currentUserId] 
            : board.participantIds,
      );
      
      final boardId = await create(boardToCreate);
      LoggerService.info('Created discussion board: $boardId', tag: _tag);
      return boardId;
    } catch (e) {
      LoggerService.error('Failed to create discussion board', tag: _tag, error: e);
      rethrow;
    }
  }

  /// Retrieves a discussion board by ID.
  /// 
  /// Delegates to parent repository for consistent error handling.
  /// 
  /// @param boardId Unique board identifier
  /// @return Board instance or null if not found
  @override
  Future<DiscussionBoard?> getBoard(String boardId) => read(boardId);

  /// Retrieves all discussion boards sorted by priority.
  /// 
  /// Orders boards with pinned items first, then by most
  /// recently updated. This ensures important and active
  /// discussions are prominently displayed.
  /// 
  /// @return List of discussion boards
  /// @throws Exception if retrieval fails
  @override
  Future<List<DiscussionBoard>> getBoards() async {
    try {
      return await list(
        orderBy: [
          OrderBy(field: 'isPinned', descending: true),
          OrderBy(field: 'updatedAt', descending: true),
        ],
      );
    } catch (e) {
      LoggerService.error('Failed to get boards', tag: _tag, error: e);
      rethrow;
    }
  }

  /// Updates board information with automatic timestamp.
  /// 
  /// Modifies board details while preserving immutable fields
  /// like creator and creation date. Updates modification time.
  /// 
  /// @param boardId Board to update
  /// @param board Updated board information
  /// @throws Exception if update fails
  @override
  Future<void> updateBoard(String boardId, DiscussionBoard board) async {
    try {
      final boardToUpdate = board.copyWith(
        updatedAt: DateTime.now(),
      );
      await update(boardId, boardToUpdate);
    } catch (e) {
      LoggerService.error('Failed to update board', tag: _tag, error: e);
      rethrow;
    }
  }

  /// Pins or unpins a discussion board.
  /// 
  /// Pinned boards appear at the top of board lists.
  /// Uses server timestamp for consistency across clients.
  /// 
  /// @param boardId Board to pin/unpin
  /// @param isPinned Whether to pin the board
  /// @throws Exception if operation fails
  @override
  Future<void> pinBoard(String boardId, bool isPinned) async {
    try {
      await _firestore
          .collection('discussion_boards')
          .doc(boardId)
          .update({
            'isPinned': isPinned,
            'updatedAt': FieldValue.serverTimestamp(),
          });
    } catch (e) {
      LoggerService.error('Failed to pin/unpin board', tag: _tag, error: e);
      rethrow;
    }
  }

  /// Creates a new discussion thread in a board.
  /// 
  /// Automatically sets author information from current user,
  /// timestamps, and increments the board's thread count.
  /// Thread is stored as a subcollection under the board.
  /// 
  /// @param boardId Target board for the thread
  /// @param thread Thread content and configuration
  /// @return Generated unique thread ID
  /// @throws Exception if thread creation fails
  @override
  Future<String> createThread(String boardId, DiscussionThread thread) async {
    try {
      final threadToCreate = thread.copyWith(
        boardId: boardId,
        authorId: _currentUserId,
        authorName: _currentUserName,
        authorRole: _currentUserRole,
        createdAt: DateTime.now(),
        updatedAt: DateTime.now(),
      );

      final ref = _firestore
          .collection('discussion_boards')
          .doc(boardId)
          .collection('threads')
          .doc();
      
      await ref.set(threadToCreate.toFirestore());
      
      // Update thread count
      await _firestore
          .collection('discussion_boards')
          .doc(boardId)
          .update({
            'threadCount': FieldValue.increment(1),
            'updatedAt': FieldValue.serverTimestamp(),
          });
      
      LoggerService.info('Created thread in board $boardId', tag: _tag);
      return ref.id;
    } catch (e) {
      LoggerService.error('Failed to create thread', tag: _tag, error: e);
      rethrow;
    }
  }

  /// Retrieves a specific discussion thread.
  /// 
  /// Fetches thread from the board's subcollection.
  /// Returns null if thread doesn't exist or on error.
  /// 
  /// @param boardId Board containing the thread
  /// @param threadId Unique thread identifier
  /// @return Thread instance or null
  @override
  Future<DiscussionThread?> getThread(String boardId, String threadId) async {
    try {
      final doc = await _firestore
          .collection('discussion_boards')
          .doc(boardId)
          .collection('threads')
          .doc(threadId)
          .get();
      
      if (doc.exists) {
        return DiscussionThread.fromFirestore(doc);
      }
      return null;
    } catch (e) {
      LoggerService.error('Failed to get thread', tag: _tag, error: e);
      return null;
    }
  }

  /// Retrieves all threads in a discussion board.
  /// 
  /// Orders threads with pinned items first, then by
  /// most recent activity. This ensures important and
  /// active discussions are prominently displayed.
  /// 
  /// @param boardId Board to get threads from
  /// @return List of discussion threads
  @override
  Future<List<DiscussionThread>> getBoardThreads(String boardId) async {
    try {
      final snapshot = await _firestore
          .collection('discussion_boards')
          .doc(boardId)
          .collection('threads')
          .orderBy('isPinned', descending: true)
          .orderBy('updatedAt', descending: true)
          .get();
      
      return snapshot.docs
          .map((doc) => DiscussionThread.fromFirestore(doc))
          .toList();
    } catch (e) {
      LoggerService.error('Failed to get board threads', tag: _tag, error: e);
      return [];
    }
  }

  @override
  Future<void> updateThread(String boardId, String threadId, DiscussionThread thread) async {
    try {
      await _firestore
          .collection('discussion_boards')
          .doc(boardId)
          .collection('threads')
          .doc(threadId)
          .update({
            ...thread.toFirestore(),
            'updatedAt': FieldValue.serverTimestamp(),
          });
    } catch (e) {
      LoggerService.error('Failed to update thread', tag: _tag, error: e);
      rethrow;
    }
  }

  /// Deletes a thread and all associated replies.
  /// 
  /// Uses batch operations to ensure atomic deletion:
  /// 1. Deletes all replies in the thread
  /// 2. Deletes the thread document
  /// 3. Updates board's thread count
  /// 
  /// This ensures data consistency even if partial failure occurs.
  /// 
  /// @param boardId Board containing the thread
  /// @param threadId Thread to delete
  /// @throws Exception if deletion fails
  @override
  Future<void> deleteThread(String boardId, String threadId) async {
    try {
      // Delete all replies first
      final repliesSnapshot = await _firestore
          .collection('discussion_boards')
          .doc(boardId)
          .collection('threads')
          .doc(threadId)
          .collection('replies')
          .get();
      
      final batch = _firestore.batch();
      for (final doc in repliesSnapshot.docs) {
        batch.delete(doc.reference);
      }
      
      // Delete the thread
      batch.delete(_firestore
          .collection('discussion_boards')
          .doc(boardId)
          .collection('threads')
          .doc(threadId));
      
      await batch.commit();
      
      // Update thread count
      await _firestore
          .collection('discussion_boards')
          .doc(boardId)
          .update({
            'threadCount': FieldValue.increment(-1),
            'updatedAt': FieldValue.serverTimestamp(),
          });
      
      LoggerService.info('Deleted thread $threadId from board $boardId', tag: _tag);
    } catch (e) {
      LoggerService.error('Failed to delete thread', tag: _tag, error: e);
      rethrow;
    }
  }

  /// Adds a like to a discussion thread.
  /// 
  /// Uses arrayUnion to prevent duplicate likes from the
  /// same user. Increments the like count for display.
  /// 
  /// @param boardId Board containing the thread
  /// @param threadId Thread to like
  /// @param userId User performing the like
  /// @throws Exception if like operation fails
  @override
  Future<void> likeThread(String boardId, String threadId, String userId) async {
    try {
      await _firestore
          .collection('discussion_boards')
          .doc(boardId)
          .collection('threads')
          .doc(threadId)
          .update({
            'likedBy': FieldValue.arrayUnion([userId]),
            'likeCount': FieldValue.increment(1),
          });
    } catch (e) {
      LoggerService.error('Failed to like thread', tag: _tag, error: e);
      rethrow;
    }
  }

  /// Removes a like from a discussion thread.
  /// 
  /// Uses arrayRemove to remove the user's like and
  /// decrements the like count accordingly.
  /// 
  /// @param boardId Board containing the thread
  /// @param threadId Thread to unlike
  /// @param userId User removing the like
  /// @throws Exception if unlike operation fails
  @override
  Future<void> unlikeThread(String boardId, String threadId, String userId) async {
    try {
      await _firestore
          .collection('discussion_boards')
          .doc(boardId)
          .collection('threads')
          .doc(threadId)
          .update({
            'likedBy': FieldValue.arrayRemove([userId]),
            'likeCount': FieldValue.increment(-1),
          });
    } catch (e) {
      LoggerService.error('Failed to unlike thread', tag: _tag, error: e);
      rethrow;
    }
  }

  /// Pins or unpins a thread within a board.
  /// 
  /// Pinned threads appear at the top of thread lists.
  /// Typically restricted to moderators or thread authors.
  /// 
  /// @param boardId Board containing the thread
  /// @param threadId Thread to pin/unpin
  /// @param isPinned Whether to pin the thread
  /// @throws Exception if operation fails
  @override
  Future<void> pinThread(String boardId, String threadId, bool isPinned) async {
    try {
      await _firestore
          .collection('discussion_boards')
          .doc(boardId)
          .collection('threads')
          .doc(threadId)
          .update({
            'isPinned': isPinned,
            'updatedAt': FieldValue.serverTimestamp(),
          });
    } catch (e) {
      LoggerService.error('Failed to pin/unpin thread', tag: _tag, error: e);
      rethrow;
    }
  }

  /// Locks or unlocks a thread for replies.
  /// 
  /// Locked threads prevent new replies but remain visible.
  /// Used for closing resolved discussions or preventing
  /// further debate on sensitive topics.
  /// 
  /// @param boardId Board containing the thread
  /// @param threadId Thread to lock/unlock
  /// @param isLocked Whether to lock the thread
  /// @throws Exception if operation fails
  @override
  Future<void> lockThread(String boardId, String threadId, bool isLocked) async {
    try {
      await _firestore
          .collection('discussion_boards')
          .doc(boardId)
          .collection('threads')
          .doc(threadId)
          .update({
            'isLocked': isLocked,
            'updatedAt': FieldValue.serverTimestamp(),
          });
    } catch (e) {
      LoggerService.error('Failed to lock/unlock thread', tag: _tag, error: e);
      rethrow;
    }
  }

  /// Creates a reply to a discussion thread.
  /// 
  /// Automatically sets author information and timestamps.
  /// Updates both thread and board metadata to reflect new
  /// activity. Reply is stored as a subcollection under thread.
  /// 
  /// Updates cascade:
  /// 1. Creates reply document
  /// 2. Increments thread reply count
  /// 3. Updates thread activity timestamp
  /// 4. Updates board activity timestamp
  /// 
  /// @param boardId Board containing the thread
  /// @param threadId Thread to reply to
  /// @param reply Reply content and metadata
  /// @return Generated unique reply ID
  /// @throws Exception if reply creation fails
  @override
  Future<String> createReply(String boardId, String threadId, ThreadReply reply) async {
    try {
      final replyToCreate = reply.copyWith(
        threadId: threadId,
        authorId: _currentUserId,
        authorName: _currentUserName,
        authorRole: _currentUserRole,
        createdAt: DateTime.now(),
      );

      final ref = _firestore
          .collection('discussion_boards')
          .doc(boardId)
          .collection('threads')
          .doc(threadId)
          .collection('replies')
          .doc();
      
      await ref.set(replyToCreate.toFirestore());
      
      // Update reply count and thread updated time
      await _firestore
          .collection('discussion_boards')
          .doc(boardId)
          .collection('threads')
          .doc(threadId)
          .update({
            'replyCount': FieldValue.increment(1),
            'updatedAt': FieldValue.serverTimestamp(),
          });
      
      // Update board updated time
      await _firestore
          .collection('discussion_boards')
          .doc(boardId)
          .update({
            'updatedAt': FieldValue.serverTimestamp(),
          });
      
      LoggerService.info('Created reply in thread $threadId', tag: _tag);
      return ref.id;
    } catch (e) {
      LoggerService.error('Failed to create reply', tag: _tag, error: e);
      rethrow;
    }
  }

  /// Retrieves all replies for a thread.
  /// 
  /// Fetches replies in chronological order to maintain
  /// conversation flow. Returns empty list on error.
  /// 
  /// @param boardId Board containing the thread
  /// @param threadId Thread to get replies for
  /// @return List of thread replies in order
  @override
  Future<List<ThreadReply>> getThreadReplies(String boardId, String threadId) async {
    try {
      final snapshot = await _firestore
          .collection('discussion_boards')
          .doc(boardId)
          .collection('threads')
          .doc(threadId)
          .collection('replies')
          .orderBy('createdAt')
          .get();
      
      return snapshot.docs
          .map((doc) => ThreadReply.fromFirestore(doc))
          .toList();
    } catch (e) {
      LoggerService.error('Failed to get thread replies', tag: _tag, error: e);
      return [];
    }
  }

  /// Updates reply content with edit tracking.
  /// 
  /// Only updates the content field and marks the reply
  /// as edited with timestamp. Preserves original author
  /// and creation information.
  /// 
  /// @param boardId Board containing the thread
  /// @param threadId Thread containing the reply
  /// @param replyId Reply to update
  /// @param reply Updated reply with new content
  /// @throws Exception if update fails
  @override
  Future<void> updateReply(String boardId, String threadId, String replyId, ThreadReply reply) async {
    try {
      await _firestore
          .collection('discussion_boards')
          .doc(boardId)
          .collection('threads')
          .doc(threadId)
          .collection('replies')
          .doc(replyId)
          .update({
            'content': reply.content,
            'isEdited': true,
            'editedAt': FieldValue.serverTimestamp(),
          });
    } catch (e) {
      LoggerService.error('Failed to update reply', tag: _tag, error: e);
      rethrow;
    }
  }

  /// Deletes a reply from a thread.
  /// 
  /// Permanently removes the reply and decrements the
  /// thread's reply count. Updates thread timestamp to
  /// reflect the change.
  /// 
  /// @param boardId Board containing the thread
  /// @param threadId Thread containing the reply
  /// @param replyId Reply to delete
  /// @throws Exception if deletion fails
  @override
  Future<void> deleteReply(String boardId, String threadId, String replyId) async {
    try {
      await _firestore
          .collection('discussion_boards')
          .doc(boardId)
          .collection('threads')
          .doc(threadId)
          .collection('replies')
          .doc(replyId)
          .delete();
      
      // Update reply count
      await _firestore
          .collection('discussion_boards')
          .doc(boardId)
          .collection('threads')
          .doc(threadId)
          .update({
            'replyCount': FieldValue.increment(-1),
            'updatedAt': FieldValue.serverTimestamp(),
          });
      
      LoggerService.info('Deleted reply $replyId from thread $threadId', tag: _tag);
    } catch (e) {
      LoggerService.error('Failed to delete reply', tag: _tag, error: e);
      rethrow;
    }
  }

  /// Adds a like to a reply.
  /// 
  /// Uses arrayUnion to prevent duplicate likes from the
  /// same user. Increments the like count for display.
  /// 
  /// @param boardId Board containing the thread
  /// @param threadId Thread containing the reply
  /// @param replyId Reply to like
  /// @param userId User performing the like
  /// @throws Exception if like operation fails
  @override
  Future<void> likeReply(String boardId, String threadId, String replyId, String userId) async {
    try {
      await _firestore
          .collection('discussion_boards')
          .doc(boardId)
          .collection('threads')
          .doc(threadId)
          .collection('replies')
          .doc(replyId)
          .update({
            'likedBy': FieldValue.arrayUnion([userId]),
            'likeCount': FieldValue.increment(1),
          });
    } catch (e) {
      LoggerService.error('Failed to like reply', tag: _tag, error: e);
      rethrow;
    }
  }

  /// Removes a like from a reply.
  /// 
  /// Uses arrayRemove to remove the user's like and
  /// decrements the like count accordingly.
  /// 
  /// @param boardId Board containing the thread
  /// @param threadId Thread containing the reply
  /// @param replyId Reply to unlike
  /// @param userId User removing the like
  /// @throws Exception if unlike operation fails
  @override
  Future<void> unlikeReply(String boardId, String threadId, String replyId, String userId) async {
    try {
      await _firestore
          .collection('discussion_boards')
          .doc(boardId)
          .collection('threads')
          .doc(threadId)
          .collection('replies')
          .doc(replyId)
          .update({
            'likedBy': FieldValue.arrayRemove([userId]),
            'likeCount': FieldValue.increment(-1),
          });
    } catch (e) {
      LoggerService.error('Failed to unlike reply', tag: _tag, error: e);
      rethrow;
    }
  }

  /// Streams all discussion boards in real-time.
  /// 
  /// Returns live updates ordered by pin status and activity.
  /// Leverages parent repository's stream method with
  /// appropriate ordering.
  /// 
  /// @return Stream of discussion board lists
  @override
  Stream<List<DiscussionBoard>> streamBoards() {
    return stream(
      orderBy: [
        OrderBy(field: 'isPinned', descending: true),
        OrderBy(field: 'updatedAt', descending: true),
      ],
    );
  }

  /// Streams threads for a specific board in real-time.
  /// 
  /// Returns live updates of threads with pinned items
  /// first, then by most recent activity. Automatically
  /// updates when threads are added, modified, or deleted.
  /// 
  /// @param boardId Board to monitor
  /// @return Stream of thread lists
  @override
  Stream<List<DiscussionThread>> streamBoardThreads(String boardId) {
    return _firestore
        .collection('discussion_boards')
        .doc(boardId)
        .collection('threads')
        .orderBy('isPinned', descending: true)
        .orderBy('updatedAt', descending: true)
        .snapshots()
        .map((snapshot) => snapshot.docs
            .map((doc) => DiscussionThread.fromFirestore(doc))
            .toList());
  }

  /// Streams replies for a specific thread in real-time.
  /// 
  /// Returns live updates of replies in chronological order.
  /// Automatically updates when replies are added, edited,
  /// or deleted.
  /// 
  /// @param boardId Board containing the thread
  /// @param threadId Thread to monitor
  /// @return Stream of reply lists
  @override
  Stream<List<ThreadReply>> streamThreadReplies(String boardId, String threadId) {
    return _firestore
        .collection('discussion_boards')
        .doc(boardId)
        .collection('threads')
        .doc(threadId)
        .collection('replies')
        .orderBy('createdAt')
        .snapshots()
        .map((snapshot) => snapshot.docs
            .map((doc) => ThreadReply.fromFirestore(doc))
            .toList());
  }

  /// Searches for threads across all boards.
  /// 
  /// Performs client-side text search on thread titles
  /// and content. This is a basic implementation that
  /// loads all threads into memory.
  /// 
  /// Note: For production use with large datasets,
  /// consider implementing server-side search with
  /// Firestore composite indexes or external search
  /// services like Algolia or Elasticsearch.
  /// 
  /// @param query Search terms (case-insensitive)
  /// @return List of matching threads
  @override
  Future<List<DiscussionThread>> searchThreads(String query) async {
    try {
      // This is a simple implementation. For better search,
      // consider using a search service like Algolia
      final boards = await getBoards();
      final allThreads = <DiscussionThread>[];
      
      for (final board in boards) {
        final threads = await getBoardThreads(board.id);
        allThreads.addAll(threads);
      }
      
      final lowercaseQuery = query.toLowerCase();
      return allThreads.where((thread) =>
          thread.title.toLowerCase().contains(lowercaseQuery) ||
          thread.content.toLowerCase().contains(lowercaseQuery)
      ).toList();
    } catch (e) {
      LoggerService.error('Failed to search threads', tag: _tag, error: e);
      return [];
    }
  }

  /// Searches for threads within a specific board.
  /// 
  /// Performs client-side text search limited to a single
  /// board. More efficient than global search when scope
  /// is known.
  /// 
  /// @param boardId Board to search within
  /// @param query Search terms (case-insensitive)
  /// @return List of matching threads from the board
  @override
  Future<List<DiscussionThread>> searchBoardThreads(String boardId, String query) async {
    try {
      final threads = await getBoardThreads(boardId);
      final lowercaseQuery = query.toLowerCase();
      
      return threads.where((thread) =>
          thread.title.toLowerCase().contains(lowercaseQuery) ||
          thread.content.toLowerCase().contains(lowercaseQuery)
      ).toList();
    } catch (e) {
      LoggerService.error('Failed to search board threads', tag: _tag, error: e);
      return [];
    }
  }
}
````

## File: lib/features/discussions/domain/models/discussion_board.dart
````dart
/// Discussion board models for educational forum functionality.
/// 
/// This module contains data models for discussion boards, threads,
/// and replies, enabling structured academic discussions within the
/// education platform.
library;

import 'package:cloud_firestore/cloud_firestore.dart';

/// Core discussion board model representing a forum category.
/// 
/// Discussion boards serve as top-level containers for organizing
/// academic discussions by topic, class, or subject area. Features:
/// - Class-specific or general discussion areas
/// - Thread counting for activity tracking
/// - Pinning capability for important boards
/// - Tag support for content categorization
/// - Participant tracking for access control
class DiscussionBoard {
  /// Unique identifier for the discussion board
  final String id;
  
  /// Board title displayed in listings
  final String title;
  
  /// Detailed description of board purpose and guidelines
  final String description;
  
  /// User ID of the board creator
  final String createdBy;
  
  /// Cached name of the board creator for display
  final String createdByName;
  
  /// Optional class ID for class-specific boards
  final String? classId;
  
  /// List of user IDs allowed to participate
  final List<String> participantIds;
  
  /// Timestamp when the board was created
  final DateTime createdAt;
  
  /// Timestamp of last activity or modification
  final DateTime updatedAt;
  
  /// Number of threads in this board
  final int threadCount;
  
  /// Whether this board is pinned to top of listings
  final bool isPinned;
  
  /// Tags for categorizing board content
  final List<String> tags;

  DiscussionBoard({
    required this.id,
    required this.title,
    required this.description,
    required this.createdBy,
    required this.createdByName,
    this.classId,
    required this.participantIds,
    required this.createdAt,
    required this.updatedAt,
    this.threadCount = 0,
    this.isPinned = false,
    this.tags = const [],
  });

  /// Factory constructor to create DiscussionBoard from Firestore document.
  /// 
  /// Handles data parsing with safe defaults including:
  /// - Timestamp conversions for date fields
  /// - List casting for participant IDs and tags
  /// - Default values for counts and flags
  /// - Null safety for optional fields
  /// 
  /// @param doc Firestore document snapshot containing board data
  /// @return Parsed DiscussionBoard instance
  factory DiscussionBoard.fromFirestore(DocumentSnapshot doc) {
    final data = doc.data() as Map<String, dynamic>;
    return DiscussionBoard(
      id: doc.id,
      title: data['title'] ?? '',
      description: data['description'] ?? '',
      createdBy: data['createdBy'] ?? '',
      createdByName: data['createdByName'] ?? '',
      classId: data['classId'],
      participantIds: List<String>.from(data['participantIds'] ?? []),
      createdAt: (data['createdAt'] as Timestamp).toDate(),
      updatedAt: (data['updatedAt'] as Timestamp).toDate(),
      threadCount: data['threadCount'] ?? 0,
      isPinned: data['isPinned'] ?? false,
      tags: List<String>.from(data['tags'] ?? []),
    );
  }

  /// Converts the DiscussionBoard instance to a Map for Firestore storage.
  /// 
  /// Serializes all board data including:
  /// - DateTime fields to Firestore Timestamps
  /// - Direct storage of lists and primitive types
  /// - Preservation of null values for optional fields
  /// 
  /// @return Map containing all board data for Firestore
  Map<String, dynamic> toFirestore() {
    return {
      'title': title,
      'description': description,
      'createdBy': createdBy,
      'createdByName': createdByName,
      'classId': classId,
      'participantIds': participantIds,
      'createdAt': Timestamp.fromDate(createdAt),
      'updatedAt': Timestamp.fromDate(updatedAt),
      'threadCount': threadCount,
      'isPinned': isPinned,
      'tags': tags,
    };
  }

  /// Creates a copy of the DiscussionBoard with updated fields.
  /// 
  /// Follows immutable data pattern for state management.
  /// Useful for:
  /// - Updating board metadata
  /// - Managing participant lists
  /// - Toggling pin status
  /// - Updating thread counts
  /// 
  /// All parameters are optional - only provided fields will be updated.
  /// 
  /// @return New DiscussionBoard instance with updated fields
  DiscussionBoard copyWith({
    String? id,
    String? title,
    String? description,
    String? createdBy,
    String? createdByName,
    String? classId,
    List<String>? participantIds,
    DateTime? createdAt,
    DateTime? updatedAt,
    int? threadCount,
    bool? isPinned,
    List<String>? tags,
  }) {
    return DiscussionBoard(
      id: id ?? this.id,
      title: title ?? this.title,
      description: description ?? this.description,
      createdBy: createdBy ?? this.createdBy,
      createdByName: createdByName ?? this.createdByName,
      classId: classId ?? this.classId,
      participantIds: participantIds ?? this.participantIds,
      createdAt: createdAt ?? this.createdAt,
      updatedAt: updatedAt ?? this.updatedAt,
      threadCount: threadCount ?? this.threadCount,
      isPinned: isPinned ?? this.isPinned,
      tags: tags ?? this.tags,
    );
  }
}

/// Discussion thread model representing individual topics within boards.
/// 
/// Threads are the primary discussion units where users post topics
/// and engage in conversations. Features include:
/// - Author tracking with role information
/// - Reply and engagement counters
/// - Like/reaction support
/// - Thread locking for moderation
/// - Pinning for important discussions
/// - Tag support for categorization
class DiscussionThread {
  /// Unique identifier for the thread
  final String id;
  
  /// ID of the parent discussion board
  final String boardId;
  
  /// Thread title/subject
  final String title;
  
  /// Main content/body of the thread post
  final String content;
  
  /// User ID of the thread author
  final String authorId;
  
  /// Cached name of the thread author
  final String authorName;
  
  /// Role of the author (teacher/student)
  final String authorRole;
  
  /// Timestamp when the thread was created
  final DateTime createdAt;
  
  /// Timestamp of last activity (new reply or edit)
  final DateTime updatedAt;
  
  /// Number of replies to this thread
  final int replyCount;
  
  /// Number of likes/reactions
  final int likeCount;
  
  /// List of user IDs who liked this thread
  final List<String> likedBy;
  
  /// Whether this thread is pinned to top
  final bool isPinned;
  
  /// Whether new replies are disabled
  final bool isLocked;
  
  /// Tags for categorizing thread content
  final List<String> tags;

  DiscussionThread({
    required this.id,
    required this.boardId,
    required this.title,
    required this.content,
    required this.authorId,
    required this.authorName,
    required this.authorRole,
    required this.createdAt,
    required this.updatedAt,
    this.replyCount = 0,
    this.likeCount = 0,
    this.likedBy = const [],
    this.isPinned = false,
    this.isLocked = false,
    this.tags = const [],
  });

  /// Factory constructor to create DiscussionThread from Firestore document.
  /// 
  /// Handles data parsing with comprehensive defaults:
  /// - Timestamp conversions for date fields
  /// - Safe list casting for likedBy and tags
  /// - Default values for counters and flags
  /// - Author information caching
  /// 
  /// @param doc Firestore document snapshot containing thread data
  /// @return Parsed DiscussionThread instance
  factory DiscussionThread.fromFirestore(DocumentSnapshot doc) {
    final data = doc.data() as Map<String, dynamic>;
    return DiscussionThread(
      id: doc.id,
      boardId: data['boardId'] ?? '',
      title: data['title'] ?? '',
      content: data['content'] ?? '',
      authorId: data['authorId'] ?? '',
      authorName: data['authorName'] ?? '',
      authorRole: data['authorRole'] ?? '',
      createdAt: (data['createdAt'] as Timestamp).toDate(),
      updatedAt: (data['updatedAt'] as Timestamp).toDate(),
      replyCount: data['replyCount'] ?? 0,
      likeCount: data['likeCount'] ?? 0,
      likedBy: List<String>.from(data['likedBy'] ?? []),
      isPinned: data['isPinned'] ?? false,
      isLocked: data['isLocked'] ?? false,
      tags: List<String>.from(data['tags'] ?? []),
    );
  }

  /// Converts the DiscussionThread instance to a Map for Firestore storage.
  /// 
  /// Serializes all thread data including:
  /// - DateTime fields to Firestore Timestamps
  /// - Lists and engagement data
  /// - Boolean flags for thread state
  /// 
  /// @return Map containing all thread data for Firestore
  Map<String, dynamic> toFirestore() {
    return {
      'boardId': boardId,
      'title': title,
      'content': content,
      'authorId': authorId,
      'authorName': authorName,
      'authorRole': authorRole,
      'createdAt': Timestamp.fromDate(createdAt),
      'updatedAt': Timestamp.fromDate(updatedAt),
      'replyCount': replyCount,
      'likeCount': likeCount,
      'likedBy': likedBy,
      'isPinned': isPinned,
      'isLocked': isLocked,
      'tags': tags,
    };
  }

  /// Creates a copy of the DiscussionThread with updated fields.
  /// 
  /// Follows immutable data pattern for state management.
  /// Useful for:
  /// - Updating engagement counters
  /// - Managing like states
  /// - Toggling pin/lock status
  /// - Editing thread content
  /// 
  /// All parameters are optional - only provided fields will be updated.
  /// 
  /// @return New DiscussionThread instance with updated fields
  DiscussionThread copyWith({
    String? id,
    String? boardId,
    String? title,
    String? content,
    String? authorId,
    String? authorName,
    String? authorRole,
    DateTime? createdAt,
    DateTime? updatedAt,
    int? replyCount,
    int? likeCount,
    List<String>? likedBy,
    bool? isPinned,
    bool? isLocked,
    List<String>? tags,
  }) {
    return DiscussionThread(
      id: id ?? this.id,
      boardId: boardId ?? this.boardId,
      title: title ?? this.title,
      content: content ?? this.content,
      authorId: authorId ?? this.authorId,
      authorName: authorName ?? this.authorName,
      authorRole: authorRole ?? this.authorRole,
      createdAt: createdAt ?? this.createdAt,
      updatedAt: updatedAt ?? this.updatedAt,
      replyCount: replyCount ?? this.replyCount,
      likeCount: likeCount ?? this.likeCount,
      likedBy: likedBy ?? this.likedBy,
      isPinned: isPinned ?? this.isPinned,
      isLocked: isLocked ?? this.isLocked,
      tags: tags ?? this.tags,
    );
  }
}

/// Reply model for thread responses and nested discussions.
/// 
/// Replies represent individual responses within discussion threads,
/// supporting nested conversations and engagement tracking. Features:
/// - Nested reply support (reply to specific comments)
/// - Edit tracking with timestamps
/// - Like/reaction functionality
/// - Author role preservation
/// - Content moderation capabilities
class ThreadReply {
  /// Unique identifier for the reply
  final String id;
  
  /// ID of the parent thread
  final String threadId;
  
  /// Reply content/message
  final String content;
  
  /// User ID of the reply author
  final String authorId;
  
  /// Cached name of the reply author
  final String authorName;
  
  /// Role of the author (teacher/student)
  final String authorRole;
  
  /// Timestamp when the reply was posted
  final DateTime createdAt;
  
  /// Whether the reply has been edited
  final bool isEdited;
  
  /// Timestamp of last edit (null if never edited)
  final DateTime? editedAt;
  
  /// Number of likes/reactions
  final int likeCount;
  
  /// List of user IDs who liked this reply
  final List<String> likedBy;
  
  /// ID of the reply being responded to (for nested replies)
  final String? replyToId;
  
  /// Cached author name of the reply being responded to
  final String? replyToAuthor;

  ThreadReply({
    required this.id,
    required this.threadId,
    required this.content,
    required this.authorId,
    required this.authorName,
    required this.authorRole,
    required this.createdAt,
    this.isEdited = false,
    this.editedAt,
    this.likeCount = 0,
    this.likedBy = const [],
    this.replyToId,
    this.replyToAuthor,
  });

  /// Factory constructor to create ThreadReply from Firestore document.
  /// 
  /// Handles data parsing including:
  /// - Timestamp conversions with null safety
  /// - Edit tracking field management
  /// - Nested reply reference preservation
  /// - Engagement data casting
  /// 
  /// @param doc Firestore document snapshot containing reply data
  /// @return Parsed ThreadReply instance
  factory ThreadReply.fromFirestore(DocumentSnapshot doc) {
    final data = doc.data() as Map<String, dynamic>;
    return ThreadReply(
      id: doc.id,
      threadId: data['threadId'] ?? '',
      content: data['content'] ?? '',
      authorId: data['authorId'] ?? '',
      authorName: data['authorName'] ?? '',
      authorRole: data['authorRole'] ?? '',
      createdAt: (data['createdAt'] as Timestamp).toDate(),
      isEdited: data['isEdited'] ?? false,
      editedAt: data['editedAt'] != null 
          ? (data['editedAt'] as Timestamp).toDate() 
          : null,
      likeCount: data['likeCount'] ?? 0,
      likedBy: List<String>.from(data['likedBy'] ?? []),
      replyToId: data['replyToId'],
      replyToAuthor: data['replyToAuthor'],
    );
  }

  /// Converts the ThreadReply instance to a Map for Firestore storage.
  /// 
  /// Serializes all reply data including:
  /// - DateTime fields to Firestore Timestamps
  /// - Edit tracking with conditional timestamp
  /// - Engagement and nested reply data
  /// 
  /// @return Map containing all reply data for Firestore
  Map<String, dynamic> toFirestore() {
    return {
      'threadId': threadId,
      'content': content,
      'authorId': authorId,
      'authorName': authorName,
      'authorRole': authorRole,
      'createdAt': Timestamp.fromDate(createdAt),
      'isEdited': isEdited,
      'editedAt': editedAt != null ? Timestamp.fromDate(editedAt!) : null,
      'likeCount': likeCount,
      'likedBy': likedBy,
      'replyToId': replyToId,
      'replyToAuthor': replyToAuthor,
    };
  }

  /// Creates a copy of the ThreadReply with updated fields.
  /// 
  /// Follows immutable data pattern for state management.
  /// Useful for:
  /// - Marking replies as edited
  /// - Updating engagement counters
  /// - Managing like states
  /// - Updating content after edits
  /// 
  /// All parameters are optional - only provided fields will be updated.
  /// 
  /// @return New ThreadReply instance with updated fields
  ThreadReply copyWith({
    String? id,
    String? threadId,
    String? content,
    String? authorId,
    String? authorName,
    String? authorRole,
    DateTime? createdAt,
    bool? isEdited,
    DateTime? editedAt,
    int? likeCount,
    List<String>? likedBy,
    String? replyToId,
    String? replyToAuthor,
  }) {
    return ThreadReply(
      id: id ?? this.id,
      threadId: threadId ?? this.threadId,
      content: content ?? this.content,
      authorId: authorId ?? this.authorId,
      authorName: authorName ?? this.authorName,
      authorRole: authorRole ?? this.authorRole,
      createdAt: createdAt ?? this.createdAt,
      isEdited: isEdited ?? this.isEdited,
      editedAt: editedAt ?? this.editedAt,
      likeCount: likeCount ?? this.likeCount,
      likedBy: likedBy ?? this.likedBy,
      replyToId: replyToId ?? this.replyToId,
      replyToAuthor: replyToAuthor ?? this.replyToAuthor,
    );
  }
}
````

## File: lib/features/discussions/domain/repositories/discussion_repository.dart
````dart
/// Discussion repository interface for forum functionality.
/// 
/// This module defines the contract for discussion board operations
/// in the education platform, supporting threaded discussions,
/// replies, and community interaction features.
library;

import '../models/discussion_board.dart';

/// Abstract repository defining discussion board operations.
/// 
/// This interface provides a comprehensive contract for discussion
/// implementations, supporting:
/// - Discussion board creation and management
/// - Threaded conversation structure
/// - Reply chains with nested discussions
/// - Like/unlike functionality for engagement
/// - Pin and lock features for moderation
/// - Real-time streaming of discussions
/// - Search capabilities across boards and threads
/// 
/// Concrete implementations handle the actual forum
/// infrastructure and data persistence.
abstract class DiscussionRepository {
  // Board operations
  
  /// Creates a new discussion board.
  /// 
  /// Initializes a board with title, description, and settings.
  /// Returns the generated board ID for reference.
  /// 
  /// @param board Board model with configuration
  /// @return Generated unique board ID
  /// @throws Exception if creation fails
  Future<String> createBoard(DiscussionBoard board);
  
  /// Retrieves a discussion board by ID.
  /// 
  /// Fetches complete board details including metadata
  /// and configuration. Returns null if not found.
  /// 
  /// @param boardId Unique board identifier
  /// @return Board instance or null
  /// @throws Exception if retrieval fails
  Future<DiscussionBoard?> getBoard(String boardId);
  
  /// Retrieves all discussion boards.
  /// 
  /// Fetches the complete list of boards, typically
  /// filtered by user permissions and visibility settings.
  /// 
  /// @return List of accessible discussion boards
  /// @throws Exception if retrieval fails
  Future<List<DiscussionBoard>> getBoards();
  
  /// Updates discussion board information.
  /// 
  /// Modifies board details such as title, description,
  /// or settings. Cannot change board type after creation.
  /// 
  /// @param boardId Board to update
  /// @param board Updated board information
  /// @throws Exception if update fails
  Future<void> updateBoard(String boardId, DiscussionBoard board);
  
  /// Pins or unpins a discussion board.
  /// 
  /// Pinned boards appear at the top of board lists
  /// for increased visibility and importance.
  /// 
  /// @param boardId Board to pin/unpin
  /// @param isPinned Whether to pin the board
  /// @throws Exception if operation fails
  Future<void> pinBoard(String boardId, bool isPinned);
  
  // Thread operations
  
  /// Creates a new discussion thread in a board.
  /// 
  /// Starts a new topic with title, content, and metadata.
  /// Returns the generated thread ID for reference.
  /// 
  /// @param boardId Target board for the thread
  /// @param thread Thread model with content
  /// @return Generated unique thread ID
  /// @throws Exception if creation fails
  Future<String> createThread(String boardId, DiscussionThread thread);
  
  /// Retrieves a specific discussion thread.
  /// 
  /// Fetches complete thread details including content,
  /// author info, and engagement metrics.
  /// 
  /// @param boardId Board containing the thread
  /// @param threadId Unique thread identifier
  /// @return Thread instance or null if not found
  /// @throws Exception if retrieval fails
  Future<DiscussionThread?> getThread(String boardId, String threadId);
  
  /// Retrieves all threads in a discussion board.
  /// 
  /// Fetches threads sorted by activity, creation date,
  /// or pinned status depending on board settings.
  /// 
  /// @param boardId Board to get threads from
  /// @return List of discussion threads
  /// @throws Exception if retrieval fails
  Future<List<DiscussionThread>> getBoardThreads(String boardId);
  
  /// Updates thread information.
  /// 
  /// Allows editing thread title or content. Typically
  /// restricted to thread author or moderators.
  /// 
  /// @param boardId Board containing the thread
  /// @param threadId Thread to update
  /// @param thread Updated thread information
  /// @throws Exception if update fails
  Future<void> updateThread(String boardId, String threadId, DiscussionThread thread);
  
  /// Deletes a discussion thread.
  /// 
  /// Removes the thread and all associated replies.
  /// This operation cannot be undone.
  /// 
  /// @param boardId Board containing the thread
  /// @param threadId Thread to delete
  /// @throws Exception if deletion fails
  Future<void> deleteThread(String boardId, String threadId);
  
  /// Adds a like to a discussion thread.
  /// 
  /// Records user engagement with the thread.
  /// Each user can only like a thread once.
  /// 
  /// @param boardId Board containing the thread
  /// @param threadId Thread to like
  /// @param userId User performing the like
  /// @throws Exception if like fails
  Future<void> likeThread(String boardId, String threadId, String userId);
  
  /// Removes a like from a discussion thread.
  /// 
  /// Reverses a previous like action by the user.
  /// 
  /// @param boardId Board containing the thread
  /// @param threadId Thread to unlike
  /// @param userId User removing the like
  /// @throws Exception if unlike fails
  Future<void> unlikeThread(String boardId, String threadId, String userId);
  
  /// Pins or unpins a thread within a board.
  /// 
  /// Pinned threads appear at the top of thread lists.
  /// Typically restricted to moderators.
  /// 
  /// @param boardId Board containing the thread
  /// @param threadId Thread to pin/unpin
  /// @param isPinned Whether to pin the thread
  /// @throws Exception if operation fails
  Future<void> pinThread(String boardId, String threadId, bool isPinned);
  
  /// Locks or unlocks a thread for replies.
  /// 
  /// Locked threads prevent new replies but remain visible.
  /// Used for closing resolved discussions.
  /// 
  /// @param boardId Board containing the thread
  /// @param threadId Thread to lock/unlock
  /// @param isLocked Whether to lock the thread
  /// @throws Exception if operation fails
  Future<void> lockThread(String boardId, String threadId, bool isLocked);
  
  // Reply operations
  
  /// Creates a reply to a discussion thread.
  /// 
  /// Adds a response to an ongoing discussion.
  /// Returns the generated reply ID.
  /// 
  /// @param boardId Board containing the thread
  /// @param threadId Thread to reply to
  /// @param reply Reply model with content
  /// @return Generated unique reply ID
  /// @throws Exception if creation fails
  Future<String> createReply(String boardId, String threadId, ThreadReply reply);
  
  /// Retrieves all replies for a thread.
  /// 
  /// Fetches replies in chronological order with
  /// author information and engagement metrics.
  /// 
  /// @param boardId Board containing the thread
  /// @param threadId Thread to get replies for
  /// @return List of thread replies
  /// @throws Exception if retrieval fails
  Future<List<ThreadReply>> getThreadReplies(String boardId, String threadId);
  
  /// Updates reply content.
  /// 
  /// Allows editing reply text. Typically restricted
  /// to reply author within a time window.
  /// 
  /// @param boardId Board containing the thread
  /// @param threadId Thread containing the reply
  /// @param replyId Reply to update
  /// @param reply Updated reply information
  /// @throws Exception if update fails
  Future<void> updateReply(String boardId, String threadId, String replyId, ThreadReply reply);
  
  /// Deletes a reply from a thread.
  /// 
  /// Removes the reply permanently. May show as
  /// "deleted" depending on implementation.
  /// 
  /// @param boardId Board containing the thread
  /// @param threadId Thread containing the reply
  /// @param replyId Reply to delete
  /// @throws Exception if deletion fails
  Future<void> deleteReply(String boardId, String threadId, String replyId);
  
  /// Adds a like to a reply.
  /// 
  /// Records user appreciation for a reply.
  /// Each user can only like a reply once.
  /// 
  /// @param boardId Board containing the thread
  /// @param threadId Thread containing the reply
  /// @param replyId Reply to like
  /// @param userId User performing the like
  /// @throws Exception if like fails
  Future<void> likeReply(String boardId, String threadId, String replyId, String userId);
  
  /// Removes a like from a reply.
  /// 
  /// Reverses a previous like action by the user.
  /// 
  /// @param boardId Board containing the thread
  /// @param threadId Thread containing the reply
  /// @param replyId Reply to unlike
  /// @param userId User removing the like
  /// @throws Exception if unlike fails
  Future<void> unlikeReply(String boardId, String threadId, String replyId, String userId);
  
  // Stream operations
  
  /// Streams all discussion boards in real-time.
  /// 
  /// Returns live updates when boards are created,
  /// updated, or deleted. Respects user permissions.
  /// 
  /// @return Stream of discussion board lists
  Stream<List<DiscussionBoard>> streamBoards();
  
  /// Streams threads for a specific board.
  /// 
  /// Returns real-time updates of threads including
  /// new posts, edits, and engagement changes.
  /// 
  /// @param boardId Board to monitor
  /// @return Stream of thread lists
  Stream<List<DiscussionThread>> streamBoardThreads(String boardId);
  
  /// Streams replies for a specific thread.
  /// 
  /// Returns real-time updates of replies including
  /// new responses, edits, and likes.
  /// 
  /// @param boardId Board containing the thread
  /// @param threadId Thread to monitor
  /// @return Stream of reply lists
  Stream<List<ThreadReply>> streamThreadReplies(String boardId, String threadId);
  
  // Search operations
  
  /// Searches for threads across all boards.
  /// 
  /// Performs text search on thread titles and content.
  /// Returns results ordered by relevance.
  /// 
  /// @param query Search terms
  /// @return List of matching threads
  /// @throws Exception if search fails
  Future<List<DiscussionThread>> searchThreads(String query);
  
  /// Searches for threads within a specific board.
  /// 
  /// Performs text search limited to a single board.
  /// Useful for focused topic searches.
  /// 
  /// @param boardId Board to search within
  /// @param query Search terms
  /// @return List of matching threads
  /// @throws Exception if search fails
  Future<List<DiscussionThread>> searchBoardThreads(String boardId, String query);
  
  /// Disposes of repository resources.
  /// 
  /// Cleans up streams, listeners, and connections.
  /// Should be called when repository is no longer needed.
  void dispose();
}
````

## File: lib/features/discussions/presentation/providers/discussion_provider.dart
````dart
/// Discussion board state management provider.
/// 
/// This module manages discussion boards, threads, and replies for the
/// education platform, providing forum-style collaborative discussions
/// with real-time updates and moderation features.
library;

import 'dart:async';
import 'package:flutter/material.dart';
import 'package:firebase_auth/firebase_auth.dart';
import '../../domain/models/discussion_board.dart';
import '../../domain/repositories/discussion_repository.dart';
import '../../../../shared/core/service_locator.dart';
import '../../../../shared/services/logger_service.dart';

/// Provider managing discussion boards and threads.
/// 
/// This provider serves as the central state manager for discussion forums,
/// coordinating hierarchical content organization. Key features:
/// - Three-tier structure: boards → threads → replies
/// - Real-time updates for all discussion levels
/// - Like/unlike functionality for engagement
/// - Moderation tools (pin, lock, delete)
/// - Tag-based organization and search
/// - Role-based permissions (teacher/student)
/// 
/// Maintains separate caches for boards, threads, and replies
/// with automatic stream management.
class DiscussionProvider with ChangeNotifier {
  /// Logger tag for this provider.
  static const String _tag = 'DiscussionProvider';
  
  /// Repository for discussion data operations.
  late final DiscussionRepository _repository;
  
  /// Firebase Auth for user identification.
  final FirebaseAuth _auth = FirebaseAuth.instance;

  // State variables
  
  /// All available discussion boards.
  List<DiscussionBoard> _boards = [];
  
  /// Threads grouped by board ID.
  final Map<String, List<DiscussionThread>> _boardThreads = {};
  
  /// Replies grouped by board_thread ID.
  final Map<String, List<ThreadReply>> _threadReplies = {};
  
  /// Currently selected board.
  DiscussionBoard? _currentBoard;
  
  /// Currently selected thread.
  DiscussionThread? _currentThread;
  
  /// Loading state for async operations.
  bool _isLoading = false;
  
  /// Latest error message for UI display.
  String? _error;

  // Stream subscriptions
  
  /// Subscription for board list updates.
  StreamSubscription<List<DiscussionBoard>>? _boardsSubscription;
  
  /// Thread subscriptions keyed by board ID.
  final Map<String, StreamSubscription<List<DiscussionThread>>> _threadSubscriptions = {};
  
  /// Reply subscriptions keyed by board_thread ID.
  final Map<String, StreamSubscription<List<ThreadReply>>> _replySubscriptions = {};

  /// Creates discussion provider with repository dependency.
  /// 
  /// Retrieves discussion repository from dependency injection.
  DiscussionProvider() {
    _repository = getIt<DiscussionRepository>();
  }

  // Getters
  
  /// List of all discussion boards.
  List<DiscussionBoard> get boards => _boards;
  
  /// Currently selected board or null.
  DiscussionBoard? get currentBoard => _currentBoard;
  
  /// Currently selected thread or null.
  DiscussionThread? get currentThread => _currentThread;
  
  /// Whether an operation is in progress.
  bool get isLoading => _isLoading;
  
  /// Latest error message or null.
  String? get error => _error;
  
  /// Current user's ID from Firebase Auth.
  String get currentUserId => _auth.currentUser?.uid ?? '';

  /// Gets threads for a specific board.
  /// 
  /// Returns cached threads or empty list if not loaded.
  /// 
  /// @param boardId Board to get threads from
  /// @return List of discussion threads
  List<DiscussionThread> getBoardThreads(String boardId) {
    return _boardThreads[boardId] ?? [];
  }

  /// Gets replies for a specific thread.
  /// 
  /// Uses composite key of board and thread IDs.
  /// Returns cached replies or empty list if not loaded.
  /// 
  /// @param boardId Board containing the thread
  /// @param threadId Thread to get replies from
  /// @return List of thread replies
  List<ThreadReply> getThreadReplies(String boardId, String threadId) {
    final key = '${boardId}_$threadId';
    return _threadReplies[key] ?? [];
  }

  /// Initializes real-time board monitoring.
  /// 
  /// Sets up stream subscription for discussion boards,
  /// automatically updating when boards are added, modified,
  /// or removed. Cancels any existing subscription first.
  void initializeBoards() {
    _boardsSubscription?.cancel();
    
    _boardsSubscription = _repository.streamBoards().listen(
      (boards) {
        _boards = boards;
        _error = null;
        notifyListeners();
      },
      onError: (error) {
        _error = error.toString();
        LoggerService.error('Failed to load boards', tag: _tag, error: error);
        notifyListeners();
      },
    );
  }

  /// Loads and subscribes to threads for a board.
  /// 
  /// Sets up real-time stream for thread updates including
  /// new threads, edits, and engagement metrics. Cancels
  /// any existing subscription for the board.
  /// 
  /// @param boardId Board to load threads from
  void loadBoardThreads(String boardId) {
    _threadSubscriptions[boardId]?.cancel();
    
    _threadSubscriptions[boardId] = _repository.streamBoardThreads(boardId).listen(
      (threads) {
        _boardThreads[boardId] = threads;
        _error = null;
        notifyListeners();
      },
      onError: (error) {
        _error = error.toString();
        LoggerService.error('Failed to load threads', tag: _tag, error: error);
        notifyListeners();
      },
    );
  }

  /// Loads and subscribes to replies for a thread.
  /// 
  /// Sets up real-time stream for reply updates including
  /// new replies, edits, and likes. Uses composite key
  /// for subscription management.
  /// 
  /// @param boardId Board containing the thread
  /// @param threadId Thread to load replies from
  void loadThreadReplies(String boardId, String threadId) {
    final key = '${boardId}_$threadId';
    _replySubscriptions[key]?.cancel();
    
    _replySubscriptions[key] = _repository.streamThreadReplies(boardId, threadId).listen(
      (replies) {
        _threadReplies[key] = replies;
        _error = null;
        notifyListeners();
      },
      onError: (error) {
        _error = error.toString();
        LoggerService.error('Failed to load replies', tag: _tag, error: error);
        notifyListeners();
      },
    );
  }

  /// Sets the active discussion board.
  /// 
  /// Automatically loads threads for the selected board
  /// and updates UI state.
  /// 
  /// @param board Board to activate
  void setCurrentBoard(DiscussionBoard board) {
    _currentBoard = board;
    loadBoardThreads(board.id);
    notifyListeners();
  }

  /// Sets the active discussion thread.
  /// 
  /// Automatically loads replies if a board is selected.
  /// Updates UI state for thread detail views.
  /// 
  /// @param thread Thread to activate
  void setCurrentThread(DiscussionThread thread) {
    _currentThread = thread;
    if (_currentBoard != null) {
      loadThreadReplies(_currentBoard!.id, thread.id);
    }
    notifyListeners();
  }

  /// Creates a new discussion board.
  /// 
  /// Board creation includes:
  /// - Automatic author attribution
  /// - Optional class association
  /// - Tag assignment for categorization
  /// - Pin status for importance
  /// 
  /// @param title Board title
  /// @param description Board purpose/rules
  /// @param tags Category tags
  /// @param isPinned Whether to pin at top
  /// @param classId Optional class association
  /// @return Created board ID or null if failed
  Future<String?> createBoard({
    required String title,
    required String description,
    List<String> tags = const [],
    bool isPinned = false,
    String? classId,
  }) async {
    _isLoading = true;
    _error = null;
    notifyListeners();

    try {
      final board = DiscussionBoard(
        id: '',
        title: title,
        description: description,
        createdBy: currentUserId,
        createdByName: _auth.currentUser?.displayName ?? 'User',
        classId: classId,
        participantIds: [currentUserId],
        createdAt: DateTime.now(),
        updatedAt: DateTime.now(),
        isPinned: isPinned,
        tags: tags,
      );

      final boardId = await _repository.createBoard(board);
      LoggerService.info('Created board: $boardId', tag: _tag);
      
      return boardId;
    } catch (e) {
      _error = e.toString();
      LoggerService.error('Failed to create board', tag: _tag, error: e);
      return null;
    } finally {
      _isLoading = false;
      notifyListeners();
    }
  }

  /// Creates a new discussion thread.
  /// 
  /// Thread creation includes:
  /// - Author attribution with role
  /// - Initial content as first post
  /// - Tag assignment for searchability
  /// - Automatic timestamp tracking
  /// 
  /// @param boardId Parent board ID
  /// @param title Thread title
  /// @param content Initial post content
  /// @param tags Category tags
  /// @return Created thread ID or null if failed
  Future<String?> createThread({
    required String boardId,
    required String title,
    required String content,
    List<String> tags = const [],
  }) async {
    _isLoading = true;
    _error = null;
    notifyListeners();

    try {
      final thread = DiscussionThread(
        id: '',
        boardId: boardId,
        title: title,
        content: content,
        authorId: currentUserId,
        authorName: _auth.currentUser?.displayName ?? 'User',
        authorRole: _auth.currentUser?.email?.endsWith('@teacher.edu') == true 
            ? 'teacher' 
            : 'student',
        createdAt: DateTime.now(),
        updatedAt: DateTime.now(),
        tags: tags,
      );

      final threadId = await _repository.createThread(boardId, thread);
      LoggerService.info('Created thread: $threadId', tag: _tag);
      
      return threadId;
    } catch (e) {
      _error = e.toString();
      LoggerService.error('Failed to create thread', tag: _tag, error: e);
      return null;
    } finally {
      _isLoading = false;
      notifyListeners();
    }
  }

  /// Creates a reply to a thread.
  /// 
  /// Reply features:
  /// - Nested reply support (reply to reply)
  /// - Author attribution with role
  /// - Automatic thread update timestamp
  /// - Real-time delivery to participants
  /// 
  /// @param boardId Parent board ID
  /// @param threadId Parent thread ID
  /// @param content Reply content
  /// @param replyToId Optional parent reply ID
  /// @param replyToAuthor Optional parent author name
  /// @return Created reply ID or null if failed
  Future<String?> createReply({
    required String boardId,
    required String threadId,
    required String content,
    String? replyToId,
    String? replyToAuthor,
  }) async {
    _isLoading = true;
    _error = null;
    notifyListeners();

    try {
      final reply = ThreadReply(
        id: '',
        threadId: threadId,
        content: content,
        authorId: currentUserId,
        authorName: _auth.currentUser?.displayName ?? 'User',
        authorRole: _auth.currentUser?.email?.endsWith('@teacher.edu') == true 
            ? 'teacher' 
            : 'student',
        createdAt: DateTime.now(),
        replyToId: replyToId,
        replyToAuthor: replyToAuthor,
      );

      final replyId = await _repository.createReply(boardId, threadId, reply);
      LoggerService.info('Created reply: $replyId', tag: _tag);
      
      return replyId;
    } catch (e) {
      _error = e.toString();
      LoggerService.error('Failed to create reply', tag: _tag, error: e);
      return null;
    } finally {
      _isLoading = false;
      notifyListeners();
    }
  }

  // Like/unlike operations
  
  /// Toggles like status for a discussion thread.
  /// 
  /// Adds or removes current user from thread's like list.
  /// Updates like count and UI state automatically through
  /// stream subscriptions.
  /// 
  /// @param boardId Board containing the thread
  /// @param threadId Thread to like/unlike
  /// @throws Exception if thread not found
  Future<void> toggleThreadLike(String boardId, String threadId) async {
    try {
      final thread = _boardThreads[boardId]?.firstWhere(
        (t) => t.id == threadId,
        orElse: () => throw Exception('Thread not found'),
      );

      if (thread?.likedBy.contains(currentUserId) ?? false) {
        await _repository.unlikeThread(boardId, threadId, currentUserId);
      } else {
        await _repository.likeThread(boardId, threadId, currentUserId);
      }
    } catch (e) {
      _error = e.toString();
      LoggerService.error('Failed to toggle thread like', tag: _tag, error: e);
      notifyListeners();
    }
  }

  /// Toggles like status for a thread reply.
  /// 
  /// Adds or removes current user from reply's like list.
  /// Uses composite key for efficient lookup.
  /// 
  /// @param boardId Board containing the thread
  /// @param threadId Thread containing the reply
  /// @param replyId Reply to like/unlike
  /// @throws Exception if reply not found
  Future<void> toggleReplyLike(String boardId, String threadId, String replyId) async {
    try {
      final key = '${boardId}_$threadId';
      final reply = _threadReplies[key]?.firstWhere(
        (r) => r.id == replyId,
        orElse: () => throw Exception('Reply not found'),
      );

      if (reply?.likedBy.contains(currentUserId) ?? false) {
        await _repository.unlikeReply(boardId, threadId, replyId, currentUserId);
      } else {
        await _repository.likeReply(boardId, threadId, replyId, currentUserId);
      }
    } catch (e) {
      _error = e.toString();
      LoggerService.error('Failed to toggle reply like', tag: _tag, error: e);
      notifyListeners();
    }
  }

  // Delete operations
  
  /// Permanently deletes a discussion thread.
  /// 
  /// Removes thread and all associated replies from Firestore.
  /// This operation cannot be undone. Consider implementing
  /// soft deletion for content moderation.
  /// 
  /// @param boardId Board containing the thread
  /// @param threadId Thread to delete
  /// @return true if deletion successful
  Future<bool> deleteThread(String boardId, String threadId) async {
    _isLoading = true;
    _error = null;
    notifyListeners();

    try {
      await _repository.deleteThread(boardId, threadId);
      LoggerService.info('Deleted thread: $threadId', tag: _tag);
      return true;
    } catch (e) {
      _error = e.toString();
      LoggerService.error('Failed to delete thread', tag: _tag, error: e);
      return false;
    } finally {
      _isLoading = false;
      notifyListeners();
    }
  }

  /// Permanently deletes a thread reply.
  /// 
  /// Removes reply from Firestore. Parent thread remains intact.
  /// This operation cannot be undone.
  /// 
  /// @param boardId Board containing the thread
  /// @param threadId Thread containing the reply
  /// @param replyId Reply to delete
  /// @return true if deletion successful
  Future<bool> deleteReply(String boardId, String threadId, String replyId) async {
    _isLoading = true;
    _error = null;
    notifyListeners();

    try {
      await _repository.deleteReply(boardId, threadId, replyId);
      LoggerService.info('Deleted reply: $replyId', tag: _tag);
      return true;
    } catch (e) {
      _error = e.toString();
      LoggerService.error('Failed to delete reply', tag: _tag, error: e);
      return false;
    } finally {
      _isLoading = false;
      notifyListeners();
    }
  }

  // Admin operations
  
  /// Pins or unpins a discussion board.
  /// 
  /// Pinned boards appear at the top of the board list.
  /// Typically restricted to teacher/admin roles.
  /// 
  /// @param boardId Board to pin/unpin
  /// @param isPinned true to pin, false to unpin
  Future<void> pinBoard(String boardId, bool isPinned) async {
    try {
      await _repository.pinBoard(boardId, isPinned);
    } catch (e) {
      _error = e.toString();
      LoggerService.error('Failed to pin/unpin board', tag: _tag, error: e);
      notifyListeners();
    }
  }

  /// Pins or unpins a discussion thread.
  /// 
  /// Pinned threads appear at the top of the thread list.
  /// Useful for important announcements or FAQs.
  /// 
  /// @param boardId Board containing the thread
  /// @param threadId Thread to pin/unpin
  /// @param isPinned true to pin, false to unpin
  Future<void> pinThread(String boardId, String threadId, bool isPinned) async {
    try {
      await _repository.pinThread(boardId, threadId, isPinned);
    } catch (e) {
      _error = e.toString();
      LoggerService.error('Failed to pin/unpin thread', tag: _tag, error: e);
      notifyListeners();
    }
  }

  /// Locks or unlocks a discussion thread.
  /// 
  /// Locked threads prevent new replies while preserving
  /// existing content. Useful for closing resolved discussions.
  /// 
  /// @param boardId Board containing the thread
  /// @param threadId Thread to lock/unlock
  /// @param isLocked true to lock, false to unlock
  Future<void> lockThread(String boardId, String threadId, bool isLocked) async {
    try {
      await _repository.lockThread(boardId, threadId, isLocked);
    } catch (e) {
      _error = e.toString();
      LoggerService.error('Failed to lock/unlock thread', tag: _tag, error: e);
      notifyListeners();
    }
  }

  // Search
  
  /// Searches for threads across all boards.
  /// 
  /// Performs text search on thread titles and content.
  /// Returns matching threads from any board. Consider
  /// implementing filters for board-specific search.
  /// 
  /// @param query Search terms
  /// @return List of matching threads or empty list
  Future<List<DiscussionThread>> searchThreads(String query) async {
    try {
      return await _repository.searchThreads(query);
    } catch (e) {
      _error = e.toString();
      LoggerService.error('Failed to search threads', tag: _tag, error: e);
      notifyListeners();
      return [];
    }
  }

  // Clean up
  
  /// Clears the current board selection.
  /// 
  /// Resets board context for navigation or refresh.
  void clearCurrentBoard() {
    _currentBoard = null;
    notifyListeners();
  }

  /// Clears the current thread selection.
  /// 
  /// Resets thread context for navigation or refresh.
  void clearCurrentThread() {
    _currentThread = null;
    notifyListeners();
  }

  /// Cleans up resources when provider is disposed.
  /// 
  /// Cancels all stream subscriptions for boards, threads,
  /// and replies to prevent memory leaks. Also disposes
  /// the repository instance.
  @override
  void dispose() {
    _boardsSubscription?.cancel();
    
    for (final subscription in _threadSubscriptions.values) {
      subscription.cancel();
    }
    
    for (final subscription in _replySubscriptions.values) {
      subscription.cancel();
    }
    
    _repository.dispose();
    super.dispose();
  }
}
````

## File: lib/features/discussions/presentation/screens/discussion_board_detail_screen.dart
````dart
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'package:intl/intl.dart';
import '../../../../shared/widgets/common/adaptive_layout.dart';
import '../providers/discussion_provider.dart';
import '../widgets/create_thread_dialog.dart';
import 'thread_detail_screen.dart';

class DiscussionBoardDetailScreen extends StatefulWidget {
  final String boardId;
  final String boardTitle;

  const DiscussionBoardDetailScreen({
    super.key,
    required this.boardId,
    required this.boardTitle,
  });

  @override
  State<DiscussionBoardDetailScreen> createState() =>
      _DiscussionBoardDetailScreenState();
}

class _DiscussionBoardDetailScreenState
    extends State<DiscussionBoardDetailScreen> {
  
  @override
  void initState() {
    super.initState();
    // Load threads when screen opens
    WidgetsBinding.instance.addPostFrameCallback((_) {
      context.read<DiscussionProvider>().loadBoardThreads(widget.boardId);
    });
  }

  @override
  Widget build(BuildContext context) {
    return AdaptiveLayout(
      title: widget.boardTitle,
      showBackButton: true,
      actions: [
        PopupMenuButton<String>(
          onSelected: (value) {
            // TODO: Implement sorting functionality
          },
          itemBuilder: (context) => [
            const PopupMenuItem(
              value: 'recent',
              child: Text('Most Recent'),
            ),
            const PopupMenuItem(
              value: 'popular',
              child: Text('Most Popular'),
            ),
            const PopupMenuItem(
              value: 'active',
              child: Text('Most Active'),
            ),
          ],
          icon: const Icon(Icons.sort),
        ),
      ],
      body: Column(
        children: [
          Container(
            width: double.infinity,
            padding: const EdgeInsets.all(16),
            child: ElevatedButton.icon(
              onPressed: () => _showCreateThreadDialog(context),
              icon: const Icon(Icons.add),
              label: const Text('Start New Thread'),
              style: ElevatedButton.styleFrom(
                padding: const EdgeInsets.symmetric(
                  horizontal: 24,
                  vertical: 12,
                ),
              ),
            ),
          ),
          Expanded(
            child: _buildThreadsList(),
          ),
        ],
      ),
    );
  }

  Widget _buildThreadsList() {
    // Sample threads data
    return ListView(
      padding: const EdgeInsets.symmetric(horizontal: 16),
      children: [
        _buildThreadCard(
          title: 'Tips for the upcoming midterm exam',
          author: 'Sarah Johnson',
          authorRole: 'student',
          content:
              'Hey everyone! I was wondering if anyone has good study strategies for the midterm...',
          createdAt: DateTime.now().subtract(const Duration(hours: 2)),
          replyCount: 15,
          likeCount: 23,
          isPinned: true,
        ),
        const SizedBox(height: 12),
        _buildThreadCard(
          title: 'Question about Assignment 3',
          author: 'Mike Chen',
          authorRole: 'student',
          content:
              'I\'m stuck on problem 5. Can someone explain the approach without giving away the answer?',
          createdAt: DateTime.now().subtract(const Duration(days: 1)),
          replyCount: 8,
          likeCount: 5,
        ),
        const SizedBox(height: 12),
        _buildThreadCard(
          title: 'Study group for Chapter 7',
          author: 'Emily Davis',
          authorRole: 'student',
          content:
              'Anyone interested in forming a study group for Chapter 7? We could meet in the library...',
          createdAt: DateTime.now().subtract(const Duration(days: 2)),
          replyCount: 12,
          likeCount: 18,
          tags: ['Study Group'],
        ),
        const SizedBox(height: 12),
        _buildThreadCard(
          title: 'Resources for extra practice',
          author: 'Prof. Smith',
          authorRole: 'teacher',
          content:
              'I\'ve compiled some additional practice problems that might help with your preparation...',
          createdAt: DateTime.now().subtract(const Duration(days: 3)),
          replyCount: 6,
          likeCount: 32,
          tags: ['Resources'],
        ),
      ],
    );
  }

  Widget _buildThreadCard({
    required String title,
    required String author,
    required String authorRole,
    required String content,
    required DateTime createdAt,
    required int replyCount,
    required int likeCount,
    bool isPinned = false,
    List<String> tags = const [],
  }) {
    final theme = Theme.of(context);

    return Card(
      child: InkWell(
        onTap: () {
          Navigator.push(
            context,
            MaterialPageRoute(
              builder: (context) => ThreadDetailScreen(
                threadId: 'temp-id',
                threadTitle: title,
                boardId: widget.boardId,
              ),
            ),
          );
        },
        borderRadius: BorderRadius.circular(12),
        child: Padding(
          padding: const EdgeInsets.all(16),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              // Header
              Row(
                children: [
                  CircleAvatar(
                    radius: 20,
                    backgroundColor: authorRole == 'teacher'
                        ? theme.colorScheme.primary
                        : theme.colorScheme.secondary,
                    child: Text(
                      author[0].toUpperCase(),
                      style: TextStyle(
                        color: authorRole == 'teacher'
                            ? theme.colorScheme.onPrimary
                            : theme.colorScheme.onSecondary,
                      ),
                    ),
                  ),
                  const SizedBox(width: 12),
                  Expanded(
                    child: Column(
                      crossAxisAlignment: CrossAxisAlignment.start,
                      children: [
                        Row(
                          children: [
                            Text(
                              author,
                              style: theme.textTheme.titleSmall?.copyWith(
                                fontWeight: FontWeight.bold,
                              ),
                            ),
                            const SizedBox(width: 8),
                            Container(
                              padding: const EdgeInsets.symmetric(
                                horizontal: 8,
                                vertical: 2,
                              ),
                              decoration: BoxDecoration(
                                color: authorRole == 'teacher'
                                    ? theme.colorScheme.primaryContainer
                                    : theme.colorScheme.secondaryContainer,
                                borderRadius: BorderRadius.circular(12),
                              ),
                              child: Text(
                                authorRole,
                                style: theme.textTheme.labelSmall,
                              ),
                            ),
                          ],
                        ),
                        Text(
                          _formatTime(createdAt),
                          style: theme.textTheme.bodySmall?.copyWith(
                            color: theme.colorScheme.onSurfaceVariant,
                          ),
                        ),
                      ],
                    ),
                  ),
                  if (isPinned)
                    Icon(
                      Icons.push_pin,
                      size: 20,
                      color: theme.colorScheme.primary,
                    ),
                ],
              ),
              const SizedBox(height: 12),
              // Title
              Text(
                title,
                style: theme.textTheme.titleMedium?.copyWith(
                  fontWeight: FontWeight.bold,
                ),
              ),
              const SizedBox(height: 8),
              // Content preview
              Text(
                content,
                style: theme.textTheme.bodyMedium,
                maxLines: 2,
                overflow: TextOverflow.ellipsis,
              ),
              if (tags.isNotEmpty) ...[
                const SizedBox(height: 12),
                Wrap(
                  spacing: 8,
                  children: tags.map((tag) {
                    return Chip(
                      label: Text(tag),
                      labelStyle: theme.textTheme.labelSmall,
                      padding: EdgeInsets.zero,
                      materialTapTargetSize: MaterialTapTargetSize.shrinkWrap,
                    );
                  }).toList(),
                ),
              ],
              const SizedBox(height: 12),
              // Stats
              Row(
                children: [
                  Icon(
                    Icons.comment_outlined,
                    size: 16,
                    color: theme.colorScheme.onSurfaceVariant,
                  ),
                  const SizedBox(width: 4),
                  Text(
                    '$replyCount replies',
                    style: theme.textTheme.bodySmall,
                  ),
                  const SizedBox(width: 16),
                  Icon(
                    Icons.thumb_up_outlined,
                    size: 16,
                    color: theme.colorScheme.onSurfaceVariant,
                  ),
                  const SizedBox(width: 4),
                  Text(
                    '$likeCount likes',
                    style: theme.textTheme.bodySmall,
                  ),
                ],
              ),
            ],
          ),
        ),
      ),
    );
  }

  String _formatTime(DateTime dateTime) {
    final now = DateTime.now();
    final difference = now.difference(dateTime);

    if (difference.inMinutes < 60) {
      return '${difference.inMinutes} minutes ago';
    } else if (difference.inHours < 24) {
      return '${difference.inHours} hours ago';
    } else if (difference.inDays < 7) {
      return '${difference.inDays} days ago';
    } else {
      return DateFormat('MMM d').format(dateTime);
    }
  }

  void _showCreateThreadDialog(BuildContext context) {
    showDialog(
      context: context,
      builder: (context) => CreateThreadDialog(boardId: widget.boardId),
    );
  }
}
````

## File: lib/features/discussions/presentation/screens/thread_detail_screen.dart
````dart
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import '../../../../shared/widgets/common/adaptive_layout.dart';
import '../providers/discussion_provider.dart';

class ThreadDetailScreen extends StatefulWidget {
  final String threadId;
  final String threadTitle;
  final String boardId;

  const ThreadDetailScreen({
    super.key,
    required this.threadId,
    required this.threadTitle,
    required this.boardId,
  });

  @override
  State<ThreadDetailScreen> createState() => _ThreadDetailScreenState();
}

class _ThreadDetailScreenState extends State<ThreadDetailScreen> {
  final _replyController = TextEditingController();
  final _scrollController = ScrollController();
  bool _isReplying = false;
  String? _replyingTo;

  @override
  void dispose() {
    _replyController.dispose();
    _scrollController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return AdaptiveLayout(
      title: 'Thread',
      showBackButton: true,
      body: Column(
        children: [
          Expanded(
            child: ListView(
              controller: _scrollController,
              padding: const EdgeInsets.all(16),
              children: [
                _buildOriginalPost(),
                const SizedBox(height: 24),
                const Divider(),
                const SizedBox(height: 16),
                _buildRepliesSection(),
              ],
            ),
          ),
          if (_isReplying) _buildReplyInput(),
        ],
      ),
      floatingActionButton: !_isReplying
          ? FloatingActionButton.extended(
              onPressed: () {
                setState(() {
                  _isReplying = true;
                  _replyingTo = null;
                });
              },
              icon: const Icon(Icons.reply),
              label: const Text('Reply'),
            )
          : null,
    );
  }

  Widget _buildOriginalPost() {
    final theme = Theme.of(context);

    return Card(
      child: Padding(
        padding: const EdgeInsets.all(16),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            // Thread title
            Text(
              widget.threadTitle,
              style: theme.textTheme.headlineSmall?.copyWith(
                fontWeight: FontWeight.bold,
              ),
            ),
            const SizedBox(height: 16),
            // Author info
            Row(
              children: [
                CircleAvatar(
                  backgroundColor: theme.colorScheme.primary,
                  child: Text(
                    'S',
                    style: TextStyle(
                      color: theme.colorScheme.onPrimary,
                    ),
                  ),
                ),
                const SizedBox(width: 12),
                Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Row(
                      children: [
                        Text(
                          'Sarah Johnson',
                          style: theme.textTheme.titleSmall?.copyWith(
                            fontWeight: FontWeight.bold,
                          ),
                        ),
                        const SizedBox(width: 8),
                        Container(
                          padding: const EdgeInsets.symmetric(
                            horizontal: 8,
                            vertical: 2,
                          ),
                          decoration: BoxDecoration(
                            color: theme.colorScheme.secondaryContainer,
                            borderRadius: BorderRadius.circular(12),
                          ),
                          child: Text(
                            'student',
                            style: theme.textTheme.labelSmall,
                          ),
                        ),
                      ],
                    ),
                    Text(
                      'Posted 2 hours ago',
                      style: theme.textTheme.bodySmall?.copyWith(
                        color: theme.colorScheme.onSurfaceVariant,
                      ),
                    ),
                  ],
                ),
                const Spacer(),
                IconButton(
                  icon: const Icon(Icons.more_vert),
                  onPressed: () => _showPostOptions(context),
                ),
              ],
            ),
            const SizedBox(height: 16),
            // Content
            const Text(
              'Hey everyone! I was wondering if anyone has good study strategies for the midterm. I\'ve been reviewing my notes but I feel like I\'m not retaining the information as well as I\'d like. '
              'Does anyone have tips for effective studying, especially for topics like Chapter 5 and 6? I find those particularly challenging.\n\n'
              'Also, would anyone be interested in forming a study group? We could meet in the library or online.',
              style: TextStyle(height: 1.5),
            ),
            const SizedBox(height: 16),
            // Tags
            Wrap(
              spacing: 8,
              children: [
                Chip(
                  label: Text(
                    'Question',
                    style: theme.textTheme.labelSmall,
                  ),
                  materialTapTargetSize: MaterialTapTargetSize.shrinkWrap,
                ),
                Chip(
                  label: Text(
                    'Study Group',
                    style: theme.textTheme.labelSmall,
                  ),
                  materialTapTargetSize: MaterialTapTargetSize.shrinkWrap,
                ),
              ],
            ),
            const SizedBox(height: 16),
            // Actions
            Row(
              children: [
                TextButton.icon(
                  onPressed: () {},
                  icon: const Icon(Icons.thumb_up_outlined),
                  label: const Text('23'),
                ),
                const SizedBox(width: 16),
                TextButton.icon(
                  onPressed: () {
                    setState(() {
                      _isReplying = true;
                      _replyingTo = null;
                    });
                  },
                  icon: const Icon(Icons.reply),
                  label: const Text('Reply'),
                ),
              ],
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildRepliesSection() {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Text(
          '15 Replies',
          style: Theme.of(context).textTheme.titleMedium?.copyWith(
                fontWeight: FontWeight.bold,
              ),
        ),
        const SizedBox(height: 16),
        _buildReply(
          author: 'Prof. Smith',
          authorRole: 'teacher',
          content:
              'Great question, Sarah! For Chapters 5 and 6, I recommend using the practice problems at the end of each chapter. '
              'Also, try explaining the concepts to someone else - teaching is one of the best ways to learn.',
          time: '1 hour ago',
          likes: 18,
        ),
        _buildReply(
          author: 'Mike Chen',
          authorRole: 'student',
          content:
              'I\'d love to join a study group! I\'m free Tuesday and Thursday afternoons. '
              'For Chapter 5, I found making flashcards really helpful.',
          time: '45 minutes ago',
          likes: 5,
          replyTo: 'Sarah Johnson',
        ),
        _buildReply(
          author: 'Emily Davis',
          authorRole: 'student',
          content:
              'Count me in for the study group! I\'ve been using the Pomodoro technique - 25 minutes of focused study, then a 5-minute break. '
              'It really helps with retention.',
          time: '30 minutes ago',
          likes: 8,
        ),
      ],
    );
  }

  Widget _buildReply({
    required String author,
    required String authorRole,
    required String content,
    required String time,
    required int likes,
    String? replyTo,
  }) {
    final theme = Theme.of(context);

    return Card(
      margin: const EdgeInsets.only(bottom: 12),
      child: Padding(
        padding: const EdgeInsets.all(16),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Row(
              children: [
                CircleAvatar(
                  radius: 16,
                  backgroundColor: authorRole == 'teacher'
                      ? theme.colorScheme.primary
                      : theme.colorScheme.secondary,
                  child: Text(
                    author[0].toUpperCase(),
                    style: TextStyle(
                      color: authorRole == 'teacher'
                          ? theme.colorScheme.onPrimary
                          : theme.colorScheme.onSecondary,
                      fontSize: 12,
                    ),
                  ),
                ),
                const SizedBox(width: 8),
                Expanded(
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      Row(
                        children: [
                          Text(
                            author,
                            style: theme.textTheme.titleSmall?.copyWith(
                              fontWeight: FontWeight.bold,
                            ),
                          ),
                          const SizedBox(width: 8),
                          Container(
                            padding: const EdgeInsets.symmetric(
                              horizontal: 6,
                              vertical: 1,
                            ),
                            decoration: BoxDecoration(
                              color: authorRole == 'teacher'
                                  ? theme.colorScheme.primaryContainer
                                  : theme.colorScheme.secondaryContainer,
                              borderRadius: BorderRadius.circular(8),
                            ),
                            child: Text(
                              authorRole,
                              style: theme.textTheme.labelSmall?.copyWith(
                                fontSize: 10,
                              ),
                            ),
                          ),
                        ],
                      ),
                      Text(
                        time,
                        style: theme.textTheme.bodySmall?.copyWith(
                          color: theme.colorScheme.onSurfaceVariant,
                          fontSize: 11,
                        ),
                      ),
                    ],
                  ),
                ),
              ],
            ),
            if (replyTo != null) ...[
              const SizedBox(height: 8),
              Container(
                padding: const EdgeInsets.all(8),
                decoration: BoxDecoration(
                  color: theme.colorScheme.surfaceContainerHighest
                      .withValues(alpha: 0.5),
                  borderRadius: BorderRadius.circular(8),
                  border: Border(
                    left: BorderSide(
                      color: theme.colorScheme.primary,
                      width: 3,
                    ),
                  ),
                ),
                child: Text(
                  'Replying to @$replyTo',
                  style: theme.textTheme.bodySmall?.copyWith(
                    fontStyle: FontStyle.italic,
                  ),
                ),
              ),
            ],
            const SizedBox(height: 8),
            Text(content),
            const SizedBox(height: 8),
            Row(
              children: [
                TextButton.icon(
                  onPressed: () {},
                  icon: const Icon(Icons.thumb_up_outlined, size: 16),
                  label: Text('$likes'),
                  style: TextButton.styleFrom(
                    minimumSize: const Size(0, 0),
                    padding: const EdgeInsets.symmetric(
                      horizontal: 8,
                      vertical: 4,
                    ),
                  ),
                ),
                const SizedBox(width: 8),
                TextButton(
                  onPressed: () {
                    setState(() {
                      _isReplying = true;
                      _replyingTo = author;
                    });
                  },
                  style: TextButton.styleFrom(
                    minimumSize: const Size(0, 0),
                    padding: const EdgeInsets.symmetric(
                      horizontal: 8,
                      vertical: 4,
                    ),
                  ),
                  child: const Text('Reply'),
                ),
              ],
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildReplyInput() {
    return Container(
      padding: const EdgeInsets.all(16),
      decoration: BoxDecoration(
        color: Theme.of(context).colorScheme.surface,
        boxShadow: [
          BoxShadow(
            offset: const Offset(0, -2),
            blurRadius: 4,
            color: Colors.black.withValues(alpha: 0.1),
          ),
        ],
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        mainAxisSize: MainAxisSize.min,
        children: [
          if (_replyingTo != null) ...[
            Container(
              padding: const EdgeInsets.all(8),
              decoration: BoxDecoration(
                color: Theme.of(context)
                    .colorScheme
                    .primaryContainer
                    .withValues(alpha: 0.3),
                borderRadius: BorderRadius.circular(8),
              ),
              child: Row(
                children: [
                  Text(
                    'Replying to @$_replyingTo',
                    style: Theme.of(context).textTheme.bodySmall,
                  ),
                  const Spacer(),
                  IconButton(
                    icon: const Icon(Icons.close, size: 16),
                    onPressed: () {
                      setState(() {
                        _replyingTo = null;
                      });
                    },
                    padding: EdgeInsets.zero,
                    constraints: const BoxConstraints(),
                  ),
                ],
              ),
            ),
            const SizedBox(height: 8),
          ],
          TextField(
            controller: _replyController,
            decoration: InputDecoration(
              hintText: 'Write your reply...',
              border: OutlineInputBorder(
                borderRadius: BorderRadius.circular(12),
              ),
            ),
            maxLines: 3,
            autofocus: true,
          ),
          const SizedBox(height: 8),
          Row(
            mainAxisAlignment: MainAxisAlignment.end,
            children: [
              TextButton(
                onPressed: () {
                  setState(() {
                    _isReplying = false;
                    _replyingTo = null;
                    _replyController.clear();
                  });
                },
                child: const Text('Cancel'),
              ),
              const SizedBox(width: 8),
              FilledButton(
                onPressed: _postReply,
                child: const Text('Post Reply'),
              ),
            ],
          ),
        ],
      ),
    );
  }

  void _postReply() async {
    if (_replyController.text.trim().isNotEmpty) {
      final discussionProvider = context.read<DiscussionProvider>();
      
      // Show loading indicator
      showDialog(
        context: context,
        barrierDismissible: false,
        builder: (context) => const Center(
          child: CircularProgressIndicator(),
        ),
      );
      
      try {
        // Create the reply
        final replyId = await discussionProvider.createReply(
          boardId: widget.boardId,
          threadId: widget.threadId,
          content: _replyController.text.trim(),
          replyToId: null, // If replying to a specific reply, this would be set
          replyToAuthor: _replyingTo, // The name of the person being replied to
        );
        
        // Remove loading dialog
        if (mounted) Navigator.pop(context);
        
        if (replyId != null && mounted) {
          // Show success message
          ScaffoldMessenger.of(context).showSnackBar(
            const SnackBar(
              content: Text('Reply posted successfully'),
              backgroundColor: Colors.green,
            ),
          );
          
          // Clear the reply UI
          setState(() {
            _isReplying = false;
            _replyingTo = null;
            _replyController.clear();
          });
        } else if (mounted) {
          // Show error if reply creation failed
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(
              content: Text(discussionProvider.error ?? 'Failed to post reply'),
              backgroundColor: Colors.red,
            ),
          );
        }
      } catch (e) {
        // Remove loading dialog if still showing
        if (mounted) Navigator.pop(context);
        
        // Show error message
        if (mounted) {
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(
              content: Text('Error posting reply: $e'),
              backgroundColor: Colors.red,
            ),
          );
        }
      }
    }
  }

  void _showPostOptions(BuildContext context) {
    showModalBottomSheet(
      context: context,
      builder: (context) => Column(
        mainAxisSize: MainAxisSize.min,
        children: [
          ListTile(
            leading: const Icon(Icons.bookmark_outline),
            title: const Text('Save Thread'),
            onTap: () {
              Navigator.pop(context);
              ScaffoldMessenger.of(context).showSnackBar(
                const SnackBar(content: Text('Thread saved')),
              );
            },
          ),
          ListTile(
            leading: const Icon(Icons.share_outlined),
            title: const Text('Share Thread'),
            onTap: () {
              Navigator.pop(context);
            },
          ),
          ListTile(
            leading: const Icon(Icons.flag_outlined),
            title: const Text('Report Thread'),
            onTap: () {
              Navigator.pop(context);
            },
          ),
        ],
      ),
    );
  }
}
````

## File: lib/features/discussions/presentation/widgets/create_board_dialog.dart
````dart
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import '../providers/discussion_provider.dart';

class CreateBoardDialog extends StatefulWidget {
  const CreateBoardDialog({super.key});

  @override
  State<CreateBoardDialog> createState() => _CreateBoardDialogState();
}

class _CreateBoardDialogState extends State<CreateBoardDialog> {
  final _formKey = GlobalKey<FormState>();
  final _titleController = TextEditingController();
  final _descriptionController = TextEditingController();
  final List<String> _selectedTags = [];
  bool _isPinned = false;

  final List<String> _availableTags = [
    'General',
    'Assignments',
    'Projects',
    'Resources',
    'Announcements',
    'Questions',
    'Study Group',
    'Events',
  ];

  @override
  void dispose() {
    _titleController.dispose();
    _descriptionController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return AlertDialog(
      title: const Text('Create Discussion Board'),
      content: Form(
        key: _formKey,
        child: SingleChildScrollView(
          child: Column(
            mainAxisSize: MainAxisSize.min,
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              TextFormField(
                controller: _titleController,
                decoration: const InputDecoration(
                  labelText: 'Board Title',
                  hintText: 'e.g., General Discussion',
                ),
                validator: (value) {
                  if (value == null || value.isEmpty) {
                    return 'Please enter a title';
                  }
                  return null;
                },
                textCapitalization: TextCapitalization.words,
              ),
              const SizedBox(height: 16),
              TextFormField(
                controller: _descriptionController,
                decoration: const InputDecoration(
                  labelText: 'Description',
                  hintText: 'Brief description of the board purpose',
                ),
                maxLines: 3,
                validator: (value) {
                  if (value == null || value.isEmpty) {
                    return 'Please enter a description';
                  }
                  return null;
                },
              ),
              const SizedBox(height: 16),
              Text(
                'Tags',
                style: Theme.of(context).textTheme.titleSmall,
              ),
              const SizedBox(height: 8),
              Wrap(
                spacing: 8,
                runSpacing: 8,
                children: _availableTags.map((tag) {
                  final isSelected = _selectedTags.contains(tag);
                  return FilterChip(
                    label: Text(tag),
                    selected: isSelected,
                    onSelected: (selected) {
                      setState(() {
                        if (selected) {
                          _selectedTags.add(tag);
                        } else {
                          _selectedTags.remove(tag);
                        }
                      });
                    },
                  );
                }).toList(),
              ),
              const SizedBox(height: 16),
              CheckboxListTile(
                title: const Text('Pin this board'),
                subtitle: const Text('Pinned boards appear at the top'),
                value: _isPinned,
                onChanged: (value) {
                  setState(() {
                    _isPinned = value ?? false;
                  });
                },
                contentPadding: EdgeInsets.zero,
              ),
            ],
          ),
        ),
      ),
      actions: [
        TextButton(
          onPressed: () => Navigator.pop(context),
          child: const Text('Cancel'),
        ),
        FilledButton(
          onPressed: _createBoard,
          child: const Text('Create'),
        ),
      ],
    );
  }

  void _createBoard() async {
    if (_formKey.currentState!.validate()) {
      final provider = context.read<DiscussionProvider>();
      
      showDialog(
        context: context,
        barrierDismissible: false,
        builder: (context) => const Center(
          child: CircularProgressIndicator(),
        ),
      );

      final boardId = await provider.createBoard(
        title: _titleController.text.trim(),
        description: _descriptionController.text.trim(),
        tags: _selectedTags,
        isPinned: _isPinned,
      );

      if (mounted) {
        Navigator.pop(context); // Close loading dialog
        Navigator.pop(context); // Close create dialog
        
        if (boardId != null) {
          ScaffoldMessenger.of(context).showSnackBar(
            const SnackBar(
              content: Text('Discussion board created successfully'),
            ),
          );
        } else {
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(
              content: Text('Failed to create board: ${provider.error}'),
              backgroundColor: Colors.red,
            ),
          );
        }
      }
    }
  }
}
````

## File: lib/features/discussions/presentation/widgets/create_thread_dialog.dart
````dart
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import '../providers/discussion_provider.dart';

class CreateThreadDialog extends StatefulWidget {
  final String boardId;

  const CreateThreadDialog({
    super.key,
    required this.boardId,
  });

  @override
  State<CreateThreadDialog> createState() => _CreateThreadDialogState();
}

class _CreateThreadDialogState extends State<CreateThreadDialog> {
  final _formKey = GlobalKey<FormState>();
  final _titleController = TextEditingController();
  final _contentController = TextEditingController();
  final List<String> _selectedTags = [];

  final List<String> _availableTags = [
    'Question',
    'Discussion',
    'Resource',
    'Help Needed',
    'Announcement',
    'Tips',
  ];

  @override
  void dispose() {
    _titleController.dispose();
    _contentController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return Dialog(
      child: Container(
        constraints: const BoxConstraints(maxWidth: 600),
        padding: const EdgeInsets.all(24),
        child: Form(
          key: _formKey,
          child: SingleChildScrollView(
            child: Column(
              mainAxisSize: MainAxisSize.min,
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Text(
                  'Start New Thread',
                  style: Theme.of(context).textTheme.headlineSmall,
                ),
                const SizedBox(height: 24),
                TextFormField(
                  controller: _titleController,
                  decoration: const InputDecoration(
                    labelText: 'Thread Title',
                    hintText: 'Give your thread a descriptive title',
                    border: OutlineInputBorder(),
                  ),
                  validator: (value) {
                    if (value == null || value.isEmpty) {
                      return 'Please enter a title';
                    }
                    return null;
                  },
                  textCapitalization: TextCapitalization.sentences,
                ),
                const SizedBox(height: 16),
                TextFormField(
                  controller: _contentController,
                  decoration: const InputDecoration(
                    labelText: 'Content',
                    hintText: 'Write your message here...',
                    border: OutlineInputBorder(),
                    alignLabelWithHint: true,
                  ),
                  maxLines: 8,
                  validator: (value) {
                    if (value == null || value.isEmpty) {
                      return 'Please enter content';
                    }
                    return null;
                  },
                ),
                const SizedBox(height: 16),
                Text(
                  'Tags (Optional)',
                  style: Theme.of(context).textTheme.titleSmall,
                ),
                const SizedBox(height: 8),
                Wrap(
                  spacing: 8,
                  runSpacing: 8,
                  children: _availableTags.map((tag) {
                    final isSelected = _selectedTags.contains(tag);
                    return FilterChip(
                      label: Text(tag),
                      selected: isSelected,
                      onSelected: (selected) {
                        setState(() {
                          if (selected) {
                            _selectedTags.add(tag);
                          } else {
                            _selectedTags.remove(tag);
                          }
                        });
                      },
                    );
                  }).toList(),
                ),
                const SizedBox(height: 24),
                Row(
                  mainAxisAlignment: MainAxisAlignment.end,
                  children: [
                    TextButton(
                      onPressed: () => Navigator.pop(context),
                      child: const Text('Cancel'),
                    ),
                    const SizedBox(width: 8),
                    FilledButton(
                      onPressed: _createThread,
                      child: const Text('Post Thread'),
                    ),
                  ],
                ),
              ],
            ),
          ),
        ),
      ),
    );
  }

  void _createThread() async {
    if (_formKey.currentState!.validate()) {
      final discussionProvider = context.read<DiscussionProvider>();
      
      // Show loading dialog
      showDialog(
        context: context,
        barrierDismissible: false,
        builder: (context) => const Center(
          child: CircularProgressIndicator(),
        ),
      );
      
      try {
        // Create the thread with the provided information
        final threadId = await discussionProvider.createThread(
          boardId: widget.boardId,
          title: _titleController.text.trim(),
          content: _contentController.text.trim(),
          tags: _selectedTags,
        );
        
        // Remove loading dialog
        if (mounted) Navigator.pop(context);
        
        if (threadId != null && mounted) {
          // Close the dialog
          Navigator.pop(context);
          
          // Show success message
          ScaffoldMessenger.of(context).showSnackBar(
            const SnackBar(
              content: Text('Thread posted successfully'),
              backgroundColor: Colors.green,
            ),
          );
        } else if (mounted) {
          // Show error if thread creation failed
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(
              content: Text(discussionProvider.error ?? 'Failed to create thread'),
              backgroundColor: Colors.red,
            ),
          );
        }
      } catch (e) {
        // Remove loading dialog if still showing
        if (mounted) Navigator.pop(context);
        
        // Show error message
        if (mounted) {
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(
              content: Text('Error creating thread: $e'),
              backgroundColor: Colors.red,
            ),
          );
        }
      }
    }
  }
}
````

## File: lib/features/games/domain/models/jeopardy_game.dart
````dart
/// Models for Jeopardy game functionality
library;

class JeopardyGame {
  final String id;
  final String title;
  final String teacherId;
  final List<JeopardyCategory> categories;
  final FinalJeopardyData? finalJeopardy;
  final DateTime createdAt;
  final DateTime updatedAt;
  final bool isPublic;

  JeopardyGame({
    required this.id,
    required this.title,
    required this.teacherId,
    required this.categories,
    this.finalJeopardy,
    required this.createdAt,
    required this.updatedAt,
    this.isPublic = false,
  });

  factory JeopardyGame.empty() => JeopardyGame(
    id: '',
    title: 'New Jeopardy Game',
    teacherId: '',
    categories: [],
    createdAt: DateTime.now(),
    updatedAt: DateTime.now(),
  );

  Map<String, dynamic> toFirestore() => {
    'title': title,
    'teacherId': teacherId,
    'categories': categories.map((c) => c.toJson()).toList(),
    'finalJeopardy': finalJeopardy?.toJson(),
    'createdAt': createdAt.toIso8601String(),
    'updatedAt': updatedAt.toIso8601String(),
    'isPublic': isPublic,
  };
}

class JeopardyCategory {
  final String name;
  final List<JeopardyQuestion> questions;

  JeopardyCategory({
    required this.name,
    required this.questions,
  });

  Map<String, dynamic> toJson() => {
    'name': name,
    'questions': questions.map((q) => q.toJson()).toList(),
  };

  factory JeopardyCategory.fromJson(Map<String, dynamic> json) => JeopardyCategory(
    name: json['name'],
    questions: (json['questions'] as List)
        .map((q) => JeopardyQuestion.fromJson(q))
        .toList(),
  );
}

class JeopardyQuestion {
  final String question;
  final String answer;
  final int points;
  final bool isAnswered;
  final String? answeredBy;
  final bool isDailyDouble;

  JeopardyQuestion({
    required this.question,
    required this.answer,
    required this.points,
    this.isAnswered = false,
    this.answeredBy,
    this.isDailyDouble = false,
  });

  JeopardyQuestion copyWith({
    String? question,
    String? answer,
    int? points,
    bool? isAnswered,
    String? answeredBy,
    bool? isDailyDouble,
  }) => JeopardyQuestion(
    question: question ?? this.question,
    answer: answer ?? this.answer,
    points: points ?? this.points,
    isAnswered: isAnswered ?? this.isAnswered,
    answeredBy: answeredBy ?? this.answeredBy,
    isDailyDouble: isDailyDouble ?? this.isDailyDouble,
  );

  Map<String, dynamic> toJson() => {
    'question': question,
    'answer': answer,
    'points': points,
    'isAnswered': isAnswered,
    'answeredBy': answeredBy,
    'isDailyDouble': isDailyDouble,
  };

  factory JeopardyQuestion.fromJson(Map<String, dynamic> json) => JeopardyQuestion(
    question: json['question'],
    answer: json['answer'],
    points: json['points'],
    isAnswered: json['isAnswered'] ?? false,
    answeredBy: json['answeredBy'],
    isDailyDouble: json['isDailyDouble'] ?? false,
  );
}

class JeopardyPlayer {
  final String id;
  String name;
  int score;

  JeopardyPlayer({
    required this.id,
    required this.name,
    this.score = 0,
  });
}

class FinalJeopardyData {
  final String category;
  final String question;
  final String answer;

  FinalJeopardyData({
    required this.category,
    required this.question,
    required this.answer,
  });

  Map<String, dynamic> toJson() => {
    'category': category,
    'question': question,
    'answer': answer,
  };

  factory FinalJeopardyData.fromJson(Map<String, dynamic> json) => FinalJeopardyData(
    category: json['category'],
    question: json['question'],
    answer: json['answer'],
  );
}
````

## File: lib/features/games/presentation/screens/jeopardy_create_screen.dart
````dart
import 'package:flutter/material.dart';
import 'package:go_router/go_router.dart';
import 'package:provider/provider.dart';
import '../../domain/models/jeopardy_game.dart';
import '../../../../shared/widgets/common/adaptive_layout.dart';
import '../providers/jeopardy_provider.dart';
import '../../../auth/presentation/providers/auth_provider.dart';

class JeopardyCreateScreen extends StatefulWidget {
  final String? gameId;
  
  const JeopardyCreateScreen({
    super.key,
    this.gameId,
  });

  @override
  State<JeopardyCreateScreen> createState() => _JeopardyCreateScreenState();
}

class _JeopardyCreateScreenState extends State<JeopardyCreateScreen> {
  final _formKey = GlobalKey<FormState>();
  final _titleController = TextEditingController();
  late JeopardyGame _game;
  bool _isEditing = false;
  bool _isLoading = false;

  @override
  void initState() {
    super.initState();
    _isEditing = widget.gameId != null;
    _loadOrCreateGame();
  }

  void _loadOrCreateGame() async {
    final authProvider = context.read<AuthProvider>();
    final jeopardyProvider = context.read<JeopardyProvider>();
    final currentUserId = authProvider.userModel?.uid ?? '';
    
    if (_isEditing) {
      // Load existing game from Firebase
      final loadedGame = await jeopardyProvider.loadGame(widget.gameId!);
      if (loadedGame != null) {
        setState(() {
          _game = loadedGame;
          _titleController.text = _game.title;
        });
      } else {
        // Handle error - game not found
        if (mounted) {
          ScaffoldMessenger.of(context).showSnackBar(
            const SnackBar(content: Text('Game not found')),
          );
          context.pop();
        }
      }
    } else {
      // Create new game with default structure
      _game = JeopardyGame(
        id: '',
        title: '',
        teacherId: currentUserId,
        categories: [
          JeopardyCategory(
            name: 'Category 1',
            questions: List.generate(5, (index) => JeopardyQuestion(
              question: '',
              answer: '',
              points: (index + 1) * 100,
            )),
          ),
        ],
        createdAt: DateTime.now(),
        updatedAt: DateTime.now(),
      );
    }
  }

  @override
  void dispose() {
    _titleController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);

    return AdaptiveLayout(
      title: _isEditing ? 'Edit Jeopardy Game' : 'Create Jeopardy Game',
      showBackButton: true,
      actions: [
        TextButton(
          onPressed: _isLoading ? null : _saveGame,
          child: _isLoading 
              ? const SizedBox(
                  width: 20,
                  height: 20,
                  child: CircularProgressIndicator(strokeWidth: 2),
                )
              : const Text('Save'),
        ),
      ],
      body: Form(
        key: _formKey,
        child: ListView(
          padding: const EdgeInsets.all(16),
          children: [
            // Game Title
            TextFormField(
              controller: _titleController,
              decoration: const InputDecoration(
                labelText: 'Game Title',
                hintText: 'Enter a title for your Jeopardy game',
                border: OutlineInputBorder(),
              ),
              validator: (value) {
                if (value == null || value.isEmpty) {
                  return 'Please enter a game title';
                }
                return null;
              },
            ),
            const SizedBox(height: 24),
            
            // Categories
            Row(
              mainAxisAlignment: MainAxisAlignment.spaceBetween,
              children: [
                Text(
                  'Categories',
                  style: theme.textTheme.titleLarge,
                ),
                FilledButton.icon(
                  onPressed: _addCategory,
                  icon: const Icon(Icons.add),
                  label: const Text('Add Category'),
                ),
              ],
            ),
            const SizedBox(height: 16),
            
            // Category List
            ..._game.categories.asMap().entries.map((entry) {
              final index = entry.key;
              final category = entry.value;
              return _buildCategorySection(index, category);
            }),
          ],
        ),
      ),
    );
  }

  Widget _buildCategorySection(int categoryIndex, JeopardyCategory category) {
    return Card(
      margin: const EdgeInsets.only(bottom: 16),
      child: Padding(
        padding: const EdgeInsets.all(16),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            // Category header
            Row(
              children: [
                Expanded(
                  child: TextFormField(
                    initialValue: category.name,
                    decoration: InputDecoration(
                      labelText: 'Category Name',
                      border: const OutlineInputBorder(),
                      suffixIcon: IconButton(
                        icon: const Icon(Icons.delete),
                        onPressed: _game.categories.length > 1
                            ? () => _removeCategory(categoryIndex)
                            : null,
                      ),
                    ),
                    onChanged: (value) {
                      setState(() {
                        _game.categories[categoryIndex] = JeopardyCategory(
                          name: value,
                          questions: category.questions,
                        );
                      });
                    },
                  ),
                ),
              ],
            ),
            const SizedBox(height: 16),
            
            // Questions
            ...category.questions.asMap().entries.map((entry) {
              final questionIndex = entry.key;
              final question = entry.value;
              return _buildQuestionRow(categoryIndex, questionIndex, question);
            }),
          ],
        ),
      ),
    );
  }

  Widget _buildQuestionRow(int categoryIndex, int questionIndex, JeopardyQuestion question) {
    final theme = Theme.of(context);
    
    return Container(
      margin: const EdgeInsets.only(bottom: 12),
      padding: const EdgeInsets.all(12),
      decoration: BoxDecoration(
        color: theme.colorScheme.surfaceContainerHighest,
        borderRadius: BorderRadius.circular(8),
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          // Points value
          Container(
            padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 4),
            decoration: BoxDecoration(
              color: theme.colorScheme.primaryContainer,
              borderRadius: BorderRadius.circular(12),
            ),
            child: Text(
              '\$${question.points}',
              style: theme.textTheme.titleSmall?.copyWith(
                color: theme.colorScheme.onPrimaryContainer,
                fontWeight: FontWeight.bold,
              ),
            ),
          ),
          const SizedBox(height: 8),
          
          // Question field
          TextFormField(
            initialValue: question.question,
            decoration: const InputDecoration(
              labelText: 'Question/Clue',
              hintText: 'Enter the question or clue',
              border: OutlineInputBorder(),
            ),
            maxLines: 2,
            onChanged: (value) => _updateQuestion(
              categoryIndex,
              questionIndex,
              question.copyWith(question: value),
            ),
          ),
          const SizedBox(height: 8),
          
          // Answer field
          TextFormField(
            initialValue: question.answer,
            decoration: const InputDecoration(
              labelText: 'Answer',
              hintText: 'Enter the answer (in Jeopardy format)',
              border: OutlineInputBorder(),
              helperText: 'Format: "Who is..." or "What is..."',
            ),
            onChanged: (value) => _updateQuestion(
              categoryIndex,
              questionIndex,
              question.copyWith(answer: value),
            ),
          ),
        ],
      ),
    );
  }

  void _updateQuestion(int categoryIndex, int questionIndex, JeopardyQuestion newQuestion) {
    setState(() {
      final category = _game.categories[categoryIndex];
      final updatedQuestions = List<JeopardyQuestion>.from(category.questions);
      updatedQuestions[questionIndex] = newQuestion;
      
      _game.categories[categoryIndex] = JeopardyCategory(
        name: category.name,
        questions: updatedQuestions,
      );
    });
  }

  void _addCategory() {
    if (_game.categories.length >= 6) {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(content: Text('Maximum 6 categories allowed')),
      );
      return;
    }
    
    setState(() {
      _game.categories.add(
        JeopardyCategory(
          name: 'Category ${_game.categories.length + 1}',
          questions: List.generate(5, (index) => JeopardyQuestion(
            question: '',
            answer: '',
            points: (index + 1) * 100,
          )),
        ),
      );
    });
  }

  void _removeCategory(int index) {
    setState(() {
      _game.categories.removeAt(index);
    });
  }

  void _saveGame() async {
    if (_formKey.currentState!.validate()) {
      // Validate all questions have content
      bool hasEmptyQuestions = false;
      for (final category in _game.categories) {
        if (category.name.isEmpty) {
          hasEmptyQuestions = true;
          break;
        }
        for (final question in category.questions) {
          if (question.question.isEmpty || question.answer.isEmpty) {
            hasEmptyQuestions = true;
            break;
          }
        }
      }
      
      if (hasEmptyQuestions) {
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(
            content: Text('Please fill in all categories, questions, and answers'),
          ),
        );
        return;
      }
      
      setState(() {
        _isLoading = true;
      });
      
      final jeopardyProvider = context.read<JeopardyProvider>();
      
      // Prepare game data
      _game = JeopardyGame(
        id: _game.id,
        title: _titleController.text,
        teacherId: _game.teacherId,
        categories: _game.categories,
        createdAt: _game.createdAt,
        updatedAt: DateTime.now(),
        isPublic: _game.isPublic,
      );
      
      // Save to Firebase
      bool success = false;
      if (_isEditing) {
        success = await jeopardyProvider.updateGame(_game.id, _game);
      } else {
        final gameId = await jeopardyProvider.createGame(_game);
        success = gameId != null;
      }
      
      setState(() {
        _isLoading = false;
      });
      
      if (success) {
        if (mounted) {
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(
              content: Text(_isEditing ? 'Game updated!' : 'Game created!'),
            ),
          );
          context.pop();
        }
      } else {
        if (mounted) {
          ScaffoldMessenger.of(context).showSnackBar(
            const SnackBar(
              content: Text('Failed to save game. Please try again.'),
              backgroundColor: Colors.red,
            ),
          );
        }
      }
    }
  }
}
````

## File: lib/features/games/presentation/screens/jeopardy_play_screen.dart
````dart
import 'dart:math';
import 'package:flutter/material.dart';
import 'package:go_router/go_router.dart';
import 'package:provider/provider.dart';
import '../../domain/models/jeopardy_game.dart';
import '../providers/jeopardy_provider.dart';

class JeopardyPlayScreen extends StatefulWidget {
  final String gameId;
  
  const JeopardyPlayScreen({
    super.key,
    required this.gameId,
  });

  @override
  State<JeopardyPlayScreen> createState() => _JeopardyPlayScreenState();
}

class _JeopardyPlayScreenState extends State<JeopardyPlayScreen> {
  JeopardyGame? _game;
  final List<JeopardyPlayer> _players = [];
  JeopardyQuestion? _selectedQuestion;
  JeopardyCategory? _selectedCategory;
  JeopardyPlayer? _currentPlayer;
  bool _showingAnswer = false;
  bool _gameStarted = false;
  bool _isLoading = true;
  final Map<String, int> _finalJeopardyWagers = {};
  final Map<String, String> _finalJeopardyAnswers = {};
  bool _showingDailyDouble = false;
  int _dailyDoubleWager = 0;
  JeopardyPlayer? _dailyDoublePlayer;

  @override
  void initState() {
    super.initState();
    _loadGame();
    _initializePlayers();
  }

  void _loadGame() async {
    final jeopardyProvider = context.read<JeopardyProvider>();
    final loadedGame = await jeopardyProvider.loadGame(widget.gameId);
    
    if (loadedGame != null) {
      setState(() {
        _game = loadedGame;
        _isLoading = false;
      });
    } else {
      // Handle error - game not found
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(content: Text('Game not found')),
        );
        context.pop();
      }
    }
  }

  void _initializePlayers() {
    // Don't auto-add players - let users set them up
  }

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    
    if (_isLoading) {
      return Scaffold(
        backgroundColor: theme.colorScheme.surface,
        body: const Center(
          child: CircularProgressIndicator(),
        ),
      );
    }
    
    if (_game == null) {
      return Scaffold(
        backgroundColor: theme.colorScheme.surface,
        body: Center(
          child: Column(
            mainAxisAlignment: MainAxisAlignment.center,
            children: [
              const Icon(Icons.error_outline, size: 64, color: Colors.red),
              const SizedBox(height: 16),
              const Text('Failed to load game'),
              const SizedBox(height: 16),
              FilledButton(
                onPressed: () => context.pop(),
                child: const Text('Go Back'),
              ),
            ],
          ),
        ),
      );
    }
    
    return Scaffold(
      backgroundColor: theme.colorScheme.surface,
      body: _gameStarted ? _buildGameScreen() : _buildSetupScreen(),
    );
  }

  Widget _buildSetupScreen() {
    final theme = Theme.of(context);
    
    return SafeArea(
      child: Padding(
        padding: const EdgeInsets.all(24),
        child: Column(
          children: [
            // Header
            Row(
              children: [
                IconButton(
                  onPressed: () => context.pop(),
                  icon: const Icon(Icons.arrow_back),
                ),
                Expanded(
                  child: Text(
                    'Game Setup',
                    style: theme.textTheme.headlineMedium,
                    textAlign: TextAlign.center,
                  ),
                ),
                const SizedBox(width: 48),
              ],
            ),
            const SizedBox(height: 32),
            
            // Game title
            Text(
              _game?.title ?? '',
              style: theme.textTheme.headlineSmall,
              textAlign: TextAlign.center,
            ),
            const SizedBox(height: 32),
            
            // Players setup
            Row(
              mainAxisAlignment: MainAxisAlignment.spaceBetween,
              children: [
                Text(
                  'Teams/Players',
                  style: theme.textTheme.titleLarge,
                ),
                FilledButton.icon(
                  onPressed: _addPlayer,
                  icon: const Icon(Icons.add),
                  label: const Text('Add Team'),
                ),
              ],
            ),
            const SizedBox(height: 16),
            
            // Player list
            Expanded(
              child: _players.isEmpty
                  ? Center(
                      child: Text(
                        'Add at least 2 teams to start',
                        style: theme.textTheme.bodyLarge?.copyWith(
                          color: theme.colorScheme.onSurfaceVariant,
                        ),
                      ),
                    )
                  : ListView.builder(
                      itemCount: _players.length,
                      itemBuilder: (context, index) => _buildPlayerSetupTile(_players[index]),
                    ),
            ),
            
            // Start button
            SizedBox(
              width: double.infinity,
              child: FilledButton(
                onPressed: _players.length >= 2 ? _startGame : null,
                child: const Text('Start Game'),
              ),
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildPlayerSetupTile(JeopardyPlayer player) {
    return Card(
      margin: const EdgeInsets.only(bottom: 12),
      child: ListTile(
        leading: CircleAvatar(
          backgroundColor: _getPlayerColor(player.id),
          child: Text(
            player.name.isNotEmpty ? player.name[0].toUpperCase() : '?',
            style: TextStyle(color: Colors.white),
          ),
        ),
        title: TextFormField(
          initialValue: player.name,
          decoration: const InputDecoration(
            hintText: 'Team name',
            border: InputBorder.none,
          ),
          onChanged: (value) {
            setState(() {
              player.name = value;
            });
          },
        ),
        trailing: IconButton(
          icon: const Icon(Icons.delete),
          onPressed: () => _removePlayer(player),
        ),
      ),
    );
  }

  Color _getPlayerColor(String playerId) {
    final colors = [
      Colors.red,
      Colors.blue,
      Colors.green,
      Colors.orange,
      Colors.purple,
      Colors.teal,
    ];
    final index = _players.indexWhere((p) => p.id == playerId);
    return colors[index % colors.length];
  }

  void _addPlayer() {
    if (_players.length >= 6) {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(content: Text('Maximum 6 teams allowed')),
      );
      return;
    }
    
    setState(() {
      _players.add(JeopardyPlayer(
        id: DateTime.now().millisecondsSinceEpoch.toString(),
        name: 'Team ${_players.length + 1}',
      ));
    });
  }

  void _removePlayer(JeopardyPlayer player) {
    setState(() {
      _players.remove(player);
    });
  }

  void _startGame() {
    if (_players.any((p) => p.name.trim().isEmpty)) {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(content: Text('Please enter names for all teams')),
      );
      return;
    }
    
    setState(() {
      _gameStarted = true;
      _currentPlayer = _players.first;
    });
  }

  Widget _buildGameScreen() {
    final theme = Theme.of(context);
    
    return Stack(
      children: [
        // Main game board
        Column(
          children: [
              // Header with game title and controls
              Container(
                padding: const EdgeInsets.all(16),
                decoration: BoxDecoration(
                  color: theme.colorScheme.surfaceContainerHighest,
                  boxShadow: [
                    BoxShadow(
                      color: Colors.black.withValues(alpha: 0.1),
                      blurRadius: 4,
                      offset: const Offset(0, 2),
                    ),
                  ],
                ),
                child: SafeArea(
                  child: Row(
                    children: [
                      IconButton(
                        onPressed: () => context.pop(),
                        icon: const Icon(Icons.close),
                      ),
                      Expanded(
                        child: Text(
                          _game?.title ?? '',
                          style: theme.textTheme.headlineSmall,
                          textAlign: TextAlign.center,
                        ),
                      ),
                      IconButton(
                        onPressed: _showScoreboard,
                        icon: const Icon(Icons.leaderboard),
                      ),
                    ],
                  ),
                ),
              ),
              
              // Game board
              Expanded(
                child: Padding(
                  padding: const EdgeInsets.all(16),
                  child: _buildGameBoard(),
                ),
              ),
              
              // Player scores
              Container(
                padding: const EdgeInsets.all(16),
                decoration: BoxDecoration(
                  color: theme.colorScheme.surfaceContainerHighest,
                  boxShadow: [
                    BoxShadow(
                      color: Colors.black.withValues(alpha: 0.1),
                      blurRadius: 4,
                      offset: const Offset(0, -2),
                    ),
                  ],
                ),
                child: _buildPlayerScores(),
              ),
            ],
          ),
          
          // Question overlay
          if (_selectedQuestion != null)
            _buildQuestionOverlay(),
        ],
      );
  }

  Widget _buildGameBoard() {
    final theme = Theme.of(context);
    
    return Column(
      children: [
        // Category headers row
        SizedBox(
          height: 80,
          child: Row(
            children: (_game?.categories ?? []).map((category) => Expanded(
              child: Container(
                margin: const EdgeInsets.symmetric(horizontal: 4),
                decoration: BoxDecoration(
                  color: theme.colorScheme.primary,
                  borderRadius: BorderRadius.circular(8),
                ),
                child: Center(
                  child: Padding(
                    padding: const EdgeInsets.all(8),
                    child: Text(
                      category.name.toUpperCase(),
                      style: theme.textTheme.titleMedium?.copyWith(
                        color: theme.colorScheme.onPrimary,
                        fontWeight: FontWeight.bold,
                      ),
                      textAlign: TextAlign.center,
                    ),
                  ),
                ),
              ),
            )).toList(),
          ),
        ),
        const SizedBox(height: 8),
        
        // Questions grid
        Expanded(
          child: Row(
            children: (_game?.categories ?? []).map((category) => Expanded(
              child: Column(
                children: category.questions.map((question) => Expanded(
                  child: Container(
                    margin: const EdgeInsets.all(4),
                    child: _buildQuestionTile(category, question),
                  ),
                )).toList(),
              ),
            )).toList(),
          ),
        ),
      ],
    );
  }

  Widget _buildQuestionTile(JeopardyCategory category, JeopardyQuestion question) {
    final theme = Theme.of(context);
    final isAnswered = question.isAnswered;
    
    return Material(
      color: isAnswered
          ? theme.colorScheme.surfaceContainerHighest
          : theme.colorScheme.primaryContainer,
      borderRadius: BorderRadius.circular(8),
      child: InkWell(
        onTap: isAnswered ? null : () => _selectQuestion(category, question),
        borderRadius: BorderRadius.circular(8),
        child: Container(
          decoration: BoxDecoration(
            borderRadius: BorderRadius.circular(8),
            border: Border.all(
              color: isAnswered
                  ? theme.colorScheme.outline.withValues(alpha: 0.3)
                  : theme.colorScheme.primary,
              width: 2,
            ),
          ),
          child: Center(
            child: Text(
              isAnswered ? '' : '\$${question.points}',
              style: theme.textTheme.headlineMedium?.copyWith(
                color: isAnswered
                    ? theme.colorScheme.onSurfaceVariant.withValues(alpha: 0.3)
                    : theme.colorScheme.onPrimaryContainer,
                fontWeight: FontWeight.bold,
              ),
            ),
          ),
        ),
      ),
    );
  }

  Widget _buildPlayerScores() {
    final theme = Theme.of(context);
    
    return Row(
      mainAxisAlignment: MainAxisAlignment.spaceEvenly,
      children: _players.map((player) {
        final isCurrentPlayer = player == _currentPlayer;
        
        return Expanded(
          child: Container(
            margin: const EdgeInsets.symmetric(horizontal: 4),
            padding: const EdgeInsets.all(12),
            decoration: BoxDecoration(
              color: isCurrentPlayer
                  ? theme.colorScheme.primaryContainer
                  : theme.colorScheme.surfaceContainer,
              borderRadius: BorderRadius.circular(8),
              border: Border.all(
                color: isCurrentPlayer
                    ? theme.colorScheme.primary
                    : theme.colorScheme.outline.withValues(alpha: 0.3),
                width: 2,
              ),
            ),
            child: Column(
              children: [
                Text(
                  player.name,
                  style: theme.textTheme.titleSmall?.copyWith(
                    fontWeight: isCurrentPlayer ? FontWeight.bold : FontWeight.normal,
                  ),
                ),
                const SizedBox(height: 4),
                Text(
                  '\$${player.score}',
                  style: theme.textTheme.headlineSmall?.copyWith(
                    color: player.score < 0 ? theme.colorScheme.error : null,
                    fontWeight: FontWeight.bold,
                  ),
                ),
              ],
            ),
          ),
        );
      }).toList(),
    );
  }

  Widget _buildQuestionOverlay() {
    final theme = Theme.of(context);
    
    if (_showingDailyDouble && !_showingAnswer) {
      return _buildDailyDoubleOverlay();
    }
    
    return Container(
      color: Colors.black.withValues(alpha: 0.9),
      child: Center(
        child: Container(
          margin: const EdgeInsets.all(32),
          padding: const EdgeInsets.all(32),
          decoration: BoxDecoration(
            color: theme.colorScheme.primary,
            borderRadius: BorderRadius.circular(16),
          ),
          child: Column(
            mainAxisSize: MainAxisSize.min,
            children: [
              // Close button
              Row(
                mainAxisAlignment: MainAxisAlignment.end,
                children: [
                  IconButton(
                    onPressed: _closeQuestion,
                    icon: const Icon(Icons.close),
                    style: IconButton.styleFrom(
                      foregroundColor: theme.colorScheme.onPrimary,
                    ),
                  ),
                ],
              ),
              
              // Points value (or wager for Daily Double)
              Text(
                _selectedQuestion!.isDailyDouble && _dailyDoubleWager > 0
                    ? '\$$_dailyDoubleWager'
                    : '\$${_selectedQuestion!.points}',
                style: theme.textTheme.displaySmall?.copyWith(
                  color: theme.colorScheme.onPrimary,
                  fontWeight: FontWeight.bold,
                ),
              ),
              const SizedBox(height: 24),
              
              // Question or Answer
              Text(
                _showingAnswer ? _selectedQuestion!.answer : _selectedQuestion!.question,
                style: theme.textTheme.headlineMedium?.copyWith(
                  color: theme.colorScheme.onPrimary,
                ),
                textAlign: TextAlign.center,
              ),
              const SizedBox(height: 32),
              
              // Action buttons
              if (!_showingAnswer) ...[
                FilledButton.tonal(
                  onPressed: _showAnswer,
                  child: const Text('Show Answer'),
                ),
              ] else ...[
                Text(
                  _selectedQuestion!.isDailyDouble
                      ? 'Did ${_dailyDoublePlayer!.name} get it right?'
                      : 'Who got it right?',
                  style: theme.textTheme.titleMedium?.copyWith(
                    color: theme.colorScheme.onPrimary,
                  ),
                ),
                const SizedBox(height: 16),
                if (_selectedQuestion!.isDailyDouble) ...[
                  Row(
                    mainAxisAlignment: MainAxisAlignment.center,
                    children: [
                      FilledButton.tonal(
                        onPressed: () => _scoreDailyDouble(true),
                        style: FilledButton.styleFrom(
                          backgroundColor: Colors.green,
                          foregroundColor: Colors.white,
                        ),
                        child: const Text('Correct'),
                      ),
                      const SizedBox(width: 16),
                      FilledButton.tonal(
                        onPressed: () => _scoreDailyDouble(false),
                        style: FilledButton.styleFrom(
                          backgroundColor: Colors.red,
                          foregroundColor: Colors.white,
                        ),
                        child: const Text('Incorrect'),
                      ),
                    ],
                  ),
                ] else ...[
                  Wrap(
                    spacing: 8,
                    runSpacing: 8,
                    children: [
                      ..._players.map((player) => FilledButton.tonal(
                        onPressed: () => _awardPoints(player),
                        style: FilledButton.styleFrom(
                          backgroundColor: _getPlayerColor(player.id),
                          foregroundColor: Colors.white,
                        ),
                        child: Text(player.name),
                      )),
                      OutlinedButton(
                        onPressed: () => _scoreQuestion(false),
                        style: OutlinedButton.styleFrom(
                          foregroundColor: theme.colorScheme.onPrimary,
                          side: BorderSide(color: theme.colorScheme.onPrimary),
                        ),
                        child: const Text('No one'),
                      ),
                    ],
                  ),
                ],
              ],
            ],
          ),
        ),
      ),
    );
  }

  void _selectQuestion(JeopardyCategory category, JeopardyQuestion question) {
    setState(() {
      _selectedQuestion = question;
      _selectedCategory = category;
      _showingAnswer = false;
      
      // Check if it's a Daily Double
      if (question.isDailyDouble && !_showingDailyDouble) {
        _showingDailyDouble = true;
        // The player who selected the Daily Double (current player with control) is the one who wagers
        _dailyDoublePlayer = _currentPlayer;
        _dailyDoubleWager = 0;
      }
    });
  }

  void _showAnswer() {
    setState(() {
      _showingAnswer = true;
    });
  }

  void _closeQuestion() {
    setState(() {
      _selectedQuestion = null;
      _selectedCategory = null;
      _showingAnswer = false;
      _showingDailyDouble = false;
      _dailyDoubleWager = 0;
      _dailyDoublePlayer = null;
    });
  }

  void _awardPoints(JeopardyPlayer player) {
    if (_selectedQuestion == null) return;
    
    setState(() {
      // Update score
      player.score += _selectedQuestion!.points;
      
      // Mark question as answered
      final categoryIndex = _game?.categories.indexOf(_selectedCategory!) ?? -1;
      if (categoryIndex != -1 && _game != null) {
        final questionIndex = _game!.categories[categoryIndex].questions.indexOf(_selectedQuestion!);
        _game!.categories[categoryIndex].questions[questionIndex] = _selectedQuestion!.copyWith(
          isAnswered: true,
          answeredBy: player.id,
        );
      }
      
      // Set current player for next selection
      _currentPlayer = player;
      
      // Close question overlay
      _selectedQuestion = null;
      _selectedCategory = null;
      _showingAnswer = false;
    });
    
    // Check if game is complete
    _checkGameComplete();
  }

  void _scoreQuestion(bool correct) {
    if (_selectedQuestion == null) return;
    
    setState(() {
      // Mark question as answered with no winner
      final categoryIndex = _game?.categories.indexOf(_selectedCategory!) ?? -1;
      if (categoryIndex != -1 && _game != null) {
        final questionIndex = _game!.categories[categoryIndex].questions.indexOf(_selectedQuestion!);
        _game!.categories[categoryIndex].questions[questionIndex] = _selectedQuestion!.copyWith(
          isAnswered: true,
          answeredBy: 'none',
        );
      }
      
      // Close question overlay
      _selectedQuestion = null;
      _selectedCategory = null;
      _showingAnswer = false;
    });
    
    // Check if game is complete
    _checkGameComplete();
  }

  void _checkGameComplete() {
    final allAnswered = _game?.categories.every(
      (cat) => cat.questions.every((q) => q.isAnswered),
    ) ?? false;
    
    if (allAnswered && _game?.finalJeopardy != null) {
      _startFinalJeopardy();
    } else if (allAnswered) {
      _showGameComplete();
    }
  }

  void _showGameComplete() {
    final winner = _players.reduce((a, b) => a.score > b.score ? a : b);
    
    showDialog(
      context: context,
      barrierDismissible: false,
      builder: (context) => AlertDialog(
        title: const Text('Game Complete!'),
        content: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            Text('Winner: ${winner.name} with \$${winner.score}!'),
            const SizedBox(height: 16),
            ...(_players..sort((a, b) => b.score.compareTo(a.score)))
                .map((player) => Padding(
                  padding: const EdgeInsets.symmetric(vertical: 4),
                  child: Text('${player.name}: \$${player.score}'),
                )),
          ],
        ),
        actions: [
          TextButton(
            onPressed: () {
              Navigator.of(context).pop();
              context.pop();
            },
            child: const Text('End Game'),
          ),
        ],
      ),
    );
  }

  void _showScoreboard() {
    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        title: const Text('Scoreboard'),
        content: Column(
          mainAxisSize: MainAxisSize.min,
          children: _players.map((player) => Padding(
            padding: const EdgeInsets.symmetric(vertical: 8),
            child: Row(
              mainAxisAlignment: MainAxisAlignment.spaceBetween,
              children: [
                Text(player.name),
                Text(
                  '\$${player.score}',
                  style: TextStyle(
                    fontWeight: FontWeight.bold,
                    color: player.score < 0 ? Theme.of(context).colorScheme.error : null,
                  ),
                ),
              ],
            ),
          )).toList(),
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.of(context).pop(),
            child: const Text('Close'),
          ),
        ],
      ),
    );
  }
  
  Widget _buildDailyDoubleOverlay() {
    final theme = Theme.of(context);
    final maxWager = max(_dailyDoublePlayer!.score, 1000);
    
    return Container(
      color: Colors.black.withValues(alpha: 0.9),
      child: Center(
        child: Container(
          margin: const EdgeInsets.all(32),
          padding: const EdgeInsets.all(32),
          decoration: BoxDecoration(
            color: theme.colorScheme.primary,
            borderRadius: BorderRadius.circular(16),
          ),
          child: Column(
            mainAxisSize: MainAxisSize.min,
            children: [
              Text(
                'DAILY DOUBLE!',
                style: theme.textTheme.displaySmall?.copyWith(
                  color: theme.colorScheme.onPrimary,
                  fontWeight: FontWeight.bold,
                ),
              ),
              const SizedBox(height: 24),
              Text(
                '${_dailyDoublePlayer!.name}, place your wager',
                style: theme.textTheme.headlineSmall?.copyWith(
                  color: theme.colorScheme.onPrimary,
                ),
              ),
              const SizedBox(height: 16),
              Text(
                'Current score: \$${_dailyDoublePlayer!.score}',
                style: theme.textTheme.titleMedium?.copyWith(
                  color: theme.colorScheme.onPrimary,
                ),
              ),
              Text(
                'Maximum wager: \$$maxWager',
                style: theme.textTheme.bodyLarge?.copyWith(
                  color: theme.colorScheme.onPrimary.withValues(alpha: 0.8),
                ),
              ),
              const SizedBox(height: 24),
              SizedBox(
                width: 200,
                child: TextFormField(
                  initialValue: _dailyDoubleWager.toString(),
                  keyboardType: TextInputType.number,
                  style: TextStyle(color: theme.colorScheme.onPrimary),
                  decoration: InputDecoration(
                    labelText: 'Wager',
                    labelStyle: TextStyle(color: theme.colorScheme.onPrimary),
                    enabledBorder: OutlineInputBorder(
                      borderSide: BorderSide(color: theme.colorScheme.onPrimary),
                    ),
                    focusedBorder: OutlineInputBorder(
                      borderSide: BorderSide(color: theme.colorScheme.onPrimary, width: 2),
                    ),
                  ),
                  onChanged: (value) {
                    final wager = int.tryParse(value) ?? 0;
                    setState(() {
                      _dailyDoubleWager = min(wager, maxWager);
                    });
                  },
                ),
              ),
              const SizedBox(height: 24),
              FilledButton.tonal(
                onPressed: _dailyDoubleWager > 0 ? _confirmDailyDoubleWager : null,
                child: const Text('Confirm Wager'),
              ),
            ],
          ),
        ),
      ),
    );
  }
  
  void _confirmDailyDoubleWager() {
    setState(() {
      _showingDailyDouble = false;
    });
  }
  
  void _scoreDailyDouble(bool correct) {
    if (_selectedQuestion == null || _dailyDoublePlayer == null) return;
    
    setState(() {
      // Update score
      if (correct) {
        _dailyDoublePlayer!.score += _dailyDoubleWager;
      } else {
        _dailyDoublePlayer!.score -= _dailyDoubleWager;
      }
      
      // Mark question as answered
      final categoryIndex = _game?.categories.indexOf(_selectedCategory!) ?? -1;
      if (categoryIndex != -1 && _game != null) {
        final questionIndex = _game!.categories[categoryIndex].questions.indexOf(_selectedQuestion!);
        _game!.categories[categoryIndex].questions[questionIndex] = _selectedQuestion!.copyWith(
          isAnswered: true,
          answeredBy: _dailyDoublePlayer!.id,
        );
      }
      
      // Set current player for next selection
      _currentPlayer = _dailyDoublePlayer;
      
      // Close question overlay
      _selectedQuestion = null;
      _selectedCategory = null;
      _showingAnswer = false;
      _showingDailyDouble = false;
      _dailyDoubleWager = 0;
      _dailyDoublePlayer = null;
    });
    
    // Check if game is complete
    _checkGameComplete();
  }
  
  void _startFinalJeopardy() {
    _showFinalJeopardyDialog();
  }
  
  void _showFinalJeopardyDialog() {
    showDialog(
      context: context,
      barrierDismissible: false,
      builder: (context) => _FinalJeopardyDialog(
        game: _game!,
        players: _players,
        onComplete: (wagers, answers) {
          setState(() {
            _finalJeopardyWagers.clear();
            _finalJeopardyWagers.addAll(wagers);
            _finalJeopardyAnswers.clear();
            _finalJeopardyAnswers.addAll(answers);
          });
          
          _scoreFinalJeopardy();
        },
      ),
    );
  }
  
  void _scoreFinalJeopardy() {
    // This would typically be done by the teacher/host
    // For now, we'll show a dialog to score each player
    _showFinalJeopardyScoringDialog();
  }
  
  void _showFinalJeopardyScoringDialog() {
    showDialog(
      context: context,
      barrierDismissible: false,
      builder: (context) => AlertDialog(
        title: const Text('Final Jeopardy Scoring'),
        content: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            Text('Question: ${_game?.finalJeopardy?.question ?? ''}'),
            const SizedBox(height: 8),
            Text('Answer: ${_game?.finalJeopardy?.answer ?? ''}'),
            const SizedBox(height: 16),
            ..._players.map((player) => Padding(
              padding: const EdgeInsets.symmetric(vertical: 8),
              child: Row(
                mainAxisAlignment: MainAxisAlignment.spaceBetween,
                children: [
                  Expanded(
                    child: Column(
                      crossAxisAlignment: CrossAxisAlignment.start,
                      children: [
                        Text(player.name, style: const TextStyle(fontWeight: FontWeight.bold)),
                        Text('Answer: ${_finalJeopardyAnswers[player.id] ?? "No answer"}'),
                        Text('Wager: \$${_finalJeopardyWagers[player.id] ?? 0}'),
                      ],
                    ),
                  ),
                  Row(
                    children: [
                      IconButton(
                        icon: const Icon(Icons.check, color: Colors.green),
                        onPressed: () => _scoreFinalJeopardyPlayer(player, true),
                      ),
                      IconButton(
                        icon: const Icon(Icons.close, color: Colors.red),
                        onPressed: () => _scoreFinalJeopardyPlayer(player, false),
                      ),
                    ],
                  ),
                ],
              ),
            )),
          ],
        ),
        actions: [
          TextButton(
            onPressed: () {
              Navigator.of(context).pop();
              _showGameComplete();
            },
            child: const Text('Finish Game'),
          ),
        ],
      ),
    );
  }
  
  void _scoreFinalJeopardyPlayer(JeopardyPlayer player, bool correct) {
    setState(() {
      final wager = _finalJeopardyWagers[player.id] ?? 0;
      if (correct) {
        player.score += wager;
      } else {
        player.score -= wager;
      }
    });
  }
}

// Final Jeopardy Dialog
class _FinalJeopardyDialog extends StatefulWidget {
  final JeopardyGame game;
  final List<JeopardyPlayer> players;
  final Function(Map<String, int>, Map<String, String>) onComplete;
  
  const _FinalJeopardyDialog({
    required this.game,
    required this.players,
    required this.onComplete,
  });
  
  @override
  State<_FinalJeopardyDialog> createState() => _FinalJeopardyDialogState();
}

class _FinalJeopardyDialogState extends State<_FinalJeopardyDialog> {
  final Map<String, int> _wagers = {};
  final Map<String, String> _answers = {};
  int _currentPlayerIndex = 0;
  bool _showingCategory = true;
  bool _showingWagers = false;
  bool _showingQuestion = false;
  
  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    
    if (_showingCategory) {
      return AlertDialog(
        backgroundColor: theme.colorScheme.primary,
        title: Text(
          'FINAL JEOPARDY',
          style: TextStyle(color: theme.colorScheme.onPrimary),
          textAlign: TextAlign.center,
        ),
        content: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            const SizedBox(height: 24),
            Text(
              'Category:',
              style: theme.textTheme.titleLarge?.copyWith(
                color: theme.colorScheme.onPrimary,
              ),
            ),
            const SizedBox(height: 16),
            Text(
              widget.game.finalJeopardy!.category.toUpperCase(),
              style: theme.textTheme.headlineMedium?.copyWith(
                color: theme.colorScheme.onPrimary,
                fontWeight: FontWeight.bold,
              ),
              textAlign: TextAlign.center,
            ),
            const SizedBox(height: 32),
          ],
        ),
        actions: [
          TextButton(
            onPressed: () {
              setState(() {
                _showingCategory = false;
                _showingWagers = true;
              });
            },
            style: TextButton.styleFrom(
              foregroundColor: theme.colorScheme.onPrimary,
            ),
            child: const Text('Continue to Wagers'),
          ),
        ],
      );
    }
    
    if (_showingWagers && _currentPlayerIndex < widget.players.length) {
      final player = widget.players[_currentPlayerIndex];
      final maxWager = max(0, player.score);
      
      return AlertDialog(
        title: Text('${player.name}\'s Wager'),
        content: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            Text('Current score: \$${player.score}'),
            Text('Maximum wager: \$$maxWager'),
            const SizedBox(height: 16),
            TextFormField(
              initialValue: _wagers[player.id]?.toString() ?? '0',
              keyboardType: TextInputType.number,
              decoration: const InputDecoration(
                labelText: 'Wager',
                border: OutlineInputBorder(),
              ),
              onChanged: (value) {
                final wager = int.tryParse(value) ?? 0;
                setState(() {
                  _wagers[player.id] = min(wager, maxWager);
                });
              },
            ),
          ],
        ),
        actions: [
          TextButton(
            onPressed: () {
              setState(() {
                _currentPlayerIndex++;
                if (_currentPlayerIndex >= widget.players.length) {
                  _showingWagers = false;
                  _showingQuestion = true;
                }
              });
            },
            child: const Text('Next'),
          ),
        ],
      );
    }
    
    if (_showingQuestion) {
      return AlertDialog(
        title: const Text('Final Jeopardy'),
        content: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            Text(
              widget.game.finalJeopardy!.question,
              style: theme.textTheme.titleLarge,
              textAlign: TextAlign.center,
            ),
            const SizedBox(height: 24),
            ...widget.players.map((player) => Padding(
              padding: const EdgeInsets.symmetric(vertical: 8),
              child: TextFormField(
                decoration: InputDecoration(
                  labelText: '${player.name}\'s Answer',
                  border: const OutlineInputBorder(),
                ),
                onChanged: (value) {
                  setState(() {
                    _answers[player.id] = value;
                  });
                },
              ),
            )),
          ],
        ),
        actions: [
          TextButton(
            onPressed: () {
              Navigator.of(context).pop();
              widget.onComplete(_wagers, _answers);
            },
            child: const Text('Submit Answers'),
          ),
        ],
      );
    }
    
    return const SizedBox.shrink();
  }
}
````

## File: lib/features/games/presentation/screens/jeopardy_screen.dart
````dart
import 'package:flutter/material.dart';
import 'package:go_router/go_router.dart';
import 'package:provider/provider.dart';
import '../../domain/models/jeopardy_game.dart';
import '../../../../shared/widgets/common/adaptive_layout.dart';
import '../providers/jeopardy_provider.dart';

class JeopardyScreen extends StatefulWidget {
  const JeopardyScreen({super.key});

  @override
  State<JeopardyScreen> createState() => _JeopardyScreenState();
}

class _JeopardyScreenState extends State<JeopardyScreen> with SingleTickerProviderStateMixin {
  late TabController _tabController;

  @override
  void initState() {
    super.initState();
    _tabController = TabController(length: 3, vsync: this, initialIndex: 0);
    
    // Initialize the Jeopardy provider
    WidgetsBinding.instance.addPostFrameCallback((_) {
      context.read<JeopardyProvider>().initialize();
    });
  }

  @override
  void dispose() {
    _tabController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);

    return AdaptiveLayout(
      title: 'Jeopardy Games',
      showBackButton: true,
      floatingActionButton: FloatingActionButton.extended(
        onPressed: _createNewGame,
        icon: const Icon(Icons.add),
        label: const Text('Create Game'),
      ),
      body: Column(
        children: [
          // TabBar
          Container(
            color: theme.colorScheme.surface,
            child: TabBar(
              controller: _tabController,
              labelColor: theme.colorScheme.primary,
              unselectedLabelColor: theme.colorScheme.onSurfaceVariant,
              indicatorColor: theme.colorScheme.primary,
              tabs: const [
                Tab(text: 'My Games'),
                Tab(text: 'Public Games'),
                Tab(text: 'Active Games'),
              ],
            ),
          ),
          // TabBarView
          Expanded(
            child: TabBarView(
              controller: _tabController,
              children: [
                _buildMyGamesTab(),
                _buildPublicGamesTab(),
                _buildActiveGamesTab(),
              ],
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildMyGamesTab() {
    return Consumer<JeopardyProvider>(
      builder: (context, provider, child) {
        if (provider.isLoading) {
          return const Center(child: CircularProgressIndicator());
        }
        
        if (provider.error != null) {
          return Center(
            child: Column(
              mainAxisAlignment: MainAxisAlignment.center,
              children: [
                const Icon(Icons.error_outline, size: 64, color: Colors.red),
                const SizedBox(height: 16),
                Text('Error: ${provider.error}'),
                const SizedBox(height: 16),
                FilledButton(
                  onPressed: () => provider.initialize(),
                  child: const Text('Retry'),
                ),
              ],
            ),
          );
        }
        
        final myGames = provider.teacherGames;
        
        if (myGames.isEmpty) {
      return Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Icon(
              Icons.grid_view_rounded,
              size: 64,
              color: Theme.of(context).colorScheme.onSurfaceVariant.withValues(alpha: 0.5),
            ),
            const SizedBox(height: 16),
            Text(
              'No games created yet',
              style: Theme.of(context).textTheme.titleMedium?.copyWith(
                color: Theme.of(context).colorScheme.onSurfaceVariant,
              ),
            ),
            const SizedBox(height: 8),
            Text(
              'Create your first Jeopardy game',
              style: Theme.of(context).textTheme.bodyMedium?.copyWith(
                color: Theme.of(context).colorScheme.onSurfaceVariant.withValues(alpha: 0.7),
              ),
            ),
            const SizedBox(height: 24),
            FilledButton.icon(
              onPressed: _createNewGame,
              icon: const Icon(Icons.add),
              label: const Text('Create Game'),
            ),
          ],
        ),
      );
        }

        return ListView.builder(
          padding: const EdgeInsets.all(16),
          itemCount: myGames.length,
          itemBuilder: (context, index) => _buildGameCard(myGames[index]),
        );
      },
    );
  }

  Widget _buildPublicGamesTab() {
    return Consumer<JeopardyProvider>(
      builder: (context, provider, child) {
        if (provider.isLoading) {
          return const Center(child: CircularProgressIndicator());
        }
        
        final publicGames = provider.publicGames;
        
        if (publicGames.isEmpty) {
          return const Center(
            child: Text('No public games available'),
          );
        }

        return ListView.builder(
          padding: const EdgeInsets.all(16),
          itemCount: publicGames.length,
          itemBuilder: (context, index) => _buildGameCard(publicGames[index]),
        );
      },
    );
  }

  Widget _buildActiveGamesTab() {
    return const Center(
      child: Text('No active games in progress'),
    );
  }

  Widget _buildGameCard(JeopardyGame game) {
    final theme = Theme.of(context);
    
    return Card(
      margin: const EdgeInsets.only(bottom: 12),
      child: InkWell(
        onTap: () => _openGame(game),
        borderRadius: BorderRadius.circular(12),
        child: Padding(
          padding: const EdgeInsets.all(16),
          child: Row(
            children: [
              // Game icon
              Container(
                width: 56,
                height: 56,
                decoration: BoxDecoration(
                  color: theme.colorScheme.primaryContainer,
                  borderRadius: BorderRadius.circular(12),
                ),
                child: Icon(
                  Icons.grid_view_rounded,
                  color: theme.colorScheme.onPrimaryContainer,
                  size: 28,
                ),
              ),
              const SizedBox(width: 16),
              // Game info
              Expanded(
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Text(
                      game.title,
                      style: theme.textTheme.titleMedium?.copyWith(
                        fontWeight: FontWeight.bold,
                      ),
                    ),
                    const SizedBox(height: 4),
                    Text(
                      '${game.categories.length} categories',
                      style: theme.textTheme.bodyMedium?.copyWith(
                        color: theme.colorScheme.onSurfaceVariant,
                      ),
                    ),
                    const SizedBox(height: 4),
                    Text(
                      'Updated ${_formatDate(game.updatedAt)}',
                      style: theme.textTheme.bodySmall?.copyWith(
                        color: theme.colorScheme.onSurfaceVariant.withValues(alpha: 0.7),
                      ),
                    ),
                  ],
                ),
              ),
              // Actions
              PopupMenuButton<String>(
                icon: const Icon(Icons.more_vert),
                onSelected: (value) => _handleGameAction(game, value),
                itemBuilder: (context) => [
                  const PopupMenuItem(value: 'play', child: Text('Play')),
                  const PopupMenuItem(value: 'edit', child: Text('Edit')),
                  const PopupMenuItem(value: 'duplicate', child: Text('Duplicate')),
                  PopupMenuItem(
                    value: 'share',
                    child: Text(game.isPublic ? 'Make Private' : 'Make Public'),
                  ),
                  const PopupMenuItem(value: 'delete', child: Text('Delete')),
                ],
              ),
            ],
          ),
        ),
      ),
    );
  }

  String _formatDate(DateTime date) {
    final now = DateTime.now();
    final difference = now.difference(date);

    if (difference.inDays == 0) {
      return 'today';
    } else if (difference.inDays == 1) {
      return 'yesterday';
    } else if (difference.inDays < 7) {
      return '${difference.inDays} days ago';
    } else if (difference.inDays < 30) {
      return '${(difference.inDays / 7).floor()} weeks ago';
    } else {
      return '${date.month}/${date.day}/${date.year}';
    }
  }

  void _createNewGame() {
    context.go('/teacher/games/jeopardy/create');
  }

  void _openGame(JeopardyGame game) {
    context.go('/teacher/games/jeopardy/${game.id}/play');
  }

  void _handleGameAction(JeopardyGame game, String action) {
    switch (action) {
      case 'play':
        _openGame(game);
        break;
      case 'edit':
        context.go('/teacher/games/jeopardy/${game.id}/edit');
        break;
      case 'duplicate':
        _duplicateGame(game);
        break;
      case 'share':
        _togglePublicStatus(game);
        break;
      case 'delete':
        _showDeleteConfirmation(game);
        break;
    }
  }

  void _showDeleteConfirmation(JeopardyGame game) {
    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        title: const Text('Delete Game?'),
        content: Text('Are you sure you want to delete "${game.title}"?'),
        actions: [
          TextButton(
            onPressed: () => Navigator.of(context).pop(),
            child: const Text('Cancel'),
          ),
          FilledButton(
            onPressed: () async {
              // Capture context-dependent values before async operations
              final navigator = Navigator.of(context);
              final provider = context.read<JeopardyProvider>();
              final scaffoldMessenger = ScaffoldMessenger.of(context);
              
              navigator.pop();
              final success = await provider.deleteGame(game.id);
              if (!mounted) return;
              
              scaffoldMessenger.showSnackBar(
                SnackBar(
                  content: Text(success 
                    ? 'Deleted "${game.title}"' 
                    : 'Failed to delete game'),
                  backgroundColor: success ? null : Colors.red,
                ),
              );
            },
            child: const Text('Delete'),
          ),
        ],
      ),
    );
  }
  
  void _togglePublicStatus(JeopardyGame game) async {
    final provider = context.read<JeopardyProvider>();
    final success = await provider.togglePublicStatus(game.id, !game.isPublic);
    
    if (mounted) {
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(
          content: Text(success 
            ? (game.isPublic ? 'Made private' : 'Made public') 
            : 'Failed to update game visibility'),
          backgroundColor: success ? null : Colors.red,
        ),
      );
    }
  }
  
  void _duplicateGame(JeopardyGame game) async {
    final provider = context.read<JeopardyProvider>();
    
    // Create a copy with a new title
    final duplicatedGame = JeopardyGame(
      id: '',
      title: 'Copy of ${game.title}',
      teacherId: game.teacherId,
      categories: game.categories,
      finalJeopardy: game.finalJeopardy,
      createdAt: DateTime.now(),
      updatedAt: DateTime.now(),
      isPublic: false,
    );
    
    final gameId = await provider.createGame(duplicatedGame);
    
    if (mounted) {
      if (gameId != null) {
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(content: Text('Game duplicated successfully')),
        );
      } else {
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(
            content: Text('Failed to duplicate game'),
            backgroundColor: Colors.red,
          ),
        );
      }
    }
  }
}
````

## File: lib/features/grades/data/repositories/grade_repository_impl.dart
````dart
/// Concrete implementation of the grade repository.
/// 
/// This module implements the GradeRepository interface using
/// Firebase Firestore as the data source. It provides comprehensive
/// grade management functionality with automatic calculations
/// and batch operations.
library;

import 'package:cloud_firestore/cloud_firestore.dart';
import '../../domain/models/grade.dart';
import '../../../../shared/services/firestore_service.dart';
import '../../../../shared/services/logger_service.dart';
import '../../domain/repositories/grade_repository.dart';
import '../../../../shared/repositories/firestore_repository.dart';

/// Firestore-based implementation of GradeRepository.
/// 
/// This class extends FirestoreRepository to leverage common
/// CRUD operations while implementing grade-specific features:
/// - Automatic grade calculation (percentage and letter grades)
/// - Batch grading operations for efficiency
/// - Grade status management (submitted, graded, returned)
/// - Statistical analysis at multiple levels
/// - Automatic grade initialization for new assignments
/// - Real-time grade streaming
/// 
/// All operations include comprehensive logging and automatic
/// timestamp management for audit trails.
class GradeRepositoryImpl extends FirestoreRepository<Grade> 
    implements GradeRepository {
  /// Firestore instance for direct database operations.
  final FirebaseFirestore _firestore;
  
  /// Creates a grade repository with Firestore backend.
  /// 
  /// Initializes the parent FirestoreRepository with grade-specific
  /// configuration including collection path and serialization functions.
  /// 
  /// @param _firestore Firestore database instance
  GradeRepositoryImpl(this._firestore)
      : super(
          firestore: _firestore,
          collectionPath: 'grades',
          fromFirestore: (doc) => Grade.fromFirestore(doc),
          toFirestore: (grade) => grade.toFirestore(),
          logTag: 'GradeRepository',
        );
  
  /// Creates a new grade entry with automatic calculations.
  /// 
  /// Automatically computes:
  /// - Percentage based on points earned vs possible
  /// - Letter grade based on percentage (if not provided)
  /// - Creation and update timestamps
  /// 
  /// The grade ID is generated by Firestore for uniqueness.
  /// 
  /// @param grade Grade model with score and feedback
  /// @return Generated unique grade ID
  /// @throws Exception if grade creation fails
  @override
  Future<String> createGrade(Grade grade) async {
    try {
      final gradeWithTimestamp = grade.copyWith(
        createdAt: DateTime.now(),
        updatedAt: DateTime.now(),
        percentage: Grade.calculatePercentage(grade.pointsEarned, grade.pointsPossible),
        letterGrade: grade.letterGrade ?? Grade.calculateLetterGrade(
          Grade.calculatePercentage(grade.pointsEarned, grade.pointsPossible)
        ),
      );
      return await create(gradeWithTimestamp);
    } catch (e) {
      LoggerService.error('Failed to create grade', tag: tag, error: e);
      rethrow;
    }
  }  
  /// Retrieves a grade by its unique identifier.
  /// 
  /// Delegates to parent repository for consistent error handling.
  /// 
  /// @param gradeId Unique grade identifier
  /// @return Grade instance or null if not found
  @override
  Future<Grade?> getGrade(String gradeId) => read(gradeId);
  
  /// Updates an existing grade with recalculation.
  /// 
  /// Automatically recalculates:
  /// - Percentage based on new scores
  /// - Letter grade if not explicitly provided
  /// - Update timestamp for audit trail
  /// 
  /// Preserves the original grade ID and creation time.
  /// 
  /// @param gradeId ID of grade to update
  /// @param grade Updated grade information
  /// @throws Exception if update fails
  @override
  Future<void> updateGrade(String gradeId, Grade grade) async {
    try {
      final updatedGrade = grade.copyWith(
        id: gradeId,
        updatedAt: DateTime.now(),
        percentage: Grade.calculatePercentage(grade.pointsEarned, grade.pointsPossible),
        letterGrade: grade.letterGrade ?? Grade.calculateLetterGrade(
          Grade.calculatePercentage(grade.pointsEarned, grade.pointsPossible)
        ),
      );
      await update(gradeId, updatedGrade);
    } catch (e) {
      LoggerService.error('Failed to update grade', tag: tag, error: e);
      rethrow;
    }
  }
  
  /// Permanently deletes a grade record.
  /// 
  /// This operation cannot be undone. Consider soft deletion
  /// or status changes for recoverable operations.
  /// 
  /// @param gradeId ID of grade to delete
  /// @throws Exception if deletion fails
  @override
  Future<void> deleteGrade(String gradeId) => delete(gradeId);
  
  /// Retrieves the grade for a specific student-assignment pair.
  /// 
  /// Queries for the unique grade entry matching both the student
  /// and assignment IDs. Returns null if not yet graded.
  /// Uses limit 1 for efficiency since only one grade should exist
  /// per student-assignment combination.
  /// 
  /// @param studentId Student's unique identifier
  /// @param assignmentId Assignment's unique identifier
  /// @return Grade instance or null if not graded
  /// @throws Exception if retrieval fails
  @override
  Future<Grade?> getStudentAssignmentGrade(String studentId, String assignmentId) async {
    try {
      final grades = await list(
        conditions: [
          QueryCondition(field: 'studentId', isEqualTo: studentId),
          QueryCondition(field: 'assignmentId', isEqualTo: assignmentId),
        ],
        limit: 1,
      );
      return grades.isNotEmpty ? grades.first : null;
    } catch (e) {
      LoggerService.error('Failed to get student assignment grade', tag: tag, error: e);
      rethrow;
    }
  }  
  /// Streams all grades for a specific assignment.
  /// 
  /// Returns real-time updates of all student grades for an
  /// assignment, ordered by student ID for consistent display.
  /// Useful for grading dashboards and batch operations.
  /// 
  /// @param assignmentId Assignment to get grades for
  /// @return Stream of grade lists
  @override
  Stream<List<Grade>> getAssignmentGrades(String assignmentId) {
    return stream(
      conditions: [
        QueryCondition(field: 'assignmentId', isEqualTo: assignmentId),
      ],
      orderBy: [
        OrderBy(field: 'studentId', descending: false),
      ],
    );
  }
  
  /// Streams all grades for a student in a specific class.
  /// 
  /// Returns real-time updates of a student's grades across
  /// all assignments in a class, ordered by most recent first.
  /// Useful for student progress tracking and report cards.
  /// 
  /// @param studentId Student's unique identifier
  /// @param classId Class identifier
  /// @return Stream of student's grades in the class
  @override
  Stream<List<Grade>> getStudentClassGrades(String studentId, String classId) {
    return stream(
      conditions: [
        QueryCondition(field: 'studentId', isEqualTo: studentId),
        QueryCondition(field: 'classId', isEqualTo: classId),
      ],
      orderBy: [
        OrderBy(field: 'createdAt', descending: true),
      ],
    );
  }
  
  /// Streams all grades for a student across all classes.
  /// 
  /// Returns comprehensive grade history for a student,
  /// ordered by most recent first. Useful for transcripts
  /// and overall academic progress tracking.
  /// 
  /// @param studentId Student's unique identifier
  /// @return Stream of all student grades
  @override
  Stream<List<Grade>> getStudentGrades(String studentId) {
    return stream(
      conditions: [
        QueryCondition(field: 'studentId', isEqualTo: studentId),
      ],
      orderBy: [
        OrderBy(field: 'createdAt', descending: true),
      ],
    );
  }  
  /// Submits a grade for an assignment.
  /// 
  /// Handles both new grade creation and existing grade updates:
  /// - If grade.id is empty, creates a new grade entry
  /// - If grade.id exists, updates the existing grade
  /// 
  /// Automatically sets:
  /// - Status to 'graded'
  /// - Graded timestamp
  /// - Update timestamp
  /// 
  /// @param grade Grade to submit with score and feedback
  /// @throws Exception if submission fails
  @override
  Future<void> submitGrade(Grade grade) async {
    try {
      final submittedGrade = grade.copyWith(
        status: GradeStatus.graded,
        gradedAt: DateTime.now(),
        updatedAt: DateTime.now(),
      );
      if (grade.id.isEmpty) {
        await createGrade(submittedGrade);
      } else {
        await updateGrade(grade.id, submittedGrade);
      }
    } catch (e) {
      LoggerService.error('Failed to submit grade', tag: tag, error: e);
      rethrow;
    }
  }
  
  /// Returns multiple grades to students in batch.
  /// 
  /// Uses Firestore batch operations for efficiency and atomicity.
  /// All grades are returned with the same timestamp, ensuring
  /// consistent release time. Updates:
  /// - Status to 'returned'
  /// - Return timestamp
  /// - Update timestamp
  /// 
  /// This may trigger notifications to students about grade availability.
  /// 
  /// @param gradeIds List of grade IDs to return
  /// @throws Exception if batch return fails
  @override
  Future<void> returnGrades(List<String> gradeIds) async {
    try {
      final batch = _firestore.batch();
      final now = DateTime.now();
      
      for (final gradeId in gradeIds) {
        final gradeRef = _firestore.collection('grades').doc(gradeId);
        batch.update(gradeRef, {
          'status': GradeStatus.returned.name,
          'returnedAt': Timestamp.fromDate(now),
          'updatedAt': Timestamp.fromDate(now),
        });
      }
      
      await batch.commit();
      LoggerService.info('Returned ${gradeIds.length} grades', tag: tag);
    } catch (e) {
      LoggerService.error('Failed to return grades', tag: tag, error: e);
      rethrow;
    }
  }  
  
  /// Returns a single grade to a student.
  /// 
  /// Makes the grade visible to the student by updating:
  /// - Status to 'returned'
  /// - Return timestamp for tracking
  /// - Update timestamp for audit trail
  /// 
  /// Individual return useful for immediate feedback scenarios.
  /// 
  /// @param gradeId Grade ID to return
  /// @throws Exception if return fails
  @override
  Future<void> returnGrade(String gradeId) async {
    try {
      final now = DateTime.now();
      await _firestore.collection('grades').doc(gradeId).update({
        'status': GradeStatus.returned.name,
        'returnedAt': Timestamp.fromDate(now),
        'updatedAt': Timestamp.fromDate(now),
      });
      LoggerService.info('Returned grade $gradeId', tag: tag);
    } catch (e) {
      LoggerService.error('Failed to return grade', tag: tag, error: e);
      rethrow;
    }
  }
  
  /// Streams all grades for an entire class.
  /// 
  /// Returns real-time updates of all grades across all
  /// assignments and students in a class. Ordered by
  /// most recent first for activity monitoring.
  /// 
  /// @param classId Class identifier
  /// @return Stream of all grades in the class
  @override
  Stream<List<Grade>> getClassGrades(String classId) {
    return stream(
      conditions: [
        QueryCondition(field: 'classId', isEqualTo: classId),
      ],
      orderBy: [
        OrderBy(field: 'createdAt', descending: true),
      ],
    );
  }
  
  /// Calculates comprehensive statistics for an assignment.
  /// 
  /// Aggregates data from all graded and returned grades to compute:
  /// - Average, median, and mode scores
  /// - Grade distribution (A-F breakdown)
  /// - Completion rates
  /// - Standard deviation
  /// - High/low scores
  /// 
  /// Only includes grades with status 'graded' or 'returned',
  /// excluding incomplete submissions.
  /// 
  /// @param assignmentId Assignment to analyze
  /// @return Statistical summary of grades
  /// @throws Exception if calculation fails
  @override
  Future<GradeStatistics> getAssignmentStatistics(String assignmentId) async {
    try {
      final grades = await list(
        conditions: [
          QueryCondition(field: 'assignmentId', isEqualTo: assignmentId),
          QueryCondition(field: 'status', whereIn: [
            GradeStatus.graded.name,
            GradeStatus.returned.name,
          ]),
        ],
      );
      return GradeStatistics.fromGrades(grades);
    } catch (e) {
      LoggerService.error('Failed to get assignment statistics', tag: tag, error: e);
      rethrow;
    }
  }
  
  /// Calculates grade statistics for a student in a class.
  /// 
  /// Generates student-specific performance metrics including:
  /// - Overall average across assignments
  /// - Assignment completion rate
  /// - Grade trends over time
  /// - Performance relative to class average
  /// - Strengths and areas for improvement
  /// 
  /// Only includes completed grades (graded or returned status).
  /// 
  /// @param studentId Student to analyze
  /// @param classId Class context
  /// @return Student's statistical summary
  /// @throws Exception if calculation fails
  @override
  Future<GradeStatistics> getStudentClassStatistics(String studentId, String classId) async {
    try {
      final grades = await list(
        conditions: [
          QueryCondition(field: 'studentId', isEqualTo: studentId),
          QueryCondition(field: 'classId', isEqualTo: classId),
          QueryCondition(field: 'status', whereIn: [
            GradeStatus.graded.name,
            GradeStatus.returned.name,
          ]),
        ],
      );
      return GradeStatistics.fromGrades(grades);
    } catch (e) {
      LoggerService.error('Failed to get student class statistics', tag: tag, error: e);
      rethrow;
    }
  }  
  /// Calculates overall statistics for an entire class.
  /// 
  /// Aggregates performance data across all students and assignments:
  /// - Class average and grade distribution
  /// - Assignment difficulty indicators
  /// - Student performance rankings
  /// - Completion rates by assignment
  /// - Trends over academic period
  /// 
  /// Useful for identifying class-wide patterns and adjusting
  /// teaching strategies.
  /// 
  /// @param classId Class to analyze
  /// @return Class statistical summary
  /// @throws Exception if calculation fails
  @override
  Future<GradeStatistics> getClassStatistics(String classId) async {
    try {
      final grades = await list(
        conditions: [
          QueryCondition(field: 'classId', isEqualTo: classId),
          QueryCondition(field: 'status', whereIn: [
            GradeStatus.graded.name,
            GradeStatus.returned.name,
          ]),
        ],
      );
      return GradeStatistics.fromGrades(grades);
    } catch (e) {
      LoggerService.error('Failed to get class statistics', tag: tag, error: e);
      rethrow;
    }
  }
  
  /// Updates multiple grades in a single atomic operation.
  /// 
  /// Efficient batch update for grading multiple submissions at once.
  /// All updates succeed or fail together, ensuring consistency.
  /// 
  /// For each grade:
  /// - Recalculates percentage and letter grade
  /// - Updates modification timestamp
  /// - Preserves other grade properties
  /// 
  /// Particularly useful for:
  /// - Grading all submissions for an assignment
  /// - Applying curve adjustments
  /// - Bulk feedback updates
  /// 
  /// @param grades Map of grade IDs to updated grade objects
  /// @throws Exception if batch update fails
  @override
  Future<void> batchUpdateGrades(Map<String, Grade> grades) async {
    try {
      final batch = _firestore.batch();
      final now = DateTime.now();
      
      grades.forEach((gradeId, grade) {
        final gradeRef = _firestore.collection('grades').doc(gradeId);
        final updatedGrade = grade.copyWith(
          updatedAt: now,
          percentage: Grade.calculatePercentage(grade.pointsEarned, grade.pointsPossible),
          letterGrade: grade.letterGrade ?? Grade.calculateLetterGrade(
            Grade.calculatePercentage(grade.pointsEarned, grade.pointsPossible)
          ),
        );
        batch.update(gradeRef, updatedGrade.toFirestore());
      });
      
      await batch.commit();
      LoggerService.info('Batch updated ${grades.length} grades', tag: tag);
    } catch (e) {
      LoggerService.error('Failed to batch update grades', tag: tag, error: e);
      rethrow;
    }
  }
  
  /// Initializes grade records for all students in a class.
  /// 
  /// Creates placeholder grade entries when a new assignment is created,
  /// allowing teachers to track:
  /// - Which students haven't submitted
  /// - Overall completion rates
  /// - Missing work patterns
  /// 
  /// Process:
  /// 1. Queries all students enrolled in the class
  /// 2. Creates a grade entry for each student with:
  ///    - Zero points earned initially
  ///    - Status set to 'notSubmitted'
  ///    - Student name cached for display
  /// 3. Uses batch operations for efficiency
  /// 
  /// This enables proactive grade management rather than
  /// reactive entry after submission.
  /// 
  /// @param assignmentId New assignment identifier
  /// @param classId Class with enrolled students
  /// @param teacherId Teacher creating the assignment
  /// @param totalPoints Maximum possible score
  /// @throws Exception if initialization fails
  @override
  Future<void> initializeGradesForAssignment(
    String assignmentId,
    String classId,
    String teacherId,
    double totalPoints,
  ) async {
    try {
      // Get all students in the class
      final studentQuery = await _firestore
          .collection('students')
          .where('classIds', arrayContains: classId)
          .get();
      
      final batch = _firestore.batch();
      final now = DateTime.now();
      
      for (final studentDoc in studentQuery.docs) {
        final studentId = studentDoc.id;
        final studentData = studentDoc.data();
        final studentName = studentData['displayName'] ?? 'Unknown Student';
        
        // Create a new grade for each student
        final gradeRef = _firestore.collection('grades').doc();
        final grade = Grade(
          id: gradeRef.id,
          studentId: studentId,
          studentName: studentName,
          assignmentId: assignmentId,
          teacherId: teacherId,
          classId: classId,
          pointsEarned: 0,
          pointsPossible: totalPoints,
          percentage: 0,
          letterGrade: 'F',
          feedback: '',
          status: GradeStatus.notSubmitted,
          createdAt: now,
          updatedAt: now,
        );
        
        batch.set(gradeRef, grade.toFirestore());
      }
      
      await batch.commit();
      LoggerService.info(
        'Initialized grades for ${studentQuery.docs.length} students in assignment $assignmentId',
        tag: tag,
      );
    } catch (e) {
      LoggerService.error('Failed to initialize grades for assignment', tag: tag, error: e);
      rethrow;
    }
  }
}
````

## File: lib/features/grades/domain/models/grade_analytics.dart
````dart
/// Analytics data for grades
class GradeAnalytics {
  final String classId;
  final String className;
  final double averageGrade;
  final double medianGrade;
  final int totalAssignments;
  final int gradedAssignments;
  final int pendingSubmissions;
  final Map<String, int> gradeDistribution; // A: count, B: count, etc.
  final Map<String, double> categoryAverages; // homework: avg, quiz: avg, etc.
  final List<StudentPerformance> studentPerformances;
  final List<AssignmentStats> assignmentStats;
  final DateTime lastUpdated;

  GradeAnalytics({
    required this.classId,
    required this.className,
    required this.averageGrade,
    required this.medianGrade,
    required this.totalAssignments,
    required this.gradedAssignments,
    required this.pendingSubmissions,
    required this.gradeDistribution,
    required this.categoryAverages,
    required this.studentPerformances,
    required this.assignmentStats,
    required this.lastUpdated,
  });

  /// Get grade distribution as percentages
  Map<String, double> get gradeDistributionPercentages {
    final total = gradeDistribution.values.fold(0, (sum, count) => sum + count);
    if (total == 0) return {};
    
    return gradeDistribution.map((grade, count) => 
      MapEntry(grade, (count / total) * 100)
    );
  }

  /// Get completion rate
  double get completionRate {
    if (totalAssignments == 0) return 0;
    return (gradedAssignments / totalAssignments) * 100;
  }

  /// Get letter grade for average
  String get averageLetterGrade => _getLetterGrade(averageGrade);

  /// Convert numeric grade to letter grade
  String _getLetterGrade(double grade) {
    if (grade >= 93) return 'A';
    if (grade >= 90) return 'A-';
    if (grade >= 87) return 'B+';
    if (grade >= 83) return 'B';
    if (grade >= 80) return 'B-';
    if (grade >= 77) return 'C+';
    if (grade >= 73) return 'C';
    if (grade >= 70) return 'C-';
    if (grade >= 67) return 'D+';
    if (grade >= 63) return 'D';
    if (grade >= 60) return 'D-';
    return 'F';
  }
}

/// Individual student performance data
class StudentPerformance {
  final String studentId;
  final String studentName;
  final double averageGrade;
  final int completedAssignments;
  final int missingAssignments;
  final int lateSubmissions;
  final Map<String, double> categoryScores; // category -> average score
  final double trend; // positive or negative trend
  final String letterGrade;

  StudentPerformance({
    required this.studentId,
    required this.studentName,
    required this.averageGrade,
    required this.completedAssignments,
    required this.missingAssignments,
    required this.lateSubmissions,
    required this.categoryScores,
    required this.trend,
    required this.letterGrade,
  });

  /// Risk level for student (at-risk, warning, good)
  String get riskLevel {
    if (averageGrade < 60 || missingAssignments > 3) return 'at-risk';
    if (averageGrade < 70 || missingAssignments > 1) return 'warning';
    return 'good';
  }

  /// Performance compared to class average
  String getPerformanceVsClass(double classAverage) {
    final diff = averageGrade - classAverage;
    if (diff > 5) return 'above';
    if (diff < -5) return 'below';
    return 'average';
  }
}

/// Statistics for individual assignments
class AssignmentStats {
  final String assignmentId;
  final String assignmentTitle;
  final String category;
  final double averageScore;
  final double medianScore;
  final double maxScore;
  final double minScore;
  final int totalSubmissions;
  final int gradedSubmissions;
  final DateTime dueDate;
  final Map<String, int> scoreDistribution; // score ranges -> count

  AssignmentStats({
    required this.assignmentId,
    required this.assignmentTitle,
    required this.category,
    required this.averageScore,
    required this.medianScore,
    required this.maxScore,
    required this.minScore,
    required this.totalSubmissions,
    required this.gradedSubmissions,
    required this.dueDate,
    required this.scoreDistribution,
  });

  /// Completion rate for this assignment
  double get completionRate {
    if (totalSubmissions == 0) return 0;
    return (gradedSubmissions / totalSubmissions) * 100;
  }

  /// Difficulty level based on average score
  String get difficultyLevel {
    if (averageScore >= 85) return 'easy';
    if (averageScore >= 70) return 'medium';
    return 'hard';
  }
}

/// Time-based grade trends
class GradeTrend {
  final DateTime date;
  final double averageGrade;
  final int assignmentCount;

  GradeTrend({
    required this.date,
    required this.averageGrade,
    required this.assignmentCount,
  });
}

/// Category performance breakdown
class CategoryPerformance {
  final String category;
  final double averageScore;
  final int assignmentCount;
  final double weight; // percentage weight in final grade

  CategoryPerformance({
    required this.category,
    required this.averageScore,
    required this.assignmentCount,
    required this.weight,
  });

  /// Weighted score contribution
  double get weightedScore => averageScore * (weight / 100);
}
````

## File: lib/features/grades/domain/models/grade.dart
````dart
/// Grade model for managing student assessment scores and feedback.
/// 
/// This module contains data models for grades and grade statistics,
/// supporting comprehensive grade management in the education platform.
library;

import 'package:cloud_firestore/cloud_firestore.dart';

/// Enumeration representing the lifecycle states of a grade.
/// 
/// Each grade progresses through various states:
/// - [draft]: Grade is being prepared but not finalized
/// - [pending]: Awaiting grading (submission received)
/// - [graded]: Grade has been assigned
/// - [returned]: Grade has been shared with student
/// - [revised]: Grade has been updated after initial grading
/// - [notSubmitted]: No submission received (grade placeholder)
enum GradeStatus {
  draft,
  pending,
  graded,
  returned,
  revised,
  notSubmitted
}

/// Core grade model representing student assessment results.
/// 
/// This model encapsulates comprehensive grading data including:
/// - Score information (points earned, percentage, letter grade)
/// - Teacher feedback and comments
/// - Rubric-based scoring details
/// - Grade lifecycle tracking
/// - Attachment support for annotated work
/// 
/// Grades are linked to specific assignments, students, and classes,
/// providing a complete assessment record for academic tracking.
class Grade {
  /// Unique identifier for the grade record
  final String id;
  
  /// ID of the assignment being graded
  final String assignmentId;
  
  /// ID of the student receiving the grade
  final String studentId;
  
  /// Cached student name for display purposes
  final String studentName;
  
  /// ID of the teacher who assigned the grade
  final String teacherId;
  
  /// ID of the class this grade belongs to
  final String classId;
  
  /// Points earned by the student
  final double pointsEarned;
  
  /// Total points possible for the assignment
  final double pointsPossible;
  
  /// Calculated percentage score (0-100)
  final double percentage;
  
  /// Optional letter grade representation (A, B, C, D, F)
  final String? letterGrade;
  
  /// Teacher's feedback and comments on the submission
  final String? feedback;
  
  /// Current status in the grading lifecycle
  final GradeStatus status;
  
  /// Timestamp when the grade was assigned
  final DateTime? gradedAt;
  
  /// Timestamp when the grade was returned to student
  final DateTime? returnedAt;
  
  /// Timestamp when the grade record was created
  final DateTime createdAt;
  
  /// Timestamp of last modification (mutable for updates)
  DateTime updatedAt;
  
  /// Optional rubric scores as key-value pairs (criterion -> score)
  final Map<String, dynamic>? rubricScores;
  
  /// URLs to attached files (annotated submissions, feedback docs)
  final List<String>? attachmentUrls;

  Grade({
    required this.id,
    required this.assignmentId,
    required this.studentId,
    required this.studentName,
    required this.teacherId,
    required this.classId,
    required this.pointsEarned,
    required this.pointsPossible,
    required this.percentage,
    this.letterGrade,
    this.feedback,
    required this.status,
    this.gradedAt,
    this.returnedAt,
    required this.createdAt,
    required this.updatedAt,
    this.rubricScores,
    this.attachmentUrls,
  });

  /// Factory constructor to create Grade from Firestore document.
  /// 
  /// Handles comprehensive data parsing including:
  /// - Timestamp conversions for date fields
  /// - Numeric type casting with safe defaults
  /// - Status enum parsing using enum name matching
  /// - Complex type handling (maps, lists)
  /// 
  /// @param doc Firestore document snapshot containing grade data
  /// @return Parsed Grade instance
  factory Grade.fromFirestore(DocumentSnapshot doc) {
    final data = doc.data() as Map<String, dynamic>;
    return Grade(
      id: doc.id,
      assignmentId: data['assignmentId'] ?? '',
      studentId: data['studentId'] ?? '',
      studentName: data['studentName'] ?? '',
      teacherId: data['teacherId'] ?? '',
      classId: data['classId'] ?? '',
      pointsEarned: (data['pointsEarned'] ?? 0).toDouble(),
      pointsPossible: (data['pointsPossible'] ?? 0).toDouble(),
      percentage: (data['percentage'] ?? 0).toDouble(),
      letterGrade: data['letterGrade'],
      feedback: data['feedback'],
      status: GradeStatus.values.firstWhere(
        (s) => s.name == data['status'],
        orElse: () => GradeStatus.pending,
      ),
      gradedAt: data['gradedAt'] != null 
          ? (data['gradedAt'] as Timestamp).toDate() 
          : null,
      returnedAt: data['returnedAt'] != null 
          ? (data['returnedAt'] as Timestamp).toDate() 
          : null,
      createdAt: (data['createdAt'] as Timestamp).toDate(),
      updatedAt: (data['updatedAt'] as Timestamp).toDate(),
      rubricScores: data['rubricScores'] as Map<String, dynamic>?,
      attachmentUrls: data['attachmentUrls'] != null 
          ? List<String>.from(data['attachmentUrls']) 
          : null,
    );
  }

  /// Converts the Grade instance to a Map for Firestore storage.
  /// 
  /// Serializes all grade data with special handling for:
  /// - DateTime fields to Firestore Timestamps
  /// - Status enum to string using .name property
  /// - Server timestamps for created/updated fields
  /// - Preservation of complex types (maps, lists)
  /// 
  /// @return Map containing all grade data for Firestore
  Map<String, dynamic> toFirestore() {
    return {
      'assignmentId': assignmentId,
      'studentId': studentId,
      'studentName': studentName,
      'teacherId': teacherId,
      'classId': classId,
      'pointsEarned': pointsEarned,
      'pointsPossible': pointsPossible,
      'percentage': percentage,
      'letterGrade': letterGrade,
      'feedback': feedback,
      'status': status.name,
      'gradedAt': gradedAt != null ? Timestamp.fromDate(gradedAt!) : null,
      'returnedAt': returnedAt != null ? Timestamp.fromDate(returnedAt!) : null,
      'createdAt': FieldValue.serverTimestamp(),
      'updatedAt': FieldValue.serverTimestamp(),
      'rubricScores': rubricScores,
      'attachmentUrls': attachmentUrls,
    };
  }

  /// Creates a copy of the Grade with updated fields.
  /// 
  /// Follows immutable data pattern for state management.
  /// Useful for:
  /// - Updating scores after revision
  /// - Adding teacher feedback
  /// - Changing grade status
  /// - Attaching rubric scores
  /// 
  /// All parameters are optional - only provided fields will be updated.
  /// 
  /// @return New Grade instance with updated fields
  Grade copyWith({
    String? id,
    String? assignmentId,
    String? studentId,
    String? studentName,
    String? teacherId,
    String? classId,
    double? pointsEarned,
    double? pointsPossible,
    double? percentage,
    String? letterGrade,
    String? feedback,
    GradeStatus? status,
    DateTime? gradedAt,
    DateTime? returnedAt,
    DateTime? createdAt,
    DateTime? updatedAt,
    Map<String, dynamic>? rubricScores,
    List<String>? attachmentUrls,
  }) {
    return Grade(
      id: id ?? this.id,
      assignmentId: assignmentId ?? this.assignmentId,
      studentId: studentId ?? this.studentId,
      studentName: studentName ?? this.studentName,
      teacherId: teacherId ?? this.teacherId,
      classId: classId ?? this.classId,
      pointsEarned: pointsEarned ?? this.pointsEarned,
      pointsPossible: pointsPossible ?? this.pointsPossible,
      percentage: percentage ?? this.percentage,
      letterGrade: letterGrade ?? this.letterGrade,
      feedback: feedback ?? this.feedback,
      status: status ?? this.status,
      gradedAt: gradedAt ?? this.gradedAt,
      returnedAt: returnedAt ?? this.returnedAt,
      createdAt: createdAt ?? this.createdAt,
      updatedAt: updatedAt ?? this.updatedAt,
      rubricScores: rubricScores ?? this.rubricScores,
      attachmentUrls: attachmentUrls ?? this.attachmentUrls,
    );
  }

  /// Calculates letter grade based on percentage score.
  /// 
  /// Uses standard grading scale:
  /// - A: 90% and above
  /// - B: 80-89%
  /// - C: 70-79%
  /// - D: 60-69%
  /// - F: Below 60%
  /// 
  /// @param percentage Score as a percentage (0-100)
  /// @return Letter grade (A, B, C, D, or F)
  static String calculateLetterGrade(double percentage) {
    if (percentage >= 90) return 'A';
    if (percentage >= 80) return 'B';
    if (percentage >= 70) return 'C';
    if (percentage >= 60) return 'D';
    return 'F';
  }

  /// Calculates percentage score from points earned and possible.
  /// 
  /// Handles division by zero safely by returning 0 when
  /// points possible is 0.
  /// 
  /// @param earned Points earned by student
  /// @param possible Total points possible
  /// @return Percentage score (0-100)
  static double calculatePercentage(double earned, double possible) {
    if (possible == 0) return 0;
    return (earned / possible) * 100;
  }
}

/// Statistical analysis model for grade collections.
/// 
/// This model provides comprehensive statistics for a set of grades,
/// useful for:
/// - Class performance analysis
/// - Student progress tracking
/// - Grade distribution visualization
/// - Academic reporting
/// 
/// Calculates common statistical measures and provides
/// letter grade distribution for visual representation.
class GradeStatistics {
  /// Average (mean) percentage of all grades
  final double average;
  
  /// Median percentage (middle value when sorted)
  final double median;
  
  /// Highest percentage score in the set
  final double highest;
  
  /// Lowest percentage score in the set
  final double lowest;
  
  /// Total number of grades analyzed
  final int totalGrades;
  
  /// Distribution of letter grades (letter -> count)
  final Map<String, int> letterGradeDistribution;

  GradeStatistics({
    required this.average,
    required this.median,
    required this.highest,
    required this.lowest,
    required this.totalGrades,
    required this.letterGradeDistribution,
  });

  /// Factory constructor to calculate statistics from a list of grades.
  /// 
  /// Performs comprehensive statistical analysis including:
  /// - Mean calculation
  /// - Median determination (handles even/odd counts)
  /// - Range identification (highest/lowest)
  /// - Letter grade distribution counting
  /// 
  /// Returns zero-valued statistics for empty grade lists.
  /// 
  /// @param grades List of Grade objects to analyze
  /// @return Calculated GradeStatistics instance
  factory GradeStatistics.fromGrades(List<Grade> grades) {
    if (grades.isEmpty) {
      return GradeStatistics(
        average: 0,
        median: 0,
        highest: 0,
        lowest: 0,
        totalGrades: 0,
        letterGradeDistribution: {},
      );
    }

    // Sort grades by percentage
    final sortedGrades = List<Grade>.from(grades)
      ..sort((a, b) => a.percentage.compareTo(b.percentage));

    // Calculate average
    final sum = grades.fold<double>(
      0, 
      (prev, grade) => prev + grade.percentage
    );
    final average = sum / grades.length;

    // Calculate median
    final middle = grades.length ~/ 2;
    final median = grades.length % 2 == 0
        ? (sortedGrades[middle - 1].percentage + sortedGrades[middle].percentage) / 2
        : sortedGrades[middle].percentage;

    // Get highest and lowest
    final highest = sortedGrades.last.percentage;
    final lowest = sortedGrades.first.percentage;

    // Count letter grades
    final letterGradeDistribution = <String, int>{};
    for (final grade in grades) {
      final letter = grade.letterGrade ?? Grade.calculateLetterGrade(grade.percentage);
      letterGradeDistribution[letter] = (letterGradeDistribution[letter] ?? 0) + 1;
    }

    return GradeStatistics(
      average: average,
      median: median,
      highest: highest,
      lowest: lowest,
      totalGrades: grades.length,
      letterGradeDistribution: letterGradeDistribution,
    );
  }
}
````

## File: lib/features/grades/domain/repositories/grade_repository.dart
````dart
/// Grade repository interface for academic assessment management.
/// 
/// This module defines the contract for grade operations in the
/// education platform, supporting grade creation, tracking,
/// statistics, and batch operations.
library;

import '../models/grade.dart';
import '../../../../shared/repositories/base_repository.dart';

/// Abstract repository defining grade management operations.
/// 
/// This interface provides a comprehensive contract for grade
/// implementations, supporting:
/// - CRUD operations for individual grades
/// - Student-assignment grade associations
/// - Grade submission and return workflows
/// - Statistical analysis at multiple levels
/// - Batch operations for efficiency
/// - Real-time grade streaming
/// - Initialization for new assignments
/// 
/// Concrete implementations handle the actual grade
/// calculation and persistence logic.
abstract class GradeRepository extends BaseRepository {
  /// Creates a new grade entry in the system.
  /// 
  /// Initializes a grade with score, feedback, and metadata.
  /// Returns the generated grade ID for reference.
  /// 
  /// @param grade Grade model with score and details
  /// @return Generated unique grade ID
  /// @throws Exception if creation fails
  Future<String> createGrade(Grade grade);
  
  /// Retrieves a grade by its unique identifier.
  /// 
  /// Fetches complete grade details including score,
  /// feedback, and submission status.
  /// 
  /// @param gradeId Unique grade identifier
  /// @return Grade instance or null if not found
  /// @throws Exception if retrieval fails
  Future<Grade?> getGrade(String gradeId);
  
  /// Updates an existing grade.
  /// 
  /// Modifies grade details such as score, feedback,
  /// or status. Typically used for re-grading.
  /// 
  /// @param gradeId ID of grade to update
  /// @param grade Updated grade information
  /// @throws Exception if update fails
  Future<void> updateGrade(String gradeId, Grade grade);
  
  /// Permanently deletes a grade.
  /// 
  /// Removes the grade record completely. This operation
  /// cannot be undone and should be used cautiously.
  /// 
  /// @param gradeId ID of grade to delete
  /// @throws Exception if deletion fails
  Future<void> deleteGrade(String gradeId);
  
  /// Retrieves the grade for a specific student-assignment pair.
  /// 
  /// Fetches the grade a student received for a particular
  /// assignment. Useful for individual grade lookup.
  /// 
  /// @param studentId Student's unique identifier
  /// @param assignmentId Assignment's unique identifier
  /// @return Grade instance or null if not graded
  /// @throws Exception if retrieval fails
  Future<Grade?> getStudentAssignmentGrade(String studentId, String assignmentId);
  
  /// Streams all grades for a specific assignment.
  /// 
  /// Returns real-time updates of all student grades
  /// for an assignment. Useful for grading dashboards.
  /// 
  /// @param assignmentId Assignment to get grades for
  /// @return Stream of grade lists
  Stream<List<Grade>> getAssignmentGrades(String assignmentId);
  
  /// Streams all grades for a student in a specific class.
  /// 
  /// Returns real-time updates of a student's grades
  /// across all assignments in a class.
  /// 
  /// @param studentId Student's unique identifier
  /// @param classId Class identifier
  /// @return Stream of student's grades in the class
  Stream<List<Grade>> getStudentClassGrades(String studentId, String classId);
  
  /// Streams all grades for a student across all classes.
  /// 
  /// Returns comprehensive grade history for a student.
  /// Useful for transcript generation.
  /// 
  /// @param studentId Student's unique identifier
  /// @return Stream of all student grades
  Stream<List<Grade>> getStudentGrades(String studentId);
  
  /// Submits a grade for an assignment.
  /// 
  /// Records the grade and updates submission status.
  /// May trigger notifications to the student.
  /// 
  /// @param grade Grade to submit with score and feedback
  /// @throws Exception if submission fails
  Future<void> submitGrade(Grade grade);
  
  /// Returns multiple grades to students.
  /// 
  /// Batch operation to make grades visible to students.
  /// Updates status and may send notifications.
  /// 
  /// @param gradeIds List of grade IDs to return
  /// @throws Exception if return operation fails
  Future<void> returnGrades(List<String> gradeIds);
  
  /// Returns a single grade to a student.
  /// 
  /// Makes the grade visible to the student and
  /// updates the return status.
  /// 
  /// @param gradeId Grade ID to return
  /// @throws Exception if return fails
  Future<void> returnGrade(String gradeId);
  
  /// Streams all grades for an entire class.
  /// 
  /// Returns real-time updates of all grades across
  /// all assignments and students in a class.
  /// 
  /// @param classId Class identifier
  /// @return Stream of all grades in the class
  Stream<List<Grade>> getClassGrades(String classId);
  
  /// Calculates grade statistics for an assignment.
  /// 
  /// Generates aggregate data including:
  /// - Average, median, and mode scores
  /// - Grade distribution
  /// - Completion rates
  /// - Standard deviation
  /// 
  /// @param assignmentId Assignment to analyze
  /// @return Statistical summary of grades
  /// @throws Exception if calculation fails
  Future<GradeStatistics> getAssignmentStatistics(String assignmentId);
  
  /// Calculates grade statistics for a student in a class.
  /// 
  /// Generates student performance metrics including:
  /// - Overall average
  /// - Assignment completion rate
  /// - Grade trends
  /// - Performance relative to class
  /// 
  /// @param studentId Student to analyze
  /// @param classId Class context
  /// @return Student's statistical summary
  /// @throws Exception if calculation fails
  Future<GradeStatistics> getStudentClassStatistics(String studentId, String classId);
  
  /// Calculates overall grade statistics for a class.
  /// 
  /// Generates class-wide metrics including:
  /// - Class average across all assignments
  /// - Grade distribution patterns
  /// - Assignment difficulty indicators
  /// - Student performance rankings
  /// 
  /// @param classId Class to analyze
  /// @return Class statistical summary
  /// @throws Exception if calculation fails
  Future<GradeStatistics> getClassStatistics(String classId);
  
  /// Updates multiple grades in a single operation.
  /// 
  /// Efficient batch update for grading multiple
  /// submissions at once. All updates succeed or
  /// fail together for consistency.
  /// 
  /// @param grades Map of grade IDs to updated grades
  /// @throws Exception if batch update fails
  Future<void> batchUpdateGrades(Map<String, Grade> grades);
  
  /// Initializes grade records for a new assignment.
  /// 
  /// Creates placeholder grade entries for all students
  /// in a class when a new assignment is created. This
  /// allows tracking of missing submissions.
  /// 
  /// @param assignmentId New assignment identifier
  /// @param classId Class with enrolled students
  /// @param teacherId Teacher creating the assignment
  /// @param totalPoints Maximum possible score
  /// @throws Exception if initialization fails
  Future<void> initializeGradesForAssignment(
    String assignmentId,
    String classId,
    String teacherId,
    double totalPoints,
  );
}
````

## File: lib/features/grades/presentation/providers/grade_analytics_provider.dart
````dart
import 'dart:math';
import 'package:flutter/foundation.dart';
import '../../domain/models/grade_analytics.dart';
import '../../data/services/grade_analytics_service.dart';

class GradeAnalyticsProvider with ChangeNotifier {
  final GradeAnalyticsService _analyticsService = GradeAnalyticsService();
  
  // Analytics data by class ID
  final Map<String, GradeAnalytics> _analyticsCache = {};
  
  // Grade trends by class ID
  final Map<String, List<GradeTrend>> _trendsCache = {};
  
  // Loading states
  final Map<String, bool> _loadingStates = {};
  
  // Error states
  final Map<String, String?> _errorStates = {};
  
  // Selected class for detailed view
  String? _selectedClassId;
  
  // Time range for trends
  int _trendDays = 30;

  // Getters
  GradeAnalytics? getClassAnalytics(String classId) => _analyticsCache[classId];
  List<GradeTrend>? getClassTrends(String classId) {
    // Generate demo trends if not cached
    if (!_trendsCache.containsKey(classId) && 
        (classId.startsWith('math-') || classId.startsWith('sci-') || 
         classId.startsWith('eng-') || classId.startsWith('hist-'))) {
      _trendsCache[classId] = _generateDemoTrends();
    }
    return _trendsCache[classId];
  }
  bool isLoading(String classId) => _loadingStates[classId] ?? false;
  String? getError(String classId) => _errorStates[classId];
  String? get selectedClassId => _selectedClassId;
  int get trendDays => _trendDays;

  /// Load analytics for a specific class
  Future<void> loadClassAnalytics(String classId, {bool forceRefresh = false}) async {
    // Check cache
    if (!forceRefresh && _analyticsCache.containsKey(classId)) {
      return;
    }

    // Set loading state
    _loadingStates[classId] = true;
    _errorStates[classId] = null;
    notifyListeners();

    try {
      // Load analytics
      final analytics = await _analyticsService.generateClassAnalytics(classId);
      _analyticsCache[classId] = analytics;
      
      // Load trends
      final trends = await _analyticsService.getGradeTrends(classId, days: _trendDays);
      _trendsCache[classId] = trends;
      
      _loadingStates[classId] = false;
      notifyListeners();
    } catch (e) {
      _loadingStates[classId] = false;
      _errorStates[classId] = e.toString();
      notifyListeners();
    }
  }

  /// Select a class for detailed view
  void selectClass(String classId) {
    _selectedClassId = classId;
    notifyListeners();
    
    // Load analytics if not already loaded
    if (!_analyticsCache.containsKey(classId)) {
      loadClassAnalytics(classId);
    }
  }

  /// Update trend time range
  void updateTrendDays(int days) {
    _trendDays = days;
    notifyListeners();
    
    // Reload trends for all cached classes
    _trendsCache.clear();
    for (final classId in _analyticsCache.keys) {
      _loadTrends(classId);
    }
  }

  /// Load trends for a class
  Future<void> _loadTrends(String classId) async {
    try {
      final trends = await _analyticsService.getGradeTrends(classId, days: _trendDays);
      _trendsCache[classId] = trends;
      notifyListeners();
    } catch (e) {
      // Silently fail for trends
    }
  }

  /// Get all loaded analytics (for overview)
  List<GradeAnalytics> get allAnalytics => _analyticsCache.values.toList();

  /// Get students at risk across all classes
  List<StudentPerformance> getAtRiskStudents() {
    final atRiskStudents = <StudentPerformance>[];
    
    for (final analytics in _analyticsCache.values) {
      atRiskStudents.addAll(
        analytics.studentPerformances.where((s) => s.riskLevel == 'at-risk')
      );
    }
    
    return atRiskStudents;
  }

  /// Get overall statistics across all classes
  Map<String, dynamic> getOverallStats() {
    if (_analyticsCache.isEmpty) return {};
    
    double totalAverage = 0;
    int totalAssignments = 0;
    int totalGraded = 0;
    int totalPending = 0;
    int totalStudents = 0;
    
    for (final analytics in _analyticsCache.values) {
      totalAverage += analytics.averageGrade;
      totalAssignments += analytics.totalAssignments;
      totalGraded += analytics.gradedAssignments;
      totalPending += analytics.pendingSubmissions;
      totalStudents += analytics.studentPerformances.length;
    }
    
    return {
      'averageGrade': totalAverage / _analyticsCache.length,
      'totalAssignments': totalAssignments,
      'totalGraded': totalGraded,
      'totalPending': totalPending,
      'totalStudents': totalStudents,
      'completionRate': totalAssignments > 0 ? (totalGraded / totalAssignments) * 100 : 0,
    };
  }

  /// Get top performing students across all classes
  List<StudentPerformance> getTopPerformers({int limit = 10}) {
    final allStudents = <StudentPerformance>[];
    
    for (final analytics in _analyticsCache.values) {
      allStudents.addAll(analytics.studentPerformances);
    }
    
    allStudents.sort((a, b) => b.averageGrade.compareTo(a.averageGrade));
    return allStudents.take(limit).toList();
  }

  /// Get most difficult assignments
  List<AssignmentStats> getMostDifficultAssignments({int limit = 10}) {
    final allAssignments = <AssignmentStats>[];
    
    for (final analytics in _analyticsCache.values) {
      allAssignments.addAll(analytics.assignmentStats);
    }
    
    allAssignments.sort((a, b) => a.averageScore.compareTo(b.averageScore));
    return allAssignments.take(limit).toList();
  }

  /// Clear cache
  void clearCache() {
    _analyticsCache.clear();
    _trendsCache.clear();
    _loadingStates.clear();
    _errorStates.clear();
    _selectedClassId = null;
    notifyListeners();
  }

  /// Refresh analytics for a specific class
  Future<void> refreshClassAnalytics(String classId) async {
    await loadClassAnalytics(classId, forceRefresh: true);
  }

  /// Refresh all analytics
  Future<void> refreshAllAnalytics() async {
    final classIds = _analyticsCache.keys.toList();
    
    for (final classId in classIds) {
      await loadClassAnalytics(classId, forceRefresh: true);
    }
  }

  /// Generate demo trends for testing
  List<GradeTrend> _generateDemoTrends() {
    final random = Random();
    final trends = <GradeTrend>[];
    final baseGrade = 75.0 + random.nextDouble() * 10;
    
    // Generate trends for the last 30 days
    for (int i = 29; i >= 0; i--) {
      final date = DateTime.now().subtract(Duration(days: i));
      // Add some variation to make it realistic
      final variation = (random.nextDouble() - 0.5) * 5;
      final trendValue = baseGrade + variation + (29 - i) * 0.1; // Slight upward trend
      
      trends.add(GradeTrend(
        date: date,
        averageGrade: trendValue.clamp(60, 95),
        assignmentCount: random.nextInt(3) + 1,
      ));
    }
    
    return trends;
  }
}
````

## File: lib/features/grades/presentation/screens/student/grades_screen.dart
````dart
import 'package:flutter/material.dart';
import 'package:go_router/go_router.dart';
import '../../../../../shared/widgets/common/common_widgets.dart';
import '../../../../../shared/theme/app_theme.dart';

class StudentGradesScreen extends StatefulWidget {
  const StudentGradesScreen({super.key});

  @override
  State<StudentGradesScreen> createState() => _StudentGradesScreenState();
}

class _StudentGradesScreenState extends State<StudentGradesScreen> {
  String _searchQuery = '';
  String _selectedCourseId = 'all';
  String _selectedFilter = 'All';

  // Hardcoded grades data for demonstration
  final List<StudentGradeEntry> _grades = [
    // Advanced Mathematics
    StudentGradeEntry(
      id: '1',
      courseId: '1',
      courseName: 'Advanced Mathematics',
      assignmentName: 'Calculus Quiz 3',
      assignmentType: AssignmentType.quiz,
      points: 45.0,
      maxPoints: 50.0,
      percentage: 90.0,
      letterGrade: 'A-',
      submittedDate: DateTime.now().subtract(const Duration(days: 2)),
      gradedDate: DateTime.now().subtract(const Duration(days: 1)),
      feedback: 'Excellent work on derivatives! Pay attention to chain rule applications.',
      status: GradeStatus.graded,
      courseColor: AppTheme.subjectColors[0],
    ),
    StudentGradeEntry(
      id: '2',
      courseId: '1',
      courseName: 'Advanced Mathematics',
      assignmentName: 'Quadratic Equations Homework',
      assignmentType: AssignmentType.homework,
      points: 18.0,
      maxPoints: 20.0,
      percentage: 90.0,
      letterGrade: 'A-',
      submittedDate: DateTime.now().subtract(const Duration(days: 7)),
      gradedDate: DateTime.now().subtract(const Duration(days: 6)),
      feedback: 'Good understanding of quadratic formulas.',
      status: GradeStatus.graded,
      courseColor: AppTheme.subjectColors[0],
    ),
    StudentGradeEntry(
      id: '3',
      courseId: '1',
      courseName: 'Advanced Mathematics',
      assignmentName: 'Midterm Exam',
      assignmentType: AssignmentType.test,
      points: 87.0,
      maxPoints: 100.0,
      percentage: 87.0,
      letterGrade: 'B+',
      submittedDate: DateTime.now().subtract(const Duration(days: 14)),
      gradedDate: DateTime.now().subtract(const Duration(days: 12)),
      feedback: 'Strong performance overall. Review trigonometric identities for next exam.',
      status: GradeStatus.graded,
      courseColor: AppTheme.subjectColors[0],
    ),
    
    // Biology Lab
    StudentGradeEntry(
      id: '4',
      courseId: '2',
      courseName: 'Biology Lab',
      assignmentName: 'Cell Division Lab Report',
      assignmentType: AssignmentType.project,
      points: 92.0,
      maxPoints: 100.0,
      percentage: 92.0,
      letterGrade: 'A-',
      submittedDate: DateTime.now().subtract(const Duration(days: 3)),
      gradedDate: DateTime.now().subtract(const Duration(days: 1)),
      feedback: 'Excellent observations and analysis. Clear methodology and conclusions.',
      status: GradeStatus.graded,
      courseColor: AppTheme.subjectColors[1],
    ),
    StudentGradeEntry(
      id: '5',
      courseId: '2',
      courseName: 'Biology Lab',
      assignmentName: 'Mitosis Quiz',
      assignmentType: AssignmentType.quiz,
      points: 42.0,
      maxPoints: 50.0,
      percentage: 84.0,
      letterGrade: 'B',
      submittedDate: DateTime.now().subtract(const Duration(days: 10)),
      gradedDate: DateTime.now().subtract(const Duration(days: 9)),
      feedback: 'Good understanding of mitosis phases.',
      status: GradeStatus.graded,
      courseColor: AppTheme.subjectColors[1],
    ),
    
    // Creative Writing
    StudentGradeEntry(
      id: '6',
      courseId: '3',
      courseName: 'Creative Writing',
      assignmentName: 'Character Analysis Essay',
      assignmentType: AssignmentType.project,
      points: 95.0,
      maxPoints: 100.0,
      percentage: 95.0,
      letterGrade: 'A',
      submittedDate: DateTime.now().subtract(const Duration(days: 5)),
      gradedDate: DateTime.now().subtract(const Duration(days: 3)),
      feedback: 'Outstanding analysis with excellent supporting evidence. Great writing style!',
      status: GradeStatus.graded,
      courseColor: AppTheme.subjectColors[2],
    ),
    StudentGradeEntry(
      id: '7',
      courseId: '3',
      courseName: 'Creative Writing',
      assignmentName: 'Poetry Collection',
      assignmentType: AssignmentType.project,
      points: null,
      maxPoints: 50.0,
      percentage: null,
      letterGrade: null,
      submittedDate: DateTime.now().subtract(const Duration(days: 1)),
      gradedDate: null,
      feedback: null,
      status: GradeStatus.submitted,
      courseColor: AppTheme.subjectColors[2],
    ),
    
    // World History
    StudentGradeEntry(
      id: '8',
      courseId: '4',
      courseName: 'World History',
      assignmentName: 'Renaissance Research Paper',
      assignmentType: AssignmentType.project,
      points: 88.0,
      maxPoints: 100.0,
      percentage: 88.0,
      letterGrade: 'B+',
      submittedDate: DateTime.now().subtract(const Duration(days: 8)),
      gradedDate: DateTime.now().subtract(const Duration(days: 6)),
      feedback: 'Well-researched paper with good historical context. Improve citation format.',
      status: GradeStatus.graded,
      courseColor: AppTheme.subjectColors[3],
    ),
    StudentGradeEntry(
      id: '9',
      courseId: '4',
      courseName: 'World History',
      assignmentName: 'Medieval Quiz',
      assignmentType: AssignmentType.quiz,
      points: 38.0,
      maxPoints: 40.0,
      percentage: 95.0,
      letterGrade: 'A',
      submittedDate: DateTime.now().subtract(const Duration(days: 15)),
      gradedDate: DateTime.now().subtract(const Duration(days: 14)),
      feedback: 'Excellent knowledge of medieval period.',
      status: GradeStatus.graded,
      courseColor: AppTheme.subjectColors[3],
    ),
    
    // AP Physics
    StudentGradeEntry(
      id: '10',
      courseId: '5',
      courseName: 'AP Physics',
      assignmentName: 'Mechanics Problem Set',
      assignmentType: AssignmentType.homework,
      points: null,
      maxPoints: 25.0,
      percentage: null,
      letterGrade: null,
      submittedDate: null,
      gradedDate: null,
      feedback: null,
      status: GradeStatus.missing,
      courseColor: AppTheme.subjectColors[1],
    ),
    StudentGradeEntry(
      id: '11',
      courseId: '5',
      courseName: 'AP Physics',
      assignmentName: 'Lab Report: Projectile Motion',
      assignmentType: AssignmentType.project,
      points: 96.0,
      maxPoints: 100.0,
      percentage: 96.0,
      letterGrade: 'A',
      submittedDate: DateTime.now().subtract(const Duration(days: 12)),
      gradedDate: DateTime.now().subtract(const Duration(days: 10)),
      feedback: 'Excellent experimental design and data analysis. Clear conclusions.',
      status: GradeStatus.graded,
      courseColor: AppTheme.subjectColors[1],
    ),
  ];

  final List<CourseOption> _courses = [
    CourseOption(id: 'all', name: 'All Courses'),
    CourseOption(id: '1', name: 'Advanced Mathematics'),
    CourseOption(id: '2', name: 'Biology Lab'),
    CourseOption(id: '3', name: 'Creative Writing'),
    CourseOption(id: '4', name: 'World History'),
    CourseOption(id: '5', name: 'AP Physics'),
  ];

  List<StudentGradeEntry> get _filteredGrades {
    List<StudentGradeEntry> filtered = _grades;

    // Apply course filter
    if (_selectedCourseId != 'all') {
      filtered = filtered.where((grade) => grade.courseId == _selectedCourseId).toList();
    }

    // Apply status filter
    if (_selectedFilter != 'All') {
      GradeStatus status = GradeStatus.values
          .firstWhere((s) => s.toString().split('.').last == _selectedFilter.toLowerCase());
      filtered = filtered.where((grade) => grade.status == status).toList();
    }

    // Apply search filter
    if (_searchQuery.isNotEmpty) {
      filtered = filtered.where((grade) {
        return grade.assignmentName.toLowerCase().contains(_searchQuery.toLowerCase()) ||
               grade.courseName.toLowerCase().contains(_searchQuery.toLowerCase());
      }).toList();
    }

    // Sort by most recent first
    filtered.sort((a, b) {
      final aDate = a.gradedDate ?? a.submittedDate ?? DateTime(1900);
      final bDate = b.gradedDate ?? b.submittedDate ?? DateTime(1900);
      return bDate.compareTo(aDate);
    });

    return filtered;
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        leading: IconButton(
          icon: const Icon(Icons.arrow_back),
          onPressed: () => context.go('/dashboard'),
          tooltip: 'Back to Dashboard',
        ),
        title: const Text('My Grades'),
        actions: [
          IconButton(
            icon: const Icon(Icons.analytics),
            onPressed: _showGradeAnalytics,
            tooltip: 'Grade Analytics',
          ),
        ],
      ),
      body: Column(
        children: [
          // Header with stats
          _buildStatsHeader(),
          
          // Filters
          _buildFiltersSection(),
          
          // Grades list
          Expanded(
            child: _filteredGrades.isEmpty
                ? _searchQuery.isNotEmpty
                    ? EmptyState.noSearchResults(searchTerm: _searchQuery)
                    : const EmptyState(
                        icon: Icons.grade,
                        title: 'No Grades',
                        message: 'No grades found for the selected filters.',
                      )
                : _buildGradesList(),
          ),
        ],
      ),
    );
  }

  Widget _buildStatsHeader() {
    final gradedEntries = _grades.where((g) => g.status == GradeStatus.graded).toList();
    final totalPoints = gradedEntries.fold<double>(0, (sum, grade) => sum + (grade.points ?? 0));
    final totalMaxPoints = gradedEntries.fold<double>(0, (sum, grade) => sum + grade.maxPoints);
    final overallPercentage = totalMaxPoints > 0 ? (totalPoints / totalMaxPoints) * 100 : 0;
    
    final submittedCount = _grades.where((g) => g.status == GradeStatus.submitted).length;
    final missingCount = _grades.where((g) => g.status == GradeStatus.missing).length;
    
    return Container(
      margin: const EdgeInsets.all(16),
      child: Row(
        children: [
          Expanded(
            child: _buildCompactStatCard(
              title: 'Overall',
              value: _getLetterGrade(overallPercentage.toDouble()),
              subtitle: '${overallPercentage.toStringAsFixed(1)}%',
              icon: Icons.grade,
              valueColor: AppTheme.getGradeColor(_getLetterGrade(overallPercentage.toDouble())),
            ),
          ),
          const SizedBox(width: 12),
          Expanded(
            child: _buildCompactStatCard(
              title: 'Graded',
              value: '${gradedEntries.length}',
              subtitle: 'Assignments',
              icon: Icons.check_circle,
              valueColor: Colors.green,
            ),
          ),
          const SizedBox(width: 12),
          Expanded(
            child: _buildCompactStatCard(
              title: 'Pending',
              value: '$submittedCount',
              subtitle: 'Submitted',
              icon: Icons.pending,
              valueColor: Colors.orange,
            ),
          ),
          const SizedBox(width: 12),
          Expanded(
            child: _buildCompactStatCard(
              title: 'Missing',
              value: '$missingCount',
              subtitle: 'Not done',
              icon: Icons.warning,
              valueColor: Colors.red,
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildCompactStatCard({
    required String title,
    required String value,
    required String subtitle,
    required IconData icon,
    Color? valueColor,
  }) {
    return Container(
      padding: const EdgeInsets.all(12),
      decoration: BoxDecoration(
        color: Theme.of(context).colorScheme.surfaceContainerLow,
        borderRadius: BorderRadius.circular(12),
        border: Border.all(
          color: Theme.of(context).colorScheme.outline.withValues(alpha: 0.2),
        ),
      ),
      child: Column(
        mainAxisSize: MainAxisSize.min,
        children: [
          Row(
            mainAxisAlignment: MainAxisAlignment.spaceBetween,
            children: [
              Icon(
                icon,
                size: 16,
                color: valueColor ?? Theme.of(context).colorScheme.primary,
              ),
              Text(
                title,
                style: Theme.of(context).textTheme.labelSmall?.copyWith(
                  color: Theme.of(context).colorScheme.onSurfaceVariant,
                  fontWeight: FontWeight.w500,
                ),
                overflow: TextOverflow.ellipsis,
              ),
            ],
          ),
          const SizedBox(height: 4),
          Text(
            value,
            style: Theme.of(context).textTheme.titleMedium?.copyWith(
              fontWeight: FontWeight.bold,
              color: valueColor,
            ),
            textAlign: TextAlign.center,
          ),
          Text(
            subtitle,
            style: Theme.of(context).textTheme.labelSmall?.copyWith(
              color: Theme.of(context).colorScheme.onSurfaceVariant,
            ),
            textAlign: TextAlign.center,
            overflow: TextOverflow.ellipsis,
          ),
        ],
      ),
    );
  }

  Widget _buildFiltersSection() {
    return Padding(
      padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
      child: Column(
        children: [
          // Search bar
          TextField(
            decoration: const InputDecoration(
              hintText: 'Search assignments...',
              prefixIcon: Icon(Icons.search),
              border: OutlineInputBorder(),
            ),
            onChanged: (value) {
              setState(() {
                _searchQuery = value;
              });
            },
          ),
          const SizedBox(height: 12),
          
          // Filter dropdowns
          Row(
            children: [
              Expanded(
                child: DropdownButtonFormField<String>(
                  isExpanded: true,
                  value: _selectedCourseId,
                  decoration: const InputDecoration(
                    labelText: 'Course',
                    border: OutlineInputBorder(),
                    isDense: true,
                    contentPadding: EdgeInsets.symmetric(horizontal: 12, vertical: 8),
                  ),
                  items: _courses
                      .map((course) => DropdownMenuItem(
                            value: course.id,
                            child: Text(
                              course.name,
                              overflow: TextOverflow.ellipsis,
                            ),
                          ))
                      .toList(),
                  onChanged: (value) {
                    setState(() {
                      _selectedCourseId = value ?? 'all';
                    });
                  },
                ),
              ),
              const SizedBox(width: 12),
              Expanded(
                child: DropdownButtonFormField<String>(
                  isExpanded: true,
                  value: _selectedFilter,
                  decoration: const InputDecoration(
                    labelText: 'Status',
                    border: OutlineInputBorder(),
                    isDense: true,
                    contentPadding: EdgeInsets.symmetric(horizontal: 12, vertical: 8),
                  ),
                  items: ['All', 'Graded', 'Submitted', 'Missing']
                      .map((filter) => DropdownMenuItem(
                            value: filter,
                            child: Text(filter),
                          ))
                      .toList(),
                  onChanged: (value) {
                    setState(() {
                      _selectedFilter = value ?? 'All';
                    });
                  },
                ),
              ),
            ],
          ),
        ],
      ),
    );
  }

  Widget _buildGradesList() {
    return ListView.builder(
      padding: const EdgeInsets.symmetric(horizontal: 16),
      itemCount: _filteredGrades.length,
      itemBuilder: (context, index) {
        final grade = _filteredGrades[index];
        return _buildGradeCard(grade);
      },
    );
  }

  Widget _buildGradeCard(StudentGradeEntry grade) {
    return AppCard(
      onTap: () => _showGradeDetails(grade),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          // Header row with assignment name and grade
          Row(
            children: [
              Container(
                width: 4,
                height: 40,
                decoration: BoxDecoration(
                  color: grade.courseColor,
                  borderRadius: BorderRadius.circular(2),
                ),
              ),
              const SizedBox(width: 12),
              Expanded(
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Text(
                      grade.assignmentName,
                      style: Theme.of(context).textTheme.titleMedium?.copyWith(
                        fontWeight: FontWeight.bold,
                      ),
                    ),
                    Text(
                      grade.courseName,
                      style: Theme.of(context).textTheme.bodyMedium?.copyWith(
                        color: Theme.of(context).colorScheme.onSurfaceVariant,
                      ),
                    ),
                  ],
                ),
              ),
              if (grade.letterGrade != null)
                StatusBadge.grade(grade: grade.letterGrade!)
              else
                _buildStatusChip(grade.status),
            ],
          ),
          
          const SizedBox(height: 16),
          
          // Grade info
          Row(
            children: [
              _buildInfoChip(Icons.category, _getAssignmentTypeLabel(grade.assignmentType)),
              const SizedBox(width: 8),
              if (grade.points != null)
                _buildInfoChip(Icons.score, '${grade.points!.toStringAsFixed(0)}/${grade.maxPoints.toStringAsFixed(0)}'),
              if (grade.percentage != null) ...[
                const SizedBox(width: 8),
                _buildInfoChip(Icons.percent, '${grade.percentage!.toStringAsFixed(1)}%'),
              ],
            ],
          ),
          
          if (grade.status == GradeStatus.graded && grade.percentage != null) ...[
            const SizedBox(height: 12),
            
            // Grade progress bar
            LinearProgressIndicator(
              value: grade.percentage! / 100,
              backgroundColor: Theme.of(context).colorScheme.surfaceContainerHighest,
              valueColor: AlwaysStoppedAnimation(
                AppTheme.getGradeColor(grade.letterGrade ?? 'F'),
              ),
            ),
          ],
          
          const SizedBox(height: 12),
          
          // Date information
          Row(
            children: [
              Icon(
                Icons.schedule,
                size: 16,
                color: Theme.of(context).colorScheme.onSurfaceVariant,
              ),
              const SizedBox(width: 4),
              Text(
                _getDateText(grade),
                style: Theme.of(context).textTheme.bodySmall?.copyWith(
                  color: Theme.of(context).colorScheme.onSurfaceVariant,
                ),
              ),
            ],
          ),
          
          // Feedback preview
          if (grade.feedback != null && grade.feedback!.isNotEmpty) ...[
            const SizedBox(height: 8),
            Row(
              children: [
                Icon(
                  Icons.feedback,
                  size: 16,
                  color: Theme.of(context).colorScheme.primary,
                ),
                const SizedBox(width: 4),
                Expanded(
                  child: Text(
                    grade.feedback!,
                    style: Theme.of(context).textTheme.bodySmall?.copyWith(
                      color: Theme.of(context).colorScheme.primary,
                    ),
                    maxLines: 2,
                    overflow: TextOverflow.ellipsis,
                  ),
                ),
              ],
            ),
          ],
        ],
      ),
    );
  }

  Widget _buildInfoChip(IconData icon, String text) {
    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
      decoration: BoxDecoration(
        color: Theme.of(context).colorScheme.surfaceContainerHighest,
        borderRadius: BorderRadius.circular(12),
      ),
      child: Row(
        mainAxisSize: MainAxisSize.min,
        children: [
          Icon(
            icon,
            size: 14,
            color: Theme.of(context).colorScheme.onSurfaceVariant,
          ),
          const SizedBox(width: 4),
          Text(
            text,
            style: Theme.of(context).textTheme.bodySmall?.copyWith(
              color: Theme.of(context).colorScheme.onSurfaceVariant,
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildStatusChip(GradeStatus status) {
    Color color;
    String label;
    
    switch (status) {
      case GradeStatus.graded:
        color = Colors.green;
        label = 'Graded';
        break;
      case GradeStatus.submitted:
        color = Colors.orange;
        label = 'Submitted';
        break;
      case GradeStatus.missing:
        color = Colors.red;
        label = 'Missing';
        break;
    }
    
    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
      decoration: BoxDecoration(
        color: color.withValues(alpha: 0.1),
        borderRadius: BorderRadius.circular(12),
      ),
      child: Text(
        label,
        style: TextStyle(
          color: color,
          fontWeight: FontWeight.w600,
          fontSize: 12,
        ),
      ),
    );
  }

  String _getAssignmentTypeLabel(AssignmentType type) {
    switch (type) {
      case AssignmentType.homework:
        return 'Homework';
      case AssignmentType.quiz:
        return 'Quiz';
      case AssignmentType.test:
        return 'Test';
      case AssignmentType.project:
        return 'Project';
      case AssignmentType.exam:
        return 'Exam';
    }
  }

  String _getDateText(StudentGradeEntry grade) {
    if (grade.gradedDate != null) {
      final days = DateTime.now().difference(grade.gradedDate!).inDays;
      if (days == 0) return 'Graded today';
      if (days == 1) return 'Graded yesterday';
      return 'Graded $days days ago';
    } else if (grade.submittedDate != null) {
      final days = DateTime.now().difference(grade.submittedDate!).inDays;
      if (days == 0) return 'Submitted today';
      if (days == 1) return 'Submitted yesterday';
      return 'Submitted $days days ago';
    } else {
      return 'Not submitted';
    }
  }

  String _getLetterGrade(double percentage) {
    if (percentage >= 97) return 'A+';
    if (percentage >= 93) return 'A';
    if (percentage >= 90) return 'A-';
    if (percentage >= 87) return 'B+';
    if (percentage >= 83) return 'B';
    if (percentage >= 80) return 'B-';
    if (percentage >= 77) return 'C+';
    if (percentage >= 73) return 'C';
    if (percentage >= 70) return 'C-';
    if (percentage >= 67) return 'D+';
    if (percentage >= 63) return 'D';
    if (percentage >= 60) return 'D-';
    return 'F';
  }

  void _showGradeDetails(StudentGradeEntry grade) {
    showModalBottomSheet(
      context: context,
      isScrollControlled: true,
      builder: (context) => GradeDetailSheet(grade: grade),
    );
  }

  void _showGradeAnalytics() {
    ScaffoldMessenger.of(context).showSnackBar(
      SnackBar(
        content: const Text('Grade analytics coming soon!'),
        action: SnackBarAction(
          label: 'OK',
          onPressed: () {},
        ),
      ),
    );
  }
}

// Grade detail modal sheet
class GradeDetailSheet extends StatelessWidget {
  final StudentGradeEntry grade;

  const GradeDetailSheet({super.key, required this.grade});

  @override
  Widget build(BuildContext context) {
    return DraggableScrollableSheet(
      initialChildSize: 0.6,
      minChildSize: 0.4,
      maxChildSize: 0.9,
      expand: false,
      builder: (context, scrollController) {
        return Container(
          decoration: BoxDecoration(
            color: Theme.of(context).colorScheme.surface,
            borderRadius: const BorderRadius.vertical(top: Radius.circular(16)),
          ),
          child: Column(
            children: [
              // Handle bar
              Container(
                margin: const EdgeInsets.only(top: 8),
                width: 40,
                height: 4,
                decoration: BoxDecoration(
                  color: Theme.of(context).colorScheme.onSurfaceVariant,
                  borderRadius: BorderRadius.circular(2),
                ),
              ),
              
              // Header
              Padding(
                padding: const EdgeInsets.all(16),
                child: Row(
                  children: [
                    Container(
                      width: 6,
                      height: 50,
                      decoration: BoxDecoration(
                        color: grade.courseColor,
                        borderRadius: BorderRadius.circular(3),
                      ),
                    ),
                    const SizedBox(width: 16),
                    Expanded(
                      child: Column(
                        crossAxisAlignment: CrossAxisAlignment.start,
                        children: [
                          Text(
                            grade.assignmentName,
                            style: Theme.of(context).textTheme.headlineSmall?.copyWith(
                              fontWeight: FontWeight.bold,
                            ),
                          ),
                          Text(
                            grade.courseName,
                            style: Theme.of(context).textTheme.titleMedium?.copyWith(
                              color: Theme.of(context).colorScheme.onSurfaceVariant,
                            ),
                          ),
                        ],
                      ),
                    ),
                    if (grade.letterGrade != null)
                      StatusBadge.grade(grade: grade.letterGrade!)
                    else
                      StatusBadge.custom(
                        label: grade.status.toString().split('.').last,
                        color: _getStatusColor(grade.status),
                      ),
                  ],
                ),
              ),
              
              // Content
              Expanded(
                child: ListView(
                  controller: scrollController,
                  padding: const EdgeInsets.symmetric(horizontal: 16),
                  children: [
                    if (grade.status == GradeStatus.graded) ...[
                      _buildDetailSection(
                        context,
                        'Grade Information',
                        [
                          if (grade.points != null)
                            _buildDetailRow(context, 'Points', '${grade.points!.toStringAsFixed(0)}/${grade.maxPoints.toStringAsFixed(0)}'),
                          if (grade.percentage != null)
                            _buildDetailRow(context, 'Percentage', '${grade.percentage!.toStringAsFixed(1)}%'),
                          if (grade.letterGrade != null)
                            _buildDetailRow(context, 'Letter Grade', grade.letterGrade!),
                        ],
                      ),
                      const SizedBox(height: 24),
                    ],
                    
                    _buildDetailSection(
                      context,
                      'Assignment Details',
                      [
                        _buildDetailRow(context, 'Type', _getAssignmentTypeLabel(grade.assignmentType)),
                        _buildDetailRow(context, 'Max Points', grade.maxPoints.toStringAsFixed(0)),
                        _buildDetailRow(context, 'Status', grade.status.toString().split('.').last),
                      ],
                    ),
                    
                    const SizedBox(height: 24),
                    
                    _buildDetailSection(
                      context,
                      'Timeline',
                      [
                        if (grade.submittedDate != null)
                          _buildDetailRow(context, 'Submitted', _formatDate(grade.submittedDate!)),
                        if (grade.gradedDate != null)
                          _buildDetailRow(context, 'Graded', _formatDate(grade.gradedDate!)),
                      ],
                    ),
                    
                    if (grade.feedback != null && grade.feedback!.isNotEmpty) ...[
                      const SizedBox(height: 24),
                      
                      _buildDetailSection(
                        context,
                        'Teacher Feedback',
                        [
                          Container(
                            width: double.infinity,
                            padding: const EdgeInsets.all(12),
                            decoration: BoxDecoration(
                              color: Theme.of(context).colorScheme.surfaceContainerLow,
                              borderRadius: BorderRadius.circular(8),
                              border: Border.all(
                                color: Theme.of(context).colorScheme.outline.withValues(alpha: 0.2),
                              ),
                            ),
                            child: Text(
                              grade.feedback!,
                              style: Theme.of(context).textTheme.bodyMedium,
                            ),
                          ),
                        ],
                      ),
                    ],
                  ],
                ),
              ),
              
              // Actions
              Padding(
                padding: const EdgeInsets.all(16),
                child: SizedBox(
                  width: double.infinity,
                  child: OutlinedButton(
                    onPressed: () => Navigator.pop(context),
                    child: const Text('Close'),
                  ),
                ),
              ),
            ],
          ),
        );
      },
    );
  }

  Widget _buildDetailSection(BuildContext context, String title, List<Widget> children) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Text(
          title,
          style: Theme.of(context).textTheme.titleMedium?.copyWith(
            fontWeight: FontWeight.bold,
          ),
        ),
        const SizedBox(height: 12),
        ...children,
      ],
    );
  }

  Widget _buildDetailRow(BuildContext context, String label, String value) {
    return Padding(
      padding: const EdgeInsets.symmetric(vertical: 4),
      child: Row(
        children: [
          SizedBox(
            width: 100,
            child: Text(
              label,
              style: Theme.of(context).textTheme.bodyMedium?.copyWith(
                color: Theme.of(context).colorScheme.onSurfaceVariant,
              ),
            ),
          ),
          Text(
            value,
            style: Theme.of(context).textTheme.bodyMedium?.copyWith(
              fontWeight: FontWeight.w500,
            ),
          ),
        ],
      ),
    );
  }

  String _getAssignmentTypeLabel(AssignmentType type) {
    switch (type) {
      case AssignmentType.homework:
        return 'Homework';
      case AssignmentType.quiz:
        return 'Quiz';
      case AssignmentType.test:
        return 'Test';
      case AssignmentType.project:
        return 'Project';
      case AssignmentType.exam:
        return 'Exam';
    }
  }

  Color _getStatusColor(GradeStatus status) {
    switch (status) {
      case GradeStatus.graded:
        return Colors.green;
      case GradeStatus.submitted:
        return Colors.orange;
      case GradeStatus.missing:
        return Colors.red;
    }
  }

  String _formatDate(DateTime date) {
    final now = DateTime.now();
    final diff = now.difference(date).inDays;
    
    if (diff == 0) {
      return 'Today';
    } else if (diff == 1) {
      return 'Yesterday';
    } else if (diff < 7) {
      return '$diff days ago';
    } else {
      return '${date.day}/${date.month}/${date.year}';
    }
  }
}

// Data models
class StudentGradeEntry {
  final String id;
  final String courseId;
  final String courseName;
  final String assignmentName;
  final AssignmentType assignmentType;
  final double? points;
  final double maxPoints;
  final double? percentage;
  final String? letterGrade;
  final DateTime? submittedDate;
  final DateTime? gradedDate;
  final String? feedback;
  final GradeStatus status;
  final Color courseColor;

  StudentGradeEntry({
    required this.id,
    required this.courseId,
    required this.courseName,
    required this.assignmentName,
    required this.assignmentType,
    this.points,
    required this.maxPoints,
    this.percentage,
    this.letterGrade,
    this.submittedDate,
    this.gradedDate,
    this.feedback,
    required this.status,
    required this.courseColor,
  });
}

class CourseOption {
  final String id;
  final String name;

  CourseOption({required this.id, required this.name});
}

enum AssignmentType {
  homework,
  quiz,
  test,
  project,
  exam,
}

enum GradeStatus {
  graded,
  submitted,
  missing,
}
````

## File: lib/features/grades/presentation/screens/teacher/grade_analytics_screen.dart
````dart
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'package:fl_chart/fl_chart.dart';
import '../../providers/grade_analytics_provider.dart';
import '../../../domain/models/grade_analytics.dart';
import '../../../../../shared/widgets/common/adaptive_layout.dart';
import '../../../../../shared/widgets/common/responsive_layout.dart';

class GradeAnalyticsScreen extends StatefulWidget {
  final String? classId;

  const GradeAnalyticsScreen({super.key, this.classId});

  @override
  State<GradeAnalyticsScreen> createState() => _GradeAnalyticsScreenState();
}

class _GradeAnalyticsScreenState extends State<GradeAnalyticsScreen> {
  String? _selectedClassId;
  
  // Demo class data
  final List<Map<String, String>> _classes = [
    {'id': 'math-101', 'name': 'Mathematics 101'},
    {'id': 'sci-202', 'name': 'Science 202'},
    {'id': 'eng-303', 'name': 'English 303'},
    {'id': 'hist-404', 'name': 'History 404'},
  ];
  
  @override
  void initState() {
    super.initState();
    _selectedClassId = widget.classId;
    
    // Load analytics for the class
    WidgetsBinding.instance.addPostFrameCallback((_) {
      final provider = context.read<GradeAnalyticsProvider>();
      if (widget.classId != null) {
        provider.loadClassAnalytics(widget.classId!);
      }
    });
  }

  @override
  Widget build(BuildContext context) {
    final analyticsProvider = context.watch<GradeAnalyticsProvider>();
    
    return AdaptiveLayout(
      title: 'Grade Analytics',
      actions: [
        IconButton(
          icon: const Icon(Icons.refresh),
          onPressed: () {
            if (_selectedClassId != null) {
              analyticsProvider.refreshClassAnalytics(_selectedClassId!);
            }
          },
        ),
        PopupMenuButton<int>(
          icon: const Icon(Icons.date_range),
          onSelected: (days) {
            analyticsProvider.updateTrendDays(days);
          },
          itemBuilder: (context) => [
            const PopupMenuItem(value: 7, child: Text('Last 7 days')),
            const PopupMenuItem(value: 30, child: Text('Last 30 days')),
            const PopupMenuItem(value: 90, child: Text('Last 90 days')),
            const PopupMenuItem(value: 180, child: Text('Last 6 months')),
          ],
        ),
      ],
      body: Column(
        children: [
          // Class selector
          Padding(
            padding: const EdgeInsets.all(16),
            child: DropdownButtonFormField<String>(
              value: _selectedClassId,
              decoration: const InputDecoration(
                labelText: 'Select Class',
                border: OutlineInputBorder(),
              ),
              items: _classes.map((classInfo) {
                return DropdownMenuItem(
                  value: classInfo['id'],
                  child: Text(classInfo['name']!),
                );
              }).toList(),
              onChanged: (classId) {
                setState(() {
                  _selectedClassId = classId;
                });
                if (classId != null) {
                  analyticsProvider.loadClassAnalytics(classId);
                }
              },
            ),
          ),
          Expanded(
            child: _selectedClassId != null
                ? _buildClassAnalytics(context, _selectedClassId!)
                : _buildOverviewAnalytics(context),
          ),
        ],
      ),
    );
  }

  Widget _buildClassAnalytics(BuildContext context, String classId) {
    final analyticsProvider = context.watch<GradeAnalyticsProvider>();
    final analytics = analyticsProvider.getClassAnalytics(classId);
    final trends = analyticsProvider.getClassTrends(classId);
    final isLoading = analyticsProvider.isLoading(classId);
    final error = analyticsProvider.getError(classId);

    if (isLoading) {
      return const Center(child: CircularProgressIndicator());
    }

    if (error != null) {
      return Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            const Icon(Icons.error_outline, size: 64, color: Colors.red),
            const SizedBox(height: 16),
            Text('Error: $error'),
            const SizedBox(height: 16),
            ElevatedButton(
              onPressed: () => analyticsProvider.refreshClassAnalytics(classId),
              child: const Text('Retry'),
            ),
          ],
        ),
      );
    }

    if (analytics == null) {
      return const Center(child: Text('No analytics data available'));
    }

    return ResponsiveContainer(
      child: RefreshIndicator(
        onRefresh: () => analyticsProvider.refreshClassAnalytics(classId),
        child: SingleChildScrollView(
          padding: const EdgeInsets.all(16),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              // Summary Cards
              _buildSummaryCards(analytics),
              const SizedBox(height: 24),
              
              // Grade Distribution Chart
              _buildSectionTitle('Grade Distribution'),
              const SizedBox(height: 16),
              _buildGradeDistributionChart(analytics),
              const SizedBox(height: 32),
              
              // Performance Trend Chart
              if (trends != null && trends.isNotEmpty) ...[
                _buildSectionTitle('Performance Trend'),
                const SizedBox(height: 16),
                _buildTrendChart(trends),
                const SizedBox(height: 32),
              ],
              
              // Category Performance
              _buildSectionTitle('Performance by Category'),
              const SizedBox(height: 16),
              _buildCategoryPerformanceChart(analytics),
              const SizedBox(height: 32),
              
              // Student Performance Table
              _buildSectionTitle('Student Performance'),
              const SizedBox(height: 16),
              _buildStudentPerformanceTable(analytics),
              const SizedBox(height: 32),
              
              // Assignment Statistics
              _buildSectionTitle('Assignment Statistics'),
              const SizedBox(height: 16),
              _buildAssignmentStatsTable(analytics),
            ],
          ),
        ),
      ),
    );
  }

  Widget _buildOverviewAnalytics(BuildContext context) {
    // Implementation for overview across all classes
    return Center(
      child: Column(
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          const Icon(Icons.analytics, size: 64),
          const SizedBox(height: 16),
          const Text(
            'Grade Analytics Dashboard',
            style: TextStyle(fontSize: 24, fontWeight: FontWeight.bold),
          ),
          const SizedBox(height: 8),
          const Text('Select a class from the dropdown to view detailed analytics'),
          const SizedBox(height: 24),
          ElevatedButton(
            onPressed: () {
              // For testing, load analytics for a hardcoded class
              context.read<GradeAnalyticsProvider>().loadClassAnalytics('test-class-1');
            },
            child: const Text('Load Test Analytics'),
          ),
        ],
      ),
    );
  }

  Widget _buildSectionTitle(String title) {
    return Text(
      title,
      style: Theme.of(context).textTheme.headlineSmall?.copyWith(
        fontWeight: FontWeight.bold,
      ),
    );
  }

  Widget _buildSummaryCards(GradeAnalytics analytics) {
    return Wrap(
      spacing: 16,
      runSpacing: 16,
      children: [
        _buildSummaryCard(
          'Class Average',
          '${analytics.averageGrade.toStringAsFixed(1)}%',
          analytics.averageLetterGrade,
          Icons.grade,
          _getGradeColor(analytics.averageLetterGrade),
        ),
        _buildSummaryCard(
          'Completion Rate',
          '${analytics.completionRate.toStringAsFixed(0)}%',
          '${analytics.gradedAssignments}/${analytics.totalAssignments}',
          Icons.assignment_turned_in,
          Colors.blue,
        ),
        _buildSummaryCard(
          'Pending Grading',
          analytics.pendingSubmissions.toString(),
          'Submissions',
          Icons.pending_actions,
          Colors.orange,
        ),
        _buildSummaryCard(
          'At-Risk Students',
          analytics.studentPerformances
              .where((s) => s.riskLevel == 'at-risk')
              .length
              .toString(),
          'Students',
          Icons.warning,
          Colors.red,
        ),
      ],
    );
  }

  Widget _buildSummaryCard(
    String title,
    String value,
    String subtitle,
    IconData icon,
    Color color,
  ) {
    return Container(
      width: 200,
      padding: const EdgeInsets.all(16),
      decoration: BoxDecoration(
        color: Theme.of(context).colorScheme.surface,
        borderRadius: BorderRadius.circular(12),
        border: Border.all(
          color: Theme.of(context).colorScheme.outline.withAlpha(51),
        ),
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Row(
            children: [
              Icon(icon, color: color, size: 24),
              const SizedBox(width: 8),
              Expanded(
                child: Text(
                  title,
                  style: Theme.of(context).textTheme.titleMedium,
                ),
              ),
            ],
          ),
          const SizedBox(height: 12),
          Text(
            value,
            style: Theme.of(context).textTheme.headlineMedium?.copyWith(
              fontWeight: FontWeight.bold,
              color: color,
            ),
          ),
          Text(
            subtitle,
            style: Theme.of(context).textTheme.bodySmall?.copyWith(
              color: Theme.of(context).colorScheme.onSurfaceVariant,
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildGradeDistributionChart(GradeAnalytics analytics) {
    final distribution = analytics.gradeDistributionPercentages;
    
    return Container(
      height: 300,
      padding: const EdgeInsets.all(16),
      decoration: BoxDecoration(
        color: Theme.of(context).colorScheme.surface,
        borderRadius: BorderRadius.circular(12),
        border: Border.all(
          color: Theme.of(context).colorScheme.outline.withAlpha(51),
        ),
      ),
      child: BarChart(
        BarChartData(
          alignment: BarChartAlignment.spaceAround,
          maxY: distribution.values.isEmpty 
              ? 100 
              : distribution.values.reduce((a, b) => a > b ? a : b) * 1.2,
          barTouchData: BarTouchData(
            enabled: true,
            touchTooltipData: BarTouchTooltipData(
              getTooltipItem: (group, groupIndex, rod, rodIndex) {
                final grade = ['A', 'B', 'C', 'D', 'F'][groupIndex];
                return BarTooltipItem(
                  '$grade\n${rod.toY.toStringAsFixed(1)}%',
                  const TextStyle(color: Colors.white),
                );
              },
            ),
          ),
          titlesData: FlTitlesData(
            show: true,
            bottomTitles: AxisTitles(
              sideTitles: SideTitles(
                showTitles: true,
                getTitlesWidget: (value, meta) {
                  const grades = ['A', 'B', 'C', 'D', 'F'];
                  return Text(
                    grades[value.toInt() % grades.length],
                    style: const TextStyle(fontSize: 14),
                  );
                },
              ),
            ),
            leftTitles: AxisTitles(
              sideTitles: SideTitles(
                showTitles: true,
                reservedSize: 35,
                getTitlesWidget: (value, meta) {
                  return Text(
                    '${value.toInt()}%',
                    style: const TextStyle(fontSize: 10),
                  );
                },
              ),
            ),
            topTitles: const AxisTitles(
              sideTitles: SideTitles(showTitles: false),
            ),
            rightTitles: const AxisTitles(
              sideTitles: SideTitles(showTitles: false),
            ),
          ),
          borderData: FlBorderData(show: false),
          barGroups: _createGradeDistributionBars(distribution),
        ),
      ),
    );
  }

  List<BarChartGroupData> _createGradeDistributionBars(Map<String, double> distribution) {
    final grades = ['A', 'B', 'C', 'D', 'F'];
    final colors = [
      Colors.green,
      Colors.blue,
      Colors.yellow[700]!,
      Colors.orange,
      Colors.red,
    ];
    
    return List.generate(grades.length, (index) {
      final grade = grades[index];
      double percentage = 0;
      
      // Sum all sub-grades for main grade
      distribution.forEach((key, value) {
        if (key.startsWith(grade)) {
          percentage += value;
        }
      });
      
      return BarChartGroupData(
        x: index,
        barRods: [
          BarChartRodData(
            toY: percentage,
            color: colors[index],
            width: 40,
            borderRadius: const BorderRadius.vertical(top: Radius.circular(6)),
          ),
        ],
      );
    });
  }

  Widget _buildTrendChart(List<GradeTrend> trends) {
    if (trends.isEmpty) return const SizedBox();
    
    return Container(
      height: 300,
      padding: const EdgeInsets.all(16),
      decoration: BoxDecoration(
        color: Theme.of(context).colorScheme.surface,
        borderRadius: BorderRadius.circular(12),
        border: Border.all(
          color: Theme.of(context).colorScheme.outline.withAlpha(51),
        ),
      ),
      child: LineChart(
        LineChartData(
          gridData: FlGridData(
            show: true,
            drawVerticalLine: true,
            horizontalInterval: 10,
            getDrawingHorizontalLine: (value) {
              return FlLine(
                color: Theme.of(context).colorScheme.outline.withAlpha(26),
                strokeWidth: 1,
              );
            },
            getDrawingVerticalLine: (value) {
              return FlLine(
                color: Theme.of(context).colorScheme.outline.withAlpha(26),
                strokeWidth: 1,
              );
            },
          ),
          titlesData: FlTitlesData(
            show: true,
            bottomTitles: AxisTitles(
              sideTitles: SideTitles(
                showTitles: true,
                reservedSize: 30,
                interval: 1,
                getTitlesWidget: (value, meta) {
                  if (value.toInt() >= 0 && value.toInt() < trends.length) {
                    final date = trends[value.toInt()].date;
                    return Text(
                      '${date.month}/${date.day}',
                      style: const TextStyle(fontSize: 10),
                    );
                  }
                  return const Text('');
                },
              ),
            ),
            leftTitles: AxisTitles(
              sideTitles: SideTitles(
                showTitles: true,
                reservedSize: 35,
                getTitlesWidget: (value, meta) {
                  return Text(
                    '${value.toInt()}%',
                    style: const TextStyle(fontSize: 10),
                  );
                },
              ),
            ),
            topTitles: const AxisTitles(
              sideTitles: SideTitles(showTitles: false),
            ),
            rightTitles: const AxisTitles(
              sideTitles: SideTitles(showTitles: false),
            ),
          ),
          borderData: FlBorderData(
            show: true,
            border: Border.all(
              color: Theme.of(context).colorScheme.outline.withAlpha(51),
            ),
          ),
          minX: 0,
          maxX: trends.length - 1,
          minY: 0,
          maxY: 100,
          lineBarsData: [
            LineChartBarData(
              spots: trends.asMap().entries.map((entry) {
                return FlSpot(entry.key.toDouble(), entry.value.averageGrade);
              }).toList(),
              isCurved: true,
              color: Theme.of(context).colorScheme.primary,
              barWidth: 3,
              isStrokeCapRound: true,
              dotData: const FlDotData(show: true),
              belowBarData: BarAreaData(
                show: true,
                color: Theme.of(context).colorScheme.primary.withAlpha(51),
              ),
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildCategoryPerformanceChart(GradeAnalytics analytics) {
    final categories = analytics.categoryAverages;
    
    if (categories.isEmpty) {
      return const Center(child: Text('No category data available'));
    }
    
    return Container(
      height: 250,
      padding: const EdgeInsets.all(16),
      decoration: BoxDecoration(
        color: Theme.of(context).colorScheme.surface,
        borderRadius: BorderRadius.circular(12),
        border: Border.all(
          color: Theme.of(context).colorScheme.outline.withAlpha(51),
        ),
      ),
      child: BarChart(
        BarChartData(
          alignment: BarChartAlignment.spaceAround,
          maxY: 100,
          barTouchData: BarTouchData(
            enabled: true,
            touchTooltipData: BarTouchTooltipData(
              getTooltipItem: (group, groupIndex, rod, rodIndex) {
                final category = categories.keys.toList()[groupIndex];
                return BarTooltipItem(
                  '$category\n${rod.toY.toStringAsFixed(1)}%',
                  const TextStyle(color: Colors.white),
                );
              },
            ),
          ),
          titlesData: FlTitlesData(
            show: true,
            bottomTitles: AxisTitles(
              sideTitles: SideTitles(
                showTitles: true,
                getTitlesWidget: (value, meta) {
                  final index = value.toInt();
                  if (index >= 0 && index < categories.length) {
                    final category = categories.keys.toList()[index];
                    return Padding(
                      padding: const EdgeInsets.only(top: 8),
                      child: Text(
                        category.length > 10 
                            ? '${category.substring(0, 10)}...' 
                            : category,
                        style: const TextStyle(fontSize: 10),
                      ),
                    );
                  }
                  return const Text('');
                },
              ),
            ),
            leftTitles: AxisTitles(
              sideTitles: SideTitles(
                showTitles: true,
                reservedSize: 35,
                getTitlesWidget: (value, meta) {
                  return Text(
                    '${value.toInt()}%',
                    style: const TextStyle(fontSize: 10),
                  );
                },
              ),
            ),
            topTitles: const AxisTitles(
              sideTitles: SideTitles(showTitles: false),
            ),
            rightTitles: const AxisTitles(
              sideTitles: SideTitles(showTitles: false),
            ),
          ),
          borderData: FlBorderData(show: false),
          barGroups: categories.entries.toList().asMap().entries.map((entry) {
            return BarChartGroupData(
              x: entry.key,
              barRods: [
                BarChartRodData(
                  toY: entry.value.value,
                  color: _getCategoryColor(entry.value.value),
                  width: 30,
                  borderRadius: const BorderRadius.vertical(top: Radius.circular(6)),
                ),
              ],
            );
          }).toList(),
        ),
      ),
    );
  }

  Widget _buildStudentPerformanceTable(GradeAnalytics analytics) {
    final students = List<StudentPerformance>.from(analytics.studentPerformances)
      ..sort((a, b) => b.averageGrade.compareTo(a.averageGrade));
    
    return Container(
      decoration: BoxDecoration(
        color: Theme.of(context).colorScheme.surface,
        borderRadius: BorderRadius.circular(12),
        border: Border.all(
          color: Theme.of(context).colorScheme.outline.withAlpha(51),
        ),
      ),
      child: SingleChildScrollView(
        scrollDirection: Axis.horizontal,
        child: DataTable(
          columns: const [
            DataColumn(label: Text('Student')),
            DataColumn(label: Text('Average')),
            DataColumn(label: Text('Grade')),
            DataColumn(label: Text('Completed')),
            DataColumn(label: Text('Missing')),
            DataColumn(label: Text('Status')),
            DataColumn(label: Text('Trend')),
          ],
          rows: students.map((student) {
            return DataRow(
              cells: [
                DataCell(Text(student.studentName)),
                DataCell(Text('${student.averageGrade.toStringAsFixed(1)}%')),
                DataCell(
                  Container(
                    padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
                    decoration: BoxDecoration(
                      color: _getGradeColor(student.letterGrade).withAlpha(51),
                      borderRadius: BorderRadius.circular(4),
                    ),
                    child: Text(
                      student.letterGrade,
                      style: TextStyle(
                        color: _getGradeColor(student.letterGrade),
                        fontWeight: FontWeight.bold,
                      ),
                    ),
                  ),
                ),
                DataCell(Text(student.completedAssignments.toString())),
                DataCell(Text(student.missingAssignments.toString())),
                DataCell(
                  _buildRiskBadge(student.riskLevel),
                ),
                DataCell(
                  Row(
                    children: [
                      Icon(
                        student.trend > 0 
                            ? Icons.trending_up 
                            : student.trend < 0 
                                ? Icons.trending_down 
                                : Icons.trending_flat,
                        color: student.trend > 0 
                            ? Colors.green 
                            : student.trend < 0 
                                ? Colors.red 
                                : Colors.grey,
                        size: 16,
                      ),
                      const SizedBox(width: 4),
                      Text(
                        '${student.trend > 0 ? '+' : ''}${student.trend.toStringAsFixed(1)}%',
                        style: TextStyle(
                          color: student.trend > 0 
                              ? Colors.green 
                              : student.trend < 0 
                                  ? Colors.red 
                                  : Colors.grey,
                          fontWeight: FontWeight.bold,
                        ),
                      ),
                    ],
                  ),
                ),
              ],
            );
          }).toList(),
        ),
      ),
    );
  }

  Widget _buildAssignmentStatsTable(GradeAnalytics analytics) {
    final assignments = List<AssignmentStats>.from(analytics.assignmentStats)
      ..sort((a, b) => a.averageScore.compareTo(b.averageScore));
    
    return Container(
      decoration: BoxDecoration(
        color: Theme.of(context).colorScheme.surface,
        borderRadius: BorderRadius.circular(12),
        border: Border.all(
          color: Theme.of(context).colorScheme.outline.withAlpha(51),
        ),
      ),
      child: SingleChildScrollView(
        scrollDirection: Axis.horizontal,
        child: DataTable(
          columns: const [
            DataColumn(label: Text('Assignment')),
            DataColumn(label: Text('Category')),
            DataColumn(label: Text('Average')),
            DataColumn(label: Text('Median')),
            DataColumn(label: Text('Range')),
            DataColumn(label: Text('Submissions')),
            DataColumn(label: Text('Difficulty')),
          ],
          rows: assignments.map((assignment) {
            return DataRow(
              cells: [
                DataCell(
                  SizedBox(
                    width: 200,
                    child: Text(
                      assignment.assignmentTitle,
                      overflow: TextOverflow.ellipsis,
                    ),
                  ),
                ),
                DataCell(Text(assignment.category)),
                DataCell(Text('${assignment.averageScore.toStringAsFixed(1)}%')),
                DataCell(Text('${assignment.medianScore.toStringAsFixed(1)}%')),
                DataCell(Text('${assignment.minScore.toStringAsFixed(0)}-${assignment.maxScore.toStringAsFixed(0)}%')),
                DataCell(Text('${assignment.gradedSubmissions}/${assignment.totalSubmissions}')),
                DataCell(
                  Container(
                    padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
                    decoration: BoxDecoration(
                      color: _getDifficultyColor(assignment.difficultyLevel).withAlpha(51),
                      borderRadius: BorderRadius.circular(4),
                    ),
                    child: Text(
                      assignment.difficultyLevel.toUpperCase(),
                      style: TextStyle(
                        color: _getDifficultyColor(assignment.difficultyLevel),
                        fontWeight: FontWeight.bold,
                        fontSize: 12,
                      ),
                    ),
                  ),
                ),
              ],
            );
          }).toList(),
        ),
      ),
    );
  }

  Widget _buildRiskBadge(String riskLevel) {
    Color color;
    IconData icon;
    
    switch (riskLevel) {
      case 'at-risk':
        color = Colors.red;
        icon = Icons.warning;
        break;
      case 'warning':
        color = Colors.orange;
        icon = Icons.error_outline;
        break;
      default:
        color = Colors.green;
        icon = Icons.check_circle_outline;
    }
    
    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
      decoration: BoxDecoration(
        color: color.withAlpha(51),
        borderRadius: BorderRadius.circular(4),
      ),
      child: Row(
        mainAxisSize: MainAxisSize.min,
        children: [
          Icon(icon, size: 14, color: color),
          const SizedBox(width: 4),
          Text(
            riskLevel.toUpperCase(),
            style: TextStyle(
              color: color,
              fontWeight: FontWeight.bold,
              fontSize: 11,
            ),
          ),
        ],
      ),
    );
  }

  Color _getGradeColor(String grade) {
    if (grade.startsWith('A')) return Colors.green;
    if (grade.startsWith('B')) return Colors.blue;
    if (grade.startsWith('C')) return Colors.yellow[700]!;
    if (grade.startsWith('D')) return Colors.orange;
    return Colors.red;
  }

  Color _getCategoryColor(double average) {
    if (average >= 90) return Colors.green;
    if (average >= 80) return Colors.blue;
    if (average >= 70) return Colors.yellow[700]!;
    if (average >= 60) return Colors.orange;
    return Colors.red;
  }

  Color _getDifficultyColor(String difficulty) {
    switch (difficulty) {
      case 'easy':
        return Colors.green;
      case 'medium':
        return Colors.orange;
      case 'hard':
        return Colors.red;
      default:
        return Colors.grey;
    }
  }
}
````

## File: lib/features/grades/presentation/screens/teacher/gradebook_screen.dart
````dart
import 'package:flutter/material.dart';
import 'package:go_router/go_router.dart';
import '../../../../../shared/widgets/common/common_widgets.dart';
import '../../../../../shared/widgets/preview/preview_example_wrapper.dart';
import '../../../../../shared/widgets/preview/example_badge.dart';
import '../../../../../shared/example/example_repository.dart';
import '../../../../../shared/theme/app_theme.dart';

class GradebookScreen extends StatefulWidget {
  const GradebookScreen({super.key});

  @override
  State<GradebookScreen> createState() => _GradebookScreenState();
}

class _GradebookScreenState extends State<GradebookScreen> {
  String _searchQuery = '';
  String _selectedClassId = '1';

  // Data state - will be replaced with preview examples when empty
  List<Assignment>? _assignments;
  List<GradebookStudent>? _students;

  List<GradebookStudent> get _filteredStudents {
    final students = _students ?? [];
    if (_searchQuery.isEmpty) return students;
    return students.where((student) {
      return student.name.toLowerCase().contains(_searchQuery.toLowerCase()) ||
          student.email.toLowerCase().contains(_searchQuery.toLowerCase());
    }).toList();
  }

  // Helper methods to convert example data to local models
  List<Assignment> _convertExampleAssignments(
      List<dynamic> exampleAssignments) {
    return exampleAssignments.map((data) {
      return Assignment(
        id: data['id'],
        name: data['name'],
        type: _parseAssignmentType(data['type']),
        dueDate: data['dueDate'],
        maxPoints: data['maxPoints'],
        weight: data['weight'],
      );
    }).toList();
  }

  AssignmentType _parseAssignmentType(String type) {
    switch (type) {
      case 'homework':
        return AssignmentType.homework;
      case 'quiz':
        return AssignmentType.quiz;
      case 'test':
        return AssignmentType.test;
      case 'project':
        return AssignmentType.project;
      default:
        return AssignmentType.homework;
    }
  }

  List<GradebookStudent> _convertExampleStudents(List<dynamic> exampleGrades) {
    // Group grades by student ID
    final Map<String, List<StudentGrade>> gradesByStudent = {};

    for (final gradeData in exampleGrades) {
      final studentId = gradeData['studentId'];
      final grade = StudentGrade(
        studentId,
        gradeData['assignmentId'],
        gradeData['points'],
        _parseGradeStatus(gradeData['status']),
      );

      gradesByStudent[studentId] ??= [];
      gradesByStudent[studentId]!.add(grade);
    }

    // Create GradebookStudent objects
    final studentNames = {
      'example_student_1': 'Emma Example',
      'example_student_2': 'Marcus Sample',
      'example_student_3': 'Aisha Demo',
      'example_student_4': 'David Preview',
      'example_student_5': 'Sophie Test',
    };

    final studentEmails = {
      'example_student_1': 'emma.example@preview.edu',
      'example_student_2': 'marcus.sample@preview.edu',
      'example_student_3': 'aisha.demo@preview.edu',
      'example_student_4': 'david.preview@preview.edu',
      'example_student_5': 'sophie.test@preview.edu',
    };

    return gradesByStudent.entries.map((entry) {
      return GradebookStudent(
        id: entry.key,
        name: studentNames[entry.key] ?? 'Unknown Student',
        email: studentEmails[entry.key] ?? 'unknown@preview.edu',
        grades: entry.value,
      );
    }).toList();
  }

  GradeStatus _parseGradeStatus(String status) {
    switch (status) {
      case 'graded':
        return GradeStatus.graded;
      case 'missing':
        return GradeStatus.missing;
      case 'late':
        return GradeStatus.late;
      case 'not_submitted':
        return GradeStatus.notSubmitted;
      default:
        return GradeStatus.notSubmitted;
    }
  }

  @override
  Widget build(BuildContext context) {
    // Get example data from repository
    final exampleAssignments =
        ExampleRepository.of<dynamic>(ExampleDomain.assignments);
    final exampleGrades = ExampleRepository.of<dynamic>(ExampleDomain.grades);

    // For now, simulate that we have no real data (empty state)
    // In a real app, this would come from a provider or service
    final List<Assignment> realAssignments = []; // Simulating empty real data
    final List<GradebookStudent> realStudents =
        []; // Simulating empty real data

    return PreviewExampleWrapper<Assignment>(
      realData: realAssignments,
      exampleData: _convertExampleAssignments(exampleAssignments),
      isLoading: false, // Set to true if loading from service
      builder: (context, assignments, isExample) {
        // Set the current data state
        _assignments = assignments;

        // Convert example grades to students if using examples
        if (isExample) {
          _students = _convertExampleStudents(exampleGrades);
        } else {
          _students = realStudents;
        }

        return Scaffold(
          appBar: AppBar(
            leading: IconButton(
              icon: const Icon(Icons.arrow_back),
              onPressed: () => context.go('/dashboard'),
              tooltip: 'Back to Dashboard',
            ),
            title: Row(
              children: [
                const Text('Gradebook'),
                if (isExample) ...[
                  const SizedBox(width: 8),
                  const ExampleBadge.compact(),
                ],
              ],
            ),
            actions: [
              IconButton(
                icon: const Icon(Icons.file_download),
                onPressed: _showExportDialog,
                tooltip: 'Export Grades',
              ),
            ],
          ),
          body: _buildGradebookBody(isExample),
          floatingActionButton: FloatingActionButton(
            onPressed: isExample
                ? () => _showExampleDialog(context)
                : _showAddAssignmentDialog,
            child: const Icon(Icons.assignment_add),
          ),
        );
      },
      onExampleTap: () => _showExampleDialog(context),
    );
  }

  Widget _buildGradebookBody(bool isExample) {
    return Column(
      children: [
        // Statistics Header
        _buildStatsHeader(isExample),

        // Class Selector and Search
        _buildControlsSection(isExample),

        // Students List
        Expanded(
          child: _filteredStudents.isEmpty
              ? _searchQuery.isNotEmpty
                  ? EmptyState.noSearchResults(searchTerm: _searchQuery)
                  : isExample
                      ? const EmptyState.noStudents()
                      : const EmptyState.noStudents()
              : _buildStudentsList(isExample),
        ),
      ],
    );
  }

  void _showExampleDialog(BuildContext context) {
    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        icon: const Icon(Icons.info_outline),
        title: const Text('Example Gradebook'),
        content: const Text(
          'This is example gradebook data to show you how the app works. '
          'Add your own assignments and students to replace these examples.',
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.of(context).pop(),
            child: const Text('Got it'),
          ),
          FilledButton(
            onPressed: () {
              Navigator.of(context).pop();
              _showAddAssignmentDialog();
            },
            child: const Text('Add Assignment'),
          ),
        ],
      ),
    );
  }

  Widget _buildStatsHeader(bool isExample) {
    final classAverage = _calculateClassAverage();
    final completionRate = _calculateCompletionRate();

    return Padding(
      padding: const EdgeInsets.fromLTRB(16, 16, 16, 8),
      child: Row(
        children: [
          Expanded(
            child: _buildCompactStatCard(
              title: 'Class Avg',
              value: '${classAverage.toStringAsFixed(1)}%',
              subtitle: _getLetterGrade(classAverage),
              icon: Icons.trending_up,
              valueColor: AppTheme.getGradeColor(_getLetterGrade(classAverage)),
              isExample: isExample,
            ),
          ),
          const SizedBox(width: 8),
          Expanded(
            child: _buildCompactStatCard(
              title: 'Completion',
              value: '${completionRate.toStringAsFixed(0)}%',
              subtitle:
                  '${_students?.where((s) => s.grades.any((g) => g.status == GradeStatus.graded)).length ?? 0}/${_students?.length ?? 0} done',
              icon: Icons.assignment_turned_in,
              isExample: isExample,
            ),
          ),
          const SizedBox(width: 8),
          Expanded(
            child: _buildCompactStatCard(
              title: 'Students',
              value: '${_students?.length ?? 0}',
              subtitle: 'Enrolled',
              icon: Icons.people,
              isExample: isExample,
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildCompactStatCard({
    required String title,
    required String value,
    required String subtitle,
    required IconData icon,
    Color? valueColor,
    bool isExample = false,
  }) {
    return Container(
      padding: const EdgeInsets.all(12),
      decoration: BoxDecoration(
        color: Theme.of(context).colorScheme.surfaceContainerLow,
        borderRadius: BorderRadius.circular(12),
        border: Border.all(
          color: Theme.of(context).colorScheme.outline.withValues(alpha: 0.2),
        ),
      ),
      child: Stack(
        children: [
          Column(
            mainAxisSize: MainAxisSize.min,
            children: [
              Row(
                children: [
                  Icon(
                    icon,
                    size: 16,
                    color: Theme.of(context).colorScheme.primary,
                  ),
                  const SizedBox(width: 6),
                  Expanded(
                    child: Text(
                      title,
                      style: Theme.of(context).textTheme.bodySmall?.copyWith(
                            color:
                                Theme.of(context).colorScheme.onSurfaceVariant,
                            fontWeight: FontWeight.w500,
                          ),
                      maxLines: 1,
                      overflow: TextOverflow.ellipsis,
                    ),
                  ),
                ],
              ),
              const SizedBox(height: 4),
              Text(
                value,
                style: Theme.of(context).textTheme.titleLarge?.copyWith(
                      fontWeight: FontWeight.bold,
                      color: valueColor,
                    ),
                maxLines: 1,
                overflow: TextOverflow.ellipsis,
              ),
              const SizedBox(height: 2),
              Text(
                subtitle,
                style: Theme.of(context).textTheme.bodySmall?.copyWith(
                      color: Theme.of(context).colorScheme.onSurfaceVariant,
                    ),
                maxLines: 1,
                overflow: TextOverflow.ellipsis,
                textAlign: TextAlign.center,
              ),
            ],
          ),
          if (isExample)
            const Positioned(
              top: 0,
              right: 0,
              child: ExampleBadge.compact(),
            ),
        ],
      ),
    );
  }

  Widget _buildControlsSection(bool isExample) {
    return Padding(
      padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
      child: Row(
        children: [
          // Class Selector
          Expanded(
            flex: 2,
            child: Container(
              padding: const EdgeInsets.symmetric(horizontal: 12),
              decoration: BoxDecoration(
                border:
                    Border.all(color: Theme.of(context).colorScheme.outline),
                borderRadius: BorderRadius.circular(8),
              ),
              child: DropdownButton<String>(
                value: _selectedClassId,
                isExpanded: true,
                underline: const SizedBox(),
                items: isExample
                    ? [
                        const DropdownMenuItem(
                            value: '1', child: Text('Advanced Mathematics')),
                        const DropdownMenuItem(
                            value: '2', child: Text('Environmental Science')),
                        const DropdownMenuItem(
                            value: '3', child: Text('Creative Writing')),
                        const DropdownMenuItem(
                            value: '4', child: Text('Physics Honors')),
                      ]
                    : [
                        const DropdownMenuItem(
                            value: '1', child: Text('Advanced Mathematics')),
                        const DropdownMenuItem(
                            value: '2', child: Text('Biology Lab')),
                        const DropdownMenuItem(
                            value: '3', child: Text('Creative Writing')),
                      ],
                onChanged: (value) {
                  setState(() {
                    _selectedClassId = value!;
                  });
                },
              ),
            ),
          ),
          const SizedBox(width: 12),
          // Search Bar
          Expanded(
            flex: 3,
            child: TextField(
              decoration: InputDecoration(
                hintText: isExample
                    ? 'Search example students...'
                    : 'Search students...',
                prefixIcon: const Icon(Icons.search),
                border: const OutlineInputBorder(),
              ),
              onChanged: (value) {
                setState(() {
                  _searchQuery = value;
                });
              },
            ),
          ),
        ],
      ),
    );
  }

  void _showStudentGradeDetail(GradebookStudent student) {
    showModalBottomSheet(
      context: context,
      isScrollControlled: true,
      builder: (context) => StudentGradeDetailSheet(
        student: student,
        assignments: _assignments ?? [],
        onGradeUpdate: (assignmentId, newPoints, newStatus) {
          setState(() {
            final grade = student.grades
                .firstWhere((g) => g.assignmentId == assignmentId);
            grade.points = newPoints;
            grade.status = newStatus;
          });
        },
      ),
    );
  }

  Widget _buildStudentsList(bool isExample) {
    return ListView.builder(
      padding: const EdgeInsets.symmetric(horizontal: 16),
      itemCount: _filteredStudents.length,
      itemBuilder: (context, index) {
        final student = _filteredStudents[index];
        return _buildStudentCard(student, isExample: isExample);
      },
    );
  }

  Widget _buildStudentCard(GradebookStudent student, {bool isExample = false}) {
    final overallGrade = _calculateStudentOverallGrade(student);
    final completedAssignments =
        student.grades.where((g) => g.status == GradeStatus.graded).length;
    final totalAssignments = _assignments?.length ?? 0;

    return AppCard(
      onTap: isExample
          ? () => _showExampleDialog(context)
          : () => _showStudentGradeDetail(student),
      child: Stack(
        children: [
          Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              // Student Header
              Row(
                children: [
                  CircleAvatar(
                    radius: 20,
                    backgroundColor: Theme.of(context).colorScheme.primary,
                    child: Text(
                      student.name.split(' ').map((n) => n[0]).join(''),
                      style: const TextStyle(
                        fontSize: 16,
                        fontWeight: FontWeight.bold,
                        color: Colors.white,
                      ),
                    ),
                  ),
                  const SizedBox(width: 12),
                  Expanded(
                    child: Column(
                      crossAxisAlignment: CrossAxisAlignment.start,
                      children: [
                        Text(
                          student.name,
                          style:
                              Theme.of(context).textTheme.titleLarge?.copyWith(
                                    fontWeight: FontWeight.bold,
                                  ),
                        ),
                        Text(
                          student.email,
                          style:
                              Theme.of(context).textTheme.bodyMedium?.copyWith(
                                    color: Theme.of(context)
                                        .colorScheme
                                        .onSurfaceVariant,
                                  ),
                        ),
                      ],
                    ),
                  ),
                  Column(
                    crossAxisAlignment: CrossAxisAlignment.end,
                    children: [
                      StatusBadge.grade(grade: _getLetterGrade(overallGrade)),
                      const SizedBox(height: 4),
                      Text(
                        '${overallGrade.toStringAsFixed(1)}%',
                        style: Theme.of(context).textTheme.bodySmall?.copyWith(
                              color: Theme.of(context)
                                  .colorScheme
                                  .onSurfaceVariant,
                            ),
                      ),
                    ],
                  ),
                ],
              ),

              const SizedBox(height: 16),

              // Progress Summary
              Row(
                children: [
                  Expanded(
                    child: Column(
                      crossAxisAlignment: CrossAxisAlignment.start,
                      children: [
                        Text(
                          'Assignments Completed',
                          style:
                              Theme.of(context).textTheme.bodySmall?.copyWith(
                                    color: Theme.of(context)
                                        .colorScheme
                                        .onSurfaceVariant,
                                  ),
                        ),
                        const SizedBox(height: 4),
                        Row(
                          children: [
                            Expanded(
                              child: LinearProgressIndicator(
                                value: totalAssignments > 0
                                    ? completedAssignments / totalAssignments
                                    : 0.0,
                                backgroundColor: Theme.of(context)
                                    .colorScheme
                                    .surfaceContainerHighest,
                                valueColor: AlwaysStoppedAnimation<Color>(
                                  Theme.of(context).colorScheme.primary,
                                ),
                              ),
                            ),
                            const SizedBox(width: 8),
                            Text(
                              '$completedAssignments/$totalAssignments',
                              style: Theme.of(context)
                                  .textTheme
                                  .bodySmall
                                  ?.copyWith(
                                    fontWeight: FontWeight.bold,
                                  ),
                            ),
                          ],
                        ),
                      ],
                    ),
                  ),
                  const SizedBox(width: 16),
                  _buildQuickStatusChips(student),
                ],
              ),

              const SizedBox(height: 8),

              // Tap hint
              Row(
                mainAxisAlignment: MainAxisAlignment.center,
                children: [
                  Icon(
                    isExample ? Icons.info_outline : Icons.touch_app,
                    size: 16,
                    color: Theme.of(context).colorScheme.primary,
                  ),
                  const SizedBox(width: 4),
                  Text(
                    isExample
                        ? 'Tap to learn about examples'
                        : 'Tap to view detailed grades',
                    style: Theme.of(context).textTheme.bodySmall?.copyWith(
                          color: Theme.of(context).colorScheme.primary,
                        ),
                  ),
                ],
              ),
            ],
          ),
          if (isExample)
            const Positioned(
              top: 8,
              right: 8,
              child: ExampleBadge.compact(),
            ),
        ],
      ),
    );
  }

  Widget _buildQuickStatusChips(GradebookStudent student) {
    final missingCount =
        student.grades.where((g) => g.status == GradeStatus.missing).length;
    final lateCount =
        student.grades.where((g) => g.status == GradeStatus.late).length;

    return Row(
      children: [
        if (missingCount > 0) ...[
          Container(
            padding: const EdgeInsets.symmetric(horizontal: 6, vertical: 2),
            decoration: BoxDecoration(
              color: Theme.of(context).colorScheme.error.withValues(alpha: 0.2),
              borderRadius: BorderRadius.circular(8),
            ),
            child: Text(
              '$missingCount Missing',
              style: Theme.of(context).textTheme.bodySmall?.copyWith(
                    color: Theme.of(context).colorScheme.error,
                    fontWeight: FontWeight.bold,
                  ),
            ),
          ),
          const SizedBox(width: 4),
        ],
        if (lateCount > 0) ...[
          Container(
            padding: const EdgeInsets.symmetric(horizontal: 6, vertical: 2),
            decoration: BoxDecoration(
              color: AppTheme.warningColor.withValues(alpha: 0.2),
              borderRadius: BorderRadius.circular(8),
            ),
            child: Text(
              '$lateCount Late',
              style: Theme.of(context).textTheme.bodySmall?.copyWith(
                    color: AppTheme.warningColor,
                    fontWeight: FontWeight.bold,
                  ),
            ),
          ),
        ],
      ],
    );
  }

  double _calculateClassAverage() {
    if (_students?.isEmpty ?? true) return 0.0;

    double totalPercentage = 0;
    int studentCount = 0;

    for (final student in _students!) {
      final grade = _calculateStudentOverallGrade(student);
      if (grade > 0) {
        totalPercentage += grade;
        studentCount++;
      }
    }

    return studentCount > 0 ? totalPercentage / studentCount : 0.0;
  }

  double _calculateCompletionRate() {
    if ((_students?.isEmpty ?? true) || (_assignments?.isEmpty ?? true)) {
      return 0.0;
    }

    int totalAssignments = _students!.length * _assignments!.length;
    int completedAssignments = 0;

    for (final student in _students!) {
      for (final grade in student.grades) {
        if (grade.status == GradeStatus.graded) {
          completedAssignments++;
        }
      }
    }

    return (completedAssignments / totalAssignments) * 100;
  }

  double _calculateStudentOverallGrade(GradebookStudent student) {
    if (_assignments?.isEmpty ?? true) return 0.0;

    double totalPoints = 0;
    double maxPoints = 0;

    for (final grade in student.grades) {
      final assignment =
          _assignments!.firstWhere((a) => a.id == grade.assignmentId);
      if (grade.status == GradeStatus.graded && grade.points != null) {
        totalPoints += grade.points!;
        maxPoints += assignment.maxPoints;
      }
    }

    return maxPoints > 0 ? (totalPoints / maxPoints) * 100 : 0.0;
  }

  String _getLetterGrade(double percentage) {
    if (percentage >= 97) return 'A+';
    if (percentage >= 93) return 'A';
    if (percentage >= 90) return 'A-';
    if (percentage >= 87) return 'B+';
    if (percentage >= 83) return 'B';
    if (percentage >= 80) return 'B-';
    if (percentage >= 77) return 'C+';
    if (percentage >= 73) return 'C';
    if (percentage >= 70) return 'C-';
    if (percentage >= 67) return 'D+';
    if (percentage >= 65) return 'D';
    if (percentage >= 60) return 'D-';
    return 'F';
  }

  void _showAddAssignmentDialog() {
    // Navigate to the assignment creation screen
    context.go('/teacher/assignments/create');
  }

  void _showExportDialog() {
    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        title: const Text('Export Grades'),
        content:
            const Text('Export options would appear here (CSV, PDF, etc.).'),
        actions: [
          TextButton(
            onPressed: () => Navigator.of(context).pop(),
            child: const Text('Cancel'),
          ),
          FilledButton(
            onPressed: () {
              Navigator.of(context).pop();
              ScaffoldMessenger.of(context).showSnackBar(
                const SnackBar(content: Text('Feature coming soon!')),
              );
            },
            child: const Text('Export'),
          ),
        ],
      ),
    );
  }
}

// Student Grade Detail Bottom Sheet
class StudentGradeDetailSheet extends StatelessWidget {
  final GradebookStudent student;
  final List<Assignment> assignments;
  final Function(String assignmentId, double?, GradeStatus) onGradeUpdate;

  const StudentGradeDetailSheet({
    super.key,
    required this.student,
    required this.assignments,
    required this.onGradeUpdate,
  });

  @override
  Widget build(BuildContext context) {
    final overallGrade = _calculateStudentOverallGrade();

    return Container(
      height: MediaQuery.of(context).size.height * 0.8,
      padding: const EdgeInsets.all(24),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          // Header
          Row(
            children: [
              CircleAvatar(
                radius: 24,
                backgroundColor: Theme.of(context).colorScheme.primary,
                child: Text(
                  student.name.split(' ').map((n) => n[0]).join(''),
                  style: const TextStyle(
                    fontSize: 18,
                    fontWeight: FontWeight.bold,
                    color: Colors.white,
                  ),
                ),
              ),
              const SizedBox(width: 16),
              Expanded(
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Text(
                      student.name,
                      style:
                          Theme.of(context).textTheme.headlineSmall?.copyWith(
                                fontWeight: FontWeight.bold,
                              ),
                    ),
                    Text(
                      student.email,
                      style: Theme.of(context).textTheme.bodyLarge?.copyWith(
                            color:
                                Theme.of(context).colorScheme.onSurfaceVariant,
                          ),
                    ),
                  ],
                ),
              ),
              IconButton(
                onPressed: () => Navigator.of(context).pop(),
                icon: const Icon(Icons.close),
              ),
            ],
          ),

          const SizedBox(height: 20),

          // Overall Grade Summary
          AppCard(
            child: Row(
              children: [
                Expanded(
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      Text(
                        'Overall Grade',
                        style: Theme.of(context).textTheme.titleMedium,
                      ),
                      const SizedBox(height: 8),
                      Row(
                        children: [
                          StatusBadge.grade(
                              grade: _getLetterGrade(overallGrade)),
                          const SizedBox(width: 8),
                          Text(
                            '${overallGrade.toStringAsFixed(1)}%',
                            style: Theme.of(context)
                                .textTheme
                                .headlineSmall
                                ?.copyWith(
                                  fontWeight: FontWeight.bold,
                                ),
                          ),
                        ],
                      ),
                    ],
                  ),
                ),
                Column(
                  crossAxisAlignment: CrossAxisAlignment.end,
                  children: [
                    Text(
                      'Completed',
                      style: Theme.of(context).textTheme.bodySmall?.copyWith(
                            color:
                                Theme.of(context).colorScheme.onSurfaceVariant,
                          ),
                    ),
                    Text(
                      '${student.grades.where((g) => g.status == GradeStatus.graded).length}/${assignments.length}',
                      style: Theme.of(context).textTheme.titleMedium?.copyWith(
                            fontWeight: FontWeight.bold,
                          ),
                    ),
                  ],
                ),
              ],
            ),
          ),

          const SizedBox(height: 16),

          Text(
            'Assignment Breakdown',
            style: Theme.of(context).textTheme.titleLarge?.copyWith(
                  fontWeight: FontWeight.bold,
                ),
          ),

          const SizedBox(height: 12),

          // Assignments List
          Expanded(
            child: ListView.builder(
              itemCount: assignments.length,
              itemBuilder: (context, index) {
                final assignment = assignments[index];
                final grade = student.grades
                    .firstWhere((g) => g.assignmentId == assignment.id);
                return _buildAssignmentGradeCard(context, assignment, grade);
              },
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildAssignmentGradeCard(
      BuildContext context, Assignment assignment, StudentGrade grade) {
    final isOverdue = assignment.dueDate.isBefore(DateTime.now());

    Color statusColor;
    String statusText;
    String scoreText;

    switch (grade.status) {
      case GradeStatus.graded:
        final percentage = (grade.points! / assignment.maxPoints) * 100;
        statusColor = AppTheme.getGradeColor(_getLetterGrade(percentage));
        statusText = _getLetterGrade(percentage);
        scoreText =
            '${grade.points!.toInt()}/${assignment.maxPoints} (${percentage.toStringAsFixed(1)}%)';
        break;
      case GradeStatus.missing:
        statusColor = Theme.of(context).colorScheme.error;
        statusText = 'Missing';
        scoreText = '0/${assignment.maxPoints} (0%)';
        break;
      case GradeStatus.late:
        statusColor = AppTheme.warningColor;
        statusText = 'Late';
        scoreText = grade.points != null
            ? '${grade.points!.toInt()}/${assignment.maxPoints}'
            : 'Not graded';
        break;
      case GradeStatus.notSubmitted:
        statusColor = Theme.of(context).colorScheme.onSurfaceVariant;
        statusText = 'Not Submitted';
        scoreText = '-';
        break;
    }

    return AppCard(
      onTap: () => _showGradeEntryDialog(context, assignment, grade),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          // Assignment Header
          Row(
            children: [
              Expanded(
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Text(
                      assignment.name,
                      style: Theme.of(context).textTheme.titleMedium?.copyWith(
                            fontWeight: FontWeight.bold,
                          ),
                    ),
                    const SizedBox(height: 4),
                    Row(
                      children: [
                        StatusBadge.assignmentType(type: assignment.type.name),
                        const SizedBox(width: 8),
                        Text(
                          'Due: ${assignment.dueDate.month}/${assignment.dueDate.day}/${assignment.dueDate.year}',
                          style:
                              Theme.of(context).textTheme.bodySmall?.copyWith(
                                    color: isOverdue
                                        ? Theme.of(context).colorScheme.error
                                        : null,
                                  ),
                        ),
                      ],
                    ),
                  ],
                ),
              ),
              Column(
                crossAxisAlignment: CrossAxisAlignment.end,
                children: [
                  StatusBadge(
                    label: statusText,
                    type: StatusType.custom,
                    customColor: statusColor,
                  ),
                  const SizedBox(height: 4),
                  Text(
                    scoreText,
                    style: Theme.of(context).textTheme.bodySmall?.copyWith(
                          fontWeight: FontWeight.bold,
                        ),
                  ),
                ],
              ),
            ],
          ),

          const SizedBox(height: 8),

          // Progress Bar for graded assignments
          if (grade.status == GradeStatus.graded) ...[
            LinearProgressIndicator(
              value: grade.points! / assignment.maxPoints,
              backgroundColor:
                  Theme.of(context).colorScheme.surfaceContainerHighest,
              valueColor: AlwaysStoppedAnimation<Color>(statusColor),
            ),
            const SizedBox(height: 8),
          ],

          // Tap hint
          Row(
            mainAxisAlignment: MainAxisAlignment.center,
            children: [
              Icon(
                Icons.edit,
                size: 14,
                color: Theme.of(context).colorScheme.primary,
              ),
              const SizedBox(width: 4),
              Text(
                'Tap to edit grade',
                style: Theme.of(context).textTheme.bodySmall?.copyWith(
                      color: Theme.of(context).colorScheme.primary,
                    ),
              ),
            ],
          ),
        ],
      ),
    );
  }

  void _showGradeEntryDialog(
      BuildContext context, Assignment assignment, StudentGrade grade) {
    showModalBottomSheet(
      context: context,
      isScrollControlled: true,
      builder: (context) => Padding(
        padding: EdgeInsets.only(
          bottom: MediaQuery.of(context).viewInsets.bottom,
        ),
        child: GradeEntrySheet(
          student: student,
          assignment: assignment,
          grade: grade,
          onSave: (newPoints, newStatus) {
            onGradeUpdate(assignment.id, newPoints, newStatus);
            Navigator.of(context).pop();
          },
        ),
      ),
    );
  }

  double _calculateStudentOverallGrade() {
    double totalPoints = 0;
    double maxPoints = 0;

    for (final grade in student.grades) {
      final assignment =
          assignments.firstWhere((a) => a.id == grade.assignmentId);
      if (grade.status == GradeStatus.graded && grade.points != null) {
        totalPoints += grade.points!;
        maxPoints += assignment.maxPoints;
      }
    }

    return maxPoints > 0 ? (totalPoints / maxPoints) * 100 : 0.0;
  }

  String _getLetterGrade(double percentage) {
    if (percentage >= 97) return 'A+';
    if (percentage >= 93) return 'A';
    if (percentage >= 90) return 'A-';
    if (percentage >= 87) return 'B+';
    if (percentage >= 83) return 'B';
    if (percentage >= 80) return 'B-';
    if (percentage >= 77) return 'C+';
    if (percentage >= 73) return 'C';
    if (percentage >= 70) return 'C-';
    if (percentage >= 67) return 'D+';
    if (percentage >= 65) return 'D';
    if (percentage >= 60) return 'D-';
    return 'F';
  }
}

// Grade Entry Bottom Sheet
class GradeEntrySheet extends StatefulWidget {
  final GradebookStudent student;
  final Assignment assignment;
  final StudentGrade grade;
  final Function(double?, GradeStatus) onSave;

  const GradeEntrySheet({
    super.key,
    required this.student,
    required this.assignment,
    required this.grade,
    required this.onSave,
  });

  @override
  State<GradeEntrySheet> createState() => _GradeEntrySheetState();
}

class _GradeEntrySheetState extends State<GradeEntrySheet> {
  late TextEditingController _pointsController;
  late GradeStatus _selectedStatus;

  @override
  void initState() {
    super.initState();
    _pointsController = TextEditingController(
      text: widget.grade.points?.toString() ?? '',
    );
    _selectedStatus = widget.grade.status;
  }

  @override
  void dispose() {
    _pointsController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    final percentage = _pointsController.text.isNotEmpty
        ? (double.tryParse(_pointsController.text) ?? 0) /
            widget.assignment.maxPoints *
            100
        : 0.0;

    return Container(
      padding: const EdgeInsets.all(24),
      child: Column(
        mainAxisSize: MainAxisSize.min,
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          // Header
          Row(
            children: [
              Expanded(
                child: Text(
                  'Grade Entry',
                  style: Theme.of(context).textTheme.headlineSmall,
                ),
              ),
              IconButton(
                onPressed: () => Navigator.of(context).pop(),
                icon: const Icon(Icons.close),
              ),
            ],
          ),
          const SizedBox(height: 16),

          // Student and Assignment Info
          AppCard(
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Text(
                  widget.student.name,
                  style: Theme.of(context).textTheme.titleLarge,
                ),
                const SizedBox(height: 8),
                Text(
                  widget.assignment.name,
                  style: Theme.of(context).textTheme.titleMedium,
                ),
                const SizedBox(height: 4),
                Row(
                  children: [
                    StatusBadge.assignmentType(
                        type: widget.assignment.type.name),
                    const SizedBox(width: 8),
                    Text(
                      'Due: ${widget.assignment.dueDate.month}/${widget.assignment.dueDate.day}/${widget.assignment.dueDate.year}',
                      style: Theme.of(context).textTheme.bodySmall,
                    ),
                  ],
                ),
              ],
            ),
          ),
          const SizedBox(height: 16),

          // Points Entry
          TextField(
            controller: _pointsController,
            keyboardType: TextInputType.number,
            decoration: InputDecoration(
              labelText: 'Points Earned',
              hintText: 'Enter points (0-${widget.assignment.maxPoints})',
              border: const OutlineInputBorder(),
              suffix: Text('/ ${widget.assignment.maxPoints}'),
            ),
            onChanged: (_) => setState(() {}),
          ),
          const SizedBox(height: 16),

          // Grade Preview
          if (_pointsController.text.isNotEmpty) ...[
            AppCard(
              child: Row(
                children: [
                  const Icon(Icons.grade),
                  const SizedBox(width: 8),
                  Text('Grade: ${percentage.toStringAsFixed(1)}%'),
                  const SizedBox(width: 8),
                  StatusBadge.grade(grade: _getLetterGrade(percentage)),
                ],
              ),
            ),
            const SizedBox(height: 16),
          ],

          // Status Selection
          Text(
            'Status',
            style: Theme.of(context).textTheme.titleMedium,
          ),
          const SizedBox(height: 8),
          Wrap(
            spacing: 8,
            children: GradeStatus.values.map((status) {
              return ChoiceChip(
                label: Text(_getStatusLabel(status)),
                selected: _selectedStatus == status,
                onSelected: (selected) {
                  if (selected) {
                    setState(() {
                      _selectedStatus = status;
                    });
                  }
                },
              );
            }).toList(),
          ),
          const SizedBox(height: 24),

          // Save Button
          SizedBox(
            width: double.infinity,
            child: FilledButton(
              onPressed: _canSave() ? _saveGrade : null,
              child: const Text('Save Grade'),
            ),
          ),
        ],
      ),
    );
  }

  bool _canSave() {
    if (_selectedStatus == GradeStatus.graded) {
      final points = double.tryParse(_pointsController.text);
      return points != null &&
          points >= 0 &&
          points <= widget.assignment.maxPoints;
    }
    return true;
  }

  void _saveGrade() {
    final points = _selectedStatus == GradeStatus.graded
        ? double.tryParse(_pointsController.text)
        : null;

    widget.onSave(points, _selectedStatus);
  }

  String _getStatusLabel(GradeStatus status) {
    switch (status) {
      case GradeStatus.graded:
        return 'Graded';
      case GradeStatus.missing:
        return 'Missing';
      case GradeStatus.late:
        return 'Late';
      case GradeStatus.notSubmitted:
        return 'Not Submitted';
    }
  }

  String _getLetterGrade(double percentage) {
    if (percentage >= 97) return 'A+';
    if (percentage >= 93) return 'A';
    if (percentage >= 90) return 'A-';
    if (percentage >= 87) return 'B+';
    if (percentage >= 83) return 'B';
    if (percentage >= 80) return 'B-';
    if (percentage >= 77) return 'C+';
    if (percentage >= 73) return 'C';
    if (percentage >= 70) return 'C-';
    if (percentage >= 67) return 'D+';
    if (percentage >= 65) return 'D';
    if (percentage >= 60) return 'D-';
    return 'F';
  }
}

// Data Models
class Assignment {
  final String id;
  final String name;
  final AssignmentType type;
  final DateTime dueDate;
  final int maxPoints;
  final double weight;

  Assignment({
    required this.id,
    required this.name,
    required this.type,
    required this.dueDate,
    required this.maxPoints,
    required this.weight,
  });
}

enum AssignmentType {
  homework,
  quiz,
  test,
  project,
}

class StudentGrade {
  final String studentId;
  final String assignmentId;
  double? points;
  GradeStatus status;

  StudentGrade(this.studentId, this.assignmentId, this.points, this.status);
}

enum GradeStatus {
  graded,
  missing,
  late,
  notSubmitted,
}

class GradebookStudent {
  final String id;
  final String name;
  final String email;
  final List<StudentGrade> grades;

  GradebookStudent({
    required this.id,
    required this.name,
    required this.email,
    required this.grades,
  });
}
````

## File: lib/features/notifications/data/services/firebase_notification_service.dart
````dart
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:firebase_auth/firebase_auth.dart';
import '../../domain/models/notification_model.dart';

class FirebaseNotificationService {
  final FirebaseFirestore _firestore = FirebaseFirestore.instance;
  final FirebaseAuth _auth = FirebaseAuth.instance;

  // Get notifications collection reference
  CollectionReference<Map<String, dynamic>> get _notificationsCollection =>
      _firestore.collection('notifications');

  // Stream of notifications for current user
  Stream<List<NotificationModel>> getUserNotifications({
    bool includeRead = true,
    NotificationType? filterType,
    int? limit,
  }) {
    final userId = _auth.currentUser?.uid;
    if (userId == null) {
      return Stream.value([]);
    }

    Query<Map<String, dynamic>> query = _notificationsCollection
        .where('userId', isEqualTo: userId)
        .orderBy('createdAt', descending: true);

    // Filter by read status
    if (!includeRead) {
      query = query.where('isRead', isEqualTo: false);
    }

    // Filter by type
    if (filterType != null) {
      query = query.where('type', isEqualTo: filterType.name);
    }

    // Apply limit
    if (limit != null) {
      query = query.limit(limit);
    }

    return query.snapshots().map((snapshot) {
      return snapshot.docs
          .map((doc) => NotificationModel.fromFirestore(doc))
          .where((notification) {
            // Filter out expired notifications
            if (notification.isExpired) return false;
            // Filter out scheduled notifications not yet due
            if (notification.isScheduled) return false;
            return true;
          })
          .toList();
    });
  }

  // Get academic notifications (grades, assignments, submissions)
  Stream<List<NotificationModel>> getAcademicNotifications() {
    final userId = _auth.currentUser?.uid;
    if (userId == null) {
      return Stream.value([]);
    }

    return _notificationsCollection
        .where('userId', isEqualTo: userId)
        .where('type', whereIn: [
          NotificationType.grade.name,
          NotificationType.assignment.name,
          NotificationType.submission.name,
        ])
        .orderBy('createdAt', descending: true)
        .snapshots()
        .map((snapshot) {
          return snapshot.docs
              .map((doc) => NotificationModel.fromFirestore(doc))
              .where((notification) {
                if (notification.isExpired) return false;
                if (notification.isScheduled) return false;
                return true;
              })
              .toList();
        });
  }

  // Get unread notifications count
  Stream<int> getUnreadNotificationCount() {
    final userId = _auth.currentUser?.uid;
    if (userId == null) {
      return Stream.value(0);
    }

    return _notificationsCollection
        .where('userId', isEqualTo: userId)
        .where('isRead', isEqualTo: false)
        .snapshots()
        .map((snapshot) {
          return snapshot.docs
              .map((doc) => NotificationModel.fromFirestore(doc))
              .where((notification) {
                if (notification.isExpired) return false;
                if (notification.isScheduled) return false;
                return true;
              })
              .length;
        });
  }

  // Mark notification as read
  Future<void> markAsRead(String notificationId) async {
    await _notificationsCollection.doc(notificationId).update({
      'isRead': true,
    });
  }

  // Mark notification as unread
  Future<void> markAsUnread(String notificationId) async {
    await _notificationsCollection.doc(notificationId).update({
      'isRead': false,
    });
  }

  // Mark all notifications as read
  Future<void> markAllAsRead() async {
    final userId = _auth.currentUser?.uid;
    if (userId == null) return;

    final batch = _firestore.batch();
    final unreadNotifications = await _notificationsCollection
        .where('userId', isEqualTo: userId)
        .where('isRead', isEqualTo: false)
        .get();

    for (final doc in unreadNotifications.docs) {
      batch.update(doc.reference, {'isRead': true});
    }

    await batch.commit();
  }

  // Delete notification
  Future<void> deleteNotification(String notificationId) async {
    await _notificationsCollection.doc(notificationId).delete();
  }

  // Delete all read notifications
  Future<void> deleteAllRead() async {
    final userId = _auth.currentUser?.uid;
    if (userId == null) return;

    final batch = _firestore.batch();
    final readNotifications = await _notificationsCollection
        .where('userId', isEqualTo: userId)
        .where('isRead', isEqualTo: true)
        .get();

    for (final doc in readNotifications.docs) {
      batch.delete(doc.reference);
    }

    await batch.commit();
  }

  // Create a new notification
  Future<void> createNotification({
    required String userId,
    required NotificationType type,
    required String title,
    required String message,
    NotificationPriority priority = NotificationPriority.normal,
    Map<String, dynamic>? actionData,
    String? imageUrl,
    String? category,
    DateTime? scheduledFor,
    DateTime? expiresAt,
  }) async {
    final notification = NotificationModel(
      id: '', // Will be set by Firestore
      userId: userId,
      type: type,
      title: title,
      message: message,
      createdAt: DateTime.now(),
      priority: priority,
      actionData: actionData,
      imageUrl: imageUrl,
      category: category,
      scheduledFor: scheduledFor,
      expiresAt: expiresAt,
    );

    await _notificationsCollection.add(notification.toFirestore());
  }

  // Create notification for grade update
  Future<void> createGradeNotification({
    required String studentId,
    required String courseName,
    required String assignmentName,
    required String grade,
    required String courseId,
    required String assignmentId,
  }) async {
    await createNotification(
      userId: studentId,
      type: NotificationType.grade,
      title: 'New Grade Posted',
      message: 'Your grade for $assignmentName in $courseName has been posted: $grade',
      priority: NotificationPriority.normal,
      actionData: {
        'courseId': courseId,
        'assignmentId': assignmentId,
        'grade': grade,
      },
    );
  }

  // Create notification for assignment
  Future<void> createAssignmentNotification({
    required String studentId,
    required String courseName,
    required String assignmentName,
    required DateTime dueDate,
    required String assignmentId,
    NotificationPriority priority = NotificationPriority.medium,
  }) async {
    final daysUntilDue = dueDate.difference(DateTime.now()).inDays;
    String message;

    if (daysUntilDue == 0) {
      message = '$assignmentName in $courseName is due today!';
      priority = NotificationPriority.high;
    } else if (daysUntilDue == 1) {
      message = '$assignmentName in $courseName is due tomorrow';
      priority = NotificationPriority.high;
    } else {
      message = '$assignmentName in $courseName is due in $daysUntilDue days';
    }

    await createNotification(
      userId: studentId,
      type: NotificationType.assignment,
      title: 'Assignment Due',
      message: message,
      priority: priority,
      actionData: {
        'assignmentId': assignmentId,
        'dueDate': dueDate.toIso8601String(),
      },
    );
  }

  // Create notification for new message
  Future<void> createMessageNotification({
    required String receiverId,
    required String senderName,
    required String messagePreview,
    required String chatRoomId,
    String? senderPhotoUrl,
  }) async {
    await createNotification(
      userId: receiverId,
      type: NotificationType.message,
      title: 'New Message from $senderName',
      message: messagePreview,
      priority: NotificationPriority.normal,
      actionData: {
        'chatRoomId': chatRoomId,
        'senderName': senderName,
      },
      imageUrl: senderPhotoUrl,
    );
  }

  // Create system notification
  Future<void> createSystemNotification({
    required List<String> userIds,
    required String title,
    required String message,
    NotificationPriority priority = NotificationPriority.normal,
    DateTime? expiresAt,
  }) async {
    final batch = _firestore.batch();

    for (final userId in userIds) {
      final notificationRef = _notificationsCollection.doc();
      final notification = NotificationModel(
        id: notificationRef.id,
        userId: userId,
        type: NotificationType.system,
        title: title,
        message: message,
        createdAt: DateTime.now(),
        priority: priority,
        expiresAt: expiresAt,
      );

      batch.set(notificationRef, notification.toFirestore());
    }

    await batch.commit();
  }

  // Get notification settings (could be extended with user preferences)
  Future<Map<String, bool>> getNotificationSettings() async {
    // For now, return default settings
    // In future, could store these in user document
    return {
      'pushNotifications': true,
      'emailNotifications': true,
      'gradeNotifications': true,
      'assignmentNotifications': true,
      'messageNotifications': true,
      'systemNotifications': true,
    };
  }

  // Update notification settings
  Future<void> updateNotificationSettings(Map<String, bool> settings) async {
    // For now, this is a placeholder
    // In future, would store these in user document
    final userId = _auth.currentUser?.uid;
    if (userId == null) return;

    // Could store in users collection
    // await _firestore.collection('users').doc(userId).update({
    //   'notificationSettings': settings,
    // });
  }
}
````

## File: lib/features/notifications/domain/models/notification_model.dart
````dart
import 'package:cloud_firestore/cloud_firestore.dart';

enum NotificationType {
  grade,
  assignment,
  message,
  system,
  calendar,
  announcement,
  discussion,
  submission
}

enum NotificationPriority {
  low,
  normal,
  medium,
  high,
  urgent
}

class NotificationModel {
  final String id;
  final String userId;
  final NotificationType type;
  final String title;
  final String message;
  final DateTime createdAt;
  final bool isRead;
  final NotificationPriority priority;
  final Map<String, dynamic>? actionData;
  final String? imageUrl;
  final String? category;
  final DateTime? scheduledFor;
  final DateTime? expiresAt;

  NotificationModel({
    required this.id,
    required this.userId,
    required this.type,
    required this.title,
    required this.message,
    required this.createdAt,
    this.isRead = false,
    this.priority = NotificationPriority.normal,
    this.actionData,
    this.imageUrl,
    this.category,
    this.scheduledFor,
    this.expiresAt,
  });

  factory NotificationModel.fromFirestore(DocumentSnapshot doc) {
    final data = doc.data() as Map<String, dynamic>;
    return NotificationModel(
      id: doc.id,
      userId: data['userId'] ?? '',
      type: NotificationType.values.firstWhere(
        (e) => e.name == data['type'],
        orElse: () => NotificationType.system,
      ),
      title: data['title'] ?? '',
      message: data['message'] ?? '',
      createdAt: (data['createdAt'] as Timestamp).toDate(),
      isRead: data['isRead'] ?? false,
      priority: NotificationPriority.values.firstWhere(
        (e) => e.name == data['priority'],
        orElse: () => NotificationPriority.normal,
      ),
      actionData: data['actionData'] as Map<String, dynamic>?,
      imageUrl: data['imageUrl'],
      category: data['category'],
      scheduledFor: data['scheduledFor'] != null
          ? (data['scheduledFor'] as Timestamp).toDate()
          : null,
      expiresAt: data['expiresAt'] != null
          ? (data['expiresAt'] as Timestamp).toDate()
          : null,
    );
  }

  Map<String, dynamic> toFirestore() {
    return {
      'userId': userId,
      'type': type.name,
      'title': title,
      'message': message,
      'createdAt': Timestamp.fromDate(createdAt),
      'isRead': isRead,
      'priority': priority.name,
      'actionData': actionData,
      'imageUrl': imageUrl,
      'category': category,
      'scheduledFor': scheduledFor != null
          ? Timestamp.fromDate(scheduledFor!)
          : null,
      'expiresAt': expiresAt != null
          ? Timestamp.fromDate(expiresAt!)
          : null,
    };
  }

  NotificationModel copyWith({
    String? id,
    String? userId,
    NotificationType? type,
    String? title,
    String? message,
    DateTime? createdAt,
    bool? isRead,
    NotificationPriority? priority,
    Map<String, dynamic>? actionData,
    String? imageUrl,
    String? category,
    DateTime? scheduledFor,
    DateTime? expiresAt,
  }) {
    return NotificationModel(
      id: id ?? this.id,
      userId: userId ?? this.userId,
      type: type ?? this.type,
      title: title ?? this.title,
      message: message ?? this.message,
      createdAt: createdAt ?? this.createdAt,
      isRead: isRead ?? this.isRead,
      priority: priority ?? this.priority,
      actionData: actionData ?? this.actionData,
      imageUrl: imageUrl ?? this.imageUrl,
      category: category ?? this.category,
      scheduledFor: scheduledFor ?? this.scheduledFor,
      expiresAt: expiresAt ?? this.expiresAt,
    );
  }

  // Helper method to get display icon based on type
  String get typeIcon {
    switch (type) {
      case NotificationType.grade:
        return '📊';
      case NotificationType.assignment:
        return '📝';
      case NotificationType.message:
        return '💬';
      case NotificationType.system:
        return 'ℹ️';
      case NotificationType.calendar:
        return '📅';
      case NotificationType.announcement:
        return '📢';
      case NotificationType.discussion:
        return '💭';
      case NotificationType.submission:
        return '📤';
    }
  }

  // Helper method to check if notification has expired
  bool get isExpired {
    if (expiresAt == null) return false;
    return DateTime.now().isAfter(expiresAt!);
  }

  // Helper method to check if notification is scheduled for future
  bool get isScheduled {
    if (scheduledFor == null) return false;
    return DateTime.now().isBefore(scheduledFor!);
  }
}
````

## File: lib/features/notifications/domain/models/notification.dart
````dart
/// Notification model for push notifications and alerts.
/// 
/// This module defines the notification structure for the educational platform,
/// supporting various notification types like assignment deadlines, messages,
/// grades, and system alerts with Firebase integration.
library;

import 'package:cloud_firestore/cloud_firestore.dart';

/// Enumeration of available notification types.
enum NotificationType {
  /// Assignment-related notifications
  assignment('Assignment'),
  
  /// Grade-related notifications
  grade('Grade'),
  
  /// Message notifications
  message('Message'),
  
  /// Event reminder notifications
  eventReminder('Event Reminder'),
  
  /// Assignment reminder notifications
  assignmentReminder('Assignment Reminder'),
  
  /// System notifications
  system('System'),
  
  /// General notifications
  general('General');

  /// Display name for the notification type
  final String displayName;
  
  const NotificationType(this.displayName);
  
  /// Creates NotificationType from string value
  static NotificationType fromString(String value) {
    // Convert snake_case or space-separated to camelCase
    final camelCase = value.toLowerCase().split(RegExp(r'[_\s]+')).asMap().entries.map((entry) {
      if (entry.key == 0) return entry.value;
      return entry.value[0].toUpperCase() + entry.value.substring(1);
    }).join('');
    
    return NotificationType.values.firstWhere(
      (type) => type.name == camelCase,
      orElse: () => NotificationType.general,
    );
  }
}

/// Notification model representing user notifications.
/// 
/// This model supports various notification types with features:
/// - Multiple notification types (assignments, grades, messages, etc.)
/// - Read/unread status tracking
/// - Related entity linking (assignment, grade, message, etc.)
/// - Rich metadata for notification details
/// - Action buttons for quick responses
/// 
/// Notifications are used to keep users informed about important
/// events and updates in the educational platform.
class Notification {
  /// Unique identifier for the notification
  final String id;
  
  /// User ID who receives the notification
  final String userId;
  
  /// Notification category type
  final String type;
  
  /// Notification title
  final String title;
  
  /// Notification message/body
  final String message;
  
  /// Whether the notification has been read
  final bool read;
  
  /// Related entity ID (assignment, grade, message, etc.)
  final String? relatedId;
  
  /// Related entity type for navigation
  final String? relatedType;
  
  /// Action to take when notification is tapped
  final String? actionUrl;
  
  /// Additional metadata for extensibility
  final Map<String, dynamic>? metadata;
  
  /// Creation timestamp
  final DateTime createdAt;
  
  /// Read timestamp (when user marked as read)
  final DateTime? readAt;

  /// Creates a notification instance.
  Notification({
    required this.id,
    required this.userId,
    required this.type,
    required this.title,
    required this.message,
    this.read = false,
    this.relatedId,
    this.relatedType,
    this.actionUrl,
    this.metadata,
    required this.createdAt,
    this.readAt,
  });

  /// Creates a Notification from Firestore document.
  factory Notification.fromFirestore(DocumentSnapshot doc) {
    final data = doc.data() as Map<String, dynamic>;
    
    return Notification(
      id: doc.id,
      userId: data['userId'] ?? '',
      type: data['type'] ?? 'general',
      title: data['title'] ?? '',
      message: data['message'] ?? '',
      read: data['read'] ?? false,
      relatedId: data['relatedId'],
      relatedType: data['relatedType'],
      actionUrl: data['actionUrl'],
      metadata: data['metadata'],
      createdAt: (data['createdAt'] as Timestamp).toDate(),
      readAt: data['readAt'] != null 
          ? (data['readAt'] as Timestamp).toDate() 
          : null,
    );
  }

  /// Converts Notification to Firestore document format.
  Map<String, dynamic> toFirestore() {
    return {
      'userId': userId,
      'type': type,
      'title': title,
      'message': message,
      'read': read,
      'relatedId': relatedId,
      'relatedType': relatedType,
      'actionUrl': actionUrl,
      'metadata': metadata,
      'createdAt': Timestamp.fromDate(createdAt),
      'readAt': readAt != null ? Timestamp.fromDate(readAt!) : null,
    };
  }

  /// Creates a copy with optional field updates.
  Notification copyWith({
    String? id,
    String? userId,
    String? type,
    String? title,
    String? message,
    bool? read,
    String? relatedId,
    String? relatedType,
    String? actionUrl,
    Map<String, dynamic>? metadata,
    DateTime? createdAt,
    DateTime? readAt,
  }) {
    return Notification(
      id: id ?? this.id,
      userId: userId ?? this.userId,
      type: type ?? this.type,
      title: title ?? this.title,
      message: message ?? this.message,
      read: read ?? this.read,
      relatedId: relatedId ?? this.relatedId,
      relatedType: relatedType ?? this.relatedType,
      actionUrl: actionUrl ?? this.actionUrl,
      metadata: metadata ?? this.metadata,
      createdAt: createdAt ?? this.createdAt,
      readAt: readAt ?? this.readAt,
    );
  }

  /// Marks the notification as read with current timestamp.
  Notification markAsRead() {
    return copyWith(
      read: true,
      readAt: DateTime.now(),
    );
  }
  
  /// Gets notification type enum from string type.
  NotificationType get notificationType => NotificationType.fromString(type);
  
  /// Checks if the notification is unread.
  bool get isUnread => !read;
  
  /// Gets a display icon based on notification type.
  String get displayIcon {
    switch (notificationType) {
      case NotificationType.assignment:
      case NotificationType.assignmentReminder:
        return '📝';
      case NotificationType.grade:
        return '📊';
      case NotificationType.message:
        return '💬';
      case NotificationType.eventReminder:
        return '📅';
      case NotificationType.system:
        return '⚙️';
      case NotificationType.general:
        return '📢';
    }
  }
}
````

## File: lib/features/student/data/repositories/student_repository_impl.dart
````dart
/// Concrete implementation of the student repository.
/// 
/// This module implements the StudentRepository interface using
/// Firebase Firestore as the data source. It provides comprehensive
/// student management functionality with enrollment tracking
/// and performance analytics.
library;

import 'package:cloud_firestore/cloud_firestore.dart';
import '../../domain/models/student.dart';
import '../../../grades/domain/models/grade.dart';
import '../../../../shared/services/firestore_service.dart';
import '../../../../shared/services/logger_service.dart';
import '../../domain/repositories/student_repository.dart';
import '../../../../shared/repositories/firestore_repository.dart';

/// Firestore-based implementation of StudentRepository.
/// 
/// This class extends FirestoreRepository to leverage common
/// CRUD operations while implementing student-specific features:
/// - Multi-class enrollment management
/// - Grade level organization and filtering
/// - Parent-student relationship tracking
/// - Academic performance statistics
/// - Batch operations for bulk enrollment
/// - Full-text search across student profiles
/// 
/// All operations include comprehensive logging and automatic
/// timestamp management for audit trails.
class StudentRepositoryImpl extends FirestoreRepository<Student> implements StudentRepository {
  /// Logger tag for this repository.
  static const String _tag = 'StudentRepository';
  
  /// Firestore instance for direct database operations.
  final FirebaseFirestore _firestore;

  /// Creates a student repository with Firestore backend.
  /// 
  /// Initializes the parent FirestoreRepository with student-specific
  /// configuration including collection path and serialization functions.
  /// 
  /// @param _firestore Firestore database instance
  StudentRepositoryImpl(this._firestore)
      : super(
          firestore: _firestore,
          collectionPath: 'students',
          fromFirestore: (doc) => Student.fromFirestore(doc),
          toFirestore: (student) => student.toFirestore(),
          logTag: _tag,
        );

  /// Creates a new student profile with timestamps.
  /// 
  /// Automatically sets creation and update timestamps.
  /// The student ID is generated by Firestore for uniqueness.
  /// 
  /// @param student Student model with profile data
  /// @return Generated unique student ID
  /// @throws Exception if creation fails
  @override
  Future<String> createStudent(Student student) async {
    try {
      // Update timestamp
      final studentToCreate = student.copyWith(
        createdAt: DateTime.now(),
        updatedAt: DateTime.now(),
      );
      return await create(studentToCreate);
    } catch (e) {
      LoggerService.error('Failed to create student', tag: _tag, error: e);
      rethrow;
    }
  }

  /// Retrieves a student by their unique identifier.
  /// 
  /// Delegates to parent repository for consistent error handling.
  /// 
  /// @param id Unique student identifier
  /// @return Student instance or null if not found
  @override
  Future<Student?> getStudent(String id) => read(id);

  /// Retrieves a student by their authentication user ID.
  /// 
  /// Maps from Firebase Auth user ID to student profile.
  /// Uses limit 1 for efficiency since userId should be unique.
  /// Useful for post-login profile loading.
  /// 
  /// @param userId Authentication user identifier
  /// @return Student instance or null if not found
  /// @throws Exception if retrieval fails
  @override
  Future<Student?> getStudentByUserId(String userId) async {
    try {
      final students = await list(
        conditions: [
          QueryCondition(field: 'userId', isEqualTo: userId),
        ],
        limit: 1,
      );
      return students.isEmpty ? null : students.first;
    } catch (e) {
      LoggerService.error('Failed to get student by user ID', tag: _tag, error: e);
      rethrow;
    }
  }

  /// Updates an existing student profile.
  /// 
  /// Automatically updates the modification timestamp.
  /// Preserves immutable fields like creation date.
  /// 
  /// @param id Student ID to update
  /// @param student Updated student information
  /// @throws Exception if update fails
  @override
  Future<void> updateStudent(String id, Student student) async {
    try {
      // Update timestamp
      final studentToUpdate = student.copyWith(
        updatedAt: DateTime.now(),
      );
      await update(id, studentToUpdate);
    } catch (e) {
      LoggerService.error('Failed to update student', tag: _tag, error: e);
      rethrow;
    }
  }

  /// Permanently deletes a student profile.
  /// 
  /// This operation cannot be undone. Consider soft deletion
  /// by setting isActive to false for recoverable removal.
  /// 
  /// @param id Student ID to delete
  /// @throws Exception if deletion fails
  @override
  Future<void> deleteStudent(String id) => delete(id);

  /// Enrolls a student in a specific class.
  /// 
  /// Uses Firestore's arrayUnion to safely add the class ID
  /// without duplicates. Updates modification timestamp using
  /// server time for consistency.
  /// 
  /// Note: Should also update the class's student roster for
  /// bidirectional relationship.
  /// 
  /// @param studentId Student to enroll
  /// @param classId Target class identifier
  /// @throws Exception if enrollment fails
  @override
  Future<void> enrollInClass(String studentId, String classId) async {
    try {
      await _firestore.collection('students').doc(studentId).update({
        'classIds': FieldValue.arrayUnion([classId]),
        'updatedAt': FieldValue.serverTimestamp(),
      });
      LoggerService.info('Student $studentId enrolled in class $classId', tag: _tag);
    } catch (e) {
      LoggerService.error('Failed to enroll student in class', tag: _tag, error: e);
      rethrow;
    }
  }

  /// Removes a student from a class enrollment.
  /// 
  /// Uses Firestore's arrayRemove to safely remove the class ID.
  /// Updates modification timestamp for audit trail.
  /// 
  /// Note: Should also update the class's student roster.
  /// 
  /// @param studentId Student to unenroll
  /// @param classId Class to remove from
  /// @throws Exception if unenrollment fails
  @override
  Future<void> unenrollFromClass(String studentId, String classId) async {
    try {
      await _firestore.collection('students').doc(studentId).update({
        'classIds': FieldValue.arrayRemove([classId]),
        'updatedAt': FieldValue.serverTimestamp(),
      });
      LoggerService.info('Student $studentId unenrolled from class $classId', tag: _tag);
    } catch (e) {
      LoggerService.error('Failed to unenroll student from class', tag: _tag, error: e);
      rethrow;
    }
  }

  /// Enrolls a student in multiple classes at once.
  /// 
  /// Efficient batch enrollment for term registration.
  /// Uses arrayUnion to add all class IDs without duplicates
  /// in a single operation.
  /// 
  /// Note: Consider updating each class's roster in batch.
  /// 
  /// @param studentId Student to enroll
  /// @param classIds List of class identifiers
  /// @throws Exception if batch enrollment fails
  @override
  Future<void> enrollInMultipleClasses(String studentId, List<String> classIds) async {
    try {
      await _firestore.collection('students').doc(studentId).update({
        'classIds': FieldValue.arrayUnion(classIds),
        'updatedAt': FieldValue.serverTimestamp(),
      });
      LoggerService.info('Student $studentId enrolled in ${classIds.length} classes', tag: _tag);
    } catch (e) {
      LoggerService.error('Failed to enroll student in multiple classes', tag: _tag, error: e);
      rethrow;
    }
  }

  /// Streams all active students enrolled in a specific class.
  /// 
  /// Filters by class enrollment and active status, ordered
  /// alphabetically by last name then first name for consistent
  /// display in class rosters.
  /// 
  /// @param classId Class to get students from
  /// @return Stream of enrolled student lists
  @override
  Stream<List<Student>> getClassStudents(String classId) {
    return stream(
      conditions: [
        QueryCondition(field: 'classIds', arrayContains: classId),
        QueryCondition(field: 'isActive', isEqualTo: true),
      ],
      orderBy: [OrderBy(field: 'lastName'), OrderBy(field: 'firstName')],
    );
  }

  /// Streams all active students in the system.
  /// 
  /// Returns only students with active enrollment status,
  /// excluding graduated, suspended, or inactive students.
  /// Ordered alphabetically for easy browsing.
  /// 
  /// @return Stream of active student lists
  @override
  Stream<List<Student>> getActiveStudents() {
    return stream(
      conditions: [
        QueryCondition(field: 'isActive', isEqualTo: true),
      ],
      orderBy: [OrderBy(field: 'lastName'), OrderBy(field: 'firstName')],
    );
  }

  /// Streams active students by their grade level.
  /// 
  /// Useful for grade-specific activities, communications,
  /// and curriculum planning. Only includes active students.
  /// 
  /// @param gradeLevel Grade level to filter by (e.g., 9 for 9th grade)
  /// @return Stream of students in that grade
  @override
  Stream<List<Student>> getStudentsByGradeLevel(int gradeLevel) {
    return stream(
      conditions: [
        QueryCondition(field: 'gradeLevel', isEqualTo: gradeLevel),
        QueryCondition(field: 'isActive', isEqualTo: true),
      ],
      orderBy: [OrderBy(field: 'lastName'), OrderBy(field: 'firstName')],
    );
  }

  /// Searches for students by name or email.
  /// 
  /// Performs client-side text search across multiple fields:
  /// - First name
  /// - Last name
  /// - Email address
  /// - Display name
  /// 
  /// This is a basic implementation that loads all active students.
  /// For production with large datasets, consider:
  /// - Server-side search with Firestore composite indexes
  /// - External search services (Algolia, Elasticsearch)
  /// - Pagination for large result sets
  /// 
  /// @param query Search terms (case-insensitive)
  /// @return List of matching students
  /// @throws Exception if search fails
  @override
  Future<List<Student>> searchStudents(String query) async {
    try {
      final lowercaseQuery = query.toLowerCase();
      
      // This is a simple implementation. For better search, consider using
      // a search service like Algolia or implementing full-text search
      final allStudents = await list(
        conditions: [
          QueryCondition(field: 'isActive', isEqualTo: true),
        ],
      );
      
      return allStudents.where((student) {
        return student.firstName.toLowerCase().contains(lowercaseQuery) ||
               student.lastName.toLowerCase().contains(lowercaseQuery) ||
               student.email.toLowerCase().contains(lowercaseQuery) ||
               student.displayName.toLowerCase().contains(lowercaseQuery);
      }).toList();
    } catch (e) {
      LoggerService.error('Failed to search students', tag: _tag, error: e);
      rethrow;
    }
  }

  /// Calculates overall academic statistics for a student.
  /// 
  /// Aggregates all graded and returned grades across all classes:
  /// - Overall average/GPA
  /// - Total assignments completed
  /// - Grade distribution
  /// - Performance trends
  /// 
  /// Only includes finalized grades (graded or returned status).
  /// Returns null if no grades found.
  /// 
  /// @param studentId Student to analyze
  /// @return Overall grade statistics or null
  /// @throws Exception if calculation fails
  @override
  Future<GradeStatistics?> getStudentOverallStatistics(String studentId) async {
    try {
      final gradesSnapshot = await _firestore
          .collection('grades')
          .where('studentId', isEqualTo: studentId)
          .where('status', whereIn: [
            GradeStatus.graded.name,
            GradeStatus.returned.name,
          ])
          .get();
      
      if (gradesSnapshot.docs.isEmpty) return null;
      
      final grades = gradesSnapshot.docs
          .map((doc) => Grade.fromFirestore(doc))
          .toList();
      
      return GradeStatistics.fromGrades(grades);
    } catch (e) {
      LoggerService.error('Failed to get student overall statistics', tag: _tag, error: e);
      rethrow;
    }
  }

  /// Gets grade statistics broken down by class.
  /// 
  /// Process:
  /// 1. Fetches all finalized grades for the student
  /// 2. Groups grades by class ID
  /// 3. Calculates statistics for each class separately
  /// 
  /// Useful for:
  /// - Identifying strong/weak subjects
  /// - Class-specific progress reports
  /// - Parent-teacher conferences
  /// 
  /// @param studentId Student to analyze
  /// @return Map of class ID to grade statistics
  /// @throws Exception if calculation fails
  @override
  Future<Map<String, GradeStatistics>> getStudentStatisticsByClass(String studentId) async {
    try {
      final gradesSnapshot = await _firestore
          .collection('grades')
          .where('studentId', isEqualTo: studentId)
          .where('status', whereIn: [
            GradeStatus.graded.name,
            GradeStatus.returned.name,
          ])
          .get();
      
      if (gradesSnapshot.docs.isEmpty) return {};
      
      final grades = gradesSnapshot.docs
          .map((doc) => Grade.fromFirestore(doc))
          .toList();
      
      // Group grades by class
      final gradesByClass = <String, List<Grade>>{};
      for (final grade in grades) {
        gradesByClass.putIfAbsent(grade.classId, () => []).add(grade);
      }
      
      // Calculate statistics for each class
      final statisticsByClass = <String, GradeStatistics>{};
      gradesByClass.forEach((classId, classGrades) {
        statisticsByClass[classId] = GradeStatistics.fromGrades(classGrades);
      });
      
      return statisticsByClass;
    } catch (e) {
      LoggerService.error('Failed to get student statistics by class', tag: _tag, error: e);
      rethrow;
    }
  }

  /// Streams all active students associated with a parent email.
  /// 
  /// Returns children linked to a parent account for family
  /// portal access. Only includes active students.
  /// 
  /// @param parentEmail Parent's email address
  /// @return Stream of associated student lists
  @override
  Stream<List<Student>> getStudentsByParentEmail(String parentEmail) {
    return stream(
      conditions: [
        QueryCondition(field: 'parentEmail', isEqualTo: parentEmail),
        QueryCondition(field: 'isActive', isEqualTo: true),
      ],
      orderBy: [OrderBy(field: 'lastName'), OrderBy(field: 'firstName')],
    );
  }

  /// Creates multiple student profiles in one atomic operation.
  /// 
  /// Efficient bulk import for:
  /// - New academic year enrollment
  /// - School transfers
  /// - System migration
  /// 
  /// Process:
  /// 1. Generates unique IDs for each student
  /// 2. Sets consistent timestamps
  /// 3. Commits all creates atomically
  /// 
  /// All creates succeed or fail together.
  /// 
  /// @param students List of student profiles to create
  /// @throws Exception if batch creation fails
  @override
  Future<void> batchCreateStudents(List<Student> students) async {
    try {
      final batch = _firestore.batch();
      final now = DateTime.now();
      
      for (final student in students) {
        final ref = _firestore.collection('students').doc();
        final studentToCreate = student.copyWith(
          id: ref.id,
          createdAt: now,
          updatedAt: now,
        );
        batch.set(ref, studentToCreate.toFirestore());
      }
      
      await batch.commit();
      LoggerService.info('Batch created ${students.length} students', tag: _tag);
    } catch (e) {
      LoggerService.error('Failed to batch create students', tag: _tag, error: e);
      rethrow;
    }
  }

  /// Updates multiple student profiles in one atomic operation.
  /// 
  /// Efficient bulk update for:
  /// - Grade level promotion
  /// - Mass status changes
  /// - Bulk data corrections
  /// 
  /// All updates use the same timestamp for consistency.
  /// Operations are atomic - all succeed or fail together.
  /// 
  /// @param students Map of student IDs to updated profiles
  /// @throws Exception if batch update fails
  @override
  Future<void> batchUpdateStudents(Map<String, Student> students) async {
    try {
      final batch = _firestore.batch();
      final now = DateTime.now();
      
      students.forEach((studentId, student) {
        final ref = _firestore.collection('students').doc(studentId);
        final studentToUpdate = student.copyWith(
          updatedAt: now,
        );
        batch.update(ref, studentToUpdate.toFirestore());
      });
      
      await batch.commit();
      LoggerService.info('Batch updated ${students.length} students', tag: _tag);
    } catch (e) {
      LoggerService.error('Failed to batch update students', tag: _tag, error: e);
      rethrow;
    }
  }

  /// Checks if an email address is available for registration.
  /// 
  /// Queries for existing students with the same email.
  /// Returns true only if no matches found.
  /// 
  /// Used during student registration to prevent duplicates.
  /// 
  /// @param email Email address to check
  /// @return true if available, false if taken
  /// @throws Exception if check fails
  @override
  Future<bool> isEmailAvailable(String email) async {
    try {
      final existing = await list(
        conditions: [
          QueryCondition(field: 'email', isEqualTo: email),
        ],
        limit: 1,
      );
      return existing.isEmpty;
    } catch (e) {
      LoggerService.error('Failed to check email availability', tag: _tag, error: e);
      rethrow;
    }
  }

  /// Verifies if a student is enrolled in a specific class.
  /// 
  /// Efficient enrollment check by loading the student profile
  /// and checking the classIds array. Returns false if student
  /// doesn't exist.
  /// 
  /// @param studentId Student to check
  /// @param classId Class to verify enrollment in
  /// @return true if enrolled, false otherwise
  /// @throws Exception if verification fails
  @override
  Future<bool> isStudentEnrolledInClass(String studentId, String classId) async {
    try {
      final student = await read(studentId);
      return student?.classIds.contains(classId) ?? false;
    } catch (e) {
      LoggerService.error('Failed to check student enrollment', tag: _tag, error: e);
      rethrow;
    }
  }
}
````

## File: lib/features/student/data/services/presence_service.dart
````dart
import 'package:firebase_auth/firebase_auth.dart';
import 'package:firebase_database/firebase_database.dart';
import '../../../../shared/services/logger_service.dart';

class PresenceService {
  final FirebaseAuth _auth = FirebaseAuth.instance;
  FirebaseDatabase? _database;
  
  FirebaseDatabase get database {
    _database ??= FirebaseDatabase.instance;
    return _database!;
  }
  
  // Privacy settings - can be extended to user preferences
  static const bool _showFullName = true;
  static const bool _showPhoto = true;
  static const bool _showRole = true;
  
  // Track user's online status with privacy controls
  Future<void> updateUserPresence(bool isOnline, {String? userRole}) async {
    try {
      final user = _auth.currentUser;
      if (user == null) return;
      
      final userStatusRef = database.ref('presence/${user.uid}');
      
      if (isOnline) {
        // User is online - store only necessary public information
        final presenceData = _buildPresenceData(user, true, userRole);
        await userStatusRef.set(presenceData);
        
        // Set up disconnect handler
        final offlineData = _buildPresenceData(user, false, userRole);
        await userStatusRef.onDisconnect().set(offlineData);
      } else {
        // User is offline
        await userStatusRef.update({
          'online': false,
          'lastSeen': ServerValue.timestamp,
        });
      }
    } catch (error) {
      LoggerService.error('Error updating user presence', error: error);
    }
  }
  
  // Build presence data with privacy controls
  Map<String, dynamic> _buildPresenceData(User user, bool isOnline, String? userRole) {
    return {
      'online': isOnline,
      'lastSeen': ServerValue.timestamp,
      'uid': user.uid,
      'displayName': _showFullName 
          ? (user.displayName ?? 'Anonymous User')
          : _getInitials(user.displayName ?? 'AU'),
      // Never expose email in presence data
      // 'email': _showEmail ? user.email : null, // Removed for security
      'photoURL': _showPhoto ? user.photoURL : null,
      'role': _showRole ? userRole : null,
      // Add privacy-safe metadata
      'isAnonymous': user.isAnonymous,
      'metadata': {
        'platform': 'web', // Can be extended to detect platform
        'version': '1.0.0', // App version for compatibility
      },
    };
  }
  
  // Get initials from display name
  String _getInitials(String displayName) {
    if (displayName.isEmpty) return 'AU';
    final parts = displayName.split(' ');
    if (parts.length >= 2) {
      return '${parts[0][0]}${parts[1][0]}'.toUpperCase();
    }
    return displayName[0].toUpperCase();
  }
  
  // Get stream of online users with filtering
  Stream<List<OnlineUser>> getOnlineUsers({bool excludeSelf = false}) {
    // Check if user is authenticated before accessing database
    final currentUser = _auth.currentUser;
    if (currentUser == null) {
      // Return an empty list if no user is logged in
      return Stream.value([]);
    }
    
    return database.ref('presence').onValue.map((DatabaseEvent event) {
      final List<OnlineUser> onlineUsers = [];
      
      if (event.snapshot.exists && event.snapshot.value != null) {
        // Safely handle the data conversion
        final rawData = event.snapshot.value;
        if (rawData is! Map) {
          LoggerService.error('Unexpected presence data format: ${rawData.runtimeType}');
          return onlineUsers;
        }
        final data = Map<dynamic, dynamic>.from(rawData);
        
        data.forEach((key, value) {
          // Filter out offline users and optionally self
          if (value['online'] == true) {
            final uid = value['uid'] ?? '';
            if (!excludeSelf || uid != currentUser.uid) {
              onlineUsers.add(OnlineUser(
                uid: uid,
                displayName: value['displayName'] ?? 'Anonymous User',
                // Email is no longer exposed in presence data
                photoURL: value['photoURL'],
                role: value['role'],
                lastSeen: value['lastSeen'] != null 
                    ? DateTime.fromMillisecondsSinceEpoch(value['lastSeen'])
                    : DateTime.now(),
                isAnonymous: value['isAnonymous'] ?? false,
                metadata: value['metadata'] != null
                    ? PresenceMetadata.fromMap(value['metadata'])
                    : null,
              ));
            }
          }
        });
      }
      
      // Sort by last seen (most recent first)
      onlineUsers.sort((a, b) => b.lastSeen.compareTo(a.lastSeen));
      
      return onlineUsers;
    }).handleError((error) {
      // Log the error but return empty list to keep UI functional
      LoggerService.error('Error fetching online users', error: error);
      return <OnlineUser>[];
    });
  }
  
  // Get specific user's online status
  Stream<bool> getUserOnlineStatus(String uid) {
    // Check if user is authenticated before accessing database
    if (_auth.currentUser == null) {
      return Stream.value(false);
    }
    
    return database.ref('presence/$uid/online').onValue.map((DatabaseEvent event) {
      return event.snapshot.value as bool? ?? false;
    }).handleError((error) {
      LoggerService.error('Error fetching user online status', error: error);
      return false;
    });
  }
  
  // Get user's last seen time
  Stream<DateTime?> getUserLastSeen(String uid) {
    if (_auth.currentUser == null) {
      return Stream.value(null);
    }
    
    return database.ref('presence/$uid/lastSeen').onValue.map((DatabaseEvent event) {
      final timestamp = event.snapshot.value as int?;
      return timestamp != null 
          ? DateTime.fromMillisecondsSinceEpoch(timestamp)
          : null;
    }).handleError((error) {
      LoggerService.error('Error fetching user last seen', error: error);
      return null;
    });
  }
  
  // Initialize presence tracking
  void initializePresence({String? userRole}) {
    _auth.authStateChanges().listen((user) {
      if (user != null) {
        updateUserPresence(true, userRole: userRole);
      }
    });
  }
  
  // Clean up presence on sign out
  Future<void> cleanupPresence() async {
    await updateUserPresence(false);
  }
  
  // Batch update presence for multiple users (admin function)
  Future<void> batchUpdatePresence(Map<String, bool> userStatuses) async {
    try {
      final updates = <String, dynamic>{};
      userStatuses.forEach((uid, isOnline) {
        updates['presence/$uid/online'] = isOnline;
        updates['presence/$uid/lastSeen'] = ServerValue.timestamp;
      });
      await database.ref().update(updates);
    } catch (error) {
      LoggerService.error('Error in batch presence update', error: error);
    }
  }
  
  // Get count of online users by role
  Stream<Map<String, int>> getOnlineUserCountByRole() {
    if (_auth.currentUser == null) {
      return Stream.value({});
    }
    
    return database.ref('presence').onValue.map((DatabaseEvent event) {
      final Map<String, int> roleCounts = {};
      
      if (event.snapshot.exists && event.snapshot.value != null) {
        // Safely handle the data conversion
        final rawData = event.snapshot.value;
        if (rawData is! Map) {
          LoggerService.error('Unexpected presence data format: ${rawData.runtimeType}');
          return roleCounts;
        }
        final data = Map<dynamic, dynamic>.from(rawData);
        
        data.forEach((key, value) {
          if (value['online'] == true) {
            final role = value['role'] ?? 'unknown';
            roleCounts[role] = (roleCounts[role] ?? 0) + 1;
          }
        });
      }
      
      return roleCounts;
    }).handleError((error) {
      LoggerService.error('Error fetching online user counts', error: error);
      return <String, int>{};
    });
  }
}

// Enhanced model for online users with privacy in mind
class OnlineUser {
  final String uid;
  final String displayName;
  final String? photoURL;
  final String? role;
  final DateTime lastSeen;
  final bool isAnonymous;
  final PresenceMetadata? metadata;
  
  OnlineUser({
    required this.uid,
    required this.displayName,
    this.photoURL,
    this.role,
    required this.lastSeen,
    this.isAnonymous = false,
    this.metadata,
  });
  
  // Helper method to get relative time
  String get relativeTime {
    final now = DateTime.now();
    final difference = now.difference(lastSeen);
    
    if (difference.inSeconds < 60) {
      return 'just now';
    } else if (difference.inMinutes < 60) {
      return '${difference.inMinutes}m ago';
    } else if (difference.inHours < 24) {
      return '${difference.inHours}h ago';
    } else {
      return '${difference.inDays}d ago';
    }
  }
  
  // Helper to check if user is active (online in last 5 minutes)
  bool get isActive {
    return DateTime.now().difference(lastSeen).inMinutes < 5;
  }
}

// Metadata for presence information
class PresenceMetadata {
  final String platform;
  final String version;
  
  PresenceMetadata({
    required this.platform,
    required this.version,
  });
  
  factory PresenceMetadata.fromMap(Map<dynamic, dynamic> map) {
    return PresenceMetadata(
      platform: map['platform'] ?? 'unknown',
      version: map['version'] ?? '0.0.0',
    );
  }
  
  Map<String, dynamic> toMap() {
    return {
      'platform': platform,
      'version': version,
    };
  }
}
````

## File: lib/features/student/data/services/student_service.dart
````dart
/// Student management service for the education platform.
/// 
/// This service provides comprehensive functionality for managing
/// student profiles, enrollments, and related data operations.
library;

import 'package:cloud_firestore/cloud_firestore.dart';
import '../../domain/models/student.dart';

/// Core service for managing students in Firestore.
/// 
/// This service handles:
/// - Student lifecycle management (create, read, update, delete)
/// - Class enrollment management
/// - Student queries and filtering
/// - Batch operations for efficient bulk processing
/// - Real-time student data streams
/// 
/// The service uses dependency injection for Firestore instance,
/// supporting both production and testing environments.
class StudentService {
  /// Firestore database instance for batch operations.
  final FirebaseFirestore _firestore;
  
  /// Reference to the students collection in Firestore.
  final CollectionReference _studentsCollection;

  /// Creates a StudentService instance.
  /// 
  /// Accepts optional [firestore] parameter for dependency injection,
  /// defaulting to the singleton instance if not provided.
  /// This pattern supports both production use and unit testing.
  StudentService({FirebaseFirestore? firestore})
      : _firestore = firestore ?? FirebaseFirestore.instance,
        _studentsCollection = (firestore ?? FirebaseFirestore.instance).collection('students');

  // --- Student CRUD Operations ---

  /// Creates a new student in Firestore.
  /// 
  /// Adds the student to the database and returns it with
  /// the generated document ID. The student's metadata and
  /// enrollment data should be set before calling this method.
  /// 
  /// @param student Student model to create
  /// @return Created student with generated ID
  /// @throws Exception if creation fails
  Future<Student> createStudent(Student student) async {
    try {
      final docRef = await _studentsCollection.add(student.toFirestore());
      return student.copyWith(id: docRef.id);
    } catch (e) {
      // Error creating student: $e
      rethrow;
    }
  }

  /// Retrieves a single student by ID.
  /// 
  /// Fetches the student document from Firestore and converts
  /// it to a Student model. Returns null if the student
  /// doesn't exist.
  /// 
  /// @param studentId Unique identifier of the student
  /// @return Student instance or null if not found
  /// @throws Exception if retrieval fails
  Future<Student?> getStudent(String studentId) async {
    try {
      final doc = await _studentsCollection.doc(studentId).get();
      if (!doc.exists) return null;
      return Student.fromFirestore(doc);
    } catch (e) {
      // Error getting student: $e
      rethrow;
    }
  }

  /// Retrieves a student by their user ID.
  /// 
  /// Queries for the student record associated with a specific
  /// user authentication ID. Returns null if no student is found.
  /// 
  /// @param userId User authentication ID
  /// @return Student instance or null if not found
  /// @throws Exception if query fails
  Future<Student?> getStudentByUserId(String userId) async {
    try {
      final query = await _studentsCollection
          .where('userId', isEqualTo: userId)
          .limit(1)
          .get();
      
      if (query.docs.isEmpty) return null;
      return Student.fromFirestore(query.docs.first);
    } catch (e) {
      // Error getting student by userId: $e
      rethrow;
    }
  }

  /// Streams all students in the system.
  /// 
  /// Returns a real-time stream of all students:
  /// - Ordered by display name (alphabetical)
  /// - Including both active and inactive students
  /// - Updated in real-time as data changes
  /// 
  /// @return Stream of student lists
  Stream<List<Student>> getAllStudents() {
    return _studentsCollection
        .orderBy('displayName')
        .snapshots()
        .map((snapshot) => snapshot.docs
            .map((doc) => Student.fromFirestore(doc))
            .toList());
  }

  /// Streams active students only.
  /// 
  /// Returns a real-time stream of students where:
  /// - isActive field is true
  /// - Ordered by display name (alphabetical)
  /// - Updated in real-time as data changes
  /// 
  /// @return Stream of active student lists
  Stream<List<Student>> getActiveStudents() {
    return _studentsCollection
        .where('isActive', isEqualTo: true)
        .snapshots()
        .map((snapshot) {
          final students = snapshot.docs
              .map((doc) => Student.fromFirestore(doc))
              .toList();
          // Sort in memory temporarily until index is created
          students.sort((a, b) => a.displayName.compareTo(b.displayName));
          return students;
        });
  }

  /// Streams students enrolled in a specific class.
  /// 
  /// Returns a real-time stream of students:
  /// - Enrolled in the given class ID
  /// - Ordered by display name (alphabetical)
  /// - Updated in real-time as enrollments change
  /// 
  /// @param classId Class identifier to filter students
  /// @return Stream of student lists for the class
  Stream<List<Student>> getStudentsForClass(String classId) {
    return _studentsCollection
        .where('classIds', arrayContains: classId)
        .orderBy('displayName')
        .snapshots()
        .map((snapshot) => snapshot.docs
            .map((doc) => Student.fromFirestore(doc))
            .toList());
  }

  /// Streams students filtered by grade level.
  /// 
  /// Returns a real-time stream of students:
  /// - At the specified grade level
  /// - Ordered by display name (alphabetical)
  /// - Updated in real-time as data changes
  /// 
  /// @param gradeLevel Grade level to filter by
  /// @return Stream of student lists for the grade
  Stream<List<Student>> getStudentsByGrade(int gradeLevel) {
    return _studentsCollection
        .where('gradeLevel', isEqualTo: gradeLevel)
        .orderBy('displayName')
        .snapshots()
        .map((snapshot) => snapshot.docs
            .map((doc) => Student.fromFirestore(doc))
            .toList());
  }

  /// Searches students by name or email.
  /// 
  /// Performs a case-insensitive search across student names and emails.
  /// Note: This is a simple implementation that may need optimization
  /// for large datasets. Consider implementing server-side search
  /// or using a search service for better performance.
  /// 
  /// @param query Search query string
  /// @return List of matching students
  /// @throws Exception if search fails
  Future<List<Student>> searchStudents(String query) async {
    try {
      final queryLower = query.toLowerCase();
      
      // Get all students and filter on client side
      // TODO: Implement server-side search for better performance
      final snapshot = await _studentsCollection.get();
      final allStudents = snapshot.docs
          .map((doc) => Student.fromFirestore(doc))
          .toList();
      
      return allStudents.where((student) {
        return student.displayName.toLowerCase().contains(queryLower) ||
               student.email.toLowerCase().contains(queryLower) ||
               student.firstName.toLowerCase().contains(queryLower) ||
               student.lastName.toLowerCase().contains(queryLower);
      }).toList();
    } catch (e) {
      // Error searching students: $e
      rethrow;
    }
  }

  /// Updates an existing student in Firestore.
  /// 
  /// Overwrites the entire student document with the provided
  /// data. Automatically updates the updatedAt timestamp.
  /// Ensure all required fields are present in the student model.
  /// 
  /// @param student Student model with updated data
  /// @throws Exception if update fails or student doesn't exist
  Future<void> updateStudent(Student student) async {
    try {
      final updatedStudent = student.copyWith(updatedAt: DateTime.now());
      await _studentsCollection
          .doc(student.id)
          .update(updatedStudent.toFirestore());
    } catch (e) {
      // Error updating student: $e
      rethrow;
    }
  }

  /// Deletes a student from Firestore.
  /// 
  /// Permanently removes the student document from the database.
  /// This operation cannot be undone. Consider using soft delete
  /// (setting isActive to false) instead for data retention.
  /// 
  /// @param studentId ID of the student to delete
  /// @throws Exception if deletion fails
  Future<void> deleteStudent(String studentId) async {
    try {
      await _studentsCollection.doc(studentId).delete();
    } catch (e) {
      // Error deleting student: $e
      rethrow;
    }
  }

  /// Soft deletes a student by setting isActive to false.
  /// 
  /// Marks the student as inactive without removing the record.
  /// This preserves historical data while removing the student
  /// from active queries and operations.
  /// 
  /// @param studentId ID of the student to deactivate
  /// @throws Exception if update fails
  Future<void> deactivateStudent(String studentId) async {
    try {
      await _studentsCollection.doc(studentId).update({
        'isActive': false,
        'updatedAt': FieldValue.serverTimestamp(),
      });
    } catch (e) {
      // Error deactivating student: $e
      rethrow;
    }
  }

  /// Reactivates a previously deactivated student.
  /// 
  /// Sets the student's isActive field back to true,
  /// making them visible in active student queries.
  /// 
  /// @param studentId ID of the student to reactivate
  /// @throws Exception if update fails
  Future<void> reactivateStudent(String studentId) async {
    try {
      await _studentsCollection.doc(studentId).update({
        'isActive': true,
        'updatedAt': FieldValue.serverTimestamp(),
      });
    } catch (e) {
      // Error reactivating student: $e
      rethrow;
    }
  }

  // --- Class Enrollment Management ---

  /// Enrolls a student in a class.
  /// 
  /// Adds the class ID to the student's classIds array if not
  /// already present. Updates the student's modification timestamp.
  /// 
  /// @param studentId ID of the student to enroll
  /// @param classId ID of the class to enroll in
  /// @throws Exception if enrollment fails
  Future<void> enrollInClass(String studentId, String classId) async {
    try {
      await _studentsCollection.doc(studentId).update({
        'classIds': FieldValue.arrayUnion([classId]),
        'updatedAt': FieldValue.serverTimestamp(),
      });
    } catch (e) {
      // Error enrolling student in class: $e
      rethrow;
    }
  }

  /// Unenrolls a student from a class.
  /// 
  /// Removes the class ID from the student's classIds array.
  /// Updates the student's modification timestamp.
  /// 
  /// @param studentId ID of the student to unenroll
  /// @param classId ID of the class to unenroll from
  /// @throws Exception if unenrollment fails
  Future<void> unenrollFromClass(String studentId, String classId) async {
    try {
      await _studentsCollection.doc(studentId).update({
        'classIds': FieldValue.arrayRemove([classId]),
        'updatedAt': FieldValue.serverTimestamp(),
      });
    } catch (e) {
      // Error unenrolling student from class: $e
      rethrow;
    }
  }

  /// Bulk enrolls multiple students in a class.
  /// 
  /// Efficiently enrolls multiple students using batch operations.
  /// All enrollments succeed or fail together (atomic operation).
  /// 
  /// @param studentIds List of student IDs to enroll
  /// @param classId ID of the class to enroll in
  /// @throws Exception if batch enrollment fails
  Future<void> bulkEnrollInClass(List<String> studentIds, String classId) async {
    try {
      final batch = _firestore.batch();
      
      for (final studentId in studentIds) {
        batch.update(_studentsCollection.doc(studentId), {
          'classIds': FieldValue.arrayUnion([classId]),
          'updatedAt': FieldValue.serverTimestamp(),
        });
      }
      
      await batch.commit();
    } catch (e) {
      // Error bulk enrolling students: $e
      rethrow;
    }
  }

  /// Bulk unenrolls multiple students from a class.
  /// 
  /// Efficiently unenrolls multiple students using batch operations.
  /// All unenrollments succeed or fail together (atomic operation).
  /// 
  /// @param studentIds List of student IDs to unenroll
  /// @param classId ID of the class to unenroll from
  /// @throws Exception if batch unenrollment fails
  Future<void> bulkUnenrollFromClass(List<String> studentIds, String classId) async {
    try {
      final batch = _firestore.batch();
      
      for (final studentId in studentIds) {
        batch.update(_studentsCollection.doc(studentId), {
          'classIds': FieldValue.arrayRemove([classId]),
          'updatedAt': FieldValue.serverTimestamp(),
        });
      }
      
      await batch.commit();
    } catch (e) {
      // Error bulk unenrolling students: $e
      rethrow;
    }
  }

  // --- Batch Operations ---

  /// Creates multiple students in a single batch operation.
  /// 
  /// Efficiently creates multiple student records using Firestore
  /// batch writes. Each student gets a generated document ID.
  /// All writes succeed or fail together (atomic operation).
  /// 
  /// @param students List of Student models to create
  /// @throws Exception if batch creation fails
  Future<void> bulkCreateStudents(List<Student> students) async {
    try {
      final batch = _firestore.batch();
      
      for (final student in students) {
        final docRef = _studentsCollection.doc();
        batch.set(docRef, student.copyWith(id: docRef.id).toFirestore());
      }
      
      await batch.commit();
    } catch (e) {
      // Error bulk creating students: $e
      rethrow;
    }
  }

  /// Updates multiple students in a single batch operation.
  /// 
  /// Efficiently updates multiple student records using Firestore
  /// batch writes. All students get updated timestamps.
  /// All updates succeed or fail together (atomic operation).
  /// 
  /// @param students List of Student models with updated data
  /// @throws Exception if batch update fails
  Future<void> bulkUpdateStudents(List<Student> students) async {
    try {
      final batch = _firestore.batch();
      final now = DateTime.now();
      
      for (final student in students) {
        final updatedStudent = student.copyWith(updatedAt: now);
        batch.update(
          _studentsCollection.doc(student.id),
          updatedStudent.toFirestore(),
        );
      }
      
      await batch.commit();
    } catch (e) {
      // Error bulk updating students: $e
      rethrow;
    }
  }

  // --- Statistics and Analytics ---

  /// Gets the total count of students in the system.
  /// 
  /// Returns the number of student records, including both
  /// active and inactive students.
  /// 
  /// @return Total student count
  /// @throws Exception if count retrieval fails
  Future<int> getTotalStudentCount() async {
    try {
      final snapshot = await _studentsCollection.count().get();
      return snapshot.count ?? 0;
    } catch (e) {
      // Error getting student count: $e
      rethrow;
    }
  }

  /// Gets the count of active students only.
  /// 
  /// Returns the number of students where isActive is true.
  /// 
  /// @return Active student count
  /// @throws Exception if count retrieval fails
  Future<int> getActiveStudentCount() async {
    try {
      final snapshot = await _studentsCollection
          .where('isActive', isEqualTo: true)
          .count()
          .get();
      return snapshot.count ?? 0;
    } catch (e) {
      // Error getting active student count: $e
      rethrow;
    }
  }

  /// Gets the count of students in a specific class.
  /// 
  /// Returns the number of students enrolled in the given class.
  /// 
  /// @param classId Class identifier
  /// @return Student count for the class
  /// @throws Exception if count retrieval fails
  Future<int> getClassStudentCount(String classId) async {
    try {
      final snapshot = await _studentsCollection
          .where('classIds', arrayContains: classId)
          .count()
          .get();
      return snapshot.count ?? 0;
    } catch (e) {
      // Error getting class student count: $e
      rethrow;
    }
  }

  /// Gets enrollment statistics by grade level.
  /// 
  /// Returns a map of grade level to student count for
  /// visualization and reporting purposes.
  /// 
  /// @return Map of grade level to student count
  /// @throws Exception if statistics retrieval fails
  Future<Map<int, int>> getGradeLevelStatistics() async {
    try {
      final snapshot = await _studentsCollection
          .where('isActive', isEqualTo: true)
          .get();
      
      final stats = <int, int>{};
      for (final doc in snapshot.docs) {
        final student = Student.fromFirestore(doc);
        stats[student.gradeLevel] = (stats[student.gradeLevel] ?? 0) + 1;
      }
      
      return stats;
    } catch (e) {
      // Error getting grade level statistics: $e
      rethrow;
    }
  }
}
````

## File: lib/features/student/domain/models/student.dart
````dart
/// Student model for managing student profiles and enrollment data.
/// 
/// This module contains the data model for students, representing
/// learners enrolled in classes within the education management system.
library;

import 'package:cloud_firestore/cloud_firestore.dart';

/// Core student model representing a learner in the system.
/// 
/// This model encapsulates all student-specific data, including:
/// - Personal information (name, email, grade)
/// - Class enrollments
/// - Parent/guardian contact information
/// - Profile metadata
/// 
/// The Student model is separate from UserModel to allow:
/// - Teacher-specific views of student data
/// - Enrollment management without full user access
/// - Parent contact information storage
/// - Grade-level specific features
class Student {
  /// Unique identifier for the student record
  final String id;
  
  /// Associated user ID linking to authentication system
  final String userId;
  
  /// Student's email address
  final String email;
  
  /// Student's first name
  final String firstName;
  
  /// Student's last name
  final String lastName;
  
  /// Display name shown in UI (typically "FirstName LastName")
  final String displayName;
  
  /// Current grade level (1-12 for K-12 systems)
  final int gradeLevel;
  
  /// Optional parent/guardian email for notifications
  final String? parentEmail;
  
  /// List of class IDs the student is enrolled in
  final List<String> classIds;
  
  /// Optional URL to student's profile photo
  final String? photoURL;
  
  /// Timestamp when the student record was created
  final DateTime createdAt;
  
  /// Timestamp of last update to student record
  final DateTime updatedAt;
  
  /// Whether the student account is active
  final bool isActive;
  
  /// Flexible metadata for additional student information
  final Map<String, dynamic>? metadata;

  Student({
    required this.id,
    required this.userId,
    required this.email,
    required this.firstName,
    required this.lastName,
    required this.displayName,
    required this.gradeLevel,
    this.parentEmail,
    required this.classIds,
    this.photoURL,
    required this.createdAt,
    required this.updatedAt,
    this.isActive = true,
    this.metadata,
  });

  /// Gets the student's full name by combining first and last names.
  /// @return Full name as "FirstName LastName"
  String get fullName => '$firstName $lastName';
  
  /// Gets the number of classes the student is enrolled in.
  /// @return Count of enrolled classes
  int get classCount => classIds.length;

  /// Factory constructor to create Student from Firestore document.
  /// 
  /// Handles data parsing with safe defaults including:
  /// - Null-safe timestamp conversions with fallback to current time
  /// - Default values for required fields
  /// - List casting for class IDs
  /// - Optional field preservation
  /// 
  /// @param doc Firestore document snapshot containing student data
  /// @return Parsed Student instance
  factory Student.fromFirestore(DocumentSnapshot doc) {
    final data = doc.data() as Map<String, dynamic>;
    return Student(
      id: doc.id,
      userId: data['userId'] ?? '',
      email: data['email'] ?? '',
      firstName: data['firstName'] ?? '',
      lastName: data['lastName'] ?? '',
      displayName: data['displayName'] ?? '',
      gradeLevel: data['gradeLevel'] ?? 0,
      parentEmail: data['parentEmail'],
      classIds: List<String>.from(data['classIds'] ?? []),
      photoURL: data['photoURL'],
      createdAt: (data['createdAt'] as Timestamp?)?.toDate() ?? DateTime.now(),
      updatedAt: (data['updatedAt'] as Timestamp?)?.toDate() ?? DateTime.now(),
      isActive: data['isActive'] ?? true,
      metadata: data['metadata'],
    );
  }

  /// Converts the Student instance to a Map for Firestore storage.
  /// 
  /// Note: DateTime fields are stored directly without conversion
  /// to Timestamp, which may need adjustment based on Firestore
  /// configuration requirements.
  /// 
  /// @return Map containing all student data for Firestore persistence
  Map<String, dynamic> toFirestore() {
    return {
      'userId': userId,
      'email': email,
      'firstName': firstName,
      'lastName': lastName,
      'displayName': displayName,
      'gradeLevel': gradeLevel,
      'parentEmail': parentEmail,
      'classIds': classIds,
      'photoURL': photoURL,
      'createdAt': createdAt,
      'updatedAt': updatedAt,
      'isActive': isActive,
      'metadata': metadata,
    };
  }

  /// Creates a copy of the Student with updated fields.
  /// 
  /// Follows the immutable data pattern for state management.
  /// Useful for:
  /// - Updating student information
  /// - Managing class enrollments
  /// - Modifying grade level or status
  /// 
  /// All parameters are optional - only provided fields will be updated.
  /// 
  /// @return New Student instance with updated fields
  Student copyWith({
    String? id,
    String? userId,
    String? email,
    String? firstName,
    String? lastName,
    String? displayName,
    int? gradeLevel,
    String? parentEmail,
    List<String>? classIds,
    String? photoURL,
    DateTime? createdAt,
    DateTime? updatedAt,
    bool? isActive,
    Map<String, dynamic>? metadata,
  }) {
    return Student(
      id: id ?? this.id,
      userId: userId ?? this.userId,
      email: email ?? this.email,
      firstName: firstName ?? this.firstName,
      lastName: lastName ?? this.lastName,
      displayName: displayName ?? this.displayName,
      gradeLevel: gradeLevel ?? this.gradeLevel,
      parentEmail: parentEmail ?? this.parentEmail,
      classIds: classIds ?? this.classIds,
      photoURL: photoURL ?? this.photoURL,
      createdAt: createdAt ?? this.createdAt,
      updatedAt: updatedAt ?? this.updatedAt,
      isActive: isActive ?? this.isActive,
      metadata: metadata ?? this.metadata,
    );
  }
}
````

## File: lib/features/student/domain/repositories/student_repository.dart
````dart
/// Student repository interface for learner management.
/// 
/// This module defines the contract for student operations in the
/// education platform, supporting student profiles, enrollment,
/// academic performance tracking, and parent associations.
library;

import '../models/student.dart';
import '../../../grades/domain/models/grade.dart';
import '../../../../shared/repositories/base_repository.dart';

/// Abstract repository defining student management operations.
/// 
/// This interface provides a comprehensive contract for student
/// implementations, supporting:
/// - CRUD operations for student profiles
/// - Class enrollment and scheduling
/// - Academic performance tracking
/// - Parent-student relationships
/// - Grade level organization
/// - Batch operations for efficiency
/// - Search and filtering capabilities
/// 
/// Concrete implementations handle the actual student
/// data persistence and business logic.
abstract class StudentRepository extends BaseRepository {
  // CRUD operations
  
  /// Creates a new student profile in the system.
  /// 
  /// Initializes a student record with personal information,
  /// grade level, and enrollment status. Returns the generated
  /// student ID for reference.
  /// 
  /// @param student Student model with profile data
  /// @return Generated unique student ID
  /// @throws Exception if creation fails
  Future<String> createStudent(Student student);
  
  /// Retrieves a student by their unique identifier.
  /// 
  /// Fetches complete student profile including personal
  /// information, enrollment status, and grade level.
  /// 
  /// @param id Unique student identifier
  /// @return Student instance or null if not found
  /// @throws Exception if retrieval fails
  Future<Student?> getStudent(String id);
  
  /// Retrieves a student by their associated user ID.
  /// 
  /// Maps from the authentication user ID to the student
  /// profile. Useful for user login flows.
  /// 
  /// @param userId Authentication user identifier
  /// @return Student instance or null if not found
  /// @throws Exception if retrieval fails
  Future<Student?> getStudentByUserId(String userId);
  
  /// Updates an existing student profile.
  /// 
  /// Modifies student information such as grade level,
  /// contact details, or enrollment status.
  /// 
  /// @param id Student ID to update
  /// @param student Updated student information
  /// @throws Exception if update fails
  Future<void> updateStudent(String id, Student student);
  
  /// Permanently deletes a student profile.
  /// 
  /// Removes the student record and associated data.
  /// This operation cannot be undone.
  /// 
  /// @param id Student ID to delete
  /// @throws Exception if deletion fails
  Future<void> deleteStudent(String id);
  
  // Class enrollment
  
  /// Enrolls a student in a specific class.
  /// 
  /// Adds the student to the class roster and updates
  /// the student's enrolled classes list.
  /// 
  /// @param studentId Student to enroll
  /// @param classId Target class identifier
  /// @throws Exception if enrollment fails
  Future<void> enrollInClass(String studentId, String classId);
  
  /// Removes a student from a class enrollment.
  /// 
  /// Updates both the class roster and student's
  /// enrolled classes list.
  /// 
  /// @param studentId Student to unenroll
  /// @param classId Class to remove from
  /// @throws Exception if unenrollment fails
  Future<void> unenrollFromClass(String studentId, String classId);
  
  /// Enrolls a student in multiple classes at once.
  /// 
  /// Batch operation for efficiency when adding a student
  /// to several classes, such as during term registration.
  /// 
  /// @param studentId Student to enroll
  /// @param classIds List of class identifiers
  /// @throws Exception if batch enrollment fails
  Future<void> enrollInMultipleClasses(String studentId, List<String> classIds);
  
  // Queries
  
  /// Streams all students enrolled in a specific class.
  /// 
  /// Returns real-time updates of the class roster,
  /// useful for attendance and grade management.
  /// 
  /// @param classId Class to get students from
  /// @return Stream of enrolled student lists
  Stream<List<Student>> getClassStudents(String classId);
  
  /// Streams all active students in the system.
  /// 
  /// Filters to only include students with active
  /// enrollment status, excluding graduated or inactive.
  /// 
  /// @return Stream of active student lists
  Stream<List<Student>> getActiveStudents();
  
  /// Streams students by their grade level.
  /// 
  /// Useful for grade-specific communications,
  /// curriculum planning, and cohort analysis.
  /// 
  /// @param gradeLevel Grade level to filter by
  /// @return Stream of students in that grade
  Stream<List<Student>> getStudentsByGradeLevel(int gradeLevel);
  
  /// Searches for students by name or ID.
  /// 
  /// Performs text search across student names and
  /// identifiers for quick lookup functionality.
  /// 
  /// @param query Search terms
  /// @return List of matching students
  /// @throws Exception if search fails
  Future<List<Student>> searchStudents(String query);
  
  // Grade related
  
  /// Calculates overall academic statistics for a student.
  /// 
  /// Aggregates performance data across all enrolled classes:
  /// - Overall GPA/average
  /// - Total assignments completed
  /// - Attendance rates
  /// - Performance trends
  /// 
  /// @param studentId Student to analyze
  /// @return Overall grade statistics or null
  /// @throws Exception if calculation fails
  Future<GradeStatistics?> getStudentOverallStatistics(String studentId);
  
  /// Gets grade statistics broken down by class.
  /// 
  /// Returns a map of class IDs to statistics, showing
  /// performance in each enrolled class separately.
  /// 
  /// @param studentId Student to analyze
  /// @return Map of class ID to grade statistics
  /// @throws Exception if calculation fails
  Future<Map<String, GradeStatistics>> getStudentStatisticsByClass(String studentId);
  
  // Parent related
  
  /// Streams all students associated with a parent email.
  /// 
  /// Returns real-time updates of children linked to a
  /// parent account, useful for parent portal access.
  /// 
  /// @param parentEmail Parent's email address
  /// @return Stream of associated student lists
  Stream<List<Student>> getStudentsByParentEmail(String parentEmail);
  
  // Batch operations
  
  /// Creates multiple student profiles in one operation.
  /// 
  /// Efficient bulk import for new student registration,
  /// such as at the beginning of an academic year.
  /// All creates succeed or fail together.
  /// 
  /// @param students List of student profiles to create
  /// @throws Exception if batch creation fails
  Future<void> batchCreateStudents(List<Student> students);
  
  /// Updates multiple student profiles in one operation.
  /// 
  /// Efficient bulk update for grade level promotion
  /// or mass profile updates. Atomically updates all
  /// provided students.
  /// 
  /// @param students Map of student IDs to updated profiles
  /// @throws Exception if batch update fails
  Future<void> batchUpdateStudents(Map<String, Student> students);
  
  // Validation
  
  /// Checks if an email address is available for use.
  /// 
  /// Verifies the email isn't already associated with
  /// an existing student account. Used during registration.
  /// 
  /// @param email Email address to check
  /// @return true if available, false if taken
  /// @throws Exception if check fails
  Future<bool> isEmailAvailable(String email);
  
  /// Verifies if a student is enrolled in a specific class.
  /// 
  /// Quick check for enrollment status without loading
  /// full student or class profiles.
  /// 
  /// @param studentId Student to check
  /// @param classId Class to verify enrollment in
  /// @return true if enrolled, false otherwise
  /// @throws Exception if verification fails
  Future<bool> isStudentEnrolledInClass(String studentId, String classId);
}
````

## File: lib/features/student/presentation/providers/student_provider.dart
````dart
/// Student management state provider.
/// 
/// This module manages student data and operations for the education platform,
/// handling student listings, profile management, grade tracking, and
/// class enrollment status through real-time Firebase streams.
library;

import 'dart:async';
import 'package:flutter/material.dart';
import '../../domain/models/student.dart';
import '../../../grades/domain/models/grade.dart';
import '../../../classes/domain/models/class_model.dart';
import '../../domain/repositories/student_repository.dart';
import '../../../classes/domain/repositories/class_repository.dart';
import '../../../../shared/core/service_locator.dart';

/// Provider managing student state and operations.
/// 
/// This provider serves as the central state manager for students,
/// coordinating between student and class repositories. Key features:
/// - Real-time student list updates with filtering capabilities
/// - Individual student profile management and statistics
/// - Class enrollment tracking for students
/// - Grade statistics aggregation (overall and per-class)
/// - Batch operations for efficient data management
/// - Parent-student relationship queries
/// - Email availability checking for registration
/// 
/// Maintains separate contexts for different student views:
/// all students, current student, and selected student for detail views.
class StudentProvider with ChangeNotifier {
  /// Repository for student data operations.
  late final StudentRepository _studentRepository;
  
  /// Repository for class data operations.
  late final ClassRepository _classRepository;
  
  // State variables
  
  /// List of students based on current filter/context.
  List<Student> _students = [];
  
  /// Currently authenticated student profile.
  Student? _currentStudent;
  
  /// Classes enrolled by the current student.
  List<ClassModel> _studentClasses = [];
  
  /// Grade statistics grouped by class ID.
  Map<String, GradeStatistics> _studentStatisticsByClass = {};
  
  /// Overall performance statistics across all classes.
  GradeStatistics? _overallStatistics;
  
  /// Loading state for async operations.
  bool _isLoading = false;
  
  /// Latest error message for UI display.
  String? _error;
  
  /// Selected student for detail views.
  Student? _selectedStudent;
  
  // Stream subscriptions
  
  /// Subscription for student list updates.
  StreamSubscription<List<Student>>? _studentsSubscription;
  
  /// Subscription for student's class enrollment updates.
  StreamSubscription<List<ClassModel>>? _classesSubscription;
  
  /// Creates student provider with repository dependencies.
  /// 
  /// Retrieves repositories from dependency injection container.
  StudentProvider() {
    _studentRepository = getIt<StudentRepository>();
    _classRepository = getIt<ClassRepository>();
  }
  
  // Getters
  
  /// List of students based on current filter.
  List<Student> get students => _students;
  
  /// Currently authenticated student profile or null.
  Student? get currentStudent => _currentStudent;
  
  /// Classes the current student is enrolled in.
  List<ClassModel> get studentClasses => _studentClasses;
  
  /// Grade statistics grouped by class ID.
  Map<String, GradeStatistics> get studentStatisticsByClass => _studentStatisticsByClass;
  
  /// Overall performance statistics or null.
  GradeStatistics? get overallStatistics => _overallStatistics;
  
  /// Whether an operation is in progress.
  bool get isLoading => _isLoading;
  
  /// Latest error message or null.
  String? get error => _error;
  
  /// Currently selected student for detail view or null.
  Student? get selectedStudent => _selectedStudent;
  
  /// Filters current student list to show only active students.
  /// 
  /// Active students are those not archived or disabled.
  /// Used for enrollment and class management views.
  List<Student> get activeStudents {
    return _students.where((s) => s.isActive).toList();
  }
  
  /// Filters current student list by grade level.
  /// 
  /// Useful for grade-specific views and assignments.
  /// 
  /// @param gradeLevel Grade level to filter by (e.g., 9, 10, 11, 12)
  /// @return List of students in the specified grade
  List<Student> getStudentsByGradeLevel(int gradeLevel) {
    return _students.where((s) => s.gradeLevel == gradeLevel).toList();
  }
  
  /// Loads and subscribes to all active students.
  /// 
  /// Sets up real-time stream for active student updates.
  /// Cancels any existing subscription before creating new one.
  /// Used in teacher views for student management.
  /// 
  /// @throws Exception if loading fails
  Future<void> loadActiveStudents() async {
    _setLoading(true);
    try {
      _studentsSubscription?.cancel();
      
      _studentsSubscription = _studentRepository.getActiveStudents().listen(
        (studentList) {
          _students = studentList;
          _setLoading(false);
          notifyListeners();
        },
        onError: (error) {
          _setError(error.toString());
          _setLoading(false);
        },
      );
    } catch (e) {
      _setError(e.toString());
      _setLoading(false);
    }
  }
  
  /// Loads and subscribes to students by grade level.
  /// 
  /// Sets up real-time stream for grade-specific student updates.
  /// Filters students to show only those in the specified grade.
  /// Cancels any existing subscription before creating new one.
  /// 
  /// @param gradeLevel Grade level to filter by
  /// @throws Exception if loading fails
  Future<void> loadStudentsByGradeLevel(int gradeLevel) async {
    _setLoading(true);
    try {
      _studentsSubscription?.cancel();
      
      _studentsSubscription = _studentRepository.getStudentsByGradeLevel(gradeLevel).listen(
        (studentList) {
          _students = studentList;
          _setLoading(false);
          notifyListeners();
        },
        onError: (error) {
          _setError(error.toString());
          _setLoading(false);
        },
      );
    } catch (e) {
      _setError(e.toString());
      _setLoading(false);
    }
  }
  
  /// Loads and subscribes to students by parent email.
  /// 
  /// Sets up real-time stream for parent-specific student updates.
  /// Used in parent portal views to show only their children.
  /// Cancels any existing subscription before creating new one.
  /// 
  /// @param parentEmail Parent's email address
  /// @throws Exception if loading fails
  Future<void> loadStudentsByParentEmail(String parentEmail) async {
    _setLoading(true);
    try {
      _studentsSubscription?.cancel();
      
      _studentsSubscription = _studentRepository.getStudentsByParentEmail(parentEmail).listen(
        (studentList) {
          _students = studentList;
          _setLoading(false);
          notifyListeners();
        },
        onError: (error) {
          _setError(error.toString());
          _setLoading(false);
        },
      );
    } catch (e) {
      _setError(e.toString());
      _setLoading(false);
    }
  }
  
  /// Loads current student profile and associated data.
  /// 
  /// Fetches student record by Firebase user ID and loads:
  /// - Student's enrolled classes
  /// - Grade statistics (overall and per-class)
  /// 
  /// Used during authentication to establish student context.
  /// 
  /// @param userId Firebase Auth user identifier
  /// @throws Exception if loading fails
  Future<void> loadCurrentStudent(String userId) async {
    _setLoading(true);
    try {
      _currentStudent = await _studentRepository.getStudentByUserId(userId);
      
      if (_currentStudent != null) {
        // Load student's classes
        await loadStudentClasses(_currentStudent!.id);
        
        // Load statistics
        await loadStudentStatistics(_currentStudent!.id);
      }
      
      _setLoading(false);
      notifyListeners();
    } catch (e) {
      _setError(e.toString());
      _setLoading(false);
    }
  }
  
  /// Loads and subscribes to student's enrolled classes.
  /// 
  /// Sets up real-time stream for class enrollment updates.
  /// Updates when student enrolls/unenrolls from classes.
  /// 
  /// @param studentId Student identifier
  /// @throws Exception if loading fails
  Future<void> loadStudentClasses(String studentId) async {
    try {
      _classesSubscription?.cancel();
      
      _classesSubscription = _classRepository.getStudentClasses(studentId).listen(
        (classList) {
          _studentClasses = classList;
          notifyListeners();
        },
        onError: (error) {
          _setError(error.toString());
        },
      );
    } catch (e) {
      _setError(e.toString());
    }
  }
  
  /// Loads comprehensive grade statistics for student.
  /// 
  /// Fetches both overall performance metrics and
  /// class-specific statistics for detailed analysis.
  /// Fails silently to avoid disrupting UI flow.
  /// 
  /// @param studentId Student identifier
  Future<void> loadStudentStatistics(String studentId) async {
    try {
      // Load overall statistics
      _overallStatistics = await _studentRepository.getStudentOverallStatistics(studentId);
      
      // Load statistics by class
      _studentStatisticsByClass = await _studentRepository.getStudentStatisticsByClass(studentId);
      
      notifyListeners();
    } catch (e) {
      _setError(e.toString());
    }
  }
  
  /// Creates a new student record.
  /// 
  /// Adds student to Firestore and updates local state
  /// through stream subscription if currently loading students.
  /// 
  /// @param student Student data to create
  /// @return true if creation successful
  Future<bool> createStudent(Student student) async {
    _setLoading(true);
    try {
      await _studentRepository.createStudent(student);
      _setLoading(false);
      return true;
    } catch (e) {
      _setError(e.toString());
      _setLoading(false);
      return false;
    }
  }
  
  /// Updates existing student information.
  /// 
  /// Modifies student in Firestore and updates all local caches
  /// for immediate UI response. Updates current, selected, and
  /// list student references if they match.
  /// 
  /// @param studentId Student identifier
  /// @param student Updated student data
  /// @return true if update successful
  Future<bool> updateStudent(String studentId, Student student) async {
    _setLoading(true);
    try {
      await _studentRepository.updateStudent(studentId, student);
      
      // Update local lists
      final index = _students.indexWhere((s) => s.id == studentId);
      if (index != -1) {
        _students[index] = student;
      }
      
      if (_currentStudent?.id == studentId) {
        _currentStudent = student;
      }
      
      if (_selectedStudent?.id == studentId) {
        _selectedStudent = student;
      }
      
      notifyListeners();
      _setLoading(false);
      return true;
    } catch (e) {
      _setError(e.toString());
      _setLoading(false);
      return false;
    }
  }
  
  /// Permanently deletes a student record.
  /// 
  /// Removes student from Firestore and all local caches.
  /// This operation cannot be undone. Consider deactivation instead.
  /// Clears current and selected student if they match.
  /// 
  /// @param studentId Student to delete
  /// @return true if deletion successful
  Future<bool> deleteStudent(String studentId) async {
    _setLoading(true);
    try {
      await _studentRepository.deleteStudent(studentId);
      
      // Remove from local list
      _students.removeWhere((s) => s.id == studentId);
      
      if (_currentStudent?.id == studentId) {
        _currentStudent = null;
      }
      
      if (_selectedStudent?.id == studentId) {
        _selectedStudent = null;
      }
      
      notifyListeners();
      _setLoading(false);
      return true;
    } catch (e) {
      _setError(e.toString());
      _setLoading(false);
      return false;
    }
  }
  
  /// Creates multiple student records in one operation.
  /// 
  /// Efficient batch creation for school setup or imports.
  /// All students are created or none are created (atomic operation).
  /// Updates local state through stream subscription.
  /// 
  /// @param students List of student data to create
  /// @return true if batch creation successful
  Future<bool> batchCreateStudents(List<Student> students) async {
    _setLoading(true);
    try {
      await _studentRepository.batchCreateStudents(students);
      _setLoading(false);
      return true;
    } catch (e) {
      _setError(e.toString());
      _setLoading(false);
      return false;
    }
  }
  
  /// Searches students by name, email, or student ID.
  /// 
  /// Performs text search across student fields.
  /// Does not affect current student list state.
  /// 
  /// @param query Search terms
  /// @return List of matching students or empty list if error
  Future<List<Student>> searchStudents(String query) async {
    try {
      return await _studentRepository.searchStudents(query);
    } catch (e) {
      _setError(e.toString());
      return [];
    }
  }
  
  /// Checks if email address is available for registration.
  /// 
  /// Validates that email is not already used by another student.
  /// Used during registration and profile update flows.
  /// 
  /// @param email Email address to check
  /// @return true if email is available, false if taken or error
  Future<bool> isEmailAvailable(String email) async {
    try {
      return await _studentRepository.isEmailAvailable(email);
    } catch (e) {
      _setError(e.toString());
      return false;
    }
  }
  
  /// Sets the currently selected student.
  /// 
  /// Used for detail views and context-aware operations.
  /// 
  /// @param student Student to select or null to clear
  void setSelectedStudent(Student? student) {
    _selectedStudent = student;
    notifyListeners();
  }
  
  // Helper methods
  
  /// Sets loading state and notifies listeners.
  /// 
  /// @param loading New loading state
  void _setLoading(bool loading) {
    _isLoading = loading;
    notifyListeners();
  }
  
  /// Sets error message and notifies listeners.
  /// 
  /// @param error Error description or null to clear
  void _setError(String? error) {
    _error = error;
    notifyListeners();
  }
  
  /// Clears error message and notifies UI.
  /// 
  /// Called after user acknowledges error.
  void clearError() {
    _error = null;
    notifyListeners();
  }
  
  /// Clears all cached student data.
  /// 
  /// Resets provider to initial state.
  /// Useful for user logout or role switch.
  void clearData() {
    _students = [];
    _currentStudent = null;
    _studentClasses = [];
    _studentStatisticsByClass = {};
    _overallStatistics = null;
    _selectedStudent = null;
    _isLoading = false;
    _error = null;
    notifyListeners();
  }
  
  /// Cleans up resources when provider is disposed.
  /// 
  /// Cancels all stream subscriptions and disposes
  /// repositories to prevent memory leaks.
  @override
  void dispose() {
    // Cancel subscriptions
    _studentsSubscription?.cancel();
    _classesSubscription?.cancel();
    
    // Dispose repositories
    _studentRepository.dispose();
    _classRepository.dispose();
    
    super.dispose();
  }
}
````

## File: lib/features/student/presentation/screens/messages_screen.dart
````dart
import 'package:flutter/material.dart';
import '../../../../shared/widgets/common/adaptive_layout.dart';
import '../../../../shared/widgets/common/responsive_layout.dart';

class StudentMessagesScreen extends StatefulWidget {
  const StudentMessagesScreen({super.key});

  @override
  State<StudentMessagesScreen> createState() => _StudentMessagesScreenState();
}

class _StudentMessagesScreenState extends State<StudentMessagesScreen> with SingleTickerProviderStateMixin {
  late TabController _tabController;
  final _searchController = TextEditingController();
  String _selectedFilter = 'All';

  @override
  void initState() {
    super.initState();
    _tabController = TabController(length: 3, vsync: this, initialIndex: 0);
  }

  @override
  void dispose() {
    _tabController.dispose();
    _searchController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);

    return AdaptiveLayout(
      title: 'Messages',
      showBackButton: true,
      floatingActionButton: FloatingActionButton.extended(
        onPressed: () {
          _showComposeMessage(context);
        },
        icon: const Icon(Icons.edit),
        label: const Text('New Message'),
      ),
      bottom: TabBar(
        controller: _tabController,
        tabs: const [
          Tab(text: 'Inbox'),
          Tab(text: 'Sent'),
          Tab(text: 'Archived'),
        ],
      ),
      body: Column(
        children: [
          // Search and Filter Bar
          Container(
            padding: const EdgeInsets.all(16),
            child: Row(
              children: [
                // Search Field
                Expanded(
                  child: TextField(
                    controller: _searchController,
                    decoration: InputDecoration(
                      hintText: 'Search messages...',
                      prefixIcon: const Icon(Icons.search),
                      suffixIcon: _searchController.text.isNotEmpty
                          ? IconButton(
                              icon: const Icon(Icons.clear),
                              onPressed: () {
                                setState(() {
                                  _searchController.clear();
                                });
                              },
                            )
                          : null,
                      border: const OutlineInputBorder(),
                      contentPadding: const EdgeInsets.symmetric(
                        horizontal: 16,
                        vertical: 12,
                      ),
                    ),
                    onChanged: (value) => setState(() {}),
                  ),
                ),
                const SizedBox(width: 12),
                // Filter Button
                Container(
                  decoration: BoxDecoration(
                    border: Border.all(color: theme.colorScheme.outline),
                    borderRadius: BorderRadius.circular(8),
                  ),
                  child: PopupMenuButton<String>(
                    initialValue: _selectedFilter,
                    onSelected: (value) {
                      setState(() {
                        _selectedFilter = value;
                      });
                    },
                    itemBuilder: (context) => [
                      const PopupMenuItem(value: 'All', child: Text('All Messages')),
                      const PopupMenuItem(value: 'Unread', child: Text('Unread')),
                      const PopupMenuItem(value: 'Starred', child: Text('Starred')),
                      const PopupMenuItem(value: 'Teachers', child: Text('From Teachers')),
                      const PopupMenuItem(value: 'Important', child: Text('Important')),
                    ],
                    child: Padding(
                      padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 8),
                      child: Row(
                        children: [
                          const Icon(Icons.filter_list, size: 20),
                          const SizedBox(width: 8),
                          Text(_selectedFilter),
                          const Icon(Icons.arrow_drop_down),
                        ],
                      ),
                    ),
                  ),
                ),
              ],
            ),
          ),
          // Messages List
          Expanded(
            child: TabBarView(
              controller: _tabController,
              children: [
                _buildInboxMessages(),
                _buildSentMessages(),
                _buildArchivedMessages(),
              ],
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildInboxMessages() {
    final messages = [
      {
        'sender': 'Mr. Smith',
        'senderType': 'Teacher',
        'subject': 'Math Assignment Feedback',
        'preview': 'Great work on your latest assignment! I wanted to provide some additional feedback...',
        'time': DateTime.now().subtract(const Duration(hours: 1)),
        'isRead': false,
        'isStarred': true,
        'hasAttachment': false,
        'priority': 'High',
      },
      {
        'sender': 'Ms. Johnson',
        'senderType': 'Teacher',
        'subject': 'Science Project Reminder',
        'preview': 'Just a friendly reminder that your science project is due next week...',
        'time': DateTime.now().subtract(const Duration(hours: 4)),
        'isRead': true,
        'isStarred': false,
        'hasAttachment': true,
        'priority': 'Normal',
      },
      {
        'sender': 'Academic Office',
        'senderType': 'Admin',
        'subject': 'Grade Report Available',
        'preview': 'Your quarter grade report is now available for download...',
        'time': DateTime.now().subtract(const Duration(days: 1)),
        'isRead': true,
        'isStarred': false,
        'hasAttachment': true,
        'priority': 'Normal',
      },
      {
        'sender': 'Dr. Wilson',
        'senderType': 'Teacher',
        'subject': 'Class Schedule Change',
        'preview': 'Please note that tomorrow\'s physics class has been moved to room 205...',
        'time': DateTime.now().subtract(const Duration(days: 2)),
        'isRead': false,
        'isStarred': true,
        'hasAttachment': false,
        'priority': 'High',
      },
    ];

    return _buildMessagesList(messages);
  }

  Widget _buildSentMessages() {
    final messages = [
      {
        'sender': 'To: Mr. Smith',
        'senderType': 'Sent',
        'subject': 'Re: Math homework question',
        'preview': 'Thank you for the explanation! I understand the concept much better now...',
        'time': DateTime.now().subtract(const Duration(hours: 6)),
        'isRead': true,
        'isStarred': false,
        'hasAttachment': false,
        'priority': 'Normal',
      },
      {
        'sender': 'To: Academic Office',
        'senderType': 'Sent',
        'subject': 'Request for transcript',
        'preview': 'I would like to request an official transcript for my college applications...',
        'time': DateTime.now().subtract(const Duration(days: 3)),
        'isRead': true,
        'isStarred': false,
        'hasAttachment': false,
        'priority': 'Normal',
      },
    ];

    return _buildMessagesList(messages);
  }

  Widget _buildArchivedMessages() {
    final messages = [
      {
        'sender': 'Previous Teacher',
        'senderType': 'Teacher',
        'subject': 'End of semester message',
        'preview': 'Thank you for being such a dedicated student this semester...',
        'time': DateTime.now().subtract(const Duration(days: 60)),
        'isRead': true,
        'isStarred': true,
        'hasAttachment': false,
        'priority': 'Normal',
      },
    ];

    return _buildMessagesList(messages);
  }

  Widget _buildMessagesList(List<Map<String, dynamic>> messages) {
    return ResponsiveContainer(
      child: ListView.builder(
        itemCount: messages.length,
        itemBuilder: (context, index) {
          final message = messages[index];
          return _buildMessageCard(message);
        },
      ),
    );
  }

  Widget _buildMessageCard(Map<String, dynamic> message) {
    final theme = Theme.of(context);
    final isUnread = !(message['isRead'] as bool);
    final isImportant = message['priority'] == 'High';
    
    Color senderTypeColor;
    IconData senderTypeIcon;
    switch (message['senderType']) {
      case 'Teacher':
        senderTypeColor = Colors.blue;
        senderTypeIcon = Icons.school;
        break;
      case 'Admin':
        senderTypeColor = Colors.purple;
        senderTypeIcon = Icons.admin_panel_settings;
        break;
      case 'Sent':
        senderTypeColor = Colors.grey;
        senderTypeIcon = Icons.send;
        break;
      default:
        senderTypeColor = Colors.grey;
        senderTypeIcon = Icons.person;
    }

    return Card(
      margin: const EdgeInsets.symmetric(horizontal: 16, vertical: 4),
      child: InkWell(
        onTap: () => _showMessageDetail(message),
        borderRadius: BorderRadius.circular(12),
        child: Padding(
          padding: const EdgeInsets.all(16),
          child: Row(
            children: [
              // Sender Avatar
              Stack(
                children: [
                  CircleAvatar(
                    backgroundColor: isUnread 
                        ? senderTypeColor.withValues(alpha: 0.2)
                        : Colors.grey.withValues(alpha: 0.1),
                    child: Icon(
                      senderTypeIcon,
                      color: isUnread ? senderTypeColor : Colors.grey,
                      size: 20,
                    ),
                  ),
                  if (isImportant)
                    Positioned(
                      top: 0,
                      right: 0,
                      child: Container(
                        width: 12,
                        height: 12,
                        decoration: const BoxDecoration(
                          color: Colors.red,
                          shape: BoxShape.circle,
                        ),
                        child: const Icon(
                          Icons.priority_high,
                          color: Colors.white,
                          size: 8,
                        ),
                      ),
                    ),
                ],
              ),
              const SizedBox(width: 12),
              // Message Content
              Expanded(
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    // Header Row
                    Row(
                      children: [
                        Expanded(
                          child: Text(
                            message['sender'],
                            style: theme.textTheme.titleMedium?.copyWith(
                              fontWeight: isUnread ? FontWeight.bold : FontWeight.normal,
                            ),
                            overflow: TextOverflow.ellipsis,
                          ),
                        ),
                        Text(
                          _formatMessageTime(message['time']),
                          style: theme.textTheme.bodySmall?.copyWith(
                            color: theme.colorScheme.onSurfaceVariant,
                            fontWeight: isUnread ? FontWeight.w600 : FontWeight.normal,
                          ),
                        ),
                      ],
                    ),
                    const SizedBox(height: 4),
                    // Subject
                    Text(
                      message['subject'],
                      style: theme.textTheme.bodyMedium?.copyWith(
                        fontWeight: isUnread ? FontWeight.w600 : FontWeight.normal,
                      ),
                      overflow: TextOverflow.ellipsis,
                    ),
                    const SizedBox(height: 2),
                    // Preview
                    Row(
                      children: [
                        Expanded(
                          child: Text(
                            message['preview'],
                            style: theme.textTheme.bodySmall?.copyWith(
                              color: theme.colorScheme.onSurfaceVariant,
                            ),
                            overflow: TextOverflow.ellipsis,
                            maxLines: 1,
                          ),
                        ),
                        if (message['hasAttachment']) ...[ 
                          const SizedBox(width: 8),
                          Icon(
                            Icons.attach_file,
                            size: 16,
                            color: theme.colorScheme.onSurfaceVariant,
                          ),
                        ],
                      ],
                    ),
                  ],
                ),
              ),
              const SizedBox(width: 8),
              // Star Button
              IconButton(
                icon: Icon(
                  message['isStarred'] ? Icons.star : Icons.star_border,
                  color: message['isStarred'] ? Colors.amber : Colors.grey,
                ),
                onPressed: () {
                  setState(() {
                    message['isStarred'] = !message['isStarred'];
                  });
                },
              ),
            ],
          ),
        ),
      ),
    );
  }

  String _formatMessageTime(DateTime time) {
    final now = DateTime.now();
    final difference = now.difference(time);
    
    if (difference.inMinutes < 60) {
      return '${difference.inMinutes}m';
    } else if (difference.inHours < 24) {
      return '${difference.inHours}h';
    } else if (difference.inDays < 7) {
      return '${difference.inDays}d';
    } else {
      return '${time.day}/${time.month}';
    }
  }

  void _showMessageDetail(Map<String, dynamic> message) {
    showModalBottomSheet(
      context: context,
      isScrollControlled: true,
      backgroundColor: Colors.transparent,
      builder: (context) => StudentMessageDetailSheet(message: message),
    );
  }

  void _showComposeMessage(BuildContext context) {
    showModalBottomSheet(
      context: context,
      isScrollControlled: true,
      backgroundColor: Colors.transparent,
      builder: (context) => const StudentComposeMessageSheet(),
    );
  }
}

// Student Message Detail Sheet
class StudentMessageDetailSheet extends StatelessWidget {
  final Map<String, dynamic> message;

  const StudentMessageDetailSheet({
    super.key,
    required this.message,
  });

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);

    return Container(
      decoration: BoxDecoration(
        color: theme.colorScheme.surface,
        borderRadius: const BorderRadius.vertical(top: Radius.circular(20)),
      ),
      child: DraggableScrollableSheet(
        initialChildSize: 0.7,
        minChildSize: 0.5,
        maxChildSize: 0.95,
        expand: false,
        builder: (context, scrollController) {
          return Column(
            children: [
              // Handle Bar
              Center(
                child: Container(
                  margin: const EdgeInsets.only(top: 12, bottom: 8),
                  width: 40,
                  height: 4,
                  decoration: BoxDecoration(
                    color: theme.colorScheme.onSurfaceVariant.withValues(alpha: 0.3),
                    borderRadius: BorderRadius.circular(2),
                  ),
                ),
              ),
              // Header
              Container(
                padding: const EdgeInsets.symmetric(horizontal: 24, vertical: 8),
                decoration: BoxDecoration(
                  border: Border(
                    bottom: BorderSide(
                      color: theme.colorScheme.outlineVariant,
                    ),
                  ),
                ),
                child: Row(
                  mainAxisAlignment: MainAxisAlignment.spaceBetween,
                  children: [
                    IconButton(
                      onPressed: () => Navigator.pop(context),
                      icon: const Icon(Icons.close),
                    ),
                    Row(
                      children: [
                        IconButton(
                          onPressed: () {},
                          icon: const Icon(Icons.archive_outlined),
                          tooltip: 'Archive',
                        ),
                        IconButton(
                          onPressed: () {},
                          icon: const Icon(Icons.delete_outline),
                          tooltip: 'Delete',
                        ),
                        IconButton(
                          onPressed: () {},
                          icon: Icon(
                            message['isStarred'] ? Icons.star : Icons.star_border,
                            color: message['isStarred'] ? Colors.amber : null,
                          ),
                          tooltip: 'Star',
                        ),
                      ],
                    ),
                  ],
                ),
              ),
              // Content
              Expanded(
                child: SingleChildScrollView(
                  controller: scrollController,
                  padding: const EdgeInsets.all(24),
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      // Subject
                      Text(
                        message['subject'],
                        style: theme.textTheme.headlineSmall?.copyWith(
                          fontWeight: FontWeight.bold,
                        ),
                      ),
                      const SizedBox(height: 16),
                      // Sender Info
                      Row(
                        children: [
                          CircleAvatar(
                            child: Text(
                              message['sender'][0].toUpperCase(),
                            ),
                          ),
                          const SizedBox(width: 12),
                          Expanded(
                            child: Column(
                              crossAxisAlignment: CrossAxisAlignment.start,
                              children: [
                                Text(
                                  message['sender'],
                                  style: theme.textTheme.titleMedium?.copyWith(
                                    fontWeight: FontWeight.w600,
                                  ),
                                ),
                                Text(
                                  'to me',
                                  style: theme.textTheme.bodySmall?.copyWith(
                                    color: theme.colorScheme.onSurfaceVariant,
                                  ),
                                ),
                              ],
                            ),
                          ),
                          Text(
                            _formatFullDate(message['time']),
                            style: theme.textTheme.bodySmall?.copyWith(
                              color: theme.colorScheme.onSurfaceVariant,
                            ),
                          ),
                        ],
                      ),
                      const SizedBox(height: 24),
                      // Message Body
                      Text(
                        '''Hi there,

${message['preview']}

I wanted to reach out to discuss your recent progress and provide some feedback on your latest work. Your dedication to learning is really showing in your assignments.

Keep up the excellent work, and please don't hesitate to reach out if you have any questions or need additional help with any concepts.

Best regards,
${message['sender']}''',
                        style: theme.textTheme.bodyLarge,
                      ),
                      
                      if (message['hasAttachment']) ...[ 
                        const SizedBox(height: 24),
                        // Attachment
                        Container(
                          padding: const EdgeInsets.all(16),
                          decoration: BoxDecoration(
                            color: theme.colorScheme.surfaceContainerHighest,
                            borderRadius: BorderRadius.circular(8),
                          ),
                          child: Row(
                            children: [
                              Icon(
                                Icons.insert_drive_file,
                                color: theme.colorScheme.primary,
                              ),
                              const SizedBox(width: 12),
                              const Expanded(
                                child: Column(
                                  crossAxisAlignment: CrossAxisAlignment.start,
                                  children: [
                                    Text(
                                      'grade_report.pdf',
                                      style: TextStyle(fontWeight: FontWeight.w600),
                                    ),
                                    Text(
                                      '156 KB',
                                      style: TextStyle(fontSize: 12),
                                    ),
                                  ],
                                ),
                              ),
                              IconButton(
                                onPressed: () {},
                                icon: const Icon(Icons.download),
                              ),
                            ],
                          ),
                        ),
                      ],
                    ],
                  ),
                ),
              ),
              // Reply Section
              Container(
                padding: const EdgeInsets.all(16),
                decoration: BoxDecoration(
                  color: theme.colorScheme.surface,
                  boxShadow: [
                    BoxShadow(
                      color: Colors.black.withValues(alpha: 0.1),
                      blurRadius: 10,
                      offset: const Offset(0, -5),
                    ),
                  ],
                ),
                child: Row(
                  children: [
                    Expanded(
                      child: FilledButton.icon(
                        onPressed: () {
                          Navigator.pop(context);
                          _showReplyMessage(context, message);
                        },
                        icon: const Icon(Icons.reply),
                        label: const Text('Reply'),
                      ),
                    ),
                    const SizedBox(width: 12),
                    Expanded(
                      child: OutlinedButton.icon(
                        onPressed: () {
                          Navigator.pop(context);
                          _showForwardMessage(context, message);
                        },
                        icon: const Icon(Icons.forward),
                        label: const Text('Forward'),
                      ),
                    ),
                  ],
                ),
              ),
            ],
          );
        },
      ),
    );
  }

  String _formatFullDate(DateTime date) {
    final months = [
      'Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun',
      'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'
    ];
    final hour = date.hour > 12 ? date.hour - 12 : date.hour;
    final amPm = date.hour >= 12 ? 'PM' : 'AM';
    return '${months[date.month - 1]} ${date.day}, ${date.year} at $hour:${date.minute.toString().padLeft(2, '0')} $amPm';
  }

  void _showReplyMessage(BuildContext context, Map<String, dynamic> originalMessage) {
    showModalBottomSheet(
      context: context,
      isScrollControlled: true,
      backgroundColor: Colors.transparent,
      builder: (context) => StudentComposeMessageSheet(
        recipient: originalMessage['sender'],
        subject: 'Re: ${originalMessage['subject']}',
      ),
    );
  }

  void _showForwardMessage(BuildContext context, Map<String, dynamic> originalMessage) {
    showModalBottomSheet(
      context: context,
      isScrollControlled: true,
      backgroundColor: Colors.transparent,
      builder: (context) => StudentComposeMessageSheet(
        subject: 'Fwd: ${originalMessage['subject']}',
      ),
    );
  }
}

// Student Compose Message Sheet
class StudentComposeMessageSheet extends StatefulWidget {
  final String? recipient;
  final String? subject;

  const StudentComposeMessageSheet({
    super.key,
    this.recipient,
    this.subject,
  });

  @override
  State<StudentComposeMessageSheet> createState() => _StudentComposeMessageSheetState();
}

class _StudentComposeMessageSheetState extends State<StudentComposeMessageSheet> {
  final _recipientController = TextEditingController();
  final _subjectController = TextEditingController();
  final _messageController = TextEditingController();
  String _recipientType = 'Teacher';

  @override
  void initState() {
    super.initState();
    if (widget.recipient != null) {
      _recipientController.text = widget.recipient!;
    }
    if (widget.subject != null) {
      _subjectController.text = widget.subject!;
    }
  }

  @override
  void dispose() {
    _recipientController.dispose();
    _subjectController.dispose();
    _messageController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);

    return Container(
      height: MediaQuery.of(context).size.height * 0.9,
      decoration: BoxDecoration(
        color: theme.colorScheme.surface,
        borderRadius: const BorderRadius.vertical(top: Radius.circular(20)),
      ),
      child: Column(
        children: [
          // Handle Bar
          Center(
            child: Container(
              margin: const EdgeInsets.only(top: 12, bottom: 8),
              width: 40,
              height: 4,
              decoration: BoxDecoration(
                color: theme.colorScheme.onSurfaceVariant.withValues(alpha: 0.3),
                borderRadius: BorderRadius.circular(2),
              ),
            ),
          ),
          // Header
          Padding(
            padding: const EdgeInsets.symmetric(horizontal: 24, vertical: 16),
            child: Row(
              mainAxisAlignment: MainAxisAlignment.spaceBetween,
              children: [
                Text(
                  'New Message',
                  style: theme.textTheme.headlineSmall?.copyWith(
                    fontWeight: FontWeight.bold,
                  ),
                ),
                Row(
                  children: [
                    IconButton(
                      onPressed: () {},
                      icon: const Icon(Icons.attach_file),
                      tooltip: 'Attach file',
                    ),
                    IconButton(
                      onPressed: () => Navigator.pop(context),
                      icon: const Icon(Icons.close),
                    ),
                  ],
                ),
              ],
            ),
          ),
          // Form
          Expanded(
            child: SingleChildScrollView(
              padding: const EdgeInsets.symmetric(horizontal: 24),
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  // Recipient Type
                  SegmentedButton<String>(
                    segments: const [
                      ButtonSegment(
                        value: 'Teacher',
                        label: Text('Teacher'),
                        icon: Icon(Icons.school),
                      ),
                      ButtonSegment(
                        value: 'Admin',
                        label: Text('Admin'),
                        icon: Icon(Icons.admin_panel_settings),
                      ),
                      ButtonSegment(
                        value: 'Support',
                        label: Text('Support'),
                        icon: Icon(Icons.help),
                      ),
                    ],
                    selected: {_recipientType},
                    onSelectionChanged: (Set<String> selection) {
                      setState(() {
                        _recipientType = selection.first;
                      });
                    },
                  ),
                  const SizedBox(height: 16),

                  // To Field
                  TextField(
                    controller: _recipientController,
                    decoration: InputDecoration(
                      labelText: 'To',
                      hintText: _recipientType == 'Teacher' 
                          ? 'Select teacher...' 
                          : _recipientType == 'Admin'
                          ? 'Academic Office'
                          : 'Support Team',
                      border: const OutlineInputBorder(),
                      suffixIcon: const Icon(Icons.person_search),
                    ),
                  ),
                  const SizedBox(height: 16),

                  // Subject Field
                  TextField(
                    controller: _subjectController,
                    decoration: const InputDecoration(
                      labelText: 'Subject',
                      hintText: 'Enter subject',
                      border: OutlineInputBorder(),
                    ),
                  ),
                  const SizedBox(height: 16),

                  // Message Field
                  TextField(
                    controller: _messageController,
                    maxLines: 10,
                    decoration: const InputDecoration(
                      labelText: 'Message',
                      hintText: 'Type your message...',
                      border: OutlineInputBorder(),
                      alignLabelWithHint: true,
                    ),
                  ),
                  
                  // Quick Message Templates
                  const SizedBox(height: 16),
                  Text(
                    'Quick Templates',
                    style: theme.textTheme.titleSmall?.copyWith(
                      fontWeight: FontWeight.w600,
                    ),
                  ),
                  const SizedBox(height: 8),
                  Wrap(
                    spacing: 8,
                    runSpacing: 8,
                    children: [
                      _buildTemplateChip('Question about assignment'),
                      _buildTemplateChip('Request for help'),
                      _buildTemplateChip('Schedule clarification'),
                      _buildTemplateChip('Absence notification'),
                    ],
                  ),
                  const SizedBox(height: 32),
                ],
              ),
            ),
          ),
          // Action Buttons
          Container(
            padding: const EdgeInsets.all(24),
            decoration: BoxDecoration(
              color: theme.colorScheme.surface,
              boxShadow: [
                BoxShadow(
                  color: Colors.black.withValues(alpha: 0.1),
                  blurRadius: 10,
                  offset: const Offset(0, -5),
                ),
              ],
            ),
            child: Row(
              children: [
                Expanded(
                  child: OutlinedButton(
                    onPressed: () {
                      // Save as draft
                      Navigator.pop(context);
                      ScaffoldMessenger.of(context).showSnackBar(
                        const SnackBar(
                          content: Text('Message saved as draft'),
                        ),
                      );
                    },
                    style: OutlinedButton.styleFrom(
                      padding: const EdgeInsets.symmetric(vertical: 16),
                    ),
                    child: const Text('Save Draft'),
                  ),
                ),
                const SizedBox(width: 16),
                Expanded(
                  flex: 2,
                  child: FilledButton.icon(
                    onPressed: () {
                      // Send message
                      Navigator.pop(context);
                      ScaffoldMessenger.of(context).showSnackBar(
                        const SnackBar(
                          content: Text('Message sent successfully'),
                        ),
                      );
                    },
                    icon: const Icon(Icons.send),
                    label: const Text('Send'),
                    style: FilledButton.styleFrom(
                      padding: const EdgeInsets.symmetric(vertical: 16),
                    ),
                  ),
                ),
              ],
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildTemplateChip(String template) {
    return ActionChip(
      label: Text(template),
      onPressed: () {
        setState(() {
          if (_subjectController.text.isEmpty) {
            _subjectController.text = template;
          }
          _messageController.text = 'Hi,\n\nI hope this message finds you well. I wanted to reach out regarding $template.\n\n[Please add your specific details here]\n\nThank you for your time and assistance.\n\nBest regards,\n[Your name]';
        });
      },
    );
  }
}
````

## File: lib/features/student/presentation/screens/teacher/students_screen.dart
````dart
import 'package:flutter/material.dart';
import '../../../domain/models/student.dart';
import '../../../data/services/student_service.dart';
import '../../../../../features/classes/domain/models/class_model.dart';
import '../../../../../shared/widgets/common/adaptive_layout.dart';
import '../../../../../shared/widgets/common/responsive_layout.dart';
import '../../../../../shared/widgets/preview/preview_example_wrapper.dart';
import '../../../../../shared/widgets/preview/example_badge.dart';
import '../../../../../shared/example/example_repository.dart';

class TeacherStudentsScreen extends StatefulWidget {
  const TeacherStudentsScreen({super.key});

  @override
  State<TeacherStudentsScreen> createState() => _TeacherStudentsScreenState();
}

class _TeacherStudentsScreenState extends State<TeacherStudentsScreen>
    with SingleTickerProviderStateMixin {
  late TabController _tabController;
  final _searchController = TextEditingController();
  final _studentService = StudentService();
  String _selectedFilter = 'All';
  String _selectedGrade = 'All';

  @override
  void initState() {
    super.initState();
    _tabController = TabController(length: 4, vsync: this, initialIndex: 0);
  }

  @override
  void dispose() {
    _tabController.dispose();
    _searchController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);

    return AdaptiveLayout(
      title: 'Students',
      showBackButton: true,
      floatingActionButton: FloatingActionButton.extended(
        onPressed: () {
          _showAddStudentSheet(context);
        },
        icon: const Icon(Icons.person_add),
        label: const Text('Add Student'),
      ),
      body: Column(
        children: [
          // TabBar
          Container(
            color: theme.colorScheme.surface,
            child: TabBar(
              controller: _tabController,
              isScrollable: true,
              labelColor: theme.colorScheme.primary,
              unselectedLabelColor: theme.colorScheme.onSurfaceVariant,
              indicatorColor: theme.colorScheme.primary,
              tabs: const [
                Tab(text: 'All Students'),
                Tab(text: 'Classes'),
                Tab(text: 'Performance'),
                Tab(text: 'Reports'),
              ],
            ),
          ),
          // Search and Filter Bar
          Container(
            padding: const EdgeInsets.all(16),
            child: Row(
              children: [
                // Search Field
                Expanded(
                  child: TextField(
                    controller: _searchController,
                    decoration: InputDecoration(
                      hintText: 'Search students...',
                      prefixIcon: const Icon(Icons.search),
                      suffixIcon: _searchController.text.isNotEmpty
                          ? IconButton(
                              icon: const Icon(Icons.clear),
                              onPressed: () {
                                setState(() {
                                  _searchController.clear();
                                });
                              },
                            )
                          : null,
                      border: const OutlineInputBorder(),
                      contentPadding: const EdgeInsets.symmetric(
                        horizontal: 16,
                        vertical: 12,
                      ),
                    ),
                    onChanged: (value) => setState(() {}),
                  ),
                ),
                const SizedBox(width: 12),
                // Grade Filter
                Container(
                  decoration: BoxDecoration(
                    border: Border.all(color: theme.colorScheme.outline),
                    borderRadius: BorderRadius.circular(8),
                  ),
                  child: PopupMenuButton<String>(
                    initialValue: _selectedGrade,
                    onSelected: (value) {
                      setState(() {
                        _selectedGrade = value;
                      });
                    },
                    itemBuilder: (context) => [
                      const PopupMenuItem(
                          value: 'All', child: Text('All Grades')),
                      const PopupMenuItem(value: '9', child: Text('Grade 9')),
                      const PopupMenuItem(value: '10', child: Text('Grade 10')),
                      const PopupMenuItem(value: '11', child: Text('Grade 11')),
                      const PopupMenuItem(value: '12', child: Text('Grade 12')),
                    ],
                    child: Padding(
                      padding: const EdgeInsets.symmetric(
                          horizontal: 12, vertical: 8),
                      child: Row(
                        children: [
                          const Icon(Icons.grade, size: 20),
                          const SizedBox(width: 8),
                          Text(_selectedGrade == 'All'
                              ? 'Grade'
                              : 'G$_selectedGrade'),
                          const Icon(Icons.arrow_drop_down),
                        ],
                      ),
                    ),
                  ),
                ),
                const SizedBox(width: 12),
                // Status Filter
                Container(
                  decoration: BoxDecoration(
                    border: Border.all(color: theme.colorScheme.outline),
                    borderRadius: BorderRadius.circular(8),
                  ),
                  child: PopupMenuButton<String>(
                    initialValue: _selectedFilter,
                    onSelected: (value) {
                      setState(() {
                        _selectedFilter = value;
                      });
                    },
                    itemBuilder: (context) => [
                      const PopupMenuItem(
                          value: 'All', child: Text('All Students')),
                      const PopupMenuItem(
                          value: 'Active', child: Text('Active')),
                      const PopupMenuItem(
                          value: 'Inactive', child: Text('Inactive')),
                      const PopupMenuItem(
                          value: 'Recent', child: Text('Recently Added')),
                    ],
                    child: Padding(
                      padding: const EdgeInsets.symmetric(
                          horizontal: 12, vertical: 8),
                      child: Row(
                        children: [
                          const Icon(Icons.filter_list, size: 20),
                          const SizedBox(width: 8),
                          Text(_selectedFilter),
                          const Icon(Icons.arrow_drop_down),
                        ],
                      ),
                    ),
                  ),
                ),
              ],
            ),
          ),
          // Students List
          Expanded(
            child: TabBarView(
              controller: _tabController,
              children: [
                _buildAllStudents(),
                _buildClassesView(),
                _buildPerformanceView(),
                _buildReportsView(),
              ],
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildAllStudents() {
    // Get example students from repository
    final exampleStudents =
        ExampleRepository.of<Student>(ExampleDomain.students);

    // For now, simulate that we have no real data (empty state)
    // In a real app, this would come from a provider or service
    final List<Student> realStudents = []; // Simulating empty real data

    return PreviewExampleWrapper<Student>(
      realData: realStudents,
      exampleData: exampleStudents,
      isLoading: false, // Set to true if loading from service
      builder: (context, students, isExample) {
        final filteredStudents = _filterStudents(students);

        if (filteredStudents.isEmpty) {
          return Center(
            child: Column(
              mainAxisAlignment: MainAxisAlignment.center,
              children: [
                const Icon(Icons.school_outlined, size: 48, color: Colors.grey),
                const SizedBox(height: 16),
                Text(
                  isExample
                      ? 'No example students available'
                      : 'No students found',
                  style: Theme.of(context).textTheme.titleMedium,
                ),
                const SizedBox(height: 8),
                Text(
                  isExample
                      ? 'Example data could not be loaded'
                      : 'Try adjusting your filters or add your first student',
                  style: Theme.of(context).textTheme.bodyMedium?.copyWith(
                        color: Theme.of(context).colorScheme.onSurfaceVariant,
                      ),
                ),
                const SizedBox(height: 16),
                ElevatedButton(
                  onPressed: () => _showAddStudentSheet(context),
                  child: Text(
                      isExample ? 'Add Real Student' : 'Add First Student'),
                ),
              ],
            ),
          );
        }

        return ResponsiveContainer(
          child: ListView.builder(
            itemCount: filteredStudents.length,
            itemBuilder: (context, index) {
              final student = filteredStudents[index];
              return _buildStudentCard(student, isExample: isExample);
            },
          ),
        );
      },
      onExampleTap: () {
        showDialog(
          context: context,
          builder: (context) => AlertDialog(
            icon: const Icon(Icons.info_outline),
            title: const Text('Example Students'),
            content: const Text(
              'These are example students to show you how the app works. '
              'Add your own students to replace these examples.',
            ),
            actions: [
              TextButton(
                onPressed: () => Navigator.of(context).pop(),
                child: const Text('Got it'),
              ),
              FilledButton(
                onPressed: () {
                  Navigator.of(context).pop();
                  _showAddStudentSheet(context);
                },
                child: const Text('Add Student'),
              ),
            ],
          ),
        );
      },
    );
  }

  Widget _buildClassesView() {
    final theme = Theme.of(context);

    // Get example classes from repository
    final exampleClasses =
        ExampleRepository.of<ClassModel>(ExampleDomain.classes);

    // For now, simulate that we have no real data (empty state)
    // In a real app, this would come from a provider or service
    final List<ClassModel> realClasses = []; // Simulating empty real data

    return PreviewExampleWrapper<ClassModel>(
      realData: realClasses,
      exampleData: exampleClasses,
      isLoading: false, // Set to true if loading from service
      builder: (context, classes, isExample) {
        if (classes.isEmpty) {
          return Center(
            child: Column(
              mainAxisAlignment: MainAxisAlignment.center,
              children: [
                const Icon(Icons.class_outlined, size: 48, color: Colors.grey),
                const SizedBox(height: 16),
                Text(
                  isExample
                      ? 'No example classes available'
                      : 'No classes found',
                  style: Theme.of(context).textTheme.titleMedium,
                ),
                const SizedBox(height: 8),
                Text(
                  isExample
                      ? 'Example data could not be loaded'
                      : 'Create your first class to get started',
                  style: Theme.of(context).textTheme.bodyMedium?.copyWith(
                        color: Theme.of(context).colorScheme.onSurfaceVariant,
                      ),
                ),
                const SizedBox(height: 16),
                ElevatedButton(
                  onPressed: () {
                    // TODO: Navigate to add class screen
                    ScaffoldMessenger.of(context).showSnackBar(
                      const SnackBar(
                        content: Text('Add class feature coming soon'),
                      ),
                    );
                  },
                  child: Text(
                      isExample ? 'Create Real Class' : 'Create First Class'),
                ),
              ],
            ),
          );
        }

        return ResponsiveContainer(
          child: Column(
            children: [
              // Class Statistics
              Container(
                padding: const EdgeInsets.all(16),
                child: Row(
                  children: [
                    Expanded(
                      child: Card(
                        child: Padding(
                          padding: const EdgeInsets.all(16),
                          child: Column(
                            crossAxisAlignment: CrossAxisAlignment.start,
                            children: [
                              Row(
                                children: [
                                  Text(
                                    'Total Classes',
                                    style: theme.textTheme.bodySmall?.copyWith(
                                      color: theme.colorScheme.onSurfaceVariant,
                                    ),
                                  ),
                                  if (isExample) ...[
                                    const SizedBox(width: 8),
                                    const ExampleBadge.compact(),
                                  ],
                                ],
                              ),
                              const SizedBox(height: 4),
                              Text(
                                '${classes.length}',
                                style: theme.textTheme.headlineMedium?.copyWith(
                                  fontWeight: FontWeight.bold,
                                  color: theme.colorScheme.primary,
                                ),
                              ),
                            ],
                          ),
                        ),
                      ),
                    ),
                    const SizedBox(width: 12),
                    Expanded(
                      child: Card(
                        child: Padding(
                          padding: const EdgeInsets.all(16),
                          child: Column(
                            crossAxisAlignment: CrossAxisAlignment.start,
                            children: [
                              Row(
                                children: [
                                  Text(
                                    'Total Students',
                                    style: theme.textTheme.bodySmall?.copyWith(
                                      color: theme.colorScheme.onSurfaceVariant,
                                    ),
                                  ),
                                  if (isExample) ...[
                                    const SizedBox(width: 8),
                                    const ExampleBadge.compact(),
                                  ],
                                ],
                              ),
                              const SizedBox(height: 4),
                              Text(
                                '${classes.fold(0, (sum, c) => sum + c.studentIds.length)}',
                                style: theme.textTheme.headlineMedium?.copyWith(
                                  fontWeight: FontWeight.bold,
                                  color: theme.colorScheme.secondary,
                                ),
                              ),
                            ],
                          ),
                        ),
                      ),
                    ),
                  ],
                ),
              ),
              // Classes List
              Expanded(
                child: ListView.builder(
                  padding: const EdgeInsets.symmetric(horizontal: 16),
                  itemCount: classes.length,
                  itemBuilder: (context, index) {
                    final classModel = classes[index];
                    return _buildClassCard(classModel, isExample: isExample);
                  },
                ),
              ),
            ],
          ),
        );
      },
      onExampleTap: () {
        showDialog(
          context: context,
          builder: (context) => AlertDialog(
            icon: const Icon(Icons.info_outline),
            title: const Text('Example Classes'),
            content: const Text(
              'These are example classes to show you how the app works. '
              'Create your own classes to replace these examples.',
            ),
            actions: [
              TextButton(
                onPressed: () => Navigator.of(context).pop(),
                child: const Text('Got it'),
              ),
              FilledButton(
                onPressed: () {
                  Navigator.of(context).pop();
                  // TODO: Navigate to add class screen
                  ScaffoldMessenger.of(context).showSnackBar(
                    const SnackBar(
                      content: Text('Add class feature coming soon'),
                    ),
                  );
                },
                child: const Text('Create Class'),
              ),
            ],
          ),
        );
      },
    );
  }

  Widget _buildClassCard(ClassModel classModel, {bool isExample = false}) {
    final theme = Theme.of(context);

    // Define colors for different subjects
    final subjectColors = {
      'Mathematics': Colors.blue,
      'Science': Colors.green,
      'Physics': Colors.purple,
      'Chemistry': Colors.orange,
      'English': Colors.red,
      'History': Colors.brown,
    };

    final subjectColor = subjectColors[classModel.subject] ?? Colors.grey;

    return Card(
      margin: const EdgeInsets.only(bottom: 12),
      child: InkWell(
        onTap: isExample
            ? () {
                showDialog(
                  context: context,
                  builder: (context) => AlertDialog(
                    icon: const Icon(Icons.info_outline),
                    title: const Text('Example Class'),
                    content: Text(
                      'This is example class "${classModel.name}" to show you how the app works. '
                      'Create your own classes to replace these examples.',
                    ),
                    actions: [
                      TextButton(
                        onPressed: () => Navigator.of(context).pop(),
                        child: const Text('Got it'),
                      ),
                      FilledButton(
                        onPressed: () {
                          Navigator.of(context).pop();
                          // TODO: Navigate to add class screen
                          ScaffoldMessenger.of(context).showSnackBar(
                            const SnackBar(
                              content: Text('Create class feature coming soon'),
                            ),
                          );
                        },
                        child: const Text('Create Class'),
                      ),
                    ],
                  ),
                );
              }
            : () {
                ScaffoldMessenger.of(context).showSnackBar(
                  SnackBar(
                    content: Text('Opening ${classModel.name}'),
                  ),
                );
              },
        borderRadius: BorderRadius.circular(12),
        child: Padding(
          padding: const EdgeInsets.all(16),
          child: Row(
            children: [
              // Class Icon
              Container(
                width: 56,
                height: 56,
                decoration: BoxDecoration(
                  color: subjectColor.withValues(alpha: 0.1),
                  borderRadius: BorderRadius.circular(12),
                ),
                child: Icon(
                  Icons.class_,
                  color: subjectColor,
                  size: 28,
                ),
              ),
              const SizedBox(width: 16),
              // Class Info
              Expanded(
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Row(
                      children: [
                        Expanded(
                          child: Text(
                            classModel.name,
                            style: theme.textTheme.titleMedium?.copyWith(
                              fontWeight: FontWeight.bold,
                            ),
                          ),
                        ),
                        if (isExample) const ExampleBadge.compact(),
                      ],
                    ),
                    const SizedBox(height: 4),
                    Text(
                      '${classModel.subject} • ${classModel.gradeLevel}',
                      style: theme.textTheme.bodyMedium?.copyWith(
                        color: theme.colorScheme.onSurfaceVariant,
                      ),
                    ),
                    const SizedBox(height: 4),
                    Row(
                      children: [
                        Icon(
                          Icons.people_outline,
                          size: 16,
                          color: theme.colorScheme.onSurfaceVariant,
                        ),
                        const SizedBox(width: 4),
                        Text(
                          '${classModel.studentIds.length} students',
                          style: theme.textTheme.bodySmall,
                        ),
                        const SizedBox(width: 12),
                        Icon(
                          Icons.location_on_outlined,
                          size: 16,
                          color: theme.colorScheme.onSurfaceVariant,
                        ),
                        const SizedBox(width: 4),
                        Text(
                          classModel.room ?? 'No room',
                          style: theme.textTheme.bodySmall,
                        ),
                      ],
                    ),
                    const SizedBox(height: 4),
                    Text(
                      classModel.schedule ?? 'No schedule',
                      style: theme.textTheme.bodySmall?.copyWith(
                        color: theme.colorScheme.primary,
                        fontWeight: FontWeight.w500,
                      ),
                    ),
                  ],
                ),
              ),
              // Arrow
              const Icon(Icons.arrow_forward_ios, size: 16),
            ],
          ),
        ),
      ),
    );
  }

  Widget _buildPerformanceView() {
    final theme = Theme.of(context);

    // Mock performance data
    final performanceData = [
      {
        'grade': 'Grade 9',
        'avgGPA': 3.2,
        'students': 45,
        'topPerformers': 12,
        'needsSupport': 8,
        'attendance': 92,
      },
      {
        'grade': 'Grade 10',
        'avgGPA': 3.4,
        'students': 52,
        'topPerformers': 18,
        'needsSupport': 5,
        'attendance': 94,
      },
      {
        'grade': 'Grade 11',
        'avgGPA': 3.5,
        'students': 48,
        'topPerformers': 20,
        'needsSupport': 4,
        'attendance': 95,
      },
      {
        'grade': 'Grade 12',
        'avgGPA': 3.6,
        'students': 40,
        'topPerformers': 22,
        'needsSupport': 3,
        'attendance': 96,
      },
    ];

    return ResponsiveContainer(
      child: SingleChildScrollView(
        padding: const EdgeInsets.all(16),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            // Overall Statistics
            Text(
              'Overall Performance',
              style: theme.textTheme.titleLarge?.copyWith(
                fontWeight: FontWeight.bold,
              ),
            ),
            const SizedBox(height: 16),
            Row(
              children: [
                Expanded(
                  child: Card(
                    child: Padding(
                      padding: const EdgeInsets.all(16),
                      child: Column(
                        children: [
                          Icon(
                            Icons.school,
                            size: 32,
                            color: theme.colorScheme.primary,
                          ),
                          const SizedBox(height: 8),
                          Text(
                            '3.43',
                            style: theme.textTheme.headlineMedium?.copyWith(
                              fontWeight: FontWeight.bold,
                              color: Colors.blue,
                            ),
                          ),
                          Text(
                            'Avg GPA',
                            style: theme.textTheme.bodySmall?.copyWith(
                              color: theme.colorScheme.onSurfaceVariant,
                            ),
                          ),
                        ],
                      ),
                    ),
                  ),
                ),
                const SizedBox(width: 12),
                Expanded(
                  child: Card(
                    child: Padding(
                      padding: const EdgeInsets.all(16),
                      child: Column(
                        children: [
                          Icon(
                            Icons.event_available,
                            size: 32,
                            color: theme.colorScheme.secondary,
                          ),
                          const SizedBox(height: 8),
                          Text(
                            '94.25%',
                            style: theme.textTheme.headlineMedium?.copyWith(
                              fontWeight: FontWeight.bold,
                              color: Colors.green,
                            ),
                          ),
                          Text(
                            'Attendance',
                            style: theme.textTheme.bodySmall?.copyWith(
                              color: theme.colorScheme.onSurfaceVariant,
                            ),
                          ),
                        ],
                      ),
                    ),
                  ),
                ),
              ],
            ),
            const SizedBox(height: 24),
            // Grade-wise Performance
            Text(
              'Performance by Grade',
              style: theme.textTheme.titleLarge?.copyWith(
                fontWeight: FontWeight.bold,
              ),
            ),
            const SizedBox(height: 16),
            ...performanceData.map((data) {
              return Card(
                margin: const EdgeInsets.only(bottom: 12),
                child: Padding(
                  padding: const EdgeInsets.all(16),
                  child: Column(
                    children: [
                      Row(
                        mainAxisAlignment: MainAxisAlignment.spaceBetween,
                        children: [
                          Text(
                            data['grade'] as String,
                            style: theme.textTheme.titleMedium?.copyWith(
                              fontWeight: FontWeight.bold,
                            ),
                          ),
                          Container(
                            padding: const EdgeInsets.symmetric(
                              horizontal: 12,
                              vertical: 4,
                            ),
                            decoration: BoxDecoration(
                              color: _getGPAColor(data['avgGPA'] as double)
                                  .withValues(alpha: 0.1),
                              borderRadius: BorderRadius.circular(12),
                            ),
                            child: Text(
                              'GPA: ${data['avgGPA']}',
                              style: TextStyle(
                                color: _getGPAColor(data['avgGPA'] as double),
                                fontWeight: FontWeight.bold,
                              ),
                            ),
                          ),
                        ],
                      ),
                      const SizedBox(height: 16),
                      Row(
                        children: [
                          Expanded(
                            child: _buildPerformanceMetric(
                              'Students',
                              '${data['students']}',
                              Icons.people,
                              theme.colorScheme.primary,
                            ),
                          ),
                          Expanded(
                            child: _buildPerformanceMetric(
                              'Top Performers',
                              '${data['topPerformers']}',
                              Icons.star,
                              Colors.amber,
                            ),
                          ),
                          Expanded(
                            child: _buildPerformanceMetric(
                              'Need Support',
                              '${data['needsSupport']}',
                              Icons.support,
                              Colors.orange,
                            ),
                          ),
                          Expanded(
                            child: _buildPerformanceMetric(
                              'Attendance',
                              '${data['attendance']}%',
                              Icons.check_circle,
                              Colors.green,
                            ),
                          ),
                        ],
                      ),
                    ],
                  ),
                ),
              );
            }),
            const SizedBox(height: 24),
            // Top Performers
            Text(
              'Top Performers',
              style: theme.textTheme.titleLarge?.copyWith(
                fontWeight: FontWeight.bold,
              ),
            ),
            const SizedBox(height: 16),
            ..._buildTopPerformers(theme),
          ],
        ),
      ),
    );
  }

  Widget _buildPerformanceMetric(
    String label,
    String value,
    IconData icon,
    Color color,
  ) {
    return Column(
      children: [
        Icon(icon, color: color, size: 20),
        const SizedBox(height: 4),
        Text(
          value,
          style: TextStyle(
            fontWeight: FontWeight.bold,
            color: color,
          ),
        ),
        Text(
          label,
          style: const TextStyle(
            fontSize: 10,
            color: Colors.grey,
          ),
        ),
      ],
    );
  }

  List<Widget> _buildTopPerformers(ThemeData theme) {
    final topPerformers = [
      {'name': 'Sarah Johnson', 'grade': 12, 'gpa': 4.0, 'rank': 1},
      {'name': 'Michael Chen', 'grade': 11, 'gpa': 3.98, 'rank': 2},
      {'name': 'Emma Williams', 'grade': 12, 'gpa': 3.95, 'rank': 3},
      {'name': 'David Kumar', 'grade': 10, 'gpa': 3.92, 'rank': 4},
      {'name': 'Jessica Martinez', 'grade': 11, 'gpa': 3.90, 'rank': 5},
    ];

    return topPerformers.map((student) {
      return Card(
        margin: const EdgeInsets.only(bottom: 8),
        child: ListTile(
          leading: CircleAvatar(
            backgroundColor: theme.colorScheme.primaryContainer,
            child: Text(
              '${student['rank']}',
              style: TextStyle(
                color: theme.colorScheme.onPrimaryContainer,
                fontWeight: FontWeight.bold,
              ),
            ),
          ),
          title: Text(student['name'] as String),
          subtitle: Text('Grade ${student['grade']} • GPA: ${student['gpa']}'),
          trailing: const Icon(
            Icons.star,
            color: Colors.amber,
          ),
        ),
      );
    }).toList();
  }

  Widget _buildReportsView() {
    final theme = Theme.of(context);

    // Mock report data
    final reports = [
      {
        'title': 'Monthly Progress Report',
        'type': 'Progress',
        'date': DateTime.now().subtract(const Duration(days: 2)),
        'status': 'Completed',
        'icon': Icons.trending_up,
        'color': Colors.green,
      },
      {
        'title': 'Attendance Summary',
        'type': 'Attendance',
        'date': DateTime.now().subtract(const Duration(days: 5)),
        'status': 'Completed',
        'icon': Icons.event_available,
        'color': Colors.blue,
      },
      {
        'title': 'Grade Distribution Analysis',
        'type': 'Academic',
        'date': DateTime.now().subtract(const Duration(days: 7)),
        'status': 'Completed',
        'icon': Icons.bar_chart,
        'color': Colors.purple,
      },
      {
        'title': 'Student Performance Report',
        'type': 'Performance',
        'date': DateTime.now().subtract(const Duration(days: 10)),
        'status': 'Completed',
        'icon': Icons.assessment,
        'color': Colors.orange,
      },
      {
        'title': 'Parent Communication Log',
        'type': 'Communication',
        'date': DateTime.now().subtract(const Duration(days: 15)),
        'status': 'Completed',
        'icon': Icons.message,
        'color': Colors.teal,
      },
    ];

    return ResponsiveContainer(
      child: Column(
        children: [
          // Report Actions
          Container(
            padding: const EdgeInsets.all(16),
            child: Row(
              children: [
                Expanded(
                  child: FilledButton.icon(
                    onPressed: () {
                      _showGenerateReportDialog(context);
                    },
                    icon: const Icon(Icons.add),
                    label: const Text('Generate Report'),
                  ),
                ),
                const SizedBox(width: 12),
                Expanded(
                  child: OutlinedButton.icon(
                    onPressed: () {
                      ScaffoldMessenger.of(context).showSnackBar(
                        const SnackBar(
                          content: Text('Opening report templates...'),
                        ),
                      );
                    },
                    icon: const Icon(Icons.folder_open),
                    label: const Text('Templates'),
                  ),
                ),
              ],
            ),
          ),
          // Recent Reports
          Padding(
            padding: const EdgeInsets.symmetric(horizontal: 16),
            child: Row(
              mainAxisAlignment: MainAxisAlignment.spaceBetween,
              children: [
                Text(
                  'Recent Reports',
                  style: theme.textTheme.titleLarge?.copyWith(
                    fontWeight: FontWeight.bold,
                  ),
                ),
                TextButton(
                  onPressed: () {},
                  child: const Text('View All'),
                ),
              ],
            ),
          ),
          // Reports List
          Expanded(
            child: ListView.builder(
              padding: const EdgeInsets.symmetric(horizontal: 16),
              itemCount: reports.length,
              itemBuilder: (context, index) {
                final report = reports[index];
                return Card(
                  margin: const EdgeInsets.only(bottom: 12),
                  child: InkWell(
                    onTap: () {
                      _showReportDetails(context, report);
                    },
                    borderRadius: BorderRadius.circular(12),
                    child: Padding(
                      padding: const EdgeInsets.all(16),
                      child: Row(
                        children: [
                          // Report Icon
                          Container(
                            width: 48,
                            height: 48,
                            decoration: BoxDecoration(
                              color: (report['color'] as Color)
                                  .withValues(alpha: 0.1),
                              borderRadius: BorderRadius.circular(12),
                            ),
                            child: Icon(
                              report['icon'] as IconData,
                              color: report['color'] as Color,
                            ),
                          ),
                          const SizedBox(width: 16),
                          // Report Info
                          Expanded(
                            child: Column(
                              crossAxisAlignment: CrossAxisAlignment.start,
                              children: [
                                Text(
                                  report['title'] as String,
                                  style: theme.textTheme.titleMedium?.copyWith(
                                    fontWeight: FontWeight.w600,
                                  ),
                                ),
                                const SizedBox(height: 4),
                                Row(
                                  children: [
                                    Container(
                                      padding: const EdgeInsets.symmetric(
                                        horizontal: 8,
                                        vertical: 2,
                                      ),
                                      decoration: BoxDecoration(
                                        color:
                                            theme.colorScheme.primaryContainer,
                                        borderRadius: BorderRadius.circular(12),
                                      ),
                                      child: Text(
                                        report['type'] as String,
                                        style:
                                            theme.textTheme.bodySmall?.copyWith(
                                          color: theme
                                              .colorScheme.onPrimaryContainer,
                                          fontWeight: FontWeight.w500,
                                        ),
                                      ),
                                    ),
                                    const SizedBox(width: 8),
                                    Text(
                                      _formatDate(report['date'] as DateTime),
                                      style:
                                          theme.textTheme.bodySmall?.copyWith(
                                        color:
                                            theme.colorScheme.onSurfaceVariant,
                                      ),
                                    ),
                                  ],
                                ),
                              ],
                            ),
                          ),
                          // Actions
                          PopupMenuButton<String>(
                            onSelected: (value) {
                              switch (value) {
                                case 'download':
                                  ScaffoldMessenger.of(context).showSnackBar(
                                    SnackBar(
                                      content: Text(
                                          'Downloading ${report['title']}...'),
                                    ),
                                  );
                                  break;
                                case 'share':
                                  ScaffoldMessenger.of(context).showSnackBar(
                                    SnackBar(
                                      content:
                                          Text('Sharing ${report['title']}...'),
                                    ),
                                  );
                                  break;
                                case 'delete':
                                  ScaffoldMessenger.of(context).showSnackBar(
                                    SnackBar(
                                      content: Text(
                                          'Deleting ${report['title']}...'),
                                    ),
                                  );
                                  break;
                              }
                            },
                            itemBuilder: (context) => [
                              const PopupMenuItem(
                                value: 'download',
                                child: Row(
                                  children: [
                                    Icon(Icons.download, size: 20),
                                    SizedBox(width: 8),
                                    Text('Download'),
                                  ],
                                ),
                              ),
                              const PopupMenuItem(
                                value: 'share',
                                child: Row(
                                  children: [
                                    Icon(Icons.share, size: 20),
                                    SizedBox(width: 8),
                                    Text('Share'),
                                  ],
                                ),
                              ),
                              const PopupMenuItem(
                                value: 'delete',
                                child: Row(
                                  children: [
                                    Icon(Icons.delete,
                                        size: 20, color: Colors.red),
                                    SizedBox(width: 8),
                                    Text('Delete',
                                        style: TextStyle(color: Colors.red)),
                                  ],
                                ),
                              ),
                            ],
                            child: const Icon(Icons.more_vert),
                          ),
                        ],
                      ),
                    ),
                  ),
                );
              },
            ),
          ),
        ],
      ),
    );
  }

  String _formatDate(DateTime date) {
    final now = DateTime.now();
    final difference = now.difference(date);

    if (difference.inDays == 0) {
      return 'Today';
    } else if (difference.inDays == 1) {
      return 'Yesterday';
    } else if (difference.inDays < 7) {
      return '${difference.inDays} days ago';
    } else {
      return '${date.day}/${date.month}/${date.year}';
    }
  }

  void _showGenerateReportDialog(BuildContext context) {
    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        title: const Text('Generate Report'),
        content: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            ListTile(
              leading: const Icon(Icons.trending_up),
              title: const Text('Progress Report'),
              subtitle: const Text('Student progress over time'),
              onTap: () {
                Navigator.pop(context);
                ScaffoldMessenger.of(context).showSnackBar(
                  const SnackBar(
                    content: Text('Generating progress report...'),
                  ),
                );
              },
            ),
            ListTile(
              leading: const Icon(Icons.event_available),
              title: const Text('Attendance Report'),
              subtitle: const Text('Attendance patterns and trends'),
              onTap: () {
                Navigator.pop(context);
                ScaffoldMessenger.of(context).showSnackBar(
                  const SnackBar(
                    content: Text('Generating attendance report...'),
                  ),
                );
              },
            ),
            ListTile(
              leading: const Icon(Icons.assessment),
              title: const Text('Performance Report'),
              subtitle: const Text('Academic performance analysis'),
              onTap: () {
                Navigator.pop(context);
                ScaffoldMessenger.of(context).showSnackBar(
                  const SnackBar(
                    content: Text('Generating performance report...'),
                  ),
                );
              },
            ),
          ],
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(context),
            child: const Text('Cancel'),
          ),
        ],
      ),
    );
  }

  void _showReportDetails(BuildContext context, Map<String, dynamic> report) {
    showModalBottomSheet(
      context: context,
      isScrollControlled: true,
      backgroundColor: Colors.transparent,
      builder: (context) => Container(
        height: MediaQuery.of(context).size.height * 0.7,
        decoration: BoxDecoration(
          color: Theme.of(context).colorScheme.surface,
          borderRadius: const BorderRadius.vertical(top: Radius.circular(20)),
        ),
        child: Column(
          children: [
            Center(
              child: Container(
                margin: const EdgeInsets.only(top: 12, bottom: 20),
                width: 40,
                height: 4,
                decoration: BoxDecoration(
                  color: Colors.grey.withValues(alpha: 0.3),
                  borderRadius: BorderRadius.circular(2),
                ),
              ),
            ),
            Padding(
              padding: const EdgeInsets.symmetric(horizontal: 24),
              child: Row(
                children: [
                  Container(
                    width: 48,
                    height: 48,
                    decoration: BoxDecoration(
                      color: (report['color'] as Color).withValues(alpha: 0.1),
                      borderRadius: BorderRadius.circular(12),
                    ),
                    child: Icon(
                      report['icon'] as IconData,
                      color: report['color'] as Color,
                    ),
                  ),
                  const SizedBox(width: 16),
                  Expanded(
                    child: Column(
                      crossAxisAlignment: CrossAxisAlignment.start,
                      children: [
                        Text(
                          report['title'] as String,
                          style:
                              Theme.of(context).textTheme.titleLarge?.copyWith(
                                    fontWeight: FontWeight.bold,
                                  ),
                        ),
                        Text(
                          'Generated on ${_formatDate(report['date'] as DateTime)}',
                          style:
                              Theme.of(context).textTheme.bodyMedium?.copyWith(
                                    color: Theme.of(context)
                                        .colorScheme
                                        .onSurfaceVariant,
                                  ),
                        ),
                      ],
                    ),
                  ),
                ],
              ),
            ),
            const SizedBox(height: 24),
            Expanded(
              child: SingleChildScrollView(
                padding: const EdgeInsets.symmetric(horizontal: 24),
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Text(
                      'Report Summary',
                      style: Theme.of(context).textTheme.titleMedium?.copyWith(
                            fontWeight: FontWeight.bold,
                          ),
                    ),
                    const SizedBox(height: 12),
                    Text(
                      'This is a mock report summary. In a real application, this would contain detailed analytics and insights based on actual student data.',
                      style: Theme.of(context).textTheme.bodyMedium,
                    ),
                    const SizedBox(height: 24),
                    Row(
                      mainAxisAlignment: MainAxisAlignment.spaceEvenly,
                      children: [
                        FilledButton.icon(
                          onPressed: () {
                            Navigator.pop(context);
                            ScaffoldMessenger.of(context).showSnackBar(
                              const SnackBar(
                                content: Text('Downloading report...'),
                              ),
                            );
                          },
                          icon: const Icon(Icons.download),
                          label: const Text('Download'),
                        ),
                        OutlinedButton.icon(
                          onPressed: () {
                            Navigator.pop(context);
                            ScaffoldMessenger.of(context).showSnackBar(
                              const SnackBar(
                                content: Text('Sharing report...'),
                              ),
                            );
                          },
                          icon: const Icon(Icons.share),
                          label: const Text('Share'),
                        ),
                      ],
                    ),
                  ],
                ),
              ),
            ),
          ],
        ),
      ),
    );
  }

  List<Student> _filterStudents(List<Student> students) {
    var filtered = students;

    // Filter by search query
    if (_searchController.text.isNotEmpty) {
      final query = _searchController.text.toLowerCase();
      filtered = filtered.where((student) {
        return student.displayName.toLowerCase().contains(query) ||
            student.email.toLowerCase().contains(query) ||
            student.firstName.toLowerCase().contains(query) ||
            student.lastName.toLowerCase().contains(query);
      }).toList();
    }

    // Filter by grade
    if (_selectedGrade != 'All') {
      final gradeLevel = int.parse(_selectedGrade);
      filtered = filtered
          .where((student) => student.gradeLevel == gradeLevel)
          .toList();
    }

    // Filter by status
    if (_selectedFilter != 'All') {
      switch (_selectedFilter) {
        case 'Active':
          filtered = filtered.where((student) => student.isActive).toList();
          break;
        case 'Inactive':
          filtered = filtered.where((student) => !student.isActive).toList();
          break;
        case 'Recent':
          final sevenDaysAgo = DateTime.now().subtract(const Duration(days: 7));
          filtered = filtered
              .where((student) => student.createdAt.isAfter(sevenDaysAgo))
              .toList();
          break;
      }
    }

    return filtered;
  }

  Widget _buildStudentCard(Student student, {bool isExample = false}) {
    final theme = Theme.of(context);
    final isActive = student.isActive;

    return Card(
      margin: const EdgeInsets.symmetric(horizontal: 16, vertical: 4),
      child: InkWell(
        onTap: isExample
            ? () {
                showDialog(
                  context: context,
                  builder: (context) => AlertDialog(
                    icon: const Icon(Icons.info_outline),
                    title: const Text('Example Student'),
                    content: Text(
                      'This is example student "${student.displayName}" to show you how the app works. '
                      'Add your own students to replace these examples.',
                    ),
                    actions: [
                      TextButton(
                        onPressed: () => Navigator.of(context).pop(),
                        child: const Text('Got it'),
                      ),
                      FilledButton(
                        onPressed: () {
                          Navigator.of(context).pop();
                          _showAddStudentSheet(context);
                        },
                        child: const Text('Add Student'),
                      ),
                    ],
                  ),
                );
              }
            : () => _showStudentDetails(student),
        borderRadius: BorderRadius.circular(12),
        child: Padding(
          padding: const EdgeInsets.all(16),
          child: Row(
            children: [
              // Student Avatar
              CircleAvatar(
                backgroundColor: isActive
                    ? theme.colorScheme.primary.withValues(alpha: 0.1)
                    : Colors.grey.withValues(alpha: 0.1),
                child: student.photoURL != null
                    ? ClipOval(
                        child: Image.network(
                          student.photoURL!,
                          width: 40,
                          height: 40,
                          fit: BoxFit.cover,
                          errorBuilder: (context, error, stackTrace) => Icon(
                            Icons.school,
                            color: isActive
                                ? theme.colorScheme.primary
                                : Colors.grey,
                          ),
                        ),
                      )
                    : Icon(
                        Icons.school,
                        color:
                            isActive ? theme.colorScheme.primary : Colors.grey,
                      ),
              ),
              const SizedBox(width: 12),
              // Student Info
              Expanded(
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    // Name and Grade
                    Row(
                      children: [
                        Expanded(
                          child: Text(
                            student.displayName,
                            style: theme.textTheme.titleMedium?.copyWith(
                              fontWeight: FontWeight.w600,
                              color: isActive ? null : Colors.grey,
                            ),
                            overflow: TextOverflow.ellipsis,
                          ),
                        ),
                        Container(
                          padding: const EdgeInsets.symmetric(
                              horizontal: 8, vertical: 2),
                          decoration: BoxDecoration(
                            color: theme.colorScheme.primary
                                .withValues(alpha: 0.1),
                            borderRadius: BorderRadius.circular(12),
                          ),
                          child: Text(
                            'Grade ${student.gradeLevel}',
                            style: theme.textTheme.bodySmall?.copyWith(
                              color: theme.colorScheme.primary,
                              fontWeight: FontWeight.w600,
                            ),
                          ),
                        ),
                      ],
                    ),
                    const SizedBox(height: 4),
                    // Email
                    Text(
                      student.email,
                      style: theme.textTheme.bodyMedium?.copyWith(
                        color: theme.colorScheme.onSurfaceVariant,
                      ),
                      overflow: TextOverflow.ellipsis,
                    ),
                    const SizedBox(height: 2),
                    // Classes count and status
                    Row(
                      children: [
                        Icon(
                          Icons.class_outlined,
                          size: 16,
                          color: theme.colorScheme.onSurfaceVariant,
                        ),
                        const SizedBox(width: 4),
                        Text(
                          '${student.classCount} classes',
                          style: theme.textTheme.bodySmall?.copyWith(
                            color: theme.colorScheme.onSurfaceVariant,
                          ),
                        ),
                        const SizedBox(width: 12),
                        Container(
                          width: 8,
                          height: 8,
                          decoration: BoxDecoration(
                            color: isActive ? Colors.green : Colors.grey,
                            shape: BoxShape.circle,
                          ),
                        ),
                        const SizedBox(width: 4),
                        Text(
                          isActive ? 'Active' : 'Inactive',
                          style: theme.textTheme.bodySmall?.copyWith(
                            color: theme.colorScheme.onSurfaceVariant,
                          ),
                        ),
                      ],
                    ),
                  ],
                ),
              ),
              const SizedBox(width: 8),
              // Actions or Example Badge
              if (isExample)
                const ExampleBadge.compact()
              else
                PopupMenuButton<String>(
                  onSelected: (value) => _handleStudentAction(value, student),
                  itemBuilder: (context) => [
                    const PopupMenuItem(
                        value: 'view', child: Text('View Details')),
                    const PopupMenuItem(
                        value: 'edit', child: Text('Edit Student')),
                    const PopupMenuItem(
                        value: 'message', child: Text('Send Message')),
                    const PopupMenuItem(
                        value: 'parent', child: Text('Contact Parent')),
                    PopupMenuItem(
                      value: isActive ? 'deactivate' : 'activate',
                      child: Text(isActive ? 'Deactivate' : 'Activate'),
                    ),
                  ],
                  child: const Icon(Icons.more_vert),
                ),
            ],
          ),
        ),
      ),
    );
  }

  Color _getGPAColor(double gpa) {
    if (gpa >= 3.5) return Colors.green;
    if (gpa >= 3.0) return Colors.blue;
    if (gpa >= 2.5) return Colors.orange;
    return Colors.red;
  }

  void _showStudentDetails(Student student) {
    showModalBottomSheet(
      context: context,
      isScrollControlled: true,
      backgroundColor: Colors.transparent,
      builder: (context) => StudentDetailSheet(student: student),
    );
  }

  void _handleStudentAction(String action, Student student) {
    switch (action) {
      case 'view':
        _showStudentDetails(student);
        break;
      case 'edit':
        _showEditStudentSheet(student);
        break;
      case 'message':
        _showMessageStudent(student);
        break;
      case 'parent':
        _showContactParent(student);
        break;
      case 'activate':
        _toggleStudentStatus(student, true);
        break;
      case 'deactivate':
        _toggleStudentStatus(student, false);
        break;
    }
  }

  void _showEditStudentSheet(Student student) {
    showModalBottomSheet(
      context: context,
      isScrollControlled: true,
      backgroundColor: Colors.transparent,
      builder: (context) => EditStudentSheet(student: student),
    );
  }

  void _showMessageStudent(Student student) {
    // Navigate to messaging screen with student pre-selected
    ScaffoldMessenger.of(context).showSnackBar(
      SnackBar(
        content: Text('Opening message to ${student.displayName}'),
        duration: const Duration(seconds: 2),
      ),
    );
  }

  void _showContactParent(Student student) {
    if (student.parentEmail != null) {
      showDialog(
        context: context,
        builder: (context) => AlertDialog(
          title: const Text('Contact Parent'),
          content: Column(
            mainAxisSize: MainAxisSize.min,
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Text('Parent Email: ${student.parentEmail}'),
              const SizedBox(height: 16),
              const Text('What would you like to do?'),
            ],
          ),
          actions: [
            TextButton(
              onPressed: () => Navigator.pop(context),
              child: const Text('Cancel'),
            ),
            FilledButton(
              onPressed: () {
                Navigator.pop(context);
                ScaffoldMessenger.of(context).showSnackBar(
                  SnackBar(
                    content: Text('Opening email to ${student.parentEmail}'),
                  ),
                );
              },
              child: const Text('Send Email'),
            ),
          ],
        ),
      );
    } else {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(
          content: Text('No parent email available for this student'),
        ),
      );
    }
  }

  void _toggleStudentStatus(Student student, bool isActive) async {
    try {
      if (isActive) {
        await _studentService.reactivateStudent(student.id);
        if (mounted) {
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(
              content: Text('${student.displayName} has been activated'),
            ),
          );
        }
      } else {
        await _studentService.deactivateStudent(student.id);
        if (mounted) {
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(
              content: Text('${student.displayName} has been deactivated'),
            ),
          );
        }
      }
    } catch (e) {
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('Error updating student status: $e'),
            backgroundColor: Colors.red,
          ),
        );
      }
    }
  }

  void _showAddStudentSheet(BuildContext context) {
    showModalBottomSheet(
      context: context,
      isScrollControlled: true,
      backgroundColor: Colors.transparent,
      builder: (context) => const AddStudentSheet(),
    );
  }
}

// Student Detail Sheet
class StudentDetailSheet extends StatelessWidget {
  final Student student;

  const StudentDetailSheet({
    super.key,
    required this.student,
  });

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);

    return Container(
      decoration: BoxDecoration(
        color: theme.colorScheme.surface,
        borderRadius: const BorderRadius.vertical(top: Radius.circular(20)),
      ),
      child: DraggableScrollableSheet(
        initialChildSize: 0.7,
        minChildSize: 0.5,
        maxChildSize: 0.95,
        expand: false,
        builder: (context, scrollController) {
          return CustomScrollView(
            controller: scrollController,
            slivers: [
              // Handle Bar
              SliverToBoxAdapter(
                child: Center(
                  child: Container(
                    margin: const EdgeInsets.only(top: 12, bottom: 20),
                    width: 40,
                    height: 4,
                    decoration: BoxDecoration(
                      color: theme.colorScheme.onSurfaceVariant
                          .withValues(alpha: 0.3),
                      borderRadius: BorderRadius.circular(2),
                    ),
                  ),
                ),
              ),
              // Content
              SliverPadding(
                padding: const EdgeInsets.symmetric(horizontal: 24),
                sliver: SliverList(
                  delegate: SliverChildListDelegate([
                    // Header
                    Row(
                      children: [
                        CircleAvatar(
                          radius: 32,
                          backgroundColor: theme.colorScheme.primaryContainer,
                          child: student.photoURL != null
                              ? ClipOval(
                                  child: Image.network(
                                    student.photoURL!,
                                    width: 64,
                                    height: 64,
                                    fit: BoxFit.cover,
                                    errorBuilder:
                                        (context, error, stackTrace) => Text(
                                      student.displayName
                                          .split(' ')
                                          .map((n) => n[0])
                                          .join(),
                                      style: TextStyle(
                                        color: theme
                                            .colorScheme.onPrimaryContainer,
                                        fontWeight: FontWeight.bold,
                                        fontSize: 20,
                                      ),
                                    ),
                                  ),
                                )
                              : Text(
                                  student.displayName
                                      .split(' ')
                                      .map((n) => n[0])
                                      .join(),
                                  style: TextStyle(
                                    color: theme.colorScheme.onPrimaryContainer,
                                    fontWeight: FontWeight.bold,
                                    fontSize: 20,
                                  ),
                                ),
                        ),
                        const SizedBox(width: 16),
                        Expanded(
                          child: Column(
                            crossAxisAlignment: CrossAxisAlignment.start,
                            children: [
                              Text(
                                student.displayName,
                                style: theme.textTheme.headlineSmall?.copyWith(
                                  fontWeight: FontWeight.bold,
                                ),
                              ),
                              Text(
                                'Grade ${student.gradeLevel} Student',
                                style: theme.textTheme.bodyLarge?.copyWith(
                                  color: theme.colorScheme.onSurfaceVariant,
                                ),
                              ),
                            ],
                          ),
                        ),
                      ],
                    ),
                    const SizedBox(height: 24),

                    // Contact Information
                    Text(
                      'Contact Information',
                      style: theme.textTheme.titleMedium?.copyWith(
                        fontWeight: FontWeight.bold,
                      ),
                    ),
                    const SizedBox(height: 12),
                    _buildContactRow(
                        Icons.email, 'Student Email', student.email),
                    if (student.parentEmail != null)
                      _buildContactRow(Icons.family_restroom, 'Parent Email',
                          student.parentEmail!)
                    else
                      _buildContactRow(Icons.family_restroom, 'Parent Email',
                          'Not provided'),
                    const SizedBox(height: 24),

                    // Academic Performance
                    Text(
                      'Academic Performance',
                      style: theme.textTheme.titleMedium?.copyWith(
                        fontWeight: FontWeight.bold,
                      ),
                    ),
                    const SizedBox(height: 12),
                    Row(
                      children: [
                        Expanded(
                          child: _buildPerformanceCard(
                            'Classes',
                            '${student.classCount}',
                            Icons.class_,
                            theme.colorScheme.primary,
                          ),
                        ),
                        const SizedBox(width: 12),
                        Expanded(
                          child: _buildPerformanceCard(
                            'Grade Level',
                            '${student.gradeLevel}',
                            Icons.school,
                            theme.colorScheme.secondary,
                          ),
                        ),
                      ],
                    ),
                    const SizedBox(height: 24),

                    // Enrolled Classes
                    Text(
                      'Enrolled Classes',
                      style: theme.textTheme.titleMedium?.copyWith(
                        fontWeight: FontWeight.bold,
                      ),
                    ),
                    const SizedBox(height: 12),
                    if (student.classIds.isNotEmpty)
                      ...student.classIds.map((classId) {
                        return Card(
                          margin: const EdgeInsets.only(bottom: 8),
                          child: ListTile(
                            leading: const Icon(Icons.class_),
                            title: Text('Class ID: $classId'),
                            subtitle: const Text('Click to view class details'),
                            trailing: const Icon(Icons.arrow_forward_ios),
                            onTap: () {
                              // TODO: Navigate to class details
                              ScaffoldMessenger.of(context).showSnackBar(
                                SnackBar(
                                  content: Text(
                                      'Class details for $classId coming soon'),
                                ),
                              );
                            },
                          ),
                        );
                      })
                    else
                      const Card(
                        child: ListTile(
                          leading: Icon(Icons.info_outline),
                          title: Text('No classes enrolled'),
                          subtitle:
                              Text('Student is not enrolled in any classes'),
                        ),
                      ),

                    const SizedBox(height: 32),
                  ]),
                ),
              ),
            ],
          );
        },
      ),
    );
  }

  Widget _buildContactRow(IconData icon, String label, String value) {
    return Padding(
      padding: const EdgeInsets.symmetric(vertical: 4),
      child: Row(
        children: [
          Icon(icon, size: 20, color: Colors.grey),
          const SizedBox(width: 12),
          Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Text(
                label,
                style: const TextStyle(
                  color: Colors.grey,
                  fontSize: 12,
                ),
              ),
              Text(
                value,
                style: const TextStyle(
                  fontWeight: FontWeight.w600,
                ),
              ),
            ],
          ),
        ],
      ),
    );
  }

  Widget _buildPerformanceCard(
      String label, String value, IconData icon, Color color) {
    return Card(
      child: Padding(
        padding: const EdgeInsets.all(16),
        child: Column(
          children: [
            Icon(icon, color: color, size: 32),
            const SizedBox(height: 8),
            Text(
              value,
              style: TextStyle(
                fontSize: 24,
                fontWeight: FontWeight.bold,
                color: color,
              ),
            ),
            Text(
              label,
              style: const TextStyle(
                color: Colors.grey,
                fontSize: 12,
              ),
            ),
          ],
        ),
      ),
    );
  }
}

// Add Student Sheet
class AddStudentSheet extends StatefulWidget {
  const AddStudentSheet({super.key});

  @override
  State<AddStudentSheet> createState() => _AddStudentSheetState();
}

class _AddStudentSheetState extends State<AddStudentSheet> {
  final _formKey = GlobalKey<FormState>();
  final _firstNameController = TextEditingController();
  final _lastNameController = TextEditingController();
  final _emailController = TextEditingController();
  final _parentEmailController = TextEditingController();
  final _studentService = StudentService();
  String _selectedGrade = '10';
  final List<String> _selectedClasses = [];
  bool _isLoading = false;

  @override
  void dispose() {
    _firstNameController.dispose();
    _lastNameController.dispose();
    _emailController.dispose();
    _parentEmailController.dispose();
    super.dispose();
  }

  Future<void> _addStudent() async {
    if (!_formKey.currentState!.validate()) {
      return;
    }

    setState(() {
      _isLoading = true;
    });

    try {
      final firstName = _firstNameController.text.trim();
      final lastName = _lastNameController.text.trim();
      final email = _emailController.text.trim();
      final parentEmail = _parentEmailController.text.trim();
      final gradeLevel = int.parse(_selectedGrade);
      final now = DateTime.now();

      final newStudent = Student(
        id: '', // Will be set by Firestore
        userId: '', // Will be set when user account is created
        email: email,
        firstName: firstName,
        lastName: lastName,
        displayName: '$firstName $lastName',
        gradeLevel: gradeLevel,
        parentEmail: parentEmail.isEmpty ? null : parentEmail,
        classIds: List<String>.from(_selectedClasses),
        createdAt: now,
        updatedAt: now,
        isActive: true,
      );

      final createdStudent = await _studentService.createStudent(newStudent);

      if (mounted) {
        Navigator.pop(context);
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text(
                'Student "${createdStudent.displayName}" added successfully'),
            backgroundColor: Colors.green,
          ),
        );
      }
    } catch (e) {
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('Error adding student: $e'),
            backgroundColor: Colors.red,
          ),
        );
      }
    } finally {
      if (mounted) {
        setState(() {
          _isLoading = false;
        });
      }
    }
  }

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);

    return Container(
      height: MediaQuery.of(context).size.height * 0.9,
      decoration: BoxDecoration(
        color: theme.colorScheme.surface,
        borderRadius: const BorderRadius.vertical(top: Radius.circular(20)),
      ),
      child: Column(
        children: [
          // Handle Bar
          Center(
            child: Container(
              margin: const EdgeInsets.only(top: 12, bottom: 8),
              width: 40,
              height: 4,
              decoration: BoxDecoration(
                color:
                    theme.colorScheme.onSurfaceVariant.withValues(alpha: 0.3),
                borderRadius: BorderRadius.circular(2),
              ),
            ),
          ),
          // Header
          Padding(
            padding: const EdgeInsets.symmetric(horizontal: 24, vertical: 16),
            child: Row(
              mainAxisAlignment: MainAxisAlignment.spaceBetween,
              children: [
                Text(
                  'Add Student',
                  style: theme.textTheme.headlineSmall?.copyWith(
                    fontWeight: FontWeight.bold,
                  ),
                ),
                IconButton(
                  onPressed: () => Navigator.pop(context),
                  icon: const Icon(Icons.close),
                ),
              ],
            ),
          ),
          // Form
          Expanded(
            child: Form(
              key: _formKey,
              child: SingleChildScrollView(
                padding: const EdgeInsets.symmetric(horizontal: 24),
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    // First Name Field
                    TextFormField(
                      controller: _firstNameController,
                      decoration: const InputDecoration(
                        labelText: 'First Name',
                        hintText: 'Enter first name',
                        border: OutlineInputBorder(),
                        prefixIcon: Icon(Icons.person),
                      ),
                      validator: (value) {
                        if (value == null || value.trim().isEmpty) {
                          return 'Please enter first name';
                        }
                        return null;
                      },
                    ),
                    const SizedBox(height: 16),

                    // Last Name Field
                    TextFormField(
                      controller: _lastNameController,
                      decoration: const InputDecoration(
                        labelText: 'Last Name',
                        hintText: 'Enter last name',
                        border: OutlineInputBorder(),
                        prefixIcon: Icon(Icons.person_outline),
                      ),
                      validator: (value) {
                        if (value == null || value.trim().isEmpty) {
                          return 'Please enter last name';
                        }
                        return null;
                      },
                    ),
                    const SizedBox(height: 16),

                    // Email Field
                    TextFormField(
                      controller: _emailController,
                      keyboardType: TextInputType.emailAddress,
                      decoration: const InputDecoration(
                        labelText: 'Student Email',
                        hintText: 'student@example.com',
                        border: OutlineInputBorder(),
                        prefixIcon: Icon(Icons.email),
                      ),
                      validator: (value) {
                        if (value == null || value.trim().isEmpty) {
                          return 'Please enter student email';
                        }
                        if (!RegExp(r'^[^@]+@[^@]+\.[^@]+')
                            .hasMatch(value.trim())) {
                          return 'Please enter a valid email address';
                        }
                        return null;
                      },
                    ),
                    const SizedBox(height: 16),

                    // Parent Email Field
                    TextFormField(
                      controller: _parentEmailController,
                      keyboardType: TextInputType.emailAddress,
                      decoration: const InputDecoration(
                        labelText: 'Parent Email (Optional)',
                        hintText: 'parent@example.com',
                        border: OutlineInputBorder(),
                        prefixIcon: Icon(Icons.family_restroom),
                      ),
                      validator: (value) {
                        if (value != null && value.trim().isNotEmpty) {
                          if (!RegExp(r'^[^@]+@[^@]+\.[^@]+')
                              .hasMatch(value.trim())) {
                            return 'Please enter a valid email address';
                          }
                        }
                        return null;
                      },
                    ),
                    const SizedBox(height: 16),

                    // Grade Dropdown
                    DropdownButtonFormField<String>(
                      value: _selectedGrade,
                      decoration: const InputDecoration(
                        labelText: 'Grade Level',
                        border: OutlineInputBorder(),
                        prefixIcon: Icon(Icons.school),
                      ),
                      items: ['9', '10', '11', '12'].map((grade) {
                        return DropdownMenuItem(
                          value: grade,
                          child: Text('Grade $grade'),
                        );
                      }).toList(),
                      onChanged: (value) {
                        setState(() {
                          _selectedGrade = value!;
                        });
                      },
                    ),
                    const SizedBox(height: 16),

                    // Classes Selection
                    Text(
                      'Assign to Classes',
                      style: theme.textTheme.titleMedium?.copyWith(
                        fontWeight: FontWeight.w600,
                      ),
                    ),
                    const SizedBox(height: 8),
                    Wrap(
                      spacing: 8,
                      runSpacing: 8,
                      children: [
                        'Math 101 - Section A',
                        'Environmental Science',
                        'Physics Honors',
                        'Chemistry 101',
                      ].map((className) {
                        final isSelected = _selectedClasses.contains(className);
                        return FilterChip(
                          label: Text(className),
                          selected: isSelected,
                          onSelected: (selected) {
                            setState(() {
                              if (selected) {
                                _selectedClasses.add(className);
                              } else {
                                _selectedClasses.remove(className);
                              }
                            });
                          },
                        );
                      }).toList(),
                    ),

                    const SizedBox(height: 32),
                  ],
                ),
              ),
            ),
          ),
          // Action Buttons
          Container(
            padding: const EdgeInsets.all(24),
            decoration: BoxDecoration(
              color: theme.colorScheme.surface,
              boxShadow: [
                BoxShadow(
                  color: Colors.black.withValues(alpha: 0.1),
                  blurRadius: 10,
                  offset: const Offset(0, -5),
                ),
              ],
            ),
            child: Row(
              children: [
                Expanded(
                  child: OutlinedButton(
                    onPressed: () => Navigator.pop(context),
                    style: OutlinedButton.styleFrom(
                      padding: const EdgeInsets.symmetric(vertical: 16),
                    ),
                    child: const Text('Cancel'),
                  ),
                ),
                const SizedBox(width: 16),
                Expanded(
                  child: FilledButton(
                    onPressed: _isLoading ? null : _addStudent,
                    style: FilledButton.styleFrom(
                      padding: const EdgeInsets.symmetric(vertical: 16),
                    ),
                    child: _isLoading
                        ? const SizedBox(
                            width: 20,
                            height: 20,
                            child: CircularProgressIndicator(
                              strokeWidth: 2,
                              valueColor:
                                  AlwaysStoppedAnimation<Color>(Colors.white),
                            ),
                          )
                        : const Text('Add Student'),
                  ),
                ),
              ],
            ),
          ),
        ],
      ),
    );
  }
}

// Edit Student Sheet
class EditStudentSheet extends StatefulWidget {
  final Student student;

  const EditStudentSheet({
    super.key,
    required this.student,
  });

  @override
  State<EditStudentSheet> createState() => _EditStudentSheetState();
}

class _EditStudentSheetState extends State<EditStudentSheet> {
  final _formKey = GlobalKey<FormState>();
  final _firstNameController = TextEditingController();
  final _lastNameController = TextEditingController();
  final _emailController = TextEditingController();
  final _parentEmailController = TextEditingController();
  final _studentService = StudentService();
  String _selectedGrade = '10';
  bool _isLoading = false;

  @override
  void initState() {
    super.initState();
    _firstNameController.text = widget.student.firstName;
    _lastNameController.text = widget.student.lastName;
    _emailController.text = widget.student.email;
    _parentEmailController.text = widget.student.parentEmail ?? '';
    _selectedGrade = widget.student.gradeLevel.toString();
  }

  @override
  void dispose() {
    _firstNameController.dispose();
    _lastNameController.dispose();
    _emailController.dispose();
    _parentEmailController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);

    return Container(
      height: MediaQuery.of(context).size.height * 0.9,
      decoration: BoxDecoration(
        color: theme.colorScheme.surface,
        borderRadius: const BorderRadius.vertical(top: Radius.circular(20)),
      ),
      child: Column(
        children: [
          Center(
            child: Container(
              margin: const EdgeInsets.only(top: 12, bottom: 8),
              width: 40,
              height: 4,
              decoration: BoxDecoration(
                color:
                    theme.colorScheme.onSurfaceVariant.withValues(alpha: 0.3),
                borderRadius: BorderRadius.circular(2),
              ),
            ),
          ),
          Padding(
            padding: const EdgeInsets.symmetric(horizontal: 24, vertical: 16),
            child: Row(
              mainAxisAlignment: MainAxisAlignment.spaceBetween,
              children: [
                Text(
                  'Edit Student',
                  style: theme.textTheme.headlineSmall?.copyWith(
                    fontWeight: FontWeight.bold,
                  ),
                ),
                IconButton(
                  onPressed: () => Navigator.pop(context),
                  icon: const Icon(Icons.close),
                ),
              ],
            ),
          ),
          Expanded(
            child: SingleChildScrollView(
              padding: const EdgeInsets.symmetric(horizontal: 24),
              child: Form(
                key: _formKey,
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    TextFormField(
                      controller: _firstNameController,
                      decoration: const InputDecoration(
                        labelText: 'First Name',
                        hintText: 'Enter first name',
                        border: OutlineInputBorder(),
                        prefixIcon: Icon(Icons.person),
                      ),
                      validator: (value) {
                        if (value == null || value.isEmpty) {
                          return 'Please enter first name';
                        }
                        return null;
                      },
                    ),
                    const SizedBox(height: 16),
                    TextFormField(
                      controller: _lastNameController,
                      decoration: const InputDecoration(
                        labelText: 'Last Name',
                        hintText: 'Enter last name',
                        border: OutlineInputBorder(),
                        prefixIcon: Icon(Icons.person),
                      ),
                      validator: (value) {
                        if (value == null || value.isEmpty) {
                          return 'Please enter last name';
                        }
                        return null;
                      },
                    ),
                    const SizedBox(height: 16),
                    TextFormField(
                      controller: _emailController,
                      keyboardType: TextInputType.emailAddress,
                      decoration: const InputDecoration(
                        labelText: 'Student Email',
                        hintText: 'student@example.com',
                        border: OutlineInputBorder(),
                        prefixIcon: Icon(Icons.email),
                      ),
                      validator: (value) {
                        if (value == null || value.isEmpty) {
                          return 'Please enter email';
                        }
                        if (!RegExp(r'^[\w-\.]+@([\w-]+\.)+[\w-]{2,4}$')
                            .hasMatch(value)) {
                          return 'Please enter a valid email';
                        }
                        return null;
                      },
                    ),
                    const SizedBox(height: 16),
                    TextFormField(
                      controller: _parentEmailController,
                      keyboardType: TextInputType.emailAddress,
                      decoration: const InputDecoration(
                        labelText: 'Parent Email (Optional)',
                        hintText: 'parent@example.com',
                        border: OutlineInputBorder(),
                        prefixIcon: Icon(Icons.family_restroom),
                      ),
                      validator: (value) {
                        if (value != null && value.isNotEmpty) {
                          if (!RegExp(r'^[\w-\.]+@([\w-]+\.)+[\w-]{2,4}$')
                              .hasMatch(value)) {
                            return 'Please enter a valid email';
                          }
                        }
                        return null;
                      },
                    ),
                    const SizedBox(height: 16),
                    DropdownButtonFormField<String>(
                      value: _selectedGrade,
                      decoration: const InputDecoration(
                        labelText: 'Grade Level',
                        border: OutlineInputBorder(),
                        prefixIcon: Icon(Icons.school),
                      ),
                      items: ['9', '10', '11', '12'].map((grade) {
                        return DropdownMenuItem(
                          value: grade,
                          child: Text('Grade $grade'),
                        );
                      }).toList(),
                      onChanged: (value) {
                        setState(() {
                          _selectedGrade = value!;
                        });
                      },
                    ),
                    const SizedBox(height: 32),
                  ],
                ),
              ),
            ),
          ),
          Container(
            padding: const EdgeInsets.all(24),
            decoration: BoxDecoration(
              color: theme.colorScheme.surface,
              boxShadow: [
                BoxShadow(
                  color: Colors.black.withValues(alpha: 0.1),
                  blurRadius: 10,
                  offset: const Offset(0, -5),
                ),
              ],
            ),
            child: Row(
              children: [
                Expanded(
                  child: OutlinedButton(
                    onPressed: _isLoading ? null : () => Navigator.pop(context),
                    style: OutlinedButton.styleFrom(
                      padding: const EdgeInsets.symmetric(vertical: 16),
                    ),
                    child: const Text('Cancel'),
                  ),
                ),
                const SizedBox(width: 16),
                Expanded(
                  child: FilledButton(
                    onPressed: _isLoading ? null : _updateStudent,
                    style: FilledButton.styleFrom(
                      padding: const EdgeInsets.symmetric(vertical: 16),
                    ),
                    child: _isLoading
                        ? const SizedBox(
                            height: 20,
                            width: 20,
                            child: CircularProgressIndicator(strokeWidth: 2),
                          )
                        : const Text('Update Student'),
                  ),
                ),
              ],
            ),
          ),
        ],
      ),
    );
  }

  Future<void> _updateStudent() async {
    if (!_formKey.currentState!.validate()) return;

    setState(() {
      _isLoading = true;
    });

    try {
      final updatedStudent = widget.student.copyWith(
        firstName: _firstNameController.text.trim(),
        lastName: _lastNameController.text.trim(),
        displayName:
            '${_firstNameController.text.trim()} ${_lastNameController.text.trim()}',
        email: _emailController.text.trim(),
        parentEmail: _parentEmailController.text.trim().isEmpty
            ? null
            : _parentEmailController.text.trim(),
        gradeLevel: int.parse(_selectedGrade),
        updatedAt: DateTime.now(),
      );

      await _studentService.updateStudent(updatedStudent);

      if (mounted) {
        Navigator.pop(context);
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('${updatedStudent.displayName} updated successfully'),
            backgroundColor: Colors.green,
          ),
        );
      }
    } catch (e) {
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('Error updating student: $e'),
            backgroundColor: Colors.red,
          ),
        );
      }
    } finally {
      if (mounted) {
        setState(() {
          _isLoading = false;
        });
      }
    }
  }
}
````

## File: lib/features/student/presentation/widgets/online_users_card.dart
````dart
import 'package:flutter/material.dart';
import '../../data/services/presence_service.dart';

class OnlineUsersCard extends StatelessWidget {
  final PresenceService _presenceService = PresenceService();
  
  final bool excludeSelf;
  
  OnlineUsersCard({super.key, this.excludeSelf = true});

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    
    return Card(
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Padding(
            padding: const EdgeInsets.all(16),
            child: Row(
              children: [
                Container(
                  width: 8,
                  height: 8,
                  decoration: BoxDecoration(
                    color: Colors.green,
                    shape: BoxShape.circle,
                  ),
                ),
                const SizedBox(width: 8),
                Text(
                  'Online Now',
                  style: theme.textTheme.titleMedium?.copyWith(
                    fontWeight: FontWeight.bold,
                  ),
                ),
              ],
            ),
          ),
          const Divider(height: 1),
          StreamBuilder<List<OnlineUser>>(
            stream: _presenceService.getOnlineUsers(excludeSelf: excludeSelf),
            builder: (context, snapshot) {
              if (snapshot.hasError) {
                // Handle error state
                return Padding(
                  padding: const EdgeInsets.all(32),
                  child: Center(
                    child: Column(
                      children: [
                        Icon(
                          Icons.error_outline,
                          size: 48,
                          color: theme.colorScheme.error,
                        ),
                        const SizedBox(height: 8),
                        Text(
                          'Could not load online users',
                          style: theme.textTheme.bodyMedium?.copyWith(
                            color: theme.colorScheme.error,
                          ),
                        ),
                      ],
                    ),
                  ),
                );
              }
              
              if (!snapshot.hasData) {
                return const Center(
                  child: Padding(
                    padding: EdgeInsets.all(32),
                    child: CircularProgressIndicator(),
                  ),
                );
              }
              
              final onlineUsers = snapshot.data!;
              
              if (onlineUsers.isEmpty) {
                return Padding(
                  padding: const EdgeInsets.all(32),
                  child: Center(
                    child: Column(
                      children: [
                        Icon(
                          Icons.people_outline,
                          size: 48,
                          color: theme.colorScheme.onSurfaceVariant.withValues(alpha: 0.5),
                        ),
                        const SizedBox(height: 8),
                        Text(
                          'No one else online',
                          style: theme.textTheme.bodyMedium?.copyWith(
                            color: theme.colorScheme.onSurfaceVariant,
                          ),
                        ),
                      ],
                    ),
                  ),
                );
              }
              
              return ListView.builder(
                shrinkWrap: true,
                physics: const NeverScrollableScrollPhysics(),
                itemCount: onlineUsers.length,
                itemBuilder: (context, index) {
                  final user = onlineUsers[index];
                  return _buildUserTile(context, user);
                },
              );
            },
          ),
        ],
      ),
    );
  }
  
  Widget _buildUserTile(BuildContext context, OnlineUser user) {
    final theme = Theme.of(context);
    
    return ListTile(
      leading: Stack(
        children: [
          CircleAvatar(
            radius: 20,
            backgroundColor: theme.colorScheme.primary,
            child: _buildUserAvatar(theme, user),
          ),
          Positioned(
            right: 0,
            bottom: 0,
            child: Container(
              width: 12,
              height: 12,
              decoration: BoxDecoration(
                color: Colors.green,
                shape: BoxShape.circle,
                border: Border.all(
                  color: theme.colorScheme.surface,
                  width: 2,
                ),
              ),
            ),
          ),
        ],
      ),
      title: Text(
        user.displayName,
        style: theme.textTheme.titleSmall,
      ),
      subtitle: Text(
        _getStatusText(user),
        style: theme.textTheme.bodySmall?.copyWith(
          color: theme.colorScheme.onSurfaceVariant,
        ),
      ),
      onTap: () {
        // TODO: Navigate to user profile or start chat
      },
    );
  }
  
  String _getStatusText(OnlineUser user) {
    // Show role and activity status
    final role = user.role ?? 'user';
    final roleText = role.substring(0, 1).toUpperCase() + role.substring(1);
    
    // Use the relative time helper from the model
    if (user.isActive) {
      return '$roleText • Active now';
    } else {
      return '$roleText • ${user.relativeTime}';
    }
  }
  
  Widget _buildUserAvatar(ThemeData theme, OnlineUser user) {
    // Helper to build initials avatar
    Widget buildInitialsAvatar() {
      return Container(
        width: 40,
        height: 40,
        decoration: BoxDecoration(
          color: theme.colorScheme.primary,
          shape: BoxShape.circle,
        ),
        child: Center(
          child: Text(
            user.displayName.isNotEmpty 
              ? user.displayName[0].toUpperCase()
              : 'U',
            style: TextStyle(
              color: theme.colorScheme.onPrimary,
              fontWeight: FontWeight.bold,
            ),
          ),
        ),
      );
    }
    
    // If no photo URL, return initials
    if (user.photoURL == null) {
      return buildInitialsAvatar();
    }
    
    // CORS is now configured, so we can load images on localhost
    
    // Otherwise, try to load the image
    return ClipOval(
      child: Image.network(
        user.photoURL!,
        width: 40,
        height: 40,
        fit: BoxFit.cover,
        errorBuilder: (context, error, stackTrace) {
          // Log error for debugging but don't show it to user
          if (error.toString().contains('CORS')) {
            debugPrint('CORS error loading profile image. Run apply_cors.sh to fix.');
          }
          return buildInitialsAvatar();
        },
        loadingBuilder: (context, child, loadingProgress) {
          if (loadingProgress == null) return child;
          return Container(
            width: 40,
            height: 40,
            color: theme.colorScheme.primary,
            child: Center(
              child: CircularProgressIndicator(
                strokeWidth: 2,
                valueColor: AlwaysStoppedAnimation<Color>(
                  theme.colorScheme.onPrimary,
                ),
              ),
            ),
          );
        },
      ),
    );
  }
}
````

## File: lib/features/teacher/presentation/screens/messages_screen.dart
````dart
import 'package:flutter/material.dart';
import '../../../../shared/widgets/common/adaptive_layout.dart';
import '../../../../shared/widgets/common/responsive_layout.dart';

class TeacherMessagesScreen extends StatefulWidget {
  const TeacherMessagesScreen({super.key});

  @override
  State<TeacherMessagesScreen> createState() => _TeacherMessagesScreenState();
}

class _TeacherMessagesScreenState extends State<TeacherMessagesScreen> with SingleTickerProviderStateMixin {
  late TabController _tabController;
  final _searchController = TextEditingController();
  String _selectedFilter = 'All';

  @override
  void initState() {
    super.initState();
    _tabController = TabController(length: 3, vsync: this, initialIndex: 0);
  }

  @override
  void dispose() {
    _tabController.dispose();
    _searchController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);

    return AdaptiveLayout(
      title: 'Messages',
      showBackButton: true,
      floatingActionButton: FloatingActionButton.extended(
        onPressed: () {
          _showComposeMessage(context);
        },
        icon: const Icon(Icons.edit),
        label: const Text('Compose'),
      ),
      bottom: TabBar(
        controller: _tabController,
        tabs: const [
          Tab(text: 'Inbox'),
          Tab(text: 'Sent'),
          Tab(text: 'Archived'),
        ],
      ),
      body: Column(
        children: [
          // Search and Filter Bar
          Container(
            padding: const EdgeInsets.all(16),
            child: Row(
              children: [
                // Search Field
                Expanded(
                  child: TextField(
                    controller: _searchController,
                    decoration: InputDecoration(
                      hintText: 'Search messages...',
                      prefixIcon: const Icon(Icons.search),
                      suffixIcon: _searchController.text.isNotEmpty
                          ? IconButton(
                              icon: const Icon(Icons.clear),
                              onPressed: () {
                                setState(() {
                                  _searchController.clear();
                                });
                              },
                            )
                          : null,
                      border: const OutlineInputBorder(),
                      contentPadding: const EdgeInsets.symmetric(
                        horizontal: 16,
                        vertical: 12,
                      ),
                    ),
                    onChanged: (value) => setState(() {}),
                  ),
                ),
                const SizedBox(width: 12),
                // Filter Button
                Container(
                  decoration: BoxDecoration(
                    border: Border.all(color: theme.colorScheme.outline),
                    borderRadius: BorderRadius.circular(8),
                  ),
                  child: PopupMenuButton<String>(
                    initialValue: _selectedFilter,
                    onSelected: (value) {
                      setState(() {
                        _selectedFilter = value;
                      });
                    },
                    itemBuilder: (context) => [
                      const PopupMenuItem(value: 'All', child: Text('All Messages')),
                      const PopupMenuItem(value: 'Unread', child: Text('Unread')),
                      const PopupMenuItem(value: 'Starred', child: Text('Starred')),
                      const PopupMenuItem(value: 'Students', child: Text('From Students')),
                      const PopupMenuItem(value: 'Parents', child: Text('From Parents')),
                    ],
                    child: Padding(
                      padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 8),
                      child: Row(
                        children: [
                          const Icon(Icons.filter_list, size: 20),
                          const SizedBox(width: 8),
                          Text(_selectedFilter),
                          const Icon(Icons.arrow_drop_down),
                        ],
                      ),
                    ),
                  ),
                ),
              ],
            ),
          ),
          // Messages List
          Expanded(
            child: TabBarView(
              controller: _tabController,
              children: [
                _buildInboxMessages(),
                _buildSentMessages(),
                _buildArchivedMessages(),
              ],
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildInboxMessages() {
    final messages = [
      {
        'sender': 'Sarah Johnson',
        'senderType': 'Student',
        'subject': 'Question about Math homework',
        'preview': 'Hi Mr. Smith, I\'m having trouble understanding problem 5 from...',
        'time': DateTime.now().subtract(const Duration(hours: 2)),
        'isRead': false,
        'isStarred': true,
        'hasAttachment': false,
      },
      {
        'sender': 'Parent - Michael Chen',
        'senderType': 'Parent',
        'subject': 'Michael\'s absence tomorrow',
        'preview': 'Dear Teacher, Michael will be absent tomorrow due to a doctor\'s appointment...',
        'time': DateTime.now().subtract(const Duration(hours: 5)),
        'isRead': true,
        'isStarred': false,
        'hasAttachment': true,
      },
      {
        'sender': 'Emma Davis',
        'senderType': 'Student',
        'subject': 'Extra credit opportunity',
        'preview': 'Hello, I was wondering if there are any extra credit opportunities available...',
        'time': DateTime.now().subtract(const Duration(days: 1)),
        'isRead': true,
        'isStarred': false,
        'hasAttachment': false,
      },
      {
        'sender': 'Admin Office',
        'senderType': 'Admin',
        'subject': 'Faculty meeting reminder',
        'preview': 'This is a reminder about the faculty meeting scheduled for Friday at 3:00 PM...',
        'time': DateTime.now().subtract(const Duration(days: 1)),
        'isRead': false,
        'isStarred': true,
        'hasAttachment': false,
      },
    ];

    return _buildMessagesList(messages);
  }

  Widget _buildSentMessages() {
    final messages = [
      {
        'sender': 'To: James Wilson',
        'senderType': 'Sent',
        'subject': 'Re: Missing assignments',
        'preview': 'Hi James, I noticed you have several missing assignments. Please submit...',
        'time': DateTime.now().subtract(const Duration(hours: 3)),
        'isRead': true,
        'isStarred': false,
        'hasAttachment': false,
      },
      {
        'sender': 'To: Parent - Sarah Johnson',
        'senderType': 'Sent',
        'subject': 'Sarah\'s progress update',
        'preview': 'Dear Mr./Mrs. Johnson, I wanted to update you on Sarah\'s excellent progress...',
        'time': DateTime.now().subtract(const Duration(days: 2)),
        'isRead': true,
        'isStarred': false,
        'hasAttachment': true,
      },
    ];

    return _buildMessagesList(messages);
  }

  Widget _buildArchivedMessages() {
    final messages = [
      {
        'sender': 'Previous Student',
        'senderType': 'Student',
        'subject': 'Thank you!',
        'preview': 'Thank you for all your help this semester. I really appreciated...',
        'time': DateTime.now().subtract(const Duration(days: 30)),
        'isRead': true,
        'isStarred': true,
        'hasAttachment': false,
      },
    ];

    return _buildMessagesList(messages);
  }

  Widget _buildMessagesList(List<Map<String, dynamic>> messages) {
    return ResponsiveContainer(
      child: ListView.builder(
        itemCount: messages.length,
        itemBuilder: (context, index) {
          final message = messages[index];
          return _buildMessageCard(message);
        },
      ),
    );
  }

  Widget _buildMessageCard(Map<String, dynamic> message) {
    final theme = Theme.of(context);
    final isUnread = !(message['isRead'] as bool);
    
    Color senderTypeColor;
    IconData senderTypeIcon;
    switch (message['senderType']) {
      case 'Student':
        senderTypeColor = Colors.blue;
        senderTypeIcon = Icons.school;
        break;
      case 'Parent':
        senderTypeColor = Colors.green;
        senderTypeIcon = Icons.family_restroom;
        break;
      case 'Admin':
        senderTypeColor = Colors.orange;
        senderTypeIcon = Icons.admin_panel_settings;
        break;
      case 'Sent':
        senderTypeColor = Colors.grey;
        senderTypeIcon = Icons.send;
        break;
      default:
        senderTypeColor = Colors.grey;
        senderTypeIcon = Icons.person;
    }

    return Card(
      margin: const EdgeInsets.symmetric(horizontal: 16, vertical: 4),
      child: InkWell(
        onTap: () => _showMessageDetail(message),
        borderRadius: BorderRadius.circular(12),
        child: Padding(
          padding: const EdgeInsets.all(16),
          child: Row(
            children: [
              // Sender Avatar
              CircleAvatar(
                backgroundColor: isUnread 
                    ? senderTypeColor.withValues(alpha: 0.2)
                    : Colors.grey.withValues(alpha: 0.1),
                child: Icon(
                  senderTypeIcon,
                  color: isUnread ? senderTypeColor : Colors.grey,
                  size: 20,
                ),
              ),
              const SizedBox(width: 12),
              // Message Content
              Expanded(
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    // Header Row
                    Row(
                      children: [
                        Expanded(
                          child: Text(
                            message['sender'],
                            style: theme.textTheme.titleMedium?.copyWith(
                              fontWeight: isUnread ? FontWeight.bold : FontWeight.normal,
                            ),
                            overflow: TextOverflow.ellipsis,
                          ),
                        ),
                        Text(
                          _formatMessageTime(message['time']),
                          style: theme.textTheme.bodySmall?.copyWith(
                            color: theme.colorScheme.onSurfaceVariant,
                            fontWeight: isUnread ? FontWeight.w600 : FontWeight.normal,
                          ),
                        ),
                      ],
                    ),
                    const SizedBox(height: 4),
                    // Subject
                    Text(
                      message['subject'],
                      style: theme.textTheme.bodyMedium?.copyWith(
                        fontWeight: isUnread ? FontWeight.w600 : FontWeight.normal,
                      ),
                      overflow: TextOverflow.ellipsis,
                    ),
                    const SizedBox(height: 2),
                    // Preview
                    Row(
                      children: [
                        Expanded(
                          child: Text(
                            message['preview'],
                            style: theme.textTheme.bodySmall?.copyWith(
                              color: theme.colorScheme.onSurfaceVariant,
                            ),
                            overflow: TextOverflow.ellipsis,
                            maxLines: 1,
                          ),
                        ),
                        if (message['hasAttachment']) ...[
                          const SizedBox(width: 8),
                          Icon(
                            Icons.attach_file,
                            size: 16,
                            color: theme.colorScheme.onSurfaceVariant,
                          ),
                        ],
                      ],
                    ),
                  ],
                ),
              ),
              const SizedBox(width: 8),
              // Star Button
              IconButton(
                icon: Icon(
                  message['isStarred'] ? Icons.star : Icons.star_border,
                  color: message['isStarred'] ? Colors.amber : Colors.grey,
                ),
                onPressed: () {
                  setState(() {
                    message['isStarred'] = !message['isStarred'];
                  });
                },
              ),
            ],
          ),
        ),
      ),
    );
  }

  String _formatMessageTime(DateTime time) {
    final now = DateTime.now();
    final difference = now.difference(time);
    
    if (difference.inMinutes < 60) {
      return '${difference.inMinutes}m';
    } else if (difference.inHours < 24) {
      return '${difference.inHours}h';
    } else if (difference.inDays < 7) {
      return '${difference.inDays}d';
    } else {
      return '${time.day}/${time.month}';
    }
  }

  void _showMessageDetail(Map<String, dynamic> message) {
    showModalBottomSheet(
      context: context,
      isScrollControlled: true,
      backgroundColor: Colors.transparent,
      builder: (context) => MessageDetailSheet(message: message),
    );
  }

  void _showComposeMessage(BuildContext context) {
    showModalBottomSheet(
      context: context,
      isScrollControlled: true,
      backgroundColor: Colors.transparent,
      builder: (context) => const ComposeMessageSheet(),
    );
  }
}

// Message Detail Sheet
class MessageDetailSheet extends StatelessWidget {
  final Map<String, dynamic> message;

  const MessageDetailSheet({
    super.key,
    required this.message,
  });

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);

    return Container(
      decoration: BoxDecoration(
        color: theme.colorScheme.surface,
        borderRadius: const BorderRadius.vertical(top: Radius.circular(20)),
      ),
      child: DraggableScrollableSheet(
        initialChildSize: 0.7,
        minChildSize: 0.5,
        maxChildSize: 0.95,
        expand: false,
        builder: (context, scrollController) {
          return Column(
            children: [
              // Handle Bar
              Center(
                child: Container(
                  margin: const EdgeInsets.only(top: 12, bottom: 8),
                  width: 40,
                  height: 4,
                  decoration: BoxDecoration(
                    color: theme.colorScheme.onSurfaceVariant.withValues(alpha: 0.3),
                    borderRadius: BorderRadius.circular(2),
                  ),
                ),
              ),
              // Header
              Container(
                padding: const EdgeInsets.symmetric(horizontal: 24, vertical: 8),
                decoration: BoxDecoration(
                  border: Border(
                    bottom: BorderSide(
                      color: theme.colorScheme.outlineVariant,
                    ),
                  ),
                ),
                child: Row(
                  mainAxisAlignment: MainAxisAlignment.spaceBetween,
                  children: [
                    IconButton(
                      onPressed: () => Navigator.pop(context),
                      icon: const Icon(Icons.close),
                    ),
                    Row(
                      children: [
                        IconButton(
                          onPressed: () {},
                          icon: const Icon(Icons.archive_outlined),
                          tooltip: 'Archive',
                        ),
                        IconButton(
                          onPressed: () {},
                          icon: const Icon(Icons.delete_outline),
                          tooltip: 'Delete',
                        ),
                        IconButton(
                          onPressed: () {},
                          icon: Icon(
                            message['isStarred'] ? Icons.star : Icons.star_border,
                            color: message['isStarred'] ? Colors.amber : null,
                          ),
                          tooltip: 'Star',
                        ),
                      ],
                    ),
                  ],
                ),
              ),
              // Content
              Expanded(
                child: SingleChildScrollView(
                  controller: scrollController,
                  padding: const EdgeInsets.all(24),
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      // Subject
                      Text(
                        message['subject'],
                        style: theme.textTheme.headlineSmall?.copyWith(
                          fontWeight: FontWeight.bold,
                        ),
                      ),
                      const SizedBox(height: 16),
                      // Sender Info
                      Row(
                        children: [
                          CircleAvatar(
                            child: Text(
                              message['sender'][0].toUpperCase(),
                            ),
                          ),
                          const SizedBox(width: 12),
                          Expanded(
                            child: Column(
                              crossAxisAlignment: CrossAxisAlignment.start,
                              children: [
                                Text(
                                  message['sender'],
                                  style: theme.textTheme.titleMedium?.copyWith(
                                    fontWeight: FontWeight.w600,
                                  ),
                                ),
                                Text(
                                  'to me',
                                  style: theme.textTheme.bodySmall?.copyWith(
                                    color: theme.colorScheme.onSurfaceVariant,
                                  ),
                                ),
                              ],
                            ),
                          ),
                          Text(
                            _formatFullDate(message['time']),
                            style: theme.textTheme.bodySmall?.copyWith(
                              color: theme.colorScheme.onSurfaceVariant,
                            ),
                          ),
                        ],
                      ),
                      const SizedBox(height: 24),
                      // Message Body
                      Text(
                        '''Hi Mr. Smith,

I'm having trouble understanding problem 5 from the homework assignment. I've tried following the steps we learned in class, but I keep getting a different answer than what's in the answer key.

Could you please help me understand where I might be going wrong? I've attached my work so you can see my process.

Thank you for your time!

Best regards,
${message['sender']}''',
                        style: theme.textTheme.bodyLarge,
                      ),
                      
                      if (message['hasAttachment']) ...[
                        const SizedBox(height: 24),
                        // Attachment
                        Container(
                          padding: const EdgeInsets.all(16),
                          decoration: BoxDecoration(
                            color: theme.colorScheme.surfaceContainerHighest,
                            borderRadius: BorderRadius.circular(8),
                          ),
                          child: Row(
                            children: [
                              Icon(
                                Icons.insert_drive_file,
                                color: theme.colorScheme.primary,
                              ),
                              const SizedBox(width: 12),
                              const Expanded(
                                child: Column(
                                  crossAxisAlignment: CrossAxisAlignment.start,
                                  children: [
                                    Text(
                                      'homework_problem_5.pdf',
                                      style: TextStyle(fontWeight: FontWeight.w600),
                                    ),
                                    Text(
                                      '245 KB',
                                      style: TextStyle(fontSize: 12),
                                    ),
                                  ],
                                ),
                              ),
                              IconButton(
                                onPressed: () {},
                                icon: const Icon(Icons.download),
                              ),
                            ],
                          ),
                        ),
                      ],
                    ],
                  ),
                ),
              ),
              // Reply Section
              Container(
                padding: const EdgeInsets.all(16),
                decoration: BoxDecoration(
                  color: theme.colorScheme.surface,
                  boxShadow: [
                    BoxShadow(
                      color: Colors.black.withValues(alpha: 0.1),
                      blurRadius: 10,
                      offset: const Offset(0, -5),
                    ),
                  ],
                ),
                child: Row(
                  children: [
                    Expanded(
                      child: FilledButton.icon(
                        onPressed: () {
                          Navigator.pop(context);
                          _showReplyMessage(context, message);
                        },
                        icon: const Icon(Icons.reply),
                        label: const Text('Reply'),
                      ),
                    ),
                    const SizedBox(width: 12),
                    Expanded(
                      child: OutlinedButton.icon(
                        onPressed: () {
                          Navigator.pop(context);
                          _showForwardMessage(context, message);
                        },
                        icon: const Icon(Icons.forward),
                        label: const Text('Forward'),
                      ),
                    ),
                  ],
                ),
              ),
            ],
          );
        },
      ),
    );
  }

  String _formatFullDate(DateTime date) {
    final months = [
      'Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun',
      'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'
    ];
    final hour = date.hour > 12 ? date.hour - 12 : date.hour;
    final amPm = date.hour >= 12 ? 'PM' : 'AM';
    return '${months[date.month - 1]} ${date.day}, ${date.year} at $hour:${date.minute.toString().padLeft(2, '0')} $amPm';
  }

  void _showReplyMessage(BuildContext context, Map<String, dynamic> originalMessage) {
    showModalBottomSheet(
      context: context,
      isScrollControlled: true,
      backgroundColor: Colors.transparent,
      builder: (context) => ComposeMessageSheet(
        recipient: originalMessage['sender'],
        subject: 'Re: ${originalMessage['subject']}',
      ),
    );
  }

  void _showForwardMessage(BuildContext context, Map<String, dynamic> originalMessage) {
    showModalBottomSheet(
      context: context,
      isScrollControlled: true,
      backgroundColor: Colors.transparent,
      builder: (context) => ComposeMessageSheet(
        subject: 'Fwd: ${originalMessage['subject']}',
      ),
    );
  }
}

// Compose Message Sheet
class ComposeMessageSheet extends StatefulWidget {
  final String? recipient;
  final String? subject;

  const ComposeMessageSheet({
    super.key,
    this.recipient,
    this.subject,
  });

  @override
  State<ComposeMessageSheet> createState() => _ComposeMessageSheetState();
}

class _ComposeMessageSheetState extends State<ComposeMessageSheet> {
  final _recipientController = TextEditingController();
  final _subjectController = TextEditingController();
  final _messageController = TextEditingController();
  String _recipientType = 'Student';

  @override
  void initState() {
    super.initState();
    if (widget.recipient != null) {
      _recipientController.text = widget.recipient!;
    }
    if (widget.subject != null) {
      _subjectController.text = widget.subject!;
    }
  }

  @override
  void dispose() {
    _recipientController.dispose();
    _subjectController.dispose();
    _messageController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);

    return Container(
      height: MediaQuery.of(context).size.height * 0.9,
      decoration: BoxDecoration(
        color: theme.colorScheme.surface,
        borderRadius: const BorderRadius.vertical(top: Radius.circular(20)),
      ),
      child: Column(
        children: [
          // Handle Bar
          Center(
            child: Container(
              margin: const EdgeInsets.only(top: 12, bottom: 8),
              width: 40,
              height: 4,
              decoration: BoxDecoration(
                color: theme.colorScheme.onSurfaceVariant.withValues(alpha: 0.3),
                borderRadius: BorderRadius.circular(2),
              ),
            ),
          ),
          // Header
          Padding(
            padding: const EdgeInsets.symmetric(horizontal: 24, vertical: 16),
            child: Row(
              mainAxisAlignment: MainAxisAlignment.spaceBetween,
              children: [
                Text(
                  'New Message',
                  style: theme.textTheme.headlineSmall?.copyWith(
                    fontWeight: FontWeight.bold,
                  ),
                ),
                Row(
                  children: [
                    IconButton(
                      onPressed: () {},
                      icon: const Icon(Icons.attach_file),
                      tooltip: 'Attach file',
                    ),
                    IconButton(
                      onPressed: () => Navigator.pop(context),
                      icon: const Icon(Icons.close),
                    ),
                  ],
                ),
              ],
            ),
          ),
          // Form
          Expanded(
            child: SingleChildScrollView(
              padding: const EdgeInsets.symmetric(horizontal: 24),
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  // Recipient Type
                  SegmentedButton<String>(
                    segments: const [
                      ButtonSegment(
                        value: 'Student',
                        label: Text('Student'),
                        icon: Icon(Icons.school),
                      ),
                      ButtonSegment(
                        value: 'Parent',
                        label: Text('Parent'),
                        icon: Icon(Icons.family_restroom),
                      ),
                      ButtonSegment(
                        value: 'Class',
                        label: Text('Class'),
                        icon: Icon(Icons.groups),
                      ),
                    ],
                    selected: {_recipientType},
                    onSelectionChanged: (Set<String> selection) {
                      setState(() {
                        _recipientType = selection.first;
                      });
                    },
                  ),
                  const SizedBox(height: 16),

                  // To Field
                  TextField(
                    controller: _recipientController,
                    decoration: InputDecoration(
                      labelText: 'To',
                      hintText: _recipientType == 'Class' 
                          ? 'Select class...' 
                          : 'Enter recipient...',
                      border: const OutlineInputBorder(),
                      suffixIcon: const Icon(Icons.person_search),
                    ),
                  ),
                  const SizedBox(height: 16),

                  // Subject Field
                  TextField(
                    controller: _subjectController,
                    decoration: const InputDecoration(
                      labelText: 'Subject',
                      hintText: 'Enter subject',
                      border: OutlineInputBorder(),
                    ),
                  ),
                  const SizedBox(height: 16),

                  // Message Field
                  TextField(
                    controller: _messageController,
                    maxLines: 10,
                    decoration: const InputDecoration(
                      labelText: 'Message',
                      hintText: 'Type your message...',
                      border: OutlineInputBorder(),
                      alignLabelWithHint: true,
                    ),
                  ),
                  const SizedBox(height: 32),
                ],
              ),
            ),
          ),
          // Action Buttons
          Container(
            padding: const EdgeInsets.all(24),
            decoration: BoxDecoration(
              color: theme.colorScheme.surface,
              boxShadow: [
                BoxShadow(
                  color: Colors.black.withValues(alpha: 0.1),
                  blurRadius: 10,
                  offset: const Offset(0, -5),
                ),
              ],
            ),
            child: Row(
              children: [
                Expanded(
                  child: OutlinedButton(
                    onPressed: () {
                      // Save as draft
                      Navigator.pop(context);
                      ScaffoldMessenger.of(context).showSnackBar(
                        const SnackBar(
                          content: Text('Message saved as draft'),
                        ),
                      );
                    },
                    style: OutlinedButton.styleFrom(
                      padding: const EdgeInsets.symmetric(vertical: 16),
                    ),
                    child: const Text('Save Draft'),
                  ),
                ),
                const SizedBox(width: 16),
                Expanded(
                  flex: 2,
                  child: FilledButton.icon(
                    onPressed: () {
                      // Send message
                      Navigator.pop(context);
                      ScaffoldMessenger.of(context).showSnackBar(
                        const SnackBar(
                          content: Text('Message sent successfully'),
                        ),
                      );
                    },
                    icon: const Icon(Icons.send),
                    label: const Text('Send'),
                    style: FilledButton.styleFrom(
                      padding: const EdgeInsets.symmetric(vertical: 16),
                    ),
                  ),
                ),
              ],
            ),
          ),
        ],
      ),
    );
  }
}
````

## File: lib/shared/models/nav_item.dart
````dart
import 'package:flutter/material.dart';

/// Navigation item model for customizable navigation
class NavItem {
  final String id;
  final String title;
  final String route;
  final IconData icon;
  final IconData activeIcon;
  final String category;
  final List<String> roles; // Which roles can use this item

  const NavItem({
    required this.id,
    required this.title,
    required this.route,
    required this.icon,
    required this.activeIcon,
    required this.category,
    required this.roles,
  });

  // Convert to/from JSON for storage
  Map<String, dynamic> toJson() => {
    'id': id,
    'title': title,
    'route': route,
    'icon': icon.codePoint,
    'activeIcon': activeIcon.codePoint,
    'category': category,
    'roles': roles,
  };

  factory NavItem.fromJson(Map<String, dynamic> json) => NavItem(
    id: json['id'],
    title: json['title'],
    route: json['route'],
    icon: IconData(json['icon'], fontFamily: 'MaterialIcons'),
    activeIcon: IconData(json['activeIcon'], fontFamily: 'MaterialIcons'),
    category: json['category'],
    roles: List<String>.from(json['roles']),
  );
}
````

## File: lib/shared/models/user_model.dart
````dart
import 'package:cloud_firestore/cloud_firestore.dart';

/// Enumeration representing the different user roles in the system.
/// 
/// Each user must have one of these roles which determines:
/// - Access permissions and available features
/// - Dashboard layout and navigation options
/// - Data visibility and modification rights
enum UserRole { teacher, student, admin }

/// Core user model representing authenticated users in the system.
/// 
/// This model serves as the central user representation throughout the app,
/// containing both common user properties and role-specific fields.
/// 
/// The model supports three user types:
/// 1. **Teachers**: Can create classes, assignments, and manage students
/// 2. **Students**: Can view assignments, submit work, and check grades
/// 3. **Admins**: Have system-wide access (future implementation)
/// 
/// Role-specific fields are nullable to allow a single model to represent
/// all user types while maintaining type safety.
class UserModel {
  /// Unique identifier from Firebase Authentication
  final String uid;
  
  /// User's email address (used for authentication)
  final String email;
  
  /// Full display name shown in the UI
  final String displayName;
  
  /// User's first name
  final String firstName;
  
  /// User's last name
  final String lastName;
  
  /// User's role in the system (optional for new/unconfigured users)
  final UserRole? role; // Made optional
  
  /// URL to user's profile photo (optional)
  final String? photoURL;
  
  /// Timestamp when the user account was created
  final DateTime createdAt;
  
  /// Timestamp of user's last activity
  final DateTime lastActive;
  
  /// Whether the user account is active
  final bool isActive;

  // Teacher-specific fields
  /// Unique teacher identifier (e.g., employee ID)
  final String? teacherId;
  
  /// List of class IDs that this teacher manages
  final List<String>? classIds;
  
  /// Teacher's department (e.g., "Mathematics", "Science")
  final String? department;

  // Student-specific fields
  /// Unique student identifier (e.g., student ID number)
  final String? studentId;
  
  /// Student's current grade level (1-12)
  final int? gradeLevel;
  
  /// Parent/guardian email for notifications
  final String? parentEmail;
  
  /// List of class IDs that this student is enrolled in
  final List<String>? enrolledClassIds;

  UserModel({
    required this.uid,
    required this.email,
    required this.displayName,
    required this.firstName,
    required this.lastName,
    this.role,
    this.photoURL,
    required this.createdAt,
    required this.lastActive,
    this.isActive = true,
    this.teacherId,
    this.classIds,
    this.department,
    this.studentId,
    this.gradeLevel,
    this.parentEmail,
    this.enrolledClassIds,
  });

  // Convenience getters
  /// Alias for displayName for backward compatibility
  String get name => displayName;
  
  /// Alias for photoURL for consistent naming convention
  String? get photoUrl => photoURL;

  /// Factory constructor to create UserModel from Firestore document.
  /// 
  /// Handles data validation and transformation including:
  /// - Legacy data migration (splitting displayName into firstName/lastName)
  /// - Type conversions for timestamps
  /// - Null safety for optional fields
  /// - Role enumeration parsing
  /// 
  /// @param doc Firestore document snapshot containing user data
  /// @return Parsed UserModel instance
  /// @throws Exception if required fields are missing
  factory UserModel.fromFirestore(DocumentSnapshot doc) {
    final data = doc.data() as Map<String, dynamic>;

    // Handle legacy data where firstName/lastName might not exist
    String firstName = data['firstName'] ?? '';
    String lastName = data['lastName'] ?? '';

    // If firstName/lastName are empty but displayName exists, try to split it
    if (firstName.isEmpty && lastName.isEmpty && data['displayName'] != null) {
      final nameParts = (data['displayName'] as String).split(' ');
      firstName = nameParts.isNotEmpty ? nameParts.first : '';
      lastName = nameParts.length > 1 ? nameParts.sublist(1).join(' ') : '';
    }

    return UserModel(
      uid: doc.id,
      email: data['email'] ?? '',
      displayName: data['displayName'] ?? '$firstName $lastName'.trim(),
      firstName: firstName,
      lastName: lastName,
      role: data['role'] != null
          ? UserRole.values.firstWhere(
              (r) => r.toString().split('.').last == data['role'],
              orElse: () => UserRole.teacher,
            )
          : null,
      photoURL: data['photoURL'],
      createdAt: data['createdAt'] != null
          ? (data['createdAt'] as Timestamp).toDate()
          : DateTime.now(),
      lastActive: data['lastActive'] != null
          ? (data['lastActive'] as Timestamp).toDate()
          : DateTime.now(),
      isActive: data['isActive'] ?? true,
      teacherId: data['teacherId'],
      classIds:
          data['classIds'] != null ? List<String>.from(data['classIds']) : null,
      department: data['department'],
      studentId: data['studentId'],
      gradeLevel: data['gradeLevel'],
      parentEmail: data['parentEmail'],
      enrolledClassIds: data['enrolledClassIds'] != null
          ? List<String>.from(data['enrolledClassIds'])
          : null,
    );
  }

  /// Converts the UserModel instance to a Map for Firestore storage.
  /// 
  /// This method serializes the model data for Firebase Firestore persistence.
  /// Only non-null role-specific fields are included to minimize storage usage.
  /// 
  /// Date fields are converted to Firestore Timestamp format.
  /// Role enum is converted to string representation without the enum prefix.
  /// 
  /// @return Map containing all user data ready for Firestore document update
  Map<String, dynamic> toFirestore() {
    return {
      'email': email,
      'displayName': displayName,
      'firstName': firstName,
      'lastName': lastName,
      if (role != null) 'role': role!.toString().split('.').last,
      'photoURL': photoURL,
      'createdAt': Timestamp.fromDate(createdAt),
      'lastActive': Timestamp.fromDate(lastActive),
      'isActive': isActive,
      if (teacherId != null) 'teacherId': teacherId,
      if (classIds != null) 'classIds': classIds,
      if (department != null) 'department': department,
      if (studentId != null) 'studentId': studentId,
      if (gradeLevel != null) 'gradeLevel': gradeLevel,
      if (parentEmail != null) 'parentEmail': parentEmail,
      if (enrolledClassIds != null) 'enrolledClassIds': enrolledClassIds,
    };
  }

  /// Creates a copy of the UserModel with updated fields.
  /// 
  /// This method follows the immutable data pattern, creating a new instance
  /// with selective field updates while preserving unchanged values.
  /// 
  /// Only fields provided as parameters will be updated in the new instance.
  /// All other fields retain their original values from the current instance.
  /// 
  /// Note: The uid, email, role, and createdAt fields cannot be changed
  /// through this method as they represent immutable user properties.
  /// 
  /// @param displayName New display name (optional)
  /// @param firstName New first name (optional)
  /// @param lastName New last name (optional)
  /// @param photoURL New photo URL (optional)
  /// @param lastActive New last active timestamp (optional)
  /// @param isActive New active status (optional)
  /// @param classIds New list of class IDs for teachers (optional)
  /// @param department New department for teachers (optional)
  /// @param gradeLevel New grade level for students (optional)
  /// @param parentEmail New parent email for students (optional)
  /// @param enrolledClassIds New list of enrolled classes for students (optional)
  /// @return New UserModel instance with updated fields
  UserModel copyWith({
    String? displayName,
    String? firstName,
    String? lastName,
    String? photoURL,
    DateTime? lastActive,
    bool? isActive,
    List<String>? classIds,
    String? department,
    int? gradeLevel,
    String? parentEmail,
    List<String>? enrolledClassIds,
  }) {
    return UserModel(
      uid: uid,
      email: email,
      displayName: displayName ?? this.displayName,
      firstName: firstName ?? this.firstName,
      lastName: lastName ?? this.lastName,
      role: role,
      photoURL: photoURL ?? this.photoURL,
      createdAt: createdAt,
      lastActive: lastActive ?? this.lastActive,
      isActive: isActive ?? this.isActive,
      teacherId: teacherId,
      classIds: classIds ?? this.classIds,
      department: department ?? this.department,
      studentId: studentId,
      gradeLevel: gradeLevel ?? this.gradeLevel,
      parentEmail: parentEmail ?? this.parentEmail,
      enrolledClassIds: enrolledClassIds ?? this.enrolledClassIds,
    );
  }

  /// Checks if the user has the teacher role.
  /// @return true if user role is teacher, false otherwise
  bool get isTeacher => role == UserRole.teacher;
  
  /// Checks if the user has the student role.
  /// @return true if user role is student, false otherwise
  bool get isStudent => role == UserRole.student;
  
  /// Checks if the user has the admin role.
  /// @return true if user role is admin, false otherwise
  bool get isAdmin => role == UserRole.admin;
  
  /// Checks if the user has any assigned role.
  /// @return true if role is not null, false if no role assigned
  bool get hasRole => role != null;
}
````

## File: lib/shared/providers/navigation_provider.dart
````dart
import 'package:flutter/widgets.dart';
import 'package:flutter/scheduler.dart';
import '../services/logger_service.dart';
import '../services/navigation_service.dart';
import '../models/nav_item.dart';

/// Provider for managing navigation favorites and customization
class NavigationProvider extends ChangeNotifier {
  List<String> _favoriteIds = [];
  bool _isLoading = false;
  String _currentRole = 'student';
  bool _initialized = false;

  List<String> get favoriteIds => _favoriteIds;
  bool get isLoading => _isLoading;
  
  List<NavItem> get favoriteItems => NavigationService.getFavoriteItems(_favoriteIds);
  List<NavItem> get availableItems => NavigationService.getItemsForRole(_currentRole);

  NavigationProvider() {
    // Initialize with default favorites to avoid empty state
    _favoriteIds = NavigationService.getDefaultFavorites(_currentRole);
  }

  /// Set the current user role
  void setRole(String role) {
    if (_currentRole != role || !_initialized) {
      _currentRole = role;
      _initialized = true;
      _loadFavorites();
    }
  }

  /// Load favorites from storage
  Future<void> _loadFavorites() async {
    _isLoading = true;
    
    // Notify listeners immediately if not in build phase
    // Otherwise, the async operation will naturally defer the notification
    if (WidgetsBinding.instance.schedulerPhase != SchedulerPhase.persistentCallbacks) {
      notifyListeners();
    }

    try {
      final savedFavorites = await NavigationService.loadFavorites();
      
      if (savedFavorites.isEmpty) {
        // Use defaults if no saved favorites
        _favoriteIds = NavigationService.getDefaultFavorites(_currentRole);
      } else {
        // Filter saved favorites to only include items available for current role
        final availableIds = NavigationService.getItemsForRole(_currentRole)
            .map((item) => item.id)
            .toSet();
        _favoriteIds = savedFavorites
            .where((id) => availableIds.contains(id))
            .take(NavigationService.maxFavorites)
            .toList();
        
        // If we have less than 4 favorites after filtering, add defaults
        if (_favoriteIds.length < NavigationService.maxFavorites) {
          final defaults = NavigationService.getDefaultFavorites(_currentRole);
          for (final defaultId in defaults) {
            if (!_favoriteIds.contains(defaultId) && 
                _favoriteIds.length < NavigationService.maxFavorites) {
              _favoriteIds.add(defaultId);
            }
          }
        }
      }
    } catch (e) {
      LoggerService.error('Error loading favorites', tag: 'NavigationProvider', error: e);
      _favoriteIds = NavigationService.getDefaultFavorites(_currentRole);
    }

    _isLoading = false;
    
    // Always notify listeners here since we're in an async callback
    notifyListeners();
  }

  /// Add item to favorites
  Future<bool> addFavorite(String itemId) async {
    if (_favoriteIds.contains(itemId) || 
        _favoriteIds.length >= NavigationService.maxFavorites) {
      return false;
    }

    _favoriteIds.add(itemId);
    notifyListeners();

    return await NavigationService.saveFavorites(_favoriteIds);
  }

  /// Remove item from favorites
  Future<bool> removeFavorite(String itemId) async {
    if (!_favoriteIds.contains(itemId)) {
      return false;
    }

    _favoriteIds.remove(itemId);
    notifyListeners();

    return await NavigationService.saveFavorites(_favoriteIds);
  }

  /// Reorder favorites
  Future<bool> reorderFavorites(int oldIndex, int newIndex) async {
    if (oldIndex < 0 || oldIndex >= _favoriteIds.length ||
        newIndex < 0 || newIndex > _favoriteIds.length) {
      return false;
    }

    if (oldIndex < newIndex) {
      newIndex -= 1;
    }

    final item = _favoriteIds.removeAt(oldIndex);
    _favoriteIds.insert(newIndex, item);
    notifyListeners();

    return await NavigationService.saveFavorites(_favoriteIds);
  }

  /// Replace a favorite at a specific index
  Future<bool> replaceFavorite(int index, String newItemId) async {
    if (index < 0 || index >= _favoriteIds.length) {
      return false;
    }

    _favoriteIds[index] = newItemId;
    notifyListeners();

    return await NavigationService.saveFavorites(_favoriteIds);
  }

  /// Reset to default favorites
  Future<bool> resetToDefaults() async {
    _favoriteIds = NavigationService.getDefaultFavorites(_currentRole);
    notifyListeners();

    return await NavigationService.saveFavorites(_favoriteIds);
  }

  /// Check if an item is a favorite
  bool isFavorite(String itemId) {
    return _favoriteIds.contains(itemId);
  }
}
````

## File: lib/shared/providers/theme_provider.dart
````dart
/// Theme management provider for application theming.
/// 
/// This module manages the application's theme state, handling dark/light
/// mode switching with persistent storage. Supports system preference
/// detection and manual theme overrides.
library;

import 'package:flutter/material.dart';
import 'package:shared_preferences/shared_preferences.dart';

/// Provider managing application theme state and persistence.
/// 
/// This provider serves as the central theme manager, coordinating
/// theme changes across the application. Key features:
/// - Light, dark, and system theme mode support
/// - Persistent theme preference storage
/// - Real-time theme switching with UI updates
/// - System brightness detection and adaptation
/// - Toggle functionality for quick theme switching
/// 
/// Theme preferences are automatically saved to SharedPreferences
/// and restored on application startup.
class ThemeProvider with ChangeNotifier {
  /// SharedPreferences key for storing theme preference.
  static const String _themeKey = 'theme_mode';
  
  /// Current theme mode (light, dark, or system).
  ThemeMode _themeMode = ThemeMode.system;
  
  /// Current theme mode setting.
  ThemeMode get themeMode => _themeMode;
  
  /// Whether the current effective theme is dark mode.
  /// 
  /// Resolves system theme mode by checking platform brightness.
  /// Returns actual dark mode state regardless of theme setting.
  bool get isDarkMode {
    if (_themeMode == ThemeMode.system) {
      // This will be determined by the system
      return WidgetsBinding.instance.platformDispatcher.platformBrightness == Brightness.dark;
    }
    return _themeMode == ThemeMode.dark;
  }
  
  /// Creates theme provider and loads saved preferences.
  /// 
  /// Automatically restores theme setting from persistent storage.
  ThemeProvider() {
    _loadTheme();
  }
  
  /// Loads theme preference from SharedPreferences.
  /// 
  /// Restores previously saved theme mode or defaults to system.
  /// Called during provider initialization.
  Future<void> _loadTheme() async {
    final prefs = await SharedPreferences.getInstance();
    final themeString = prefs.getString(_themeKey);
    
    if (themeString != null) {
      _themeMode = ThemeMode.values.firstWhere(
        (mode) => mode.toString() == themeString,
        orElse: () => ThemeMode.system,
      );
      notifyListeners();
    }
  }
  
  /// Toggles between light and dark theme modes.
  /// 
  /// Cycling behavior:
  /// - Light → Dark
  /// - Dark → Light
  /// - System → Opposite of current effective theme
  /// 
  /// Automatically saves preference and updates UI.
  Future<void> toggleTheme() async {
    if (_themeMode == ThemeMode.light) {
      _themeMode = ThemeMode.dark;
    } else if (_themeMode == ThemeMode.dark) {
      _themeMode = ThemeMode.light;
    } else {
      // If system, switch to the opposite of current
      _themeMode = isDarkMode ? ThemeMode.light : ThemeMode.dark;
    }
    
    final prefs = await SharedPreferences.getInstance();
    await prefs.setString(_themeKey, _themeMode.toString());
    notifyListeners();
  }
  
  /// Sets specific theme mode.
  /// 
  /// Allows direct setting to light, dark, or system mode.
  /// Automatically saves preference and updates UI.
  /// 
  /// @param mode Theme mode to set (light, dark, or system)
  Future<void> setThemeMode(ThemeMode mode) async {
    _themeMode = mode;
    final prefs = await SharedPreferences.getInstance();
    await prefs.setString(_themeKey, mode.toString());
    notifyListeners();
  }
}
````

## File: lib/shared/repositories/base_repository.dart
````dart
/// Base repository pattern for data access layer abstraction.
/// 
/// This abstract class defines the foundation for all repository
/// implementations in the education platform, providing a consistent
/// interface for resource management across different data sources.
library;

/// Base repository interface that all repositories should implement.
/// 
/// Repositories in this application follow the Repository pattern to:
/// - Abstract data access logic from business logic
/// - Enable easy switching between data sources
/// - Facilitate unit testing with mock implementations
/// - Provide a consistent API for data operations
/// 
/// All concrete repository implementations should extend this class
/// and implement domain-specific data access methods while inheriting
/// the common resource management functionality.
/// 
/// Example implementation:
/// ```dart
/// class UserRepository extends BaseRepository {
///   final FirebaseFirestore _firestore;
///   StreamSubscription? _subscription;
///   
///   UserRepository(this._firestore);
///   
///   Stream<User> getUser(String id) { ... }
///   
///   @override
///   void dispose() {
///     _subscription?.cancel();
///     super.dispose();
///   }
/// }
/// ```
abstract class BaseRepository {
  /// Clean up any resources used by the repository.
  /// 
  /// Override this method in concrete implementations to:
  /// - Cancel stream subscriptions
  /// - Close database connections
  /// - Clear caches or temporary data
  /// - Release any held resources
  /// 
  /// Always call super.dispose() when overriding to ensure
  /// proper cleanup chain execution.
  void dispose() {}
}
````

## File: lib/shared/repositories/firestore_repository_enhanced.dart
````dart
import 'package:cloud_firestore/cloud_firestore.dart';
import '../services/firestore_service_enhanced.dart';
import '../services/logger_service.dart';
import 'mixins/pagination_mixin.dart';
import 'base_repository.dart';

/// Enhanced base repository with pagination support.
/// 
/// This abstract class extends the base repository pattern to include
/// pagination capabilities while maintaining backward compatibility.
/// All repositories that need pagination should extend this class.
abstract class FirestoreRepositoryEnhanced<T> extends BaseRepository {
  /// Enhanced Firestore service with pagination
  late final FirestoreServiceEnhanced<T> _service;
  
  /// Logging tag for this repository
  final String tag;
  
  /// Function to serialize model instances into Firestore data
  late final Map<String, dynamic> Function(T) _toFirestore;
  
  /// Creates an enhanced repository with pagination support
  FirestoreRepositoryEnhanced({
    required FirebaseFirestore firestore,
    required String collectionPath,
    required T Function(DocumentSnapshot<Map<String, dynamic>>) fromFirestore,
    required Map<String, dynamic> Function(T) toFirestore,
    required this.tag,
  }) {
    _toFirestore = toFirestore;
    _service = FirestoreServiceEnhanced<T>(
      collectionPath: collectionPath,
      fromFirestore: (DocumentSnapshot doc) => fromFirestore(doc as DocumentSnapshot<Map<String, dynamic>>),
      toFirestore: toFirestore,
    );
  }
  
  /// Get paginated items from the collection.
  /// 
  /// @param pageSize Number of items per page
  /// @param startAfter Optional cursor for pagination
  /// @param orderBy Field to order by
  /// @param descending Whether to order descending
  /// @return PaginatedResult with items and metadata
  Future<PaginatedResult<T>> getPaginated({
    int pageSize = PaginationMixin.defaultPageSize,
    DocumentSnapshot? startAfter,
    String orderBy = 'createdAt',
    bool descending = true,
  }) async {
    try {
      LoggerService.info(
        'Getting paginated items (pageSize: $pageSize, orderBy: $orderBy)',
        tag: tag,
      );
      
      return await _service.getPaginated(
        pageSize: pageSize,
        startAfter: startAfter,
        orderBy: orderBy,
        descending: descending,
      );
    } catch (e) {
      LoggerService.error(
        'Failed to get paginated items',
        tag: tag,
        error: e,
      );
      rethrow;
    }
  }
  
  /// Get paginated stream of items.
  /// 
  /// Returns a stream that emits paginated results whenever
  /// the underlying data changes.
  Stream<PaginatedResult<T>> streamPaginated({
    int pageSize = PaginationMixin.defaultPageSize,
    DocumentSnapshot? startAfter,
    String orderBy = 'createdAt',
    bool descending = true,
  }) {
    LoggerService.info(
      'Starting paginated stream (pageSize: $pageSize, orderBy: $orderBy)',
      tag: tag,
    );
    
    return _service.streamPaginated(
      pageSize: pageSize,
      startAfter: startAfter,
      orderBy: orderBy,
      descending: descending,
    );
  }
  
  /// Query with pagination and filters.
  /// 
  /// Supports complex queries with multiple constraints.
  Future<PaginatedResult<T>> queryPaginated({
    required List<QueryConstraint> constraints,
    int pageSize = PaginationMixin.defaultPageSize,
    DocumentSnapshot? startAfter,
  }) async {
    try {
      LoggerService.info(
        'Executing paginated query (pageSize: $pageSize, constraints: ${constraints.length})',
        tag: tag,
      );
      
      return await _service.queryPaginated(
        constraints: constraints,
        pageSize: pageSize,
        startAfter: startAfter,
      );
    } catch (e) {
      LoggerService.error(
        'Failed to execute paginated query',
        tag: tag,
        error: e,
      );
      rethrow;
    }
  }
  
  // Standard CRUD operations (maintained for compatibility)
  
  /// Create a new document
  Future<String> create(T item) async {
    try {
      LoggerService.info('Creating new document', tag: tag);
      return await _service.create(_toFirestore(item));
    } catch (e) {
      LoggerService.error('Failed to create document', tag: tag, error: e);
      rethrow;
    }
  }
  
  /// Read a document by ID
  Future<T?> read(String id) async {
    try {
      LoggerService.info('Reading document (id: $id)', tag: tag);
      return await _service.get(id);
    } catch (e) {
      LoggerService.error('Failed to read document', tag: tag, error: e);
      rethrow;
    }
  }
  
  /// Update a document
  Future<void> update(String id, T item) async {
    try {
      LoggerService.info('Updating document (id: $id)', tag: tag);
      await _service.update(id, _toFirestore(item));
    } catch (e) {
      LoggerService.error('Failed to update document', tag: tag, error: e);
      rethrow;
    }
  }
  
  /// Delete a document
  Future<void> delete(String id) async {
    try {
      LoggerService.info('Deleting document (id: $id)', tag: tag);
      await _service.delete(id);
    } catch (e) {
      LoggerService.error('Failed to delete document', tag: tag, error: e);
      rethrow;
    }
  }
  
  /// Get all documents (DEPRECATED - use getPaginated instead)
  @Deprecated('Use getPaginated() for better performance')
  Future<List<T>> getAll() async {
    LoggerService.warning(
      'getAll() is deprecated. Consider using getPaginated() for better performance.',
      tag: tag,
    );
    
    // Load all using pagination internally
    final result = await _service.getAll();
    return result;
  }
  
  /// Stream all documents
  Stream<List<T>> streamAll() {
    LoggerService.info('Starting stream for all documents', tag: tag);
    return _service.query();
  }
  
  /// Query documents
  Future<List<T>> query({
    required String field,
    required dynamic isEqualTo,
  }) async {
    try {
      LoggerService.info(
        'Querying documents (field: $field, value: $isEqualTo)',
        tag: tag,
      );
      
      // Use pagination for queries too
      final result = await _service.getPaginated(
        where: field,
        isEqualTo: isEqualTo,
        pageSize: PaginationMixin.maxPageSize,
      );
      
      return result.items;
    } catch (e) {
      LoggerService.error('Failed to query documents', tag: tag, error: e);
      rethrow;
    }
  }
  
  /// Batch write operations
  Future<void> batchWrite(List<BatchOperation<T>> operations) async {
    try {
      LoggerService.info(
        'Executing batch write (operations: ${operations.length})',
        tag: tag,
      );
      
      final batch = FirebaseFirestore.instance.batch();
      
      for (final op in operations) {
        final docRef = _service.collection.doc(op.id);
        
        switch (op.type) {
          case BatchOperationType.create:
            batch.set(docRef, _toFirestore(op.data as T));
            break;
          case BatchOperationType.update:
            batch.update(docRef, _toFirestore(op.data as T));
            break;
          case BatchOperationType.delete:
            batch.delete(docRef);
            break;
        }
      }
      
      await batch.commit();
      LoggerService.info('Batch write completed successfully', tag: tag);
    } catch (e) {
      LoggerService.error('Failed to execute batch write', tag: tag, error: e);
      rethrow;
    }
  }
  
  @override
  void dispose() {
    LoggerService.info('Disposing repository', tag: tag);
    super.dispose();
  }
}

/// Batch operation types
enum BatchOperationType { create, update, delete }

/// Batch operation container
class BatchOperation<T> {
  final String? id;
  final BatchOperationType type;
  final T? data;
  
  const BatchOperation({
    this.id,
    required this.type,
    this.data,
  });
}
````

## File: lib/shared/repositories/firestore_repository.dart
````dart
/// Generic Firestore repository implementation with comprehensive logging.
/// 
/// This module provides an abstract repository that wraps FirestoreService
/// with additional features like automatic logging, error handling, and
/// a consistent interface for data access operations.
library;

import 'package:cloud_firestore/cloud_firestore.dart';
import '../services/firestore_service.dart';
import '../services/logger_service.dart';
import 'base_repository.dart';

/// Generic Firestore repository that provides common CRUD operations.
/// 
/// This abstract class serves as a foundation for concrete repositories,
/// offering:
/// - Type-safe CRUD operations with generic typing
/// - Automatic logging of all data operations
/// - Comprehensive error handling with stack traces
/// - Query support with filtering and ordering
/// - Real-time streaming capabilities
/// - Integration with FirestoreService for data persistence
/// 
/// Concrete repositories should extend this class and provide
/// domain-specific methods while leveraging the base functionality.
/// 
/// @param T The type of model this repository manages
abstract class FirestoreRepository<T> extends BaseRepository {
  /// Underlying service for Firestore operations.
  final FirestoreService<T> _firestoreService;
  
  /// Logging tag for identifying repository operations.
  final String tag;
  
  /// Creates a generic Firestore repository instance.
  /// 
  /// Initializes the repository with required configuration for
  /// data serialization and collection management.
  /// 
  /// @param firestore Firestore instance for database access
  /// @param collectionPath Path to the Firestore collection
  /// @param fromFirestore Function to deserialize documents to models
  /// @param toFirestore Function to serialize models to documents
  /// @param logTag Optional custom tag for logging (defaults to class name)
  FirestoreRepository({
    required FirebaseFirestore firestore,
    required String collectionPath,
    required T Function(DocumentSnapshot doc) fromFirestore,
    required Map<String, dynamic> Function(T item) toFirestore,
    String? logTag,
  })  : _firestoreService = FirestoreService<T>(
          firestore: firestore,
          collectionPath: collectionPath,
          fromFirestore: fromFirestore,
          toFirestore: toFirestore,
        ),
        tag = logTag ?? 'FirestoreRepository<$T>';
  
  /// Creates a new document in Firestore.
  /// 
  /// Serializes the provided model and creates a new document
  /// with an auto-generated ID. Logs the operation and provides
  /// comprehensive error handling.
  /// 
  /// @param item Model instance to create
  /// @return Generated document ID
  /// @throws Exception if creation fails
  Future<String> create(T item) async {
    try {
      LoggerService.debug('Creating document', tag: tag);
      return await _firestoreService.create(_firestoreService.toFirestore(item));
    } catch (e, stackTrace) {
      LoggerService.error(
        'Failed to create document',
        tag: tag,
        error: e,
        stackTrace: stackTrace,
      );
      rethrow;
    }
  }  
  /// Reads a document by ID from Firestore.
  /// 
  /// Retrieves and deserializes a single document. Returns null
  /// if the document doesn't exist. Includes logging and error
  /// handling for debugging.
  /// 
  /// @param id Document ID to retrieve
  /// @return Deserialized model or null if not found
  /// @throws Exception if read operation fails
  Future<T?> read(String id) async {
    try {
      LoggerService.debug('Reading document: $id', tag: tag);
      return await _firestoreService.get(id);
    } catch (e, stackTrace) {
      LoggerService.error(
        'Failed to read document: $id',
        tag: tag,
        error: e,
        stackTrace: stackTrace,
      );
      rethrow;
    }
  }
  
  /// Updates an existing document in Firestore.
  /// 
  /// Serializes the model and overwrites the document with
  /// the specified ID. The document must exist or the operation
  /// will fail. Includes comprehensive logging.
  /// 
  /// @param id Document ID to update
  /// @param item Updated model instance
  /// @throws Exception if update fails or document doesn't exist
  Future<void> update(String id, T item) async {
    try {
      LoggerService.debug('Updating document: $id', tag: tag);
      await _firestoreService.update(id, _firestoreService.toFirestore(item));
    } catch (e, stackTrace) {
      LoggerService.error(
        'Failed to update document: $id',
        tag: tag,
        error: e,
        stackTrace: stackTrace,
      );
      rethrow;
    }
  }  
  /// Deletes a document from Firestore.
  /// 
  /// Permanently removes the document with the specified ID.
  /// This operation cannot be undone. Logs the deletion for
  /// audit purposes.
  /// 
  /// @param id Document ID to delete
  /// @throws Exception if deletion fails
  Future<void> delete(String id) async {
    try {
      LoggerService.debug('Deleting document: $id', tag: tag);
      await _firestoreService.delete(id);
    } catch (e, stackTrace) {
      LoggerService.error(
        'Failed to delete document: $id',
        tag: tag,
        error: e,
        stackTrace: stackTrace,
      );
      rethrow;
    }
  }
  
  /// Lists documents with optional filtering and ordering.
  /// 
  /// Performs a one-time query to retrieve documents matching
  /// the specified conditions. Results can be filtered, ordered,
  /// and limited. Uses the stream API internally but returns
  /// only the first emission.
  /// 
  /// @param conditions Optional query filters
  /// @param orderBy Optional sorting specifications
  /// @param limit Optional result count limit
  /// @return List of matching documents
  /// @throws Exception if query fails
  Future<List<T>> list({
    List<QueryCondition>? conditions,
    List<OrderBy>? orderBy,
    int? limit,
  }) async {
    try {
      LoggerService.debug('Listing documents', tag: tag);
      final stream = _firestoreService.query(
        conditions: conditions,
        orderBy: orderBy,
        limit: limit,
      );
      return await stream.first;
    } catch (e, stackTrace) {
      LoggerService.error(
        'Failed to list documents',
        tag: tag,
        error: e,
        stackTrace: stackTrace,
      );
      rethrow;
    }
  }
  
  /// Streams documents with real-time updates.
  /// 
  /// Creates a stream that emits document lists whenever
  /// matching documents change in Firestore. Supports the
  /// same filtering and ordering options as list().
  /// 
  /// The stream continues emitting updates until cancelled.
  /// Remember to cancel subscriptions to prevent memory leaks.
  /// 
  /// @param conditions Optional query filters
  /// @param orderBy Optional sorting specifications  
  /// @param limit Optional result count limit
  /// @return Stream of document lists with real-time updates
  Stream<List<T>> stream({
    List<QueryCondition>? conditions,
    List<OrderBy>? orderBy,
    int? limit,
  }) {
    LoggerService.debug('Streaming documents', tag: tag);
    return _firestoreService.query(
      conditions: conditions,
      orderBy: orderBy,
      limit: limit,
    );
  }
  
  /// Gets the underlying FirestoreService for advanced operations.
  /// 
  /// Provides access to the wrapped service for operations not
  /// covered by the repository interface, such as batch operations
  /// or complex queries.
  /// 
  /// @return The internal FirestoreService instance
  FirestoreService<T> get service => _firestoreService;
}
````

## File: lib/shared/repositories/mixins/pagination_mixin.dart
````dart
import 'package:cloud_firestore/cloud_firestore.dart';

/// Mixin providing pagination functionality for Firestore repositories.
/// 
/// This mixin adds pagination capabilities to repository classes,
/// enabling efficient data loading for large collections while
/// maintaining performance and reducing bandwidth usage.
/// 
/// Features:
/// - Cursor-based pagination for consistent results
/// - Configurable page sizes
/// - Support for ordering and filtering
/// - Automatic query management
/// - Error handling and recovery
/// 
/// Example usage:
/// ```dart
/// class UserRepository extends BaseRepository with PaginationMixin {
///   Future<PaginatedResult<User>> getUsers({
///     int pageSize = 20,
///     DocumentSnapshot? startAfter,
///   }) async {
///     final query = FirebaseFirestore.instance
///         .collection('users')
///         .orderBy('createdAt', descending: true);
///     
///     return getPaginatedData(
///       query: query,
///       pageSize: pageSize,
///       startAfter: startAfter,
///       fromFirestore: (doc) => User.fromFirestore(doc),
///     );
///   }
/// }
/// ```
mixin PaginationMixin {
  /// Default page size if not specified
  static const int defaultPageSize = 20;
  
  /// Maximum allowed page size to prevent performance issues
  static const int maxPageSize = 100;

  /// Get paginated data from a Firestore query.
  /// 
  /// This method handles the common pagination logic for Firestore queries,
  /// including cursor management, result mapping, and metadata generation.
  /// 
  /// @param query The base Firestore query (must include orderBy)
  /// @param fromFirestore Function to convert DocumentSnapshot to model
  /// @param pageSize Number of documents per page
  /// @param startAfter Optional cursor for pagination continuation
  /// @return PaginatedResult containing data and pagination metadata
  Future<PaginatedResult<T>> getPaginatedData<T>({
    required Query query,
    required T Function(DocumentSnapshot) fromFirestore,
    int pageSize = defaultPageSize,
    DocumentSnapshot? startAfter,
  }) async {
    // Validate and constrain page size
    final effectivePageSize = pageSize.clamp(1, maxPageSize);
    
    // Apply pagination cursor if provided
    Query paginatedQuery = query.limit(effectivePageSize + 1); // +1 to check hasMore
    if (startAfter != null) {
      paginatedQuery = paginatedQuery.startAfterDocument(startAfter);
    }
    
    try {
      final snapshot = await paginatedQuery.get();
      final docs = snapshot.docs;
      
      // Check if there are more pages
      final hasMore = docs.length > effectivePageSize;
      
      // Remove the extra document used for hasMore check
      final resultDocs = hasMore 
          ? docs.sublist(0, effectivePageSize)
          : docs;
      
      // Map documents to models
      final items = resultDocs.map((doc) => fromFirestore(doc)).toList();
      
      return PaginatedResult<T>(
        items: items,
        hasMore: hasMore,
        lastDocument: resultDocs.isNotEmpty ? resultDocs.last : null,
        pageSize: effectivePageSize,
        totalFetched: items.length,
      );
    } catch (e) {
      // Return empty result on error
      return PaginatedResult<T>(
        items: [],
        hasMore: false,
        lastDocument: null,
        pageSize: effectivePageSize,
        totalFetched: 0,
        error: e.toString(),
      );
    }
  }

  /// Get paginated stream of data from Firestore.
  /// 
  /// Creates a stream that emits paginated results whenever the underlying
  /// data changes. Useful for real-time pagination scenarios.
  /// 
  /// @param query The base Firestore query (must include orderBy)
  /// @param fromFirestore Function to convert DocumentSnapshot to model
  /// @param pageSize Number of documents per page
  /// @param startAfter Optional cursor for pagination continuation
  /// @return Stream of PaginatedResult
  Stream<PaginatedResult<T>> getPaginatedStream<T>({
    required Query query,
    required T Function(DocumentSnapshot) fromFirestore,
    int pageSize = defaultPageSize,
    DocumentSnapshot? startAfter,
  }) {
    // Validate and constrain page size
    final effectivePageSize = pageSize.clamp(1, maxPageSize);
    
    // Apply pagination
    Query paginatedQuery = query.limit(effectivePageSize + 1);
    if (startAfter != null) {
      paginatedQuery = paginatedQuery.startAfterDocument(startAfter);
    }
    
    return paginatedQuery.snapshots().map((snapshot) {
      final docs = snapshot.docs;
      
      // Check if there are more pages
      final hasMore = docs.length > effectivePageSize;
      
      // Remove the extra document
      final resultDocs = hasMore 
          ? docs.sublist(0, effectivePageSize)
          : docs;
      
      // Map to models
      final items = resultDocs.map((doc) => fromFirestore(doc)).toList();
      
      return PaginatedResult<T>(
        items: items,
        hasMore: hasMore,
        lastDocument: resultDocs.isNotEmpty ? resultDocs.last : null,
        pageSize: effectivePageSize,
        totalFetched: items.length,
      );
    }).handleError((error) {
      // Emit error result
      return PaginatedResult<T>(
        items: [],
        hasMore: false,
        lastDocument: null,
        pageSize: effectivePageSize,
        totalFetched: 0,
        error: error.toString(),
      );
    });
  }

  /// Load all pages of data sequentially.
  /// 
  /// WARNING: Use with caution for large datasets. This method loads
  /// all documents from a collection, which can be expensive and slow.
  /// Consider using regular pagination for better performance.
  /// 
  /// @param query The base Firestore query
  /// @param fromFirestore Function to convert DocumentSnapshot to model
  /// @param onProgress Optional callback for progress updates
  /// @return List of all items in the collection
  Future<List<T>> getAllPaginated<T>({
    required Query query,
    required T Function(DocumentSnapshot) fromFirestore,
    void Function(int fetched, int total)? onProgress,
  }) async {
    final allItems = <T>[];
    DocumentSnapshot? lastDoc;
    bool hasMore = true;
    
    while (hasMore) {
      final result = await getPaginatedData(
        query: query,
        fromFirestore: fromFirestore,
        pageSize: maxPageSize, // Use max for efficiency
        startAfter: lastDoc,
      );
      
      allItems.addAll(result.items);
      hasMore = result.hasMore;
      lastDoc = result.lastDocument;
      
      // Report progress if callback provided
      onProgress?.call(allItems.length, -1); // -1 indicates unknown total
      
      // Add small delay to prevent rate limiting
      if (hasMore) {
        await Future.delayed(const Duration(milliseconds: 100));
      }
    }
    
    return allItems;
  }
}

/// Result container for paginated queries.
/// 
/// Contains the fetched items along with pagination metadata
/// needed to fetch subsequent pages.
class PaginatedResult<T> {
  /// List of items in this page
  final List<T> items;
  
  /// Whether more pages are available
  final bool hasMore;
  
  /// Last document in this page (cursor for next page)
  final DocumentSnapshot? lastDocument;
  
  /// Page size used for this query
  final int pageSize;
  
  /// Number of items actually fetched
  final int totalFetched;
  
  /// Error message if query failed
  final String? error;
  
  /// Whether the query succeeded
  bool get isSuccess => error == null;
  
  /// Whether this is the last page
  bool get isLastPage => !hasMore;
  
  /// Whether this page is empty
  bool get isEmpty => items.isEmpty;

  const PaginatedResult({
    required this.items,
    required this.hasMore,
    required this.lastDocument,
    required this.pageSize,
    required this.totalFetched,
    this.error,
  });
  
  /// Create a copy with updated fields
  PaginatedResult<T> copyWith({
    List<T>? items,
    bool? hasMore,
    DocumentSnapshot? lastDocument,
    int? pageSize,
    int? totalFetched,
    String? error,
  }) {
    return PaginatedResult<T>(
      items: items ?? this.items,
      hasMore: hasMore ?? this.hasMore,
      lastDocument: lastDocument ?? this.lastDocument,
      pageSize: pageSize ?? this.pageSize,
      totalFetched: totalFetched ?? this.totalFetched,
      error: error ?? this.error,
    );
  }
}

/// Extension methods for Query to support pagination
extension QueryPaginationExtension on Query {
  /// Apply pagination parameters to a query
  Query paginate({
    required int pageSize,
    DocumentSnapshot? startAfter,
  }) {
    Query query = limit(pageSize);
    if (startAfter != null) {
      query = query.startAfterDocument(startAfter);
    }
    return query;
  }
}
````

## File: lib/shared/screens/common/common/placeholder_screen.dart
````dart
import 'package:flutter/material.dart';

/// Generic placeholder screen for features under development.
/// 
/// This reusable widget displays a consistent "under construction" message
/// for screens that haven't been implemented yet. It helps maintain
/// navigation flow during development while clearly indicating to users
/// that the feature is not yet available.
/// 
/// Usage:
/// ```dart
/// PlaceholderScreen(title: 'Calendar')
/// ```
/// 
/// @param title The title to display in the app bar and content
class PlaceholderScreen extends StatelessWidget {
  final String title;

  const PlaceholderScreen({
    super.key,
    required this.title,
  });

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: Text(title),
      ),
      body: Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Icon(
              Icons.construction,
              size: 64,
              color: Theme.of(context).colorScheme.primary,
            ),
            const SizedBox(height: 16),
            Text(
              title,
              style: Theme.of(context).textTheme.headlineSmall,
            ),
            const SizedBox(height: 8),
            Text(
              'This screen is under construction',
              style: Theme.of(context).textTheme.bodyLarge?.copyWith(
                    color: Theme.of(context).colorScheme.onSurfaceVariant,
                  ),
            ),
          ],
        ),
      ),
    );
  }
}
````

## File: lib/shared/screens/help_screen.dart
````dart
import 'package:flutter/material.dart';
import '../widgets/common/adaptive_layout.dart';
import '../widgets/common/responsive_layout.dart';

class HelpScreen extends StatefulWidget {
  const HelpScreen({super.key});

  @override
  State<HelpScreen> createState() => _HelpScreenState();
}

class _HelpScreenState extends State<HelpScreen> with SingleTickerProviderStateMixin {
  late TabController _tabController;
  final _searchController = TextEditingController();
  String _searchQuery = '';

  @override
  void initState() {
    super.initState();
    _tabController = TabController(length: 4, vsync: this, initialIndex: 0);
  }

  @override
  void dispose() {
    _tabController.dispose();
    _searchController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return AdaptiveLayout(
      title: 'Help & Support',
      showBackButton: true,
      actions: [
        IconButton(
          icon: const Icon(Icons.contact_support),
          onPressed: () => _showContactSupport(context),
          tooltip: 'Contact Support',
        ),
      ],
      bottom: TabBar(
        controller: _tabController,
        tabs: const [
          Tab(text: 'FAQ', icon: Icon(Icons.help_outline)),
          Tab(text: 'Guides', icon: Icon(Icons.menu_book)),
          Tab(text: 'Videos', icon: Icon(Icons.play_circle_outline)),
          Tab(text: 'Feedback', icon: Icon(Icons.feedback_outlined)),
        ],
        isScrollable: true,
      ),
      body: Column(
        children: [
          // Search Bar
          Container(
            padding: const EdgeInsets.all(16),
            child: TextField(
              controller: _searchController,
              decoration: InputDecoration(
                hintText: 'Search help topics...',
                prefixIcon: const Icon(Icons.search),
                suffixIcon: _searchController.text.isNotEmpty
                    ? IconButton(
                        icon: const Icon(Icons.clear),
                        onPressed: () {
                          setState(() {
                            _searchController.clear();
                            _searchQuery = '';
                          });
                        },
                      )
                    : null,
                border: const OutlineInputBorder(),
                contentPadding: const EdgeInsets.symmetric(
                  horizontal: 16,
                  vertical: 12,
                ),
              ),
              onChanged: (value) {
                setState(() {
                  _searchQuery = value;
                });
              },
            ),
          ),
          // Tab Content
          Expanded(
            child: TabBarView(
              controller: _tabController,
              children: [
                _buildFAQTab(),
                _buildGuidesTab(),
                _buildVideosTab(),
                _buildFeedbackTab(),
              ],
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildFAQTab() {
    final faqs = [
      {
        'category': 'Getting Started',
        'questions': [
          {
            'question': 'How do I log in to my account?',
            'answer': 'Use your school-provided email and password to log in. If you forgot your password, click "Forgot Password" on the login screen.',
          },
          {
            'question': 'How do I change my password?',
            'answer': 'Go to Settings > Security & Privacy > Change Password. You\'ll need to enter your current password and a new password.',
          },
          {
            'question': 'What browsers are supported?',
            'answer': 'The Teacher Dashboard works best on modern browsers like Chrome, Firefox, Safari, and Edge. Make sure your browser is up to date.',
          },
        ],
      },
      {
        'category': 'Grades & Assignments',
        'questions': [
          {
            'question': 'How do I view my grades?',
            'answer': 'Navigate to the Grades section from the main dashboard. You can filter by course, assignment type, or search for specific assignments.',
          },
          {
            'question': 'When will new grades appear?',
            'answer': 'Grades typically appear within 24-48 hours after your teacher enters them. You\'ll receive a notification when new grades are posted.',
          },
          {
            'question': 'How do I submit an assignment?',
            'answer': 'Go to Assignments, find your assignment, and click "Submit". Follow the prompts to upload files or enter text responses.',
          },
          {
            'question': 'Can I resubmit an assignment?',
            'answer': 'This depends on your teacher\'s settings. Some assignments allow resubmission before the due date, while others do not.',
          },
        ],
      },
      {
        'category': 'Messages & Communication',
        'questions': [
          {
            'question': 'How do I message my teacher?',
            'answer': 'Go to Messages and click "Compose". Select your teacher from the recipient list and type your message.',
          },
          {
            'question': 'Can parents see my messages?',
            'answer': 'No, direct messages between students and teachers are private. However, teachers may contact parents separately about academic matters.',
          },
          {
            'question': 'How do I get notifications?',
            'answer': 'Enable notifications in Settings > Notifications. You can choose to receive push notifications, emails, or both.',
          },
        ],
      },
      {
        'category': 'Technical Issues',
        'questions': [
          {
            'question': 'The app is running slowly. What can I do?',
            'answer': 'Try clearing your browser cache, closing other tabs, or restarting your browser. Make sure you have a stable internet connection.',
          },
          {
            'question': 'I can\'t upload files. What\'s wrong?',
            'answer': 'Check that your file is under the size limit (usually 10MB) and in a supported format. Try using a different browser if the problem persists.',
          },
          {
            'question': 'The page won\'t load. What should I do?',
            'answer': 'Refresh the page, check your internet connection, and try logging out and back in. If the problem continues, contact support.',
          },
        ],
      },
    ];

    final filteredFAQs = _searchQuery.isEmpty
        ? faqs
        : faqs.map((category) {
            final filteredQuestions = category['questions'] as List;
            final matchingQuestions = filteredQuestions.where((q) {
              final question = q['question'] as String;
              final answer = q['answer'] as String;
              return question.toLowerCase().contains(_searchQuery.toLowerCase()) ||
                     answer.toLowerCase().contains(_searchQuery.toLowerCase());
            }).toList();
            
            return {
              'category': category['category'],
              'questions': matchingQuestions,
            };
          }).where((category) => (category['questions'] as List).isNotEmpty).toList();

    return ResponsiveContainer(
      child: ListView.builder(
        padding: const EdgeInsets.all(16),
        itemCount: filteredFAQs.length,
        itemBuilder: (context, index) {
          final category = filteredFAQs[index];
          return _buildFAQCategory(category);
        },
      ),
    );
  }

  Widget _buildFAQCategory(Map<String, dynamic> category) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Padding(
          padding: const EdgeInsets.symmetric(vertical: 16),
          child: Text(
            category['category'] as String,
            style: Theme.of(context).textTheme.titleLarge?.copyWith(
              fontWeight: FontWeight.bold,
              color: Theme.of(context).colorScheme.primary,
            ),
          ),
        ),
        ...((category['questions'] as List).map((q) => _buildFAQItem(q)).toList()),
        const SizedBox(height: 24),
      ],
    );
  }

  Widget _buildFAQItem(Map<String, String> faq) {
    return Card(
      margin: const EdgeInsets.only(bottom: 8),
      child: ExpansionTile(
        title: Text(
          faq['question']!,
          style: Theme.of(context).textTheme.titleMedium?.copyWith(
            fontWeight: FontWeight.w600,
          ),
        ),
        children: [
          Padding(
            padding: const EdgeInsets.all(16),
            child: Text(
              faq['answer']!,
              style: Theme.of(context).textTheme.bodyMedium?.copyWith(
                color: Theme.of(context).colorScheme.onSurfaceVariant,
              ),
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildGuidesTab() {
    final guides = [
      {
        'title': 'Getting Started Guide',
        'description': 'Learn the basics of using the Teacher Dashboard',
        'icon': Icons.rocket_launch,
        'duration': '5 min read',
        'sections': [
          'Setting up your profile',
          'Navigating the dashboard',
          'Understanding the main features',
          'Customizing your settings',
        ],
      },
      {
        'title': 'Student Guide to Grades',
        'description': 'Everything you need to know about viewing and understanding your grades',
        'icon': Icons.grade,
        'duration': '8 min read',
        'sections': [
          'Viewing your current grades',
          'Understanding grade calculations',
          'Tracking assignment progress',
          'Grade history and trends',
        ],
      },
      {
        'title': 'Assignment Submission Guide',
        'description': 'Step-by-step instructions for submitting assignments',
        'icon': Icons.assignment,
        'duration': '6 min read',
        'sections': [
          'Finding your assignments',
          'Uploading files and documents',
          'Text-based submissions',
          'Late submission policies',
        ],
      },
      {
        'title': 'Communication Best Practices',
        'description': 'How to effectively communicate with teachers and classmates',
        'icon': Icons.message,
        'duration': '4 min read',
        'sections': [
          'Writing professional messages',
          'When to message vs. email',
          'Response time expectations',
          'Emergency contact procedures',
        ],
      },
      {
        'title': 'Calendar and Scheduling',
        'description': 'Managing your academic schedule effectively',
        'icon': Icons.calendar_today,
        'duration': '7 min read',
        'sections': [
          'Viewing your class schedule',
          'Important dates and deadlines',
          'Setting up reminders',
          'Syncing with external calendars',
        ],
      },
      {
        'title': 'Mobile App Features',
        'description': 'Getting the most out of the mobile experience',
        'icon': Icons.phone_android,
        'duration': '5 min read',
        'sections': [
          'Installing the mobile app',
          'Offline functionality',
          'Push notifications setup',
          'Mobile-specific features',
        ],
      },
    ];

    return ResponsiveContainer(
      child: ListView.builder(
        padding: const EdgeInsets.all(16),
        itemCount: guides.length,
        itemBuilder: (context, index) {
          final guide = guides[index];
          return _buildGuideCard(guide);
        },
      ),
    );
  }

  Widget _buildGuideCard(Map<String, dynamic> guide) {
    return Card(
      margin: const EdgeInsets.only(bottom: 16),
      child: InkWell(
        onTap: () => _showGuideDetail(guide),
        borderRadius: BorderRadius.circular(12),
        child: Padding(
          padding: const EdgeInsets.all(16),
          child: Row(
            children: [
              Container(
                padding: const EdgeInsets.all(12),
                decoration: BoxDecoration(
                  color: Theme.of(context).colorScheme.primaryContainer,
                  borderRadius: BorderRadius.circular(12),
                ),
                child: Icon(
                  guide['icon'] as IconData,
                  color: Theme.of(context).colorScheme.onPrimaryContainer,
                  size: 24,
                ),
              ),
              const SizedBox(width: 16),
              Expanded(
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Text(
                      guide['title'] as String,
                      style: Theme.of(context).textTheme.titleMedium?.copyWith(
                        fontWeight: FontWeight.bold,
                      ),
                    ),
                    const SizedBox(height: 4),
                    Text(
                      guide['description'] as String,
                      style: Theme.of(context).textTheme.bodyMedium?.copyWith(
                        color: Theme.of(context).colorScheme.onSurfaceVariant,
                      ),
                    ),
                    const SizedBox(height: 8),
                    Row(
                      children: [
                        Icon(
                          Icons.access_time,
                          size: 16,
                          color: Theme.of(context).colorScheme.primary,
                        ),
                        const SizedBox(width: 4),
                        Text(
                          guide['duration'] as String,
                          style: Theme.of(context).textTheme.bodySmall?.copyWith(
                            color: Theme.of(context).colorScheme.primary,
                            fontWeight: FontWeight.w500,
                          ),
                        ),
                      ],
                    ),
                  ],
                ),
              ),
              const Icon(Icons.chevron_right),
            ],
          ),
        ),
      ),
    );
  }

  Widget _buildVideosTab() {
    final videos = [
      {
        'title': 'Teacher Dashboard Overview',
        'description': 'A complete walkthrough of the Teacher Dashboard interface',
        'duration': '12:34',
        'thumbnail': 'overview',
        'category': 'Getting Started',
      },
      {
        'title': 'How to Submit Assignments',
        'description': 'Step-by-step guide to submitting your homework and projects',
        'duration': '8:45',
        'thumbnail': 'assignments',
        'category': 'Assignments',
      },
      {
        'title': 'Understanding Your Grades',
        'description': 'Learn how grades are calculated and how to track your progress',
        'duration': '15:20',
        'thumbnail': 'grades',
        'category': 'Grades',
      },
      {
        'title': 'Messaging Your Teachers',
        'description': 'Best practices for communicating with your instructors',
        'duration': '6:12',
        'thumbnail': 'messaging',
        'category': 'Communication',
      },
      {
        'title': 'Mobile App Tutorial',
        'description': 'Get the most out of the Teacher Dashboard mobile app',
        'duration': '10:30',
        'thumbnail': 'mobile',
        'category': 'Mobile',
      },
      {
        'title': 'Troubleshooting Common Issues',
        'description': 'Solutions to frequently encountered problems',
        'duration': '14:18',
        'thumbnail': 'troubleshooting',
        'category': 'Support',
      },
    ];

    return ResponsiveContainer(
      child: ListView.builder(
        padding: const EdgeInsets.all(16),
        itemCount: videos.length,
        itemBuilder: (context, index) {
          final video = videos[index];
          return _buildVideoCard(video);
        },
      ),
    );
  }

  Widget _buildVideoCard(Map<String, String> video) {
    return Card(
      margin: const EdgeInsets.only(bottom: 16),
      child: InkWell(
        onTap: () => _playVideo(video),
        borderRadius: BorderRadius.circular(12),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            // Video Thumbnail
            Container(
              height: 180,
              decoration: BoxDecoration(
                color: Theme.of(context).colorScheme.surfaceContainerHighest,
                borderRadius: const BorderRadius.vertical(top: Radius.circular(12)),
              ),
              child: Stack(
                children: [
                  Center(
                    child: Icon(
                      Icons.play_circle_filled,
                      size: 64,
                      color: Theme.of(context).colorScheme.primary,
                    ),
                  ),
                  Positioned(
                    bottom: 8,
                    right: 8,
                    child: Container(
                      padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
                      decoration: BoxDecoration(
                        color: Colors.black.withValues(alpha: 0.7),
                        borderRadius: BorderRadius.circular(4),
                      ),
                      child: Text(
                        video['duration']!,
                        style: const TextStyle(
                          color: Colors.white,
                          fontSize: 12,
                          fontWeight: FontWeight.w500,
                        ),
                      ),
                    ),
                  ),
                ],
              ),
            ),
            // Video Info
            Padding(
              padding: const EdgeInsets.all(16),
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Container(
                    padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
                    decoration: BoxDecoration(
                      color: Theme.of(context).colorScheme.secondaryContainer,
                      borderRadius: BorderRadius.circular(12),
                    ),
                    child: Text(
                      video['category']!,
                      style: Theme.of(context).textTheme.labelSmall?.copyWith(
                        color: Theme.of(context).colorScheme.onSecondaryContainer,
                        fontWeight: FontWeight.w600,
                      ),
                    ),
                  ),
                  const SizedBox(height: 8),
                  Text(
                    video['title']!,
                    style: Theme.of(context).textTheme.titleMedium?.copyWith(
                      fontWeight: FontWeight.bold,
                    ),
                  ),
                  const SizedBox(height: 4),
                  Text(
                    video['description']!,
                    style: Theme.of(context).textTheme.bodyMedium?.copyWith(
                      color: Theme.of(context).colorScheme.onSurfaceVariant,
                    ),
                  ),
                ],
              ),
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildFeedbackTab() {
    return ResponsiveContainer(
      child: SingleChildScrollView(
        padding: const EdgeInsets.all(16),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            // Feedback Form
            Card(
              child: Padding(
                padding: const EdgeInsets.all(16),
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Text(
                      'Share Your Feedback',
                      style: Theme.of(context).textTheme.titleLarge?.copyWith(
                        fontWeight: FontWeight.bold,
                      ),
                    ),
                    const SizedBox(height: 8),
                    Text(
                      'Help us improve the Teacher Dashboard by sharing your thoughts and suggestions.',
                      style: Theme.of(context).textTheme.bodyMedium?.copyWith(
                        color: Theme.of(context).colorScheme.onSurfaceVariant,
                      ),
                    ),
                    const SizedBox(height: 24),
                    // Feedback Type
                    DropdownButtonFormField<String>(
                      decoration: const InputDecoration(
                        labelText: 'Feedback Type',
                        border: OutlineInputBorder(),
                      ),
                      items: const [
                        DropdownMenuItem(value: 'bug', child: Text('Bug Report')),
                        DropdownMenuItem(value: 'feature', child: Text('Feature Request')),
                        DropdownMenuItem(value: 'improvement', child: Text('Improvement Suggestion')),
                        DropdownMenuItem(value: 'general', child: Text('General Feedback')),
                      ],
                      onChanged: (value) {},
                    ),
                    const SizedBox(height: 16),
                    // Subject
                    const TextField(
                      decoration: InputDecoration(
                        labelText: 'Subject',
                        hintText: 'Brief description of your feedback',
                        border: OutlineInputBorder(),
                      ),
                    ),
                    const SizedBox(height: 16),
                    // Message
                    const TextField(
                      maxLines: 5,
                      decoration: InputDecoration(
                        labelText: 'Details',
                        hintText: 'Please provide detailed feedback...',
                        border: OutlineInputBorder(),
                        alignLabelWithHint: true,
                      ),
                    ),
                    const SizedBox(height: 24),
                    // Submit Button
                    SizedBox(
                      width: double.infinity,
                      child: FilledButton.icon(
                        onPressed: () => _submitFeedback(),
                        icon: const Icon(Icons.send),
                        label: const Text('Submit Feedback'),
                        style: FilledButton.styleFrom(
                          padding: const EdgeInsets.symmetric(vertical: 16),
                        ),
                      ),
                    ),
                  ],
                ),
              ),
            ),
            
            const SizedBox(height: 24),
            
            // Quick Feedback Options
            Text(
              'Quick Feedback',
              style: Theme.of(context).textTheme.titleMedium?.copyWith(
                fontWeight: FontWeight.bold,
              ),
            ),
            const SizedBox(height: 12),
            
            Row(
              children: [
                Expanded(
                  child: _buildQuickFeedbackCard(
                    'Feature Request',
                    Icons.lightbulb_outline,
                    'Suggest new features',
                    () => _showQuickFeedback('feature'),
                  ),
                ),
                const SizedBox(width: 12),
                Expanded(
                  child: _buildQuickFeedbackCard(
                    'Bug Report',
                    Icons.bug_report_outlined,
                    'Report issues',
                    () => _showQuickFeedback('bug'),
                  ),
                ),
              ],
            ),
            
            const SizedBox(height: 32),
            
            // Contact Information
            Card(
              child: Padding(
                padding: const EdgeInsets.all(16),
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Text(
                      'Need Immediate Help?',
                      style: Theme.of(context).textTheme.titleMedium?.copyWith(
                        fontWeight: FontWeight.bold,
                      ),
                    ),
                    const SizedBox(height: 12),
                    ListTile(
                      leading: const Icon(Icons.email),
                      title: const Text('Email Support'),
                      subtitle: const Text('support@teacherdashboard.edu'),
                      trailing: const Icon(Icons.chevron_right),
                      onTap: () => _contactSupport('email'),
                    ),
                    ListTile(
                      leading: const Icon(Icons.phone),
                      title: const Text('Phone Support'),
                      subtitle: const Text('1-800-TEACHER (Available 9 AM - 5 PM EST)'),
                      trailing: const Icon(Icons.chevron_right),
                      onTap: () => _contactSupport('phone'),
                    ),
                    ListTile(
                      leading: const Icon(Icons.chat),
                      title: const Text('Live Chat'),
                      subtitle: const Text('Chat with our support team'),
                      trailing: const Icon(Icons.chevron_right),
                      onTap: () => _contactSupport('chat'),
                    ),
                  ],
                ),
              ),
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildQuickFeedbackCard(
    String title,
    IconData icon,
    String subtitle,
    VoidCallback onTap,
  ) {
    return Card(
      child: InkWell(
        onTap: onTap,
        borderRadius: BorderRadius.circular(12),
        child: Padding(
          padding: const EdgeInsets.all(16),
          child: Column(
            children: [
              Icon(
                icon,
                size: 32,
                color: Theme.of(context).colorScheme.primary,
              ),
              const SizedBox(height: 8),
              Text(
                title,
                style: Theme.of(context).textTheme.titleSmall?.copyWith(
                  fontWeight: FontWeight.bold,
                ),
                textAlign: TextAlign.center,
              ),
              const SizedBox(height: 4),
              Text(
                subtitle,
                style: Theme.of(context).textTheme.bodySmall?.copyWith(
                  color: Theme.of(context).colorScheme.onSurfaceVariant,
                ),
                textAlign: TextAlign.center,
              ),
            ],
          ),
        ),
      ),
    );
  }

  void _showGuideDetail(Map<String, dynamic> guide) {
    showModalBottomSheet(
      context: context,
      isScrollControlled: true,
      backgroundColor: Colors.transparent,
      builder: (context) => GuideDetailSheet(guide: guide),
    );
  }

  void _playVideo(Map<String, String> video) {
    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        title: Text(video['title']!),
        content: Text('This would open the video: ${video['description']}'),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(context),
            child: const Text('Close'),
          ),
          FilledButton(
            onPressed: () {
              Navigator.pop(context);
              // TODO: Implement video player
            },
            child: const Text('Watch Video'),
          ),
        ],
      ),
    );
  }

  void _submitFeedback() {
    ScaffoldMessenger.of(context).showSnackBar(
      const SnackBar(
        content: Text('Thank you for your feedback! We\'ll review it soon.'),
      ),
    );
  }

  void _showQuickFeedback(String type) {
    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        title: Text(type == 'feature' ? 'Feature Request' : 'Bug Report'),
        content: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            TextField(
              decoration: InputDecoration(
                labelText: type == 'feature' ? 'Feature Description' : 'Bug Description',
                border: const OutlineInputBorder(),
              ),
              maxLines: 3,
            ),
          ],
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(context),
            child: const Text('Cancel'),
          ),
          FilledButton(
            onPressed: () {
              Navigator.pop(context);
              _submitFeedback();
            },
            child: const Text('Submit'),
          ),
        ],
      ),
    );
  }

  void _contactSupport(String method) {
    String message;
    switch (method) {
      case 'email':
        message = 'Opening email client...';
        break;
      case 'phone':
        message = 'Opening phone dialer...';
        break;
      case 'chat':
        message = 'Opening live chat...';
        break;
      default:
        message = 'Contacting support...';
    }

    ScaffoldMessenger.of(context).showSnackBar(
      SnackBar(content: Text(message)),
    );
  }

  void _showContactSupport(BuildContext context) {
    showModalBottomSheet(
      context: context,
      builder: (context) => Container(
        padding: const EdgeInsets.all(24),
        child: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            Text(
              'Contact Support',
              style: Theme.of(context).textTheme.titleLarge?.copyWith(
                fontWeight: FontWeight.bold,
              ),
            ),
            const SizedBox(height: 16),
            ListTile(
              leading: const Icon(Icons.email),
              title: const Text('Email'),
              subtitle: const Text('support@teacherdashboard.edu'),
              onTap: () {
                Navigator.pop(context);
                _contactSupport('email');
              },
            ),
            ListTile(
              leading: const Icon(Icons.phone),
              title: const Text('Phone'),
              subtitle: const Text('1-800-TEACHER'),
              onTap: () {
                Navigator.pop(context);
                _contactSupport('phone');
              },
            ),
            ListTile(
              leading: const Icon(Icons.chat),
              title: const Text('Live Chat'),
              subtitle: const Text('Available 9 AM - 5 PM EST'),
              onTap: () {
                Navigator.pop(context);
                _contactSupport('chat');
              },
            ),
          ],
        ),
      ),
    );
  }
}

// Guide Detail Sheet
class GuideDetailSheet extends StatelessWidget {
  final Map<String, dynamic> guide;

  const GuideDetailSheet({super.key, required this.guide});

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);

    return Container(
      height: MediaQuery.of(context).size.height * 0.8,
      decoration: BoxDecoration(
        color: theme.colorScheme.surface,
        borderRadius: const BorderRadius.vertical(top: Radius.circular(20)),
      ),
      child: Column(
        children: [
          // Handle Bar
          Center(
            child: Container(
              margin: const EdgeInsets.only(top: 12, bottom: 8),
              width: 40,
              height: 4,
              decoration: BoxDecoration(
                color: theme.colorScheme.onSurfaceVariant.withValues(alpha: 0.3),
                borderRadius: BorderRadius.circular(2),
              ),
            ),
          ),
          // Header
          Padding(
            padding: const EdgeInsets.symmetric(horizontal: 24, vertical: 16),
            child: Row(
              children: [
                Container(
                  padding: const EdgeInsets.all(12),
                  decoration: BoxDecoration(
                    color: theme.colorScheme.primaryContainer,
                    borderRadius: BorderRadius.circular(12),
                  ),
                  child: Icon(
                    guide['icon'] as IconData,
                    color: theme.colorScheme.onPrimaryContainer,
                    size: 24,
                  ),
                ),
                const SizedBox(width: 16),
                Expanded(
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      Text(
                        guide['title'] as String,
                        style: theme.textTheme.titleLarge?.copyWith(
                          fontWeight: FontWeight.bold,
                        ),
                      ),
                      const SizedBox(height: 4),
                      Row(
                        children: [
                          Icon(
                            Icons.access_time,
                            size: 16,
                            color: theme.colorScheme.primary,
                          ),
                          const SizedBox(width: 4),
                          Text(
                            guide['duration'] as String,
                            style: theme.textTheme.bodySmall?.copyWith(
                              color: theme.colorScheme.primary,
                              fontWeight: FontWeight.w500,
                            ),
                          ),
                        ],
                      ),
                    ],
                  ),
                ),
                IconButton(
                  onPressed: () => Navigator.pop(context),
                  icon: const Icon(Icons.close),
                ),
              ],
            ),
          ),
          // Content
          Expanded(
            child: SingleChildScrollView(
              padding: const EdgeInsets.symmetric(horizontal: 24),
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Text(
                    guide['description'] as String,
                    style: theme.textTheme.bodyLarge?.copyWith(
                      color: theme.colorScheme.onSurfaceVariant,
                    ),
                  ),
                  const SizedBox(height: 24),
                  Text(
                    'What You\'ll Learn:',
                    style: theme.textTheme.titleMedium?.copyWith(
                      fontWeight: FontWeight.bold,
                    ),
                  ),
                  const SizedBox(height: 12),
                  ...((guide['sections'] as List<String>).map((section) => 
                    Padding(
                      padding: const EdgeInsets.only(bottom: 8),
                      child: Row(
                        children: [
                          Icon(
                            Icons.check_circle,
                            size: 20,
                            color: theme.colorScheme.primary,
                          ),
                          const SizedBox(width: 12),
                          Expanded(
                            child: Text(
                              section,
                              style: theme.textTheme.bodyMedium,
                            ),
                          ),
                        ],
                      ),
                    ),
                  ).toList()),
                  const SizedBox(height: 32),
                ],
              ),
            ),
          ),
          // Action Button
          Container(
            padding: const EdgeInsets.all(24),
            child: SizedBox(
              width: double.infinity,
              child: FilledButton.icon(
                onPressed: () {
                  Navigator.pop(context);
                  ScaffoldMessenger.of(context).showSnackBar(
                    const SnackBar(
                      content: Text('Opening full guide...'),
                    ),
                  );
                },
                icon: const Icon(Icons.menu_book),
                label: const Text('Read Full Guide'),
                style: FilledButton.styleFrom(
                  padding: const EdgeInsets.symmetric(vertical: 16),
                ),
              ),
            ),
          ),
        ],
      ),
    );
  }
}
````

## File: lib/shared/services/cache_service.dart
````dart
import 'dart:async';
import 'dart:convert';
import 'package:flutter/foundation.dart';
import 'package:shared_preferences/shared_preferences.dart';
import 'logger_service.dart';

/// Comprehensive caching service for the application.
/// 
/// Provides in-memory and persistent caching with TTL support,
/// size limits, and automatic cleanup.
class CacheService {
  /// Singleton instance
  static final CacheService _instance = CacheService._internal();
  
  /// Factory constructor returns singleton
  factory CacheService() => _instance;
  
  /// Private constructor
  CacheService._internal();
  
  /// In-memory cache storage
  final Map<String, CacheEntry> _memoryCache = {};
  
  /// Cache size tracking
  int _currentMemorySize = 0;
  
  /// Maximum memory cache size (10MB default)
  static const int _maxMemorySize = 10 * 1024 * 1024; // 10MB
  
  /// Timer for periodic cleanup
  Timer? _cleanupTimer;
  
  /// SharedPreferences instance
  SharedPreferences? _prefs;
  
  /// Cache statistics
  final CacheStatistics _stats = CacheStatistics();
  
  /// Initialize the cache service
  Future<void> initialize() async {
    try {
      _prefs = await SharedPreferences.getInstance();
      
      // Start periodic cleanup
      _cleanupTimer = Timer.periodic(
        const Duration(minutes: 5),
        (_) => _performCleanup(),
      );
      
      LoggerService.info('Cache service initialized');
    } catch (e) {
      LoggerService.error('Failed to initialize cache service', error: e);
    }
  }
  
  /// Get value from cache (memory first, then persistent).
  /// 
  /// @param key Cache key
  /// @param forceFresh Skip cache and return null
  /// @return Cached value or null if not found/expired
  Future<T?> get<T>(
    String key, {
    bool forceFresh = false,
  }) async {
    if (forceFresh) {
      _stats.recordMiss();
      return null;
    }
    
    // Try memory cache first
    final memoryEntry = _memoryCache[key];
    if (memoryEntry != null && !memoryEntry.isExpired) {
      _stats.recordHit();
      LoggerService.debug('Cache hit (memory): $key');
      return memoryEntry.value as T?;
    }
    
    // Try persistent cache
    if (_prefs != null && T == String || 
        T == int || T == double || T == bool || 
        T == List<String>) {
      final value = _getPersistent<T>(key);
      if (value != null) {
        // Check TTL for persistent cache
        final ttlKey = '_ttl_$key';
        final ttl = _prefs!.getInt(ttlKey);
        if (ttl == null || DateTime.now().millisecondsSinceEpoch < ttl) {
          _stats.recordHit();
          LoggerService.debug('Cache hit (persistent): $key');
          
          // Promote to memory cache
          _setMemory(key, value, Duration(
            milliseconds: ttl != null 
              ? ttl - DateTime.now().millisecondsSinceEpoch
              : 3600000, // 1 hour default
          ));
          
          return value;
        }
      }
    }
    
    _stats.recordMiss();
    LoggerService.debug('Cache miss: $key');
    return null;
  }
  
  /// Set value in cache (both memory and persistent).
  /// 
  /// @param key Cache key
  /// @param value Value to cache
  /// @param ttl Time to live
  /// @param persistentOnly Only store in persistent cache
  Future<void> set<T>(
    String key,
    T value, {
    Duration ttl = const Duration(hours: 1),
    bool persistentOnly = false,
  }) async {
    try {
      // Store in memory cache
      if (!persistentOnly) {
        _setMemory(key, value, ttl);
      }
      
      // Store in persistent cache if supported type
      if (_prefs != null && _isPersistableType<T>()) {
        await _setPersistent(key, value, ttl);
      }
      
      _stats.recordSet();
      LoggerService.debug('Cache set: $key (TTL: ${ttl.inSeconds}s)');
    } catch (e) {
      LoggerService.error('Failed to set cache (key: $key)', error: e);
    }
  }
  
  /// Get value from cache or compute it.
  /// 
  /// If value is not in cache or expired, computes it using
  /// the provided function and caches the result.
  Future<T> getOrCompute<T>(
    String key,
    Future<T> Function() compute, {
    Duration ttl = const Duration(hours: 1),
    bool forceFresh = false,
  }) async {
    if (!forceFresh) {
      final cached = await get<T>(key);
      if (cached != null) {
        return cached;
      }
    }
    
    // Compute value
    final value = await compute();
    
    // Cache it
    await set(key, value, ttl: ttl);
    
    return value;
  }
  
  /// Remove value from cache.
  Future<void> remove(String key) async {
    // Remove from memory
    final removed = _memoryCache.remove(key);
    if (removed != null) {
      _currentMemorySize -= removed.sizeInBytes;
    }
    
    // Remove from persistent
    if (_prefs != null) {
      await _prefs!.remove(key);
      await _prefs!.remove('_ttl_$key');
    }
    
    _stats.recordEviction();
    LoggerService.debug('Cache removed: $key');
  }
  
  /// Clear all cache.
  Future<void> clear() async {
    // Clear memory cache
    _memoryCache.clear();
    _currentMemorySize = 0;
    
    // Clear persistent cache
    if (_prefs != null) {
      final keys = _prefs!.getKeys().toList();
      for (final key in keys) {
        // Only remove our cache entries
        if (!key.startsWith('_ttl_') && !key.contains('flutter.')) {
          await _prefs!.remove(key);
        }
      }
      // Remove TTL entries
      for (final key in keys) {
        if (key.startsWith('_ttl_')) {
          await _prefs!.remove(key);
        }
      }
    }
    
    LoggerService.info('Cache cleared');
  }
  
  /// Clear cache by pattern.
  Future<void> clearPattern(String pattern) async {
    // Clear from memory
    final keysToRemove = _memoryCache.keys
        .where((key) => key.contains(pattern))
        .toList();
    
    for (final key in keysToRemove) {
      await remove(key);
    }
    
    LoggerService.info('Cache pattern cleared: $pattern');
  }
  
  /// Get cache statistics.
  CacheStatistics getStatistics() => _stats.copy();
  
  /// Get cache size info.
  CacheSizeInfo getSizeInfo() {
    int persistentCount = 0;
    int persistentSize = 0;
    
    if (_prefs != null) {
      final keys = _prefs!.getKeys();
      for (final key in keys) {
        if (!key.startsWith('_ttl_') && !key.contains('flutter.')) {
          persistentCount++;
          // Estimate size
          final value = _prefs!.get(key);
          if (value is String) {
            persistentSize += value.length * 2; // UTF-16
          } else {
            persistentSize += 8; // Rough estimate for numbers
          }
        }
      }
    }
    
    return CacheSizeInfo(
      memoryEntries: _memoryCache.length,
      memoryBytes: _currentMemorySize,
      persistentEntries: persistentCount,
      persistentBytes: persistentSize,
    );
  }
  
  /// Store in memory cache with LRU eviction.
  void _setMemory(String key, dynamic value, Duration ttl) {
    // Calculate size
    final size = _estimateSize(value);
    
    // Evict if necessary
    while (_currentMemorySize + size > _maxMemorySize && _memoryCache.isNotEmpty) {
      _evictOldest();
    }
    
    // Store entry
    _memoryCache[key] = CacheEntry(
      value: value,
      expiry: DateTime.now().add(ttl),
      sizeInBytes: size,
    );
    _currentMemorySize += size;
  }
  
  /// Get from persistent cache.
  T? _getPersistent<T>(String key) {
    if (T == String) {
      return _prefs!.getString(key) as T?;
    } else if (T == int) {
      return _prefs!.getInt(key) as T?;
    } else if (T == double) {
      return _prefs!.getDouble(key) as T?;
    } else if (T == bool) {
      return _prefs!.getBool(key) as T?;
    } else if (T == List<String>) {
      return _prefs!.getStringList(key) as T?;
    }
    return null;
  }
  
  /// Set in persistent cache.
  Future<void> _setPersistent<T>(String key, T value, Duration ttl) async {
    // Store value
    if (value is String) {
      await _prefs!.setString(key, value);
    } else if (value is int) {
      await _prefs!.setInt(key, value);
    } else if (value is double) {
      await _prefs!.setDouble(key, value);
    } else if (value is bool) {
      await _prefs!.setBool(key, value);
    } else if (value is List<String>) {
      await _prefs!.setStringList(key, value);
    }
    
    // Store TTL
    final ttlKey = '_ttl_$key';
    await _prefs!.setInt(
      ttlKey,
      DateTime.now().add(ttl).millisecondsSinceEpoch,
    );
  }
  
  /// Check if type is persistable.
  bool _isPersistableType<T>() {
    return T == String || 
           T == int || 
           T == double || 
           T == bool || 
           T == List<String>;
  }
  
  /// Estimate memory size of value.
  int _estimateSize(dynamic value) {
    if (value == null) return 0;
    
    if (value is String) {
      return value.length * 2; // UTF-16
    } else if (value is int || value is double) {
      return 8;
    } else if (value is bool) {
      return 1;
    } else if (value is List) {
      return value.fold<int>(0, (sum, item) => sum + _estimateSize(item));
    } else if (value is Map) {
      int size = 0;
      value.forEach((k, v) {
        size += _estimateSize(k) + _estimateSize(v);
      });
      return size;
    } else {
      // For objects, try to serialize and measure
      try {
        return json.encode(value).length * 2;
      } catch (_) {
        return 1024; // Default 1KB
      }
    }
  }
  
  /// Evict oldest entry from memory cache.
  void _evictOldest() {
    if (_memoryCache.isEmpty) return;
    
    String? oldestKey;
    DateTime? oldestTime;
    
    _memoryCache.forEach((key, entry) {
      if (oldestTime == null || entry.created.isBefore(oldestTime!)) {
        oldestTime = entry.created;
        oldestKey = key;
      }
    });
    
    if (oldestKey != null) {
      final removed = _memoryCache.remove(oldestKey);
      if (removed != null) {
        _currentMemorySize -= removed.sizeInBytes;
        _stats.recordEviction();
      }
    }
  }
  
  /// Perform periodic cleanup.
  void _performCleanup() {
    // Clean expired entries from memory
    final keysToRemove = <String>[];
    _memoryCache.forEach((key, entry) {
      if (entry.isExpired) {
        keysToRemove.add(key);
      }
    });
    
    for (final key in keysToRemove) {
      remove(key);
    }
    
    if (keysToRemove.isNotEmpty) {
      LoggerService.debug(
        'Cache cleanup removed ${keysToRemove.length} expired entries',
      );
    }
  }
  
  /// Dispose of resources.
  void dispose() {
    _cleanupTimer?.cancel();
    _memoryCache.clear();
    LoggerService.info('Cache service disposed');
  }
}

/// Cache entry container.
@immutable
class CacheEntry {
  final dynamic value;
  final DateTime expiry;
  final DateTime created;
  final int sizeInBytes;
  
  CacheEntry({
    required this.value,
    required this.expiry,
    required this.sizeInBytes,
    DateTime? created,
  }) : created = created ?? DateTime.now();
  
  bool get isExpired => DateTime.now().isAfter(expiry);
  
  Duration get timeToLive => expiry.difference(DateTime.now());
}

/// Cache statistics tracker.
class CacheStatistics {
  int _hits = 0;
  int _misses = 0;
  int _sets = 0;
  int _evictions = 0;
  
  int get hits => _hits;
  int get misses => _misses;
  int get sets => _sets;
  int get evictions => _evictions;
  
  double get hitRate => _hits + _misses > 0 
      ? _hits / (_hits + _misses) 
      : 0.0;
  
  void recordHit() => _hits++;
  void recordMiss() => _misses++;
  void recordSet() => _sets++;
  void recordEviction() => _evictions++;
  
  CacheStatistics copy() {
    return CacheStatistics()
      .._hits = _hits
      .._misses = _misses
      .._sets = _sets
      .._evictions = _evictions;
  }
  
  Map<String, dynamic> toJson() => {
    'hits': _hits,
    'misses': _misses,
    'sets': _sets,
    'evictions': _evictions,
    'hitRate': hitRate,
  };
}

/// Cache size information.
@immutable
class CacheSizeInfo {
  final int memoryEntries;
  final int memoryBytes;
  final int persistentEntries;
  final int persistentBytes;
  
  const CacheSizeInfo({
    required this.memoryEntries,
    required this.memoryBytes,
    required this.persistentEntries,
    required this.persistentBytes,
  });
  
  int get totalEntries => memoryEntries + persistentEntries;
  int get totalBytes => memoryBytes + persistentBytes;
  
  Map<String, dynamic> toJson() => {
    'memory': {
      'entries': memoryEntries,
      'bytes': memoryBytes,
      'mb': (memoryBytes / 1024 / 1024).toStringAsFixed(2),
    },
    'persistent': {
      'entries': persistentEntries,
      'bytes': persistentBytes,
      'kb': (persistentBytes / 1024).toStringAsFixed(2),
    },
    'total': {
      'entries': totalEntries,
      'bytes': totalBytes,
    },
  };
}
````

## File: lib/shared/services/error_handler_service.dart
````dart
/// Global error handling service for the application.
/// 
/// This service provides centralized error handling with user-friendly
/// messages for common Firebase errors, especially permission errors.
/// It can show errors as snackbars, dialogs, or custom overlays.
library;

import 'package:flutter/material.dart';
import 'package:firebase_auth/firebase_auth.dart';
import 'logger_service.dart';

/// Global error handler service for consistent error presentation.
/// 
/// Features:
/// - User-friendly error messages for Firebase errors
/// - Permission error detection and handling
/// - Network error handling
/// - Customizable error presentation (snackbar, dialog, overlay)
/// - Error logging and tracking
class ErrorHandlerService {
  static const String _tag = 'ErrorHandlerService';
  
  /// Global navigator key for showing errors from anywhere
  static final GlobalKey<NavigatorState> navigatorKey = GlobalKey<NavigatorState>();
  
  /// Global scaffold messenger key for showing snackbars
  static final GlobalKey<ScaffoldMessengerState> scaffoldMessengerKey = GlobalKey<ScaffoldMessengerState>();
  
  /// Handle an error and show appropriate UI feedback.
  /// 
  /// @param error The error object
  /// @param context Optional build context for showing dialogs
  /// @param message Optional custom message to show
  /// @param showAsDialog Whether to show as dialog instead of snackbar
  static void handleError(
    dynamic error, {
    BuildContext? context,
    String? message,
    bool showAsDialog = false,
    VoidCallback? onRetry,
  }) {
    // Log the error
    LoggerService.error(
      message ?? 'An error occurred',
      tag: _tag,
      error: error,
    );
    
    // Get user-friendly message
    final errorMessage = getErrorMessage(error, customMessage: message);
    
    // Show error UI
    if (showAsDialog && (context != null || navigatorKey.currentContext != null)) {
      _showErrorDialog(
        context ?? navigatorKey.currentContext!,
        errorMessage,
        onRetry: onRetry,
      );
    } else {
      _showErrorSnackbar(errorMessage, onRetry: onRetry);
    }
  }
  
  /// Get a user-friendly error message based on the error type.
  static String getErrorMessage(dynamic error, {String? customMessage}) {
    if (customMessage != null) return customMessage;
    
    // Handle FirebaseException
    if (error is FirebaseException) {
      switch (error.code) {
        // Firestore permission errors
        case 'permission-denied':
          return 'You don\'t have permission to access this data. Please contact your teacher if you believe this is an error.';
        
        // Auth errors
        case 'user-not-found':
          return 'No user found with this email address.';
        case 'wrong-password':
          return 'Incorrect password. Please try again.';
        case 'email-already-in-use':
          return 'This email is already registered.';
        case 'weak-password':
          return 'Password is too weak. Please use a stronger password.';
        case 'invalid-email':
          return 'Invalid email address format.';
        case 'user-disabled':
          return 'This account has been disabled. Please contact support.';
        case 'too-many-requests':
          return 'Too many failed attempts. Please try again later.';
        case 'network-request-failed':
          return 'Network error. Please check your internet connection.';
        
        // Firestore errors
        case 'unavailable':
          return 'Service temporarily unavailable. Please try again later.';
        case 'data-loss':
          return 'Data integrity error. Please refresh and try again.';
        case 'deadline-exceeded':
          return 'Request timed out. Please check your connection and try again.';
        case 'resource-exhausted':
          return 'Too many requests. Please wait a moment and try again.';
        case 'failed-precondition':
          return 'Operation failed. Please refresh and try again.';
        case 'aborted':
          return 'Operation was cancelled. Please try again.';
        case 'out-of-range':
          return 'Invalid data range. Please check your input.';
        case 'unimplemented':
          return 'This feature is not yet available.';
        case 'internal':
          return 'An internal error occurred. Please try again later.';
        case 'not-found':
          return 'The requested data was not found.';
        case 'already-exists':
          return 'This item already exists.';
        
        default:
          return 'An error occurred: ${error.message ?? error.code}';
      }
    }
    
    // Handle other specific error types
    if (error is FirebaseAuthException) {
      return getErrorMessage(error as FirebaseException);
    }
    
    // Network errors
    if (error.toString().contains('SocketException') || 
        error.toString().contains('NetworkException')) {
      return 'Network error. Please check your internet connection.';
    }
    
    // Format errors
    if (error is FormatException) {
      return 'Invalid data format. Please check your input.';
    }
    
    // Type errors (often from null data)
    if (error is TypeError) {
      return 'Data loading error. Please refresh and try again.';
    }
    
    // Default error message
    return 'An unexpected error occurred. Please try again.';
  }
  
  /// Show error as a snackbar.
  static void _showErrorSnackbar(String message, {VoidCallback? onRetry}) {
    final messenger = scaffoldMessengerKey.currentState;
    if (messenger == null) return;
    
    messenger.clearSnackBars();
    messenger.showSnackBar(
      SnackBar(
        content: Text(message),
        backgroundColor: Colors.red[700],
        behavior: SnackBarBehavior.floating,
        duration: const Duration(seconds: 6),
        action: onRetry != null
            ? SnackBarAction(
                label: 'RETRY',
                textColor: Colors.white,
                onPressed: onRetry,
              )
            : null,
      ),
    );
  }
  
  /// Show error as a dialog.
  static void _showErrorDialog(
    BuildContext context,
    String message, {
    VoidCallback? onRetry,
  }) {
    showDialog(
      context: context,
      barrierDismissible: false,
      builder: (context) => AlertDialog(
        icon: const Icon(
          Icons.error_outline,
          color: Colors.red,
          size: 48,
        ),
        title: const Text('Error'),
        content: Text(message),
        actions: [
          if (onRetry != null)
            TextButton(
              onPressed: () {
                Navigator.pop(context);
                onRetry();
              },
              child: const Text('RETRY'),
            ),
          TextButton(
            onPressed: () => Navigator.pop(context),
            child: const Text('OK'),
          ),
        ],
      ),
    );
  }
  
  /// Show a permission denied dialog with more context.
  static void showPermissionDeniedDialog(
    BuildContext context, {
    required String resource,
    String? additionalInfo,
  }) {
    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        icon: Icon(
          Icons.lock_outline,
          color: Theme.of(context).colorScheme.error,
          size: 48,
        ),
        title: const Text('Access Denied'),
        content: Column(
          mainAxisSize: MainAxisSize.min,
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text('You don\'t have permission to access $resource.'),
            if (additionalInfo != null) ...[
              const SizedBox(height: 8),
              Text(
                additionalInfo,
                style: Theme.of(context).textTheme.bodySmall,
              ),
            ],
            const SizedBox(height: 16),
            const Text(
              'If you believe this is an error, please contact your teacher or administrator.',
              style: TextStyle(fontStyle: FontStyle.italic),
            ),
          ],
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(context),
            child: const Text('OK'),
          ),
        ],
      ),
    );
  }
  
  /// Extract Firebase error code from error message.
  static String? extractFirebaseErrorCode(dynamic error) {
    if (error is FirebaseException) {
      return error.code;
    }
    
    // Try to extract from string representation
    final errorString = error.toString();
    final match = RegExp(r'\[([^\]]+)\]').firstMatch(errorString);
    return match?.group(1);
  }
  
  /// Check if error is a permission error.
  static bool isPermissionError(dynamic error) {
    final code = extractFirebaseErrorCode(error);
    return code == 'permission-denied' || 
           error.toString().contains('permission-denied') ||
           error.toString().contains('PERMISSION_DENIED');
  }
  
  /// Check if error is a network error.
  static bool isNetworkError(dynamic error) {
    final errorString = error.toString().toLowerCase();
    return errorString.contains('network') ||
           errorString.contains('socket') ||
           errorString.contains('connection') ||
           errorString.contains('unavailable');
  }
}

/// Extension to make error handling easier on BuildContext.
extension ErrorHandlingExtension on BuildContext {
  /// Show an error with context-aware presentation.
  void showError(
    dynamic error, {
    String? message,
    bool asDialog = false,
    VoidCallback? onRetry,
  }) {
    ErrorHandlerService.handleError(
      error,
      context: this,
      message: message,
      showAsDialog: asDialog,
      onRetry: onRetry,
    );
  }
  
  /// Show a permission denied error.
  void showPermissionError({
    required String resource,
    String? additionalInfo,
  }) {
    ErrorHandlerService.showPermissionDeniedDialog(
      this,
      resource: resource,
      additionalInfo: additionalInfo,
    );
  }
}
````

## File: lib/shared/services/firestore_service_enhanced.dart
````dart
import 'package:cloud_firestore/cloud_firestore.dart';
import '../repositories/mixins/pagination_mixin.dart';
import 'firestore_service.dart';
import 'logger_service.dart';

/// Enhanced Firestore service with pagination support.
/// 
/// Extends the base FirestoreService to add pagination capabilities
/// while maintaining backward compatibility with existing code.
class FirestoreServiceEnhanced<T> extends FirestoreService<T> with PaginationMixin {
  /// Creates an enhanced Firestore service with pagination.
  FirestoreServiceEnhanced({
    required super.collectionPath,
    required super.fromFirestore,
    required super.toFirestore,
  });

  /// Get paginated documents from the collection.
  /// 
  /// Returns a page of documents with metadata for pagination.
  /// 
  /// @param pageSize Number of documents per page
  /// @param startAfter Optional cursor for pagination
  /// @param orderBy Field to order by (defaults to 'createdAt')
  /// @param descending Whether to order descending
  /// @param where Optional field for filtering
  /// @param isEqualTo Optional value for equality filtering
  /// @return PaginatedResult with documents and pagination info
  Future<PaginatedResult<T>> getPaginated({
    int pageSize = PaginationMixin.defaultPageSize,
    DocumentSnapshot? startAfter,
    String orderBy = 'createdAt',
    bool descending = true,
    String? where,
    dynamic isEqualTo,
  }) async {
    try {
      Query query = collection.orderBy(orderBy, descending: descending);
      
      // Apply filtering if provided
      if (where != null && isEqualTo != null) {
        query = query.where(where, isEqualTo: isEqualTo);
      }
      
      return await getPaginatedData(
        query: query,
        fromFirestore: fromFirestore,
        pageSize: pageSize,
        startAfter: startAfter,
      );
    } catch (e) {
      LoggerService.error(
        'Error getting paginated data from $collectionPath',
        error: e,
      );
      rethrow;
    }
  }

  /// Get paginated stream of documents.
  /// 
  /// Returns a stream that emits paginated results whenever
  /// the underlying data changes.
  Stream<PaginatedResult<T>> streamPaginated({
    int pageSize = PaginationMixin.defaultPageSize,
    DocumentSnapshot? startAfter,
    String orderBy = 'createdAt',
    bool descending = true,
    String? where,
    dynamic isEqualTo,
  }) {
    try {
      Query query = collection.orderBy(orderBy, descending: descending);
      
      // Apply filtering if provided
      if (where != null && isEqualTo != null) {
        query = query.where(where, isEqualTo: isEqualTo);
      }
      
      return getPaginatedStream(
        query: query,
        fromFirestore: fromFirestore,
        pageSize: pageSize,
        startAfter: startAfter,
      );
    } catch (e) {
      LoggerService.error(
        'Error streaming paginated data from $collectionPath',
        error: e,
      );
      rethrow;
    }
  }

  /// Get documents with compound queries and pagination.
  /// 
  /// Supports multiple where clauses and complex queries.
  Future<PaginatedResult<T>> queryPaginated({
    required List<QueryConstraint> constraints,
    int pageSize = PaginationMixin.defaultPageSize,
    DocumentSnapshot? startAfter,
  }) async {
    try {
      Query query = collection;
      
      // Apply all constraints
      for (final constraint in constraints) {
        query = constraint.apply(query);
      }
      
      return await getPaginatedData(
        query: query,
        fromFirestore: fromFirestore,
        pageSize: pageSize,
        startAfter: startAfter,
      );
    } catch (e) {
      LoggerService.error(
        'Error executing paginated query on $collectionPath',
        error: e,
      );
      rethrow;
    }
  }

  /// DEPRECATED: Use getPaginated() instead.
  /// Maintained for backward compatibility.
  @override
  Future<List<T>> getAll() async {
    LoggerService.warning(
      'getAll() is deprecated. Use getPaginated() for better performance.',
    );
    
    // Use pagination to load all documents
    final allItems = await getAllPaginated(
      query: collection.orderBy('createdAt', descending: true),
      fromFirestore: fromFirestore,
    );
    
    return allItems;
  }
}

/// Query constraint for building complex queries.
abstract class QueryConstraint {
  /// Apply this constraint to a query.
  Query apply(Query query);
}

/// Where clause constraint.
class WhereConstraint extends QueryConstraint {
  final String field;
  final dynamic isEqualTo;
  final dynamic isLessThan;
  final dynamic isLessThanOrEqualTo;
  final dynamic isGreaterThan;
  final dynamic isGreaterThanOrEqualTo;
  final dynamic arrayContains;
  final List<dynamic>? arrayContainsAny;
  final List<dynamic>? whereIn;
  final List<dynamic>? whereNotIn;
  final bool? isNull;

  WhereConstraint({
    required this.field,
    this.isEqualTo,
    this.isLessThan,
    this.isLessThanOrEqualTo,
    this.isGreaterThan,
    this.isGreaterThanOrEqualTo,
    this.arrayContains,
    this.arrayContainsAny,
    this.whereIn,
    this.whereNotIn,
    this.isNull,
  });

  @override
  Query apply(Query query) {
    if (isEqualTo != null) {
      return query.where(field, isEqualTo: isEqualTo);
    } else if (isLessThan != null) {
      return query.where(field, isLessThan: isLessThan);
    } else if (isLessThanOrEqualTo != null) {
      return query.where(field, isLessThanOrEqualTo: isLessThanOrEqualTo);
    } else if (isGreaterThan != null) {
      return query.where(field, isGreaterThan: isGreaterThan);
    } else if (isGreaterThanOrEqualTo != null) {
      return query.where(field, isGreaterThanOrEqualTo: isGreaterThanOrEqualTo);
    } else if (arrayContains != null) {
      return query.where(field, arrayContains: arrayContains);
    } else if (arrayContainsAny != null) {
      return query.where(field, arrayContainsAny: arrayContainsAny);
    } else if (whereIn != null) {
      return query.where(field, whereIn: whereIn);
    } else if (whereNotIn != null) {
      return query.where(field, whereNotIn: whereNotIn);
    } else if (isNull != null) {
      return query.where(field, isNull: isNull);
    }
    return query;
  }
}

/// Order by constraint.
class OrderByConstraint extends QueryConstraint {
  final String field;
  final bool descending;

  OrderByConstraint({
    required this.field,
    this.descending = false,
  });

  @override
  Query apply(Query query) {
    return query.orderBy(field, descending: descending);
  }
}

/// Limit constraint.
class LimitConstraint extends QueryConstraint {
  final int limit;

  LimitConstraint(this.limit);

  @override
  Query apply(Query query) {
    return query.limit(limit);
  }
}
````

## File: lib/shared/services/firestore_service.dart
````dart
/// Generic Firestore service providing reusable CRUD operations.
/// 
/// This module implements a generic service pattern for Firestore
/// operations, reducing code duplication across different data services
/// in the education platform.
library;

import 'package:cloud_firestore/cloud_firestore.dart';
import 'logger_service.dart';

/// Generic Firestore service to handle common CRUD operations.
/// 
/// This service provides a type-safe, reusable implementation for:
/// - Create, Read, Update, Delete operations
/// - Complex queries with multiple conditions
/// - Batch operations for efficiency
/// - Stream-based real-time updates
/// 
/// The service uses generic typing to work with any data model
/// that can be serialized to/from Firestore documents.
/// 
/// @param T The type of model this service manages
class FirestoreService<T> {
  /// Firestore database instance.
  final FirebaseFirestore _firestore;
  
  /// Path to the Firestore collection this service manages.
  final String collectionPath;
  
  /// Function to deserialize Firestore documents into model instances.
  final T Function(DocumentSnapshot doc) fromFirestore;
  
  /// Function to serialize model instances into Firestore data.
  final Map<String, dynamic> Function(T item) toFirestore;

  /// Creates a generic Firestore service instance.
  /// 
  /// @param firestore Optional Firestore instance for dependency injection
  /// @param collectionPath Path to the target collection
  /// @param fromFirestore Deserialization function for documents
  /// @param toFirestore Serialization function for models
  FirestoreService({
    FirebaseFirestore? firestore,
    required this.collectionPath,
    required this.fromFirestore,
    required this.toFirestore,
  }) : _firestore = firestore ?? FirebaseFirestore.instance;

  /// Gets the Firestore collection reference.
  /// 
  /// @return Reference to the managed collection
  CollectionReference get collection => _firestore.collection(collectionPath);

  /// Creates a new document with auto-generated ID.
  /// 
  /// Adds the document to Firestore and returns the generated
  /// document ID. The data should be pre-serialized before
  /// calling this method.
  /// 
  /// @param data Serialized document data
  /// @return Generated document ID
  /// @throws Exception if creation fails
  Future<String> create(Map<String, dynamic> data) async {
    try {
      final docRef = await collection.add(data);
      return docRef.id;
    } catch (e) {
      LoggerService.error('Error creating document', error: e);
      rethrow;
    }
  }
  
  /// Creates a document with a specific ID.
  /// 
  /// Use this when you need to control the document ID,
  /// such as for user profiles or deterministic IDs.
  /// 
  /// @param id Document ID to use
  /// @param data Serialized document data
  /// @throws Exception if creation fails
  Future<void> createWithId(String id, Map<String, dynamic> data) async {
    try {
      await collection.doc(id).set(data);
    } catch (e) {
      LoggerService.error('Error creating document with ID', error: e);
      rethrow;
    }
  }

  /// Retrieves a single document by ID.
  /// 
  /// Fetches the document and deserializes it using the
  /// provided fromFirestore function. Returns null if
  /// the document doesn't exist.
  /// 
  /// @param id Document ID to retrieve
  /// @return Deserialized model instance or null
  /// @throws Exception if retrieval fails
  Future<T?> get(String id) async {
    try {
      final doc = await collection.doc(id).get();
      if (!doc.exists) return null;
      return fromFirestore(doc);
    } catch (e) {
      LoggerService.error('Error getting document', error: e);
      rethrow;
    }
  }

  /// Retrieves all documents in the collection.
  /// 
  /// Fetches the entire collection and deserializes each
  /// document. Use with caution for large collections as
  /// this loads all data into memory.
  /// 
  /// @return List of all deserialized model instances
  /// @throws Exception if retrieval fails
  Future<List<T>> getAll() async {
    try {
      final snapshot = await collection.get();
      return snapshot.docs.map((doc) => fromFirestore(doc)).toList();
    } catch (e) {
      LoggerService.error('Error getting all documents', error: e);
      rethrow;
    }
  }
  
  /// Updates an existing document.
  /// 
  /// Performs a partial update - only fields included in
  /// the data parameter are modified. Other fields remain
  /// unchanged.
  /// 
  /// @param id Document ID to update
  /// @param data Fields to update (pre-serialized)
  /// @throws Exception if update fails or document doesn't exist
  Future<void> update(String id, Map<String, dynamic> data) async {
    try {
      await collection.doc(id).update(data);
    } catch (e) {
      LoggerService.error('Error updating document', error: e);
      rethrow;
    }
  }

  /// Deletes a single document.
  /// 
  /// Permanently removes the document from Firestore.
  /// This operation cannot be undone.
  /// 
  /// @param id Document ID to delete
  /// @throws Exception if deletion fails
  Future<void> delete(String id) async {
    try {
      await collection.doc(id).delete();
    } catch (e) {
      LoggerService.error('Error deleting document', error: e);
      rethrow;
    }
  }

  /// Performs complex queries with real-time updates.
  /// 
  /// Supports multiple query conditions, ordering, and limits.
  /// Returns a stream that updates when matching documents change.
  /// 
  /// Example usage:
  /// ```dart
  /// query(
  ///   conditions: [QueryCondition(field: 'age', isGreaterThan: 18)],
  ///   orderBy: [OrderBy(field: 'name')],
  ///   limit: 10
  /// )
  /// ```
  /// 
  /// @param conditions List of query conditions to apply
  /// @param orderBy List of ordering specifications
  /// @param limit Maximum number of results
  /// @return Stream of matching documents
  /// @throws Exception if query construction fails
  Stream<List<T>> query({
    List<QueryCondition>? conditions,
    List<OrderBy>? orderBy,
    int? limit,
  }) {
    try {
      Query query = collection;

      // Apply conditions
      if (conditions != null) {
        for (final condition in conditions) {
          query = query.where(
            condition.field,
            isEqualTo: condition.isEqualTo,
            isNotEqualTo: condition.isNotEqualTo,
            isLessThan: condition.isLessThan,
            isLessThanOrEqualTo: condition.isLessThanOrEqualTo,
            isGreaterThan: condition.isGreaterThan,
            isGreaterThanOrEqualTo: condition.isGreaterThanOrEqualTo,
            arrayContains: condition.arrayContains,
            arrayContainsAny: condition.arrayContainsAny,
            whereIn: condition.whereIn,
            whereNotIn: condition.whereNotIn,
            isNull: condition.isNull,
          );
        }
      }
      
      // Apply ordering
      if (orderBy != null) {
        for (final order in orderBy) {
          query = query.orderBy(order.field, descending: order.descending);
        }
      }

      // Apply limit
      if (limit != null) {
        query = query.limit(limit);
      }

      return query.snapshots().map((snapshot) =>
          snapshot.docs.map((doc) => fromFirestore(doc)).toList());
    } catch (e) {
      LoggerService.error('Error querying documents', error: e);
      rethrow;
    }
  }

  /// Deletes multiple documents in a single batch operation.
  /// 
  /// Efficiently removes multiple documents using Firestore
  /// batch writes. All deletions succeed or fail together
  /// (atomic operation).
  /// 
  /// @param ids List of document IDs to delete
  /// @throws Exception if batch deletion fails
  Future<void> deleteMany(List<String> ids) async {
    try {
      final batch = _firestore.batch();
      for (final id in ids) {
        batch.delete(collection.doc(id));
      }
      await batch.commit();
    } catch (e) {
      LoggerService.error('Error deleting multiple documents', error: e);
      rethrow;
    }
  }

  /// Checks if a document exists without retrieving its data.
  /// 
  /// Useful for validation before performing operations
  /// that require the document to exist.
  /// 
  /// @param id Document ID to check
  /// @return true if document exists, false otherwise
  /// @throws Exception if check fails
  Future<bool> exists(String id) async {
    try {
      final doc = await collection.doc(id).get();
      return doc.exists;
    } catch (e) {
      LoggerService.error('Error checking document existence', error: e);
      rethrow;
    }
  }
}

/// Represents a single query condition for Firestore queries.
/// 
/// Supports all Firestore query operators including:
/// - Equality and inequality comparisons
/// - Range queries (less than, greater than)
/// - Array queries (contains, contains any)
/// - Set membership queries (in, not in)
/// - Null checks
/// 
/// Only one condition type should be set per instance.
class QueryCondition {
  /// Field name to apply the condition to.
  final String field;
  
  /// Value for equality comparison.
  final Object? isEqualTo;
  
  /// Value for inequality comparison.
  final Object? isNotEqualTo;
  
  /// Value for less-than comparison.
  final Object? isLessThan;
  
  /// Value for less-than-or-equal comparison.
  final Object? isLessThanOrEqualTo;
  
  /// Value for greater-than comparison.
  final Object? isGreaterThan;
  
  /// Value for greater-than-or-equal comparison.
  final Object? isGreaterThanOrEqualTo;
  
  /// Value to check if array field contains.
  final Object? arrayContains;
  
  /// Values to check if array field contains any.
  final List<Object?>? arrayContainsAny;
  
  /// Values to check if field is in the set.
  final List<Object?>? whereIn;
  
  /// Values to check if field is not in the set.
  final List<Object?>? whereNotIn;
  
  /// Whether to check if field is null.
  final bool? isNull;

  /// Creates a query condition.
  /// 
  /// Only set one condition type per instance. Multiple conditions
  /// on the same field require separate QueryCondition instances.
  QueryCondition({
    required this.field,
    this.isEqualTo,
    this.isNotEqualTo,
    this.isLessThan,
    this.isLessThanOrEqualTo,
    this.isGreaterThan,
    this.isGreaterThanOrEqualTo,
    this.arrayContains,
    this.arrayContainsAny,
    this.whereIn,
    this.whereNotIn,
    this.isNull,
  });
}

/// Specifies ordering for query results.
/// 
/// Used to sort query results by one or more fields
/// in ascending or descending order.
class OrderBy {
  /// Field name to order by.
  final String field;
  
  /// Whether to sort in descending order (default: false for ascending).
  final bool descending;

  /// Creates an ordering specification.
  /// 
  /// @param field Field name to sort by
  /// @param descending Whether to sort in descending order (default: false)
  OrderBy({
    required this.field,
    this.descending = false,
  });
}
````

## File: lib/shared/services/logger_service.dart
````dart
/// Centralized logging service for the education platform.
/// 
/// This service provides structured logging with multiple severity levels,
/// console output in debug mode, and Firebase Crashlytics integration
/// for production error tracking.
library;

import 'package:flutter/foundation.dart';
import 'package:firebase_crashlytics/firebase_crashlytics.dart';

/// Enumeration of available log severity levels.
/// 
/// Levels are ordered from least to most severe:
/// - debug: Development-time debugging information
/// - info: General informational messages
/// - warning: Potentially problematic situations
/// - error: Error events requiring attention
enum LogLevel {
  debug,
  info,
  warning,
  error,
}

/// Singleton service for centralized application logging.
/// 
/// This service provides:
/// - Structured logging with severity levels
/// - Console output with color coding in debug mode
/// - Firebase Crashlytics integration for production
/// - Contextual tagging for log categorization
/// - Extension methods for convenient logging
/// 
/// In debug mode, all log levels are printed to console.
/// In production, only warnings and errors are sent to Crashlytics.
class LoggerService {
  /// Singleton instance of the logger service.
  static final LoggerService _instance = LoggerService._internal();
  
  /// Factory constructor returning the singleton instance.
  factory LoggerService() => _instance;
  
  /// Private constructor for singleton pattern.
  LoggerService._internal();
  
  /// Minimum log level to display (can be configured via environment)
  static LogLevel minimumLogLevel = kDebugMode ? LogLevel.warning : LogLevel.warning;

  /// Logs a debug message (only in debug mode).
  /// 
  /// Debug messages are only printed in development builds
  /// and are completely ignored in production. Use for
  /// detailed debugging information during development.
  /// 
  /// @param message Debug message to log
  /// @param tag Optional tag for categorizing the log
  static void debug(String message, {String? tag}) {
    if (kDebugMode) {
      _log(LogLevel.debug, message, tag: tag);
    }
  }

  /// Logs an informational message.
  /// 
  /// Info messages are printed in debug mode and logged
  /// to analytics in production. Use for significant
  /// application events and state changes.
  /// 
  /// @param message Informational message to log
  /// @param tag Optional tag for categorizing the log
  static void info(String message, {String? tag}) {
    _log(LogLevel.info, message, tag: tag);
  }

  /// Logs a warning message.
  /// 
  /// Warnings indicate potentially problematic situations
  /// that don't prevent operation but should be addressed.
  /// Displayed in yellow in debug console and sent to
  /// Crashlytics in production.
  /// 
  /// @param message Warning message to log
  /// @param tag Optional tag for categorizing the log
  static void warning(String message, {String? tag}) {
    _log(LogLevel.warning, message, tag: tag);
  }
  
  /// Logs an error message with optional exception details.
  /// 
  /// Errors represent failure conditions requiring attention.
  /// Displayed in red in debug console and automatically
  /// sent to Firebase Crashlytics in production builds.
  /// 
  /// @param message Error description
  /// @param tag Optional tag for categorizing the error
  /// @param error Optional error object (Exception, Error, etc.)
  /// @param stackTrace Optional stack trace for debugging
  static void error(String message, {String? tag, dynamic error, StackTrace? stackTrace}) {
    _log(LogLevel.error, message, tag: tag, error: error, stackTrace: stackTrace);
    
    // Send to Crashlytics in production
    if (!kDebugMode && error != null) {
      FirebaseCrashlytics.instance.recordError(
        error,
        stackTrace,
        reason: message,
        information: tag != null ? ['Tag: $tag'] : [],
      );
    }
  }

  /// Internal logging method handling all log levels.
  /// 
  /// Formats log messages with timestamp, level, and optional tag.
  /// Routes output based on build mode:
  /// - Debug: Prints to console with color coding
  /// - Production: Sends warnings/errors to Crashlytics
  /// 
  /// @param level Severity level of the log
  /// @param message Log message content
  /// @param tag Optional categorization tag
  /// @param error Optional error object for error logs
  /// @param stackTrace Optional stack trace for error logs
  static void _log(
    LogLevel level,
    String message, {
    String? tag,
    dynamic error,
    StackTrace? stackTrace,
  }) {
    // Skip logging if below minimum level
    final levelIndex = LogLevel.values.indexOf(level);
    final minLevelIndex = LogLevel.values.indexOf(minimumLogLevel);
    if (levelIndex < minLevelIndex) {
      return;
    }
    
    final timestamp = DateTime.now().toIso8601String();
    final levelStr = level.toString().split('.').last.toUpperCase();
    final tagStr = tag != null ? '[$tag] ' : '';
    
    final logMessage = '$timestamp [$levelStr] $tagStr$message';
    
    if (kDebugMode) {
      // In debug mode, print to console
      switch (level) {
        case LogLevel.debug:
        case LogLevel.info:
          debugPrint(logMessage);
          break;
        case LogLevel.warning:
          debugPrint('\x1B[33m$logMessage\x1B[0m'); // Yellow
          break;
        case LogLevel.error:
          debugPrint('\x1B[31m$logMessage\x1B[0m'); // Red
          if (error != null) {
            debugPrint('Error: $error');
          }
          if (stackTrace != null) {
            debugPrint('Stack trace:\n$stackTrace');
          }
          break;
      }
    } else {
      // In production, only log warnings and errors
      if (level == LogLevel.warning || level == LogLevel.error) {
        // You could send to Firebase Analytics or other logging service here
        FirebaseCrashlytics.instance.log(logMessage);
      }
    }
  }
}

/// Extension providing convenient logging methods for any object.
/// 
/// Automatically tags log messages with the object's runtime type,
/// making it easy to track which class generated each log entry.
/// 
/// Example usage:
/// ```dart
/// class MyService {
///   void doSomething() {
///     logInfo('Starting operation');
///     try {
///       // ... operation code
///     } catch (e, stack) {
///       logError('Operation failed', error: e, stackTrace: stack);
///     }
///   }
/// }
/// ```
extension LoggerExtension on Object {
  /// Gets the logger service instance.
  LoggerService get logger => LoggerService();
  
  /// Logs a debug message tagged with this object's type.
  /// 
  /// @param message Debug message to log
  void logDebug(String message) => LoggerService.debug(message, tag: runtimeType.toString());
  
  /// Logs an info message tagged with this object's type.
  /// 
  /// @param message Informational message to log
  void logInfo(String message) => LoggerService.info(message, tag: runtimeType.toString());
  
  /// Logs a warning message tagged with this object's type.
  /// 
  /// @param message Warning message to log
  void logWarning(String message) => LoggerService.warning(message, tag: runtimeType.toString());
  
  /// Logs an error message tagged with this object's type.
  /// 
  /// @param message Error description
  /// @param error Optional error object
  /// @param stackTrace Optional stack trace
  void logError(String message, {dynamic error, StackTrace? stackTrace}) => 
      LoggerService.error(message, tag: runtimeType.toString(), error: error, stackTrace: stackTrace);
}
````

## File: lib/shared/services/navigation_service.dart
````dart
import 'package:flutter/material.dart';
import 'package:shared_preferences/shared_preferences.dart';
import 'dart:convert';
import '../models/nav_item.dart';
import './logger_service.dart';

/// Service for managing navigation items and favorites
class NavigationService {
  static const String _favoritesKey = 'nav_favorites';
  static const int maxFavorites = 4;

  // All available navigation items
  static const List<NavItem> allItems = [
    // Student items
    NavItem(
      id: 'dashboard',
      title: 'Dashboard',
      route: '/dashboard',
      icon: Icons.dashboard_outlined,
      activeIcon: Icons.dashboard,
      category: 'general',
      roles: ['student', 'teacher'],
    ),
    NavItem(
      id: 'courses',
      title: 'Courses',
      route: '/student/courses',
      icon: Icons.book_outlined,
      activeIcon: Icons.book,
      category: 'academic',
      roles: ['student'],
    ),
    NavItem(
      id: 'assignments',
      title: 'Assignments',
      route: '/student/assignments',
      icon: Icons.assignment_outlined,
      activeIcon: Icons.assignment,
      category: 'academic',
      roles: ['student'],
    ),
    NavItem(
      id: 'grades',
      title: 'Grades',
      route: '/student/grades',
      icon: Icons.grade_outlined,
      activeIcon: Icons.grade,
      category: 'academic',
      roles: ['student'],
    ),
    NavItem(
      id: 'messages',
      title: 'Messages',
      route: '/messages',
      icon: Icons.chat_outlined,
      activeIcon: Icons.chat,
      category: 'communication',
      roles: ['student', 'teacher'],
    ),
    NavItem(
      id: 'calendar',
      title: 'Calendar',
      route: '/calendar',
      icon: Icons.calendar_month_outlined,
      activeIcon: Icons.calendar_month,
      category: 'planning',
      roles: ['student', 'teacher'],
    ),
    NavItem(
      id: 'notifications',
      title: 'Notifications',
      route: '/notifications',
      icon: Icons.notifications_outlined,
      activeIcon: Icons.notifications,
      category: 'communication',
      roles: ['student', 'teacher'],
    ),
    NavItem(
      id: 'discussions',
      title: 'Discussions',
      route: '/discussions',
      icon: Icons.forum_outlined,
      activeIcon: Icons.forum,
      category: 'communication',
      roles: ['student', 'teacher'],
    ),
    NavItem(
      id: 'settings',
      title: 'Settings',
      route: '/settings',
      icon: Icons.settings_outlined,
      activeIcon: Icons.settings,
      category: 'system',
      roles: ['student', 'teacher'],
    ),
    // Teacher items
    NavItem(
      id: 'classes',
      title: 'Classes',
      route: '/teacher/classes',
      icon: Icons.class_outlined,
      activeIcon: Icons.class_,
      category: 'teaching',
      roles: ['teacher'],
    ),
    NavItem(
      id: 'gradebook',
      title: 'Gradebook',
      route: '/teacher/gradebook',
      icon: Icons.grade_outlined,
      activeIcon: Icons.grade,
      category: 'teaching',
      roles: ['teacher'],
    ),
    NavItem(
      id: 'teacher-assignments',
      title: 'Assignments',
      route: '/teacher/assignments',
      icon: Icons.assignment_outlined,
      activeIcon: Icons.assignment,
      category: 'teaching',
      roles: ['teacher'],
    ),
    NavItem(
      id: 'students',
      title: 'Students',
      route: '/teacher/students',
      icon: Icons.people_outline,
      activeIcon: Icons.people,
      category: 'teaching',
      roles: ['teacher'],
    ),
    NavItem(
      id: 'analytics',
      title: 'Analytics',
      route: '/teacher/analytics',
      icon: Icons.analytics_outlined,
      activeIcon: Icons.analytics,
      category: 'teaching',
      roles: ['teacher'],
    ),
  ];

  /// Get navigation items for a specific role
  static List<NavItem> getItemsForRole(String role) {
    return allItems.where((item) => item.roles.contains(role)).toList();
  }

  /// Get items by category
  static List<NavItem> getItemsByCategory(String category, String role) {
    return allItems
        .where((item) => item.category == category && item.roles.contains(role))
        .toList();
  }

  /// Load favorite item IDs from storage
  static Future<List<String>> loadFavorites() async {
    try {
      final prefs = await SharedPreferences.getInstance();
      final favoritesJson = prefs.getString(_favoritesKey);
      if (favoritesJson != null) {
        return List<String>.from(json.decode(favoritesJson));
      }
    } catch (e) {
      LoggerService.error('Error loading favorites', tag: 'NavigationService', error: e);
    }
    return [];
  }

  /// Save favorite item IDs to storage
  static Future<bool> saveFavorites(List<String> favoriteIds) async {
    try {
      final prefs = await SharedPreferences.getInstance();
      // Limit to max favorites
      final limitedFavorites = favoriteIds.take(maxFavorites).toList();
      return await prefs.setString(_favoritesKey, json.encode(limitedFavorites));
    } catch (e) {
      LoggerService.error('Error saving favorites', tag: 'NavigationService', error: e);
      return false;
    }
  }

  /// Get default favorites for a role
  static List<String> getDefaultFavorites(String role) {
    if (role == 'student') {
      return ['dashboard', 'courses', 'assignments', 'grades'];
    } else if (role == 'teacher') {
      return ['dashboard', 'classes', 'gradebook', 'messages'];
    }
    return ['dashboard', 'settings'];
  }

  /// Get navigation items from favorite IDs
  static List<NavItem> getFavoriteItems(List<String> favoriteIds) {
    return favoriteIds
        .map((id) => allItems.firstWhere(
              (item) => item.id == id,
              orElse: () => allItems.first,
            ))
        .toList();
  }
}
````

## File: lib/shared/services/performance_service.dart
````dart
import 'dart:async';
import 'logger_service.dart';

/// Comprehensive performance monitoring service.
/// 
/// Provides performance monitoring with custom metrics,
/// trace management, and performance analysis capabilities.
class PerformanceService {
  static final PerformanceService _instance = PerformanceService._internal();
  
  /// Factory constructor returns singleton
  factory PerformanceService() => _instance;
  
  /// Private constructor
  PerformanceService._internal();
  
  /// Active traces map
  final Map<String, MockTrace> _activeTraces = {};
  
  /// Performance metrics storage
  final Map<String, PerformanceMetric> _metrics = {};
  
  /// Performance thresholds for alerting
  static const Duration _slowOperationThreshold = Duration(seconds: 3);
  
  /// Initialize the performance service
  Future<void> initialize() async {
    try {
      LoggerService.info('Performance service initialized (mock mode)');
    } catch (e) {
      LoggerService.error('Failed to initialize performance service', error: e);
    }
  }
  
  /// Start a custom trace for performance monitoring.
  /// 
  /// @param name Unique trace name
  /// @param attributes Optional attributes for the trace
  /// @return Trace object for stopping
  MockTrace? startTrace(String name, {Map<String, String>? attributes}) {
    try {
      final trace = MockTrace(name);
      _activeTraces[name] = trace;
      
      LoggerService.debug('Started trace: $name');
      return trace;
    } catch (e) {
      LoggerService.error('Failed to start trace: $name', error: e);
      return null;
    }
  }
  
  /// Stop a trace and record metrics.
  /// 
  /// @param name Trace name to stop
  /// @param metrics Optional custom metrics to record
  Future<void> stopTrace(String name, {Map<String, int>? metrics}) async {
    try {
      final trace = _activeTraces[name];
      if (trace != null) {
        trace.stop();
        _activeTraces.remove(name);
        
        LoggerService.debug('Stopped trace: $name');
      }
    } catch (e) {
      LoggerService.error('Failed to stop trace: $name', error: e);
    }
  }
  
  /// Time an async operation with automatic trace management.
  /// 
  /// @param name Operation name for tracing
  /// @param operation The async operation to time
  /// @param attributes Optional trace attributes
  /// @return Result of the operation
  Future<T> timeOperation<T>(
    String name,
    Future<T> Function() operation, {
    Map<String, String>? attributes,
  }) async {
    final stopwatch = Stopwatch()..start();
    
    try {
      final result = await operation();
      
      stopwatch.stop();
      final duration = stopwatch.elapsed;
      
      // Record metrics
      recordMetric('${name}_duration_ms', duration.inMilliseconds.toDouble());
      recordMetric('${name}_success', 1);
      
      // Log slow operations
      if (duration > _slowOperationThreshold) {
        LoggerService.warning(
          'Slow operation detected: $name (${duration.inMilliseconds}ms > ${_slowOperationThreshold.inMilliseconds}ms)',
        );
      }
      
      return result;
    } catch (error) {
      stopwatch.stop();
      final duration = stopwatch.elapsed;
      
      // Record error metrics
      recordMetric('${name}_duration_ms', duration.inMilliseconds.toDouble());
      recordMetric('${name}_error', 1);
      
      LoggerService.error(
        'Operation failed: $name (${duration.inMilliseconds}ms)',
        error: error,
      );
      
      rethrow;
    }
  }
  
  /// Record a custom metric value.
  /// 
  /// @param name Metric name
  /// @param value Metric value
  void recordMetric(String name, double value) {
    _metrics[name] = PerformanceMetric(
      name: name,
      value: value,
      timestamp: DateTime.now(),
    );
    
    LoggerService.debug('Recorded metric: $name = $value');
  }
  
  /// Get performance statistics.
  /// 
  /// @return Map of performance metrics and statistics
  Map<String, dynamic> getPerformanceStats() {
    return {
      'activeTraces': _activeTraces.length,
      'totalMetrics': _metrics.length,
      'metrics': _metrics.map((key, value) => MapEntry(key, value.toMap())),
    };
  }
  
  /// Clear all performance data.
  void clearPerformanceData() {
    _activeTraces.clear();
    _metrics.clear();
    LoggerService.debug('Performance data cleared');
  }
}

/// Mock trace implementation for performance monitoring.
class MockTrace {
  final String name;
  final DateTime _startTime;
  DateTime? _stopTime;
  
  MockTrace(this.name) : _startTime = DateTime.now();
  
  void stop() {
    _stopTime = DateTime.now();
  }
  
  Duration get duration => _stopTime?.difference(_startTime) ?? Duration.zero;
}

/// Performance metric data container.
class PerformanceMetric {
  final String name;
  final double value;
  final DateTime timestamp;
  
  PerformanceMetric({
    required this.name,
    required this.value,
    required this.timestamp,
  });
  
  Map<String, dynamic> toMap() {
    return {
      'name': name,
      'value': value,
      'timestamp': timestamp.toIso8601String(),
    };
  }
}
````

## File: lib/shared/services/retry_service.dart
````dart
import 'dart:async';
import 'dart:math';
import 'package:flutter/foundation.dart';
import 'logger_service.dart';

/// Service for handling retries with exponential backoff.
/// 
/// Provides resilient error handling for network operations,
/// API calls, and other potentially failing operations.
class RetryService {
  /// Default retry configuration
  static const RetryConfig defaultConfig = RetryConfig();
  
  /// Execute an operation with retry logic.
  /// 
  /// Attempts to execute the provided operation with automatic
  /// retry on failure using exponential backoff.
  /// 
  /// @param operation The async operation to execute
  /// @param config Retry configuration options
  /// @param onRetry Optional callback called before each retry
  /// @return Result of the operation
  /// @throws The last error if all retries fail
  static Future<T> withRetry<T>(
    Future<T> Function() operation, {
    RetryConfig config = defaultConfig,
    void Function(int attempt, Duration delay, dynamic error)? onRetry,
  }) async {
    int attempt = 0;
    dynamic lastError;
    
    while (attempt < config.maxAttempts) {
      try {
        // Attempt the operation
        return await operation();
      } catch (error) {
        lastError = error;
        attempt++;
        
        // Check if error is retryable
        if (!_isRetryableError(error, config)) {
          LoggerService.error(
            'Non-retryable error encountered (attempt: $attempt)',
            error: error,
          );
          rethrow;
        }
        
        // Check if we've exhausted retries
        if (attempt >= config.maxAttempts) {
          LoggerService.error(
            'Max retry attempts reached (attempts: $attempt, max: ${config.maxAttempts})',
            error: error,
          );
          break;
        }
        
        // Calculate delay with exponential backoff
        final delay = _calculateDelay(
          attempt: attempt,
          baseDelay: config.baseDelay,
          maxDelay: config.maxDelay,
          jitter: config.useJitter,
        );
        
        // Log retry attempt
        LoggerService.warning(
          'Retrying operation (attempt: $attempt/${config.maxAttempts}, delay: ${delay.inMilliseconds}ms, error: ${error.toString()})',
        );
        
        // Call retry callback if provided
        onRetry?.call(attempt, delay, error);
        
        // Wait before retrying
        await Future.delayed(delay);
      }
    }
    
    // All retries exhausted
    throw RetryException(
      'Operation failed after $attempt attempts',
      lastError: lastError,
      attempts: attempt,
    );
  }
  
  /// Execute an operation with timeout and retry.
  /// 
  /// Combines timeout handling with retry logic for operations
  /// that might hang or take too long.
  static Future<T> withTimeoutAndRetry<T>(
    Future<T> Function() operation, {
    required Duration timeout,
    RetryConfig config = defaultConfig,
    void Function(int attempt, Duration delay, dynamic error)? onRetry,
  }) async {
    return withRetry(
      () => operation().timeout(
        timeout,
        onTimeout: () {
          throw TimeoutException(
            'Operation timed out after ${timeout.inSeconds} seconds',
            timeout,
          );
        },
      ),
      config: config,
      onRetry: onRetry,
    );
  }
  
  /// Execute multiple operations with retry.
  /// 
  /// Attempts all operations and retries only the failed ones.
  /// Useful for batch operations where partial success is acceptable.
  static Future<List<RetryResult<T>>> withRetryBatch<T>(
    List<Future<T> Function()> operations, {
    RetryConfig config = defaultConfig,
    bool stopOnFirstError = false,
  }) async {
    final results = <RetryResult<T>>[];
    
    for (int i = 0; i < operations.length; i++) {
      try {
        final result = await withRetry(
          operations[i],
          config: config,
        );
        results.add(RetryResult.success(result, index: i));
      } catch (error) {
        results.add(RetryResult.failure(error, index: i));
        
        if (stopOnFirstError) {
          // Add remaining operations as skipped
          for (int j = i + 1; j < operations.length; j++) {
            results.add(RetryResult.skipped(index: j));
          }
          break;
        }
      }
    }
    
    return results;
  }
  
  /// Create a retry-enabled function wrapper.
  /// 
  /// Wraps a function to automatically retry on failure.
  /// Useful for creating resilient API clients.
  static Future<T> Function() createRetryable<T>(
    Future<T> Function() operation, {
    RetryConfig config = defaultConfig,
  }) {
    return () => withRetry(operation, config: config);
  }
  
  /// Calculate delay with exponential backoff.
  static Duration _calculateDelay({
    required int attempt,
    required Duration baseDelay,
    required Duration maxDelay,
    required bool jitter,
  }) {
    // Calculate exponential delay
    final exponentialDelay = baseDelay * pow(2, attempt - 1);
    
    // Cap at max delay
    var delay = exponentialDelay > maxDelay ? maxDelay : exponentialDelay;
    
    // Add jitter if enabled
    if (jitter) {
      final random = Random();
      final jitterAmount = delay * random.nextDouble() * 0.3; // Up to 30% jitter
      delay = delay + jitterAmount;
    }
    
    return delay;
  }
  
  /// Check if an error is retryable.
  static bool _isRetryableError(dynamic error, RetryConfig config) {
    // Check custom retry condition
    if (config.retryIf != null) {
      return config.retryIf!(error);
    }
    
    // Default retryable errors
    final errorString = error.toString().toLowerCase();
    
    // Network errors
    if (errorString.contains('network') ||
        errorString.contains('connection') ||
        errorString.contains('timeout') ||
        errorString.contains('unavailable') ||
        errorString.contains('deadline')) {
      return true;
    }
    
    // Firebase errors
    if (errorString.contains('firebase') &&
        (errorString.contains('unavailable') ||
         errorString.contains('internal') ||
         errorString.contains('deadline-exceeded'))) {
      return true;
    }
    
    // HTTP errors (5xx are retryable, 4xx are not)
    if (error is Exception) {
      final message = error.toString();
      if (message.contains('500') ||
          message.contains('502') ||
          message.contains('503') ||
          message.contains('504')) {
        return true;
      }
    }
    
    return false;
  }
}

/// Configuration for retry behavior.
@immutable
class RetryConfig {
  /// Maximum number of retry attempts
  final int maxAttempts;
  
  /// Base delay between retries
  final Duration baseDelay;
  
  /// Maximum delay between retries
  final Duration maxDelay;
  
  /// Whether to add jitter to delays
  final bool useJitter;
  
  /// Custom condition for retryable errors
  final bool Function(dynamic error)? retryIf;
  
  const RetryConfig({
    this.maxAttempts = 3,
    this.baseDelay = const Duration(seconds: 1),
    this.maxDelay = const Duration(seconds: 30),
    this.useJitter = true,
    this.retryIf,
  });
  
  /// Create a copy with updated values
  RetryConfig copyWith({
    int? maxAttempts,
    Duration? baseDelay,
    Duration? maxDelay,
    bool? useJitter,
    bool Function(dynamic error)? retryIf,
  }) {
    return RetryConfig(
      maxAttempts: maxAttempts ?? this.maxAttempts,
      baseDelay: baseDelay ?? this.baseDelay,
      maxDelay: maxDelay ?? this.maxDelay,
      useJitter: useJitter ?? this.useJitter,
      retryIf: retryIf ?? this.retryIf,
    );
  }
}

/// Result of a batch retry operation.
class RetryResult<T> {
  /// Whether the operation succeeded
  final bool success;
  
  /// The result value (if successful)
  final T? value;
  
  /// The error (if failed)
  final dynamic error;
  
  /// Whether the operation was skipped
  final bool skipped;
  
  /// Index in the original batch
  final int index;
  
  const RetryResult._({
    required this.success,
    this.value,
    this.error,
    required this.skipped,
    required this.index,
  });
  
  /// Create a successful result
  factory RetryResult.success(T value, {required int index}) {
    return RetryResult._(
      success: true,
      value: value,
      skipped: false,
      index: index,
    );
  }
  
  /// Create a failed result
  factory RetryResult.failure(dynamic error, {required int index}) {
    return RetryResult._(
      success: false,
      error: error,
      skipped: false,
      index: index,
    );
  }
  
  /// Create a skipped result
  factory RetryResult.skipped({required int index}) {
    return RetryResult._(
      success: false,
      skipped: true,
      index: index,
    );
  }
}

/// Exception thrown when all retry attempts fail.
class RetryException implements Exception {
  /// Error message
  final String message;
  
  /// The last error encountered
  final dynamic lastError;
  
  /// Number of attempts made
  final int attempts;
  
  const RetryException(
    this.message, {
    this.lastError,
    required this.attempts,
  });
  
  @override
  String toString() {
    return 'RetryException: $message (attempts: $attempts, lastError: $lastError)';
  }
}

/// Common retry configurations.
class RetryConfigs {
  /// Fast retry for quick operations
  static const fast = RetryConfig(
    maxAttempts: 3,
    baseDelay: Duration(milliseconds: 100),
    maxDelay: Duration(seconds: 2),
  );
  
  /// Standard retry for network operations
  static const standard = RetryConfig(
    maxAttempts: 3,
    baseDelay: Duration(seconds: 1),
    maxDelay: Duration(seconds: 10),
  );
  
  /// Aggressive retry for critical operations
  static const aggressive = RetryConfig(
    maxAttempts: 5,
    baseDelay: Duration(seconds: 2),
    maxDelay: Duration(seconds: 60),
  );
  
  /// No retry (single attempt)
  static const noRetry = RetryConfig(
    maxAttempts: 1,
  );
}
````

## File: lib/shared/services/validation_service.dart
````dart
import 'dart:convert';

/// Comprehensive validation and sanitization service for user inputs
class ValidationService {
  
  // Email validation regex - RFC 5322 compliant
  static final _emailRegex = RegExp(
    r'^[a-zA-Z0-9.!#$%&*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$',
  );
  
  // Password strength regex patterns
  static final _hasUpperCase = RegExp(r'[A-Z]');
  static final _hasLowerCase = RegExp(r'[a-z]');
  static final _hasDigit = RegExp(r'\d');
  static final _hasSpecialChar = RegExp(r'[!@#$%^&*(),.?":{}|<>]');
  
  // Phone number patterns for common formats
  static final _phoneRegex = RegExp(
    r'^(\+\d{1,3}[- ]?)?\(?\d{3}\)?[- ]?\d{3}[- ]?\d{4}$',
  );
  
  // Class code pattern (6 characters, uppercase letters and numbers)
  static final _classCodeRegex = RegExp(r'^[A-Z0-9]{6}$');
  
  // Username pattern (alphanumeric, underscore, hyphen, 3-20 chars)
  static final _usernameRegex = RegExp(r'^[a-zA-Z0-9_-]{3,20}$');
  
  // URL validation pattern
  static final _urlRegex = RegExp(
    r'^https?:\/\/(www\.)?[-a-zA-Z0-9@:%._\+~#=]{1,256}\.[a-zA-Z0-9()]{1,6}\b([-a-zA-Z0-9()@:%_\+.~#?&//=]*)$',
  );

  /// Validate email address
  static String? validateEmail(String? email) {
    if (email == null || email.isEmpty) {
      return 'Email is required';
    }
    
    final trimmed = email.trim().toLowerCase();
    if (!_emailRegex.hasMatch(trimmed)) {
      return 'Please enter a valid email address';
    }
    
    // Additional checks for common typos
    if (trimmed.contains('..') || 
        trimmed.startsWith('.') || 
        trimmed.endsWith('.') ||
        trimmed.contains('@.') ||
        trimmed.contains('.@')) {
      return 'Invalid email format';
    }
    
    return null;
  }

  /// Validate password with strength requirements
  static String? validatePassword(String? password, {
    int minLength = 8,
    bool requireUpperCase = true,
    bool requireLowerCase = true,
    bool requireDigit = true,
    bool requireSpecialChar = true,
  }) {
    if (password == null || password.isEmpty) {
      return 'Password is required';
    }
    
    if (password.length < minLength) {
      return 'Password must be at least $minLength characters';
    }
    
    final requirements = <String>[];
    
    if (requireUpperCase && !_hasUpperCase.hasMatch(password)) {
      requirements.add('uppercase letter');
    }
    
    if (requireLowerCase && !_hasLowerCase.hasMatch(password)) {
      requirements.add('lowercase letter');
    }
    
    if (requireDigit && !_hasDigit.hasMatch(password)) {
      requirements.add('number');
    }
    
    if (requireSpecialChar && !_hasSpecialChar.hasMatch(password)) {
      requirements.add('special character');
    }
    
    if (requirements.isNotEmpty) {
      final reqText = requirements.join(', ');
      return 'Password must contain at least one $reqText';
    }
    
    return null;
  }

  /// Validate username
  static String? validateUsername(String? username) {
    if (username == null || username.isEmpty) {
      return 'Username is required';
    }
    
    if (username.length < 3) {
      return 'Username must be at least 3 characters';
    }
    
    if (username.length > 20) {
      return 'Username must be less than 20 characters';
    }
    
    if (!_usernameRegex.hasMatch(username)) {
      return 'Username can only contain letters, numbers, underscore, and hyphen';
    }
    
    // Check for offensive words (basic list - extend as needed)
    final lowercased = username.toLowerCase();
    final restrictedUsernames = ['admin', 'root', 'test', 'user', 'guest'];
    if (restrictedUsernames.contains(lowercased)) {
      return 'This username is not available';
    }
    
    return null;
  }

  /// Validate display name
  static String? validateDisplayName(String? name) {
    if (name == null || name.isEmpty) {
      return 'Name is required';
    }
    
    final trimmed = name.trim();
    if (trimmed.length < 2) {
      return 'Name must be at least 2 characters';
    }
    
    if (trimmed.length > 50) {
      return 'Name must be less than 50 characters';
    }
    
    // Allow letters, spaces, hyphens, apostrophes
    final nameRegex = RegExp(r"^[a-zA-Z\s\-']+$");
    if (!nameRegex.hasMatch(trimmed)) {
      return 'Name can only contain letters, spaces, hyphens, and apostrophes';
    }
    
    return null;
  }

  /// Validate phone number
  static String? validatePhoneNumber(String? phone) {
    if (phone == null || phone.isEmpty) {
      return null; // Phone is often optional
    }
    
    final cleaned = phone.replaceAll(RegExp(r'[^\d+]'), '');
    if (cleaned.length < 10 || cleaned.length > 15) {
      return 'Please enter a valid phone number';
    }
    
    if (!_phoneRegex.hasMatch(phone)) {
      return 'Invalid phone number format';
    }
    
    return null;
  }

  /// Validate class code
  static String? validateClassCode(String? code) {
    if (code == null || code.isEmpty) {
      return 'Class code is required';
    }
    
    final upperCode = code.toUpperCase().trim();
    if (upperCode.length != 6) {
      return 'Class code must be exactly 6 characters';
    }
    
    if (!_classCodeRegex.hasMatch(upperCode)) {
      return 'Class code can only contain uppercase letters and numbers';
    }
    
    return null;
  }

  /// Validate URL
  static String? validateUrl(String? url) {
    if (url == null || url.isEmpty) {
      return null; // URLs are often optional
    }
    
    if (!_urlRegex.hasMatch(url)) {
      return 'Please enter a valid URL';
    }
    
    return null;
  }

  /// Validate age/date of birth
  static String? validateAge(int? age, {int minAge = 13, int maxAge = 120}) {
    if (age == null) {
      return 'Age is required';
    }
    
    if (age < minAge) {
      return 'You must be at least $minAge years old';
    }
    
    if (age > maxAge) {
      return 'Please enter a valid age';
    }
    
    return null;
  }

  /// Validate text length
  static String? validateTextLength(
    String? text, {
    required String fieldName,
    int? minLength,
    int? maxLength,
    bool required = true,
  }) {
    if (text == null || text.isEmpty) {
      return required ? '$fieldName is required' : null;
    }
    
    final trimmed = text.trim();
    
    if (minLength != null && trimmed.length < minLength) {
      return '$fieldName must be at least $minLength characters';
    }
    
    if (maxLength != null && trimmed.length > maxLength) {
      return '$fieldName must be less than $maxLength characters';
    }
    
    return null;
  }

  /// Sanitize HTML input
  static String sanitizeHtml(String input) {
    // Basic HTML entity decoding
    var sanitized = input
        .replaceAll('&amp;', '&')
        .replaceAll('&lt;', '<')
        .replaceAll('&gt;', '>')
        .replaceAll('&quot;', '"')
        .replaceAll('&#39;', "'");
    
    // Remove script tags and their content
    sanitized = sanitized.replaceAll(RegExp(r'<script[^>]*>.*?</script>', 
        multiLine: true, caseSensitive: false), '');
    
    // Remove iframe tags
    sanitized = sanitized.replaceAll(RegExp(r'<iframe[^>]*>.*?</iframe>', 
        multiLine: true, caseSensitive: false), '');
    
    // Remove event handlers (simplified)
    sanitized = sanitized.replaceAll(RegExp(r'on\w+\s*=', caseSensitive: false), '');
    
    // Remove javascript: URLs
    sanitized = sanitized.replaceAll(RegExp(r'javascript:', 
        caseSensitive: false), '');
    
    return sanitized.trim();
  }

  /// Sanitize input for Firebase paths
  static String sanitizeFirebasePath(String input) {
    // Firebase doesn't allow: ., #, $, [, ]
    return input
        .replaceAll('.', '_')
        .replaceAll('#', '_')
        .replaceAll('\$', '_')
        .replaceAll('[', '_')
        .replaceAll(']', '_')
        .replaceAll('/', '_'); // Also replace forward slashes
  }

  /// Sanitize input for display (prevent XSS)
  static String sanitizeForDisplay(String input) {
    return input
        .replaceAll('&', '&amp;')
        .replaceAll('<', '&lt;')
        .replaceAll('>', '&gt;')
        .replaceAll('"', '&quot;')
        .replaceAll("'", '&#39;');
  }

  /// Validate and sanitize JSON string
  static Map<String, dynamic>? validateJson(String? jsonString) {
    if (jsonString == null || jsonString.isEmpty) {
      return null;
    }
    
    try {
      final decoded = json.decode(jsonString);
      if (decoded is Map<String, dynamic>) {
        return decoded;
      }
    } catch (e) {
      // Invalid JSON
    }
    
    return null;
  }

  /// Check if string contains SQL injection patterns
  static bool containsSqlInjection(String input) {
    final sqlPatterns = [
      RegExp(r'\b(union|select|insert|update|delete|drop|create)\b', 
          caseSensitive: false),
      RegExp(r'(--|;)', caseSensitive: false),
      RegExp(r"['`]", caseSensitive: false),
    ];
    
    return sqlPatterns.any((pattern) => pattern.hasMatch(input));
  }

  /// Validate file upload
  static String? validateFileUpload({
    required String fileName,
    required int fileSizeBytes,
    List<String> allowedExtensions = const ['.jpg', '.jpeg', '.png', '.gif', '.pdf', '.doc', '.docx'],
    int maxSizeMB = 10,
  }) {
    // Check file extension
    final extension = fileName.toLowerCase().substring(fileName.lastIndexOf('.'));
    if (!allowedExtensions.contains(extension)) {
      return 'File type not allowed. Allowed types: ${allowedExtensions.join(', ')}';
    }
    
    // Check file size
    final maxSizeBytes = maxSizeMB * 1024 * 1024;
    if (fileSizeBytes > maxSizeBytes) {
      return 'File size must be less than $maxSizeMB MB';
    }
    
    // Check for double extensions (potential security risk)
    final parts = fileName.split('.');
    if (parts.length > 2) {
      // Check if any part contains executable extensions
      final dangerousExtensions = ['exe', 'bat', 'cmd', 'sh', 'app'];
      for (final part in parts) {
        if (dangerousExtensions.contains(part.toLowerCase())) {
          return 'Invalid file name';
        }
      }
    }
    
    return null;
  }

  /// Validate credit card number (basic Luhn algorithm)
  static String? validateCreditCard(String? cardNumber) {
    if (cardNumber == null || cardNumber.isEmpty) {
      return 'Card number is required';
    }
    
    // Remove spaces and hyphens
    final cleaned = cardNumber.replaceAll(RegExp(r'[\s-]'), '');
    
    // Check if all characters are digits
    if (!RegExp(r'^\d+$').hasMatch(cleaned)) {
      return 'Card number can only contain digits';
    }
    
    // Check length (most cards are 13-19 digits)
    if (cleaned.length < 13 || cleaned.length > 19) {
      return 'Invalid card number length';
    }
    
    // Luhn algorithm
    var sum = 0;
    var isEven = false;
    
    for (var i = cleaned.length - 1; i >= 0; i--) {
      var digit = int.parse(cleaned[i]);
      
      if (isEven) {
        digit *= 2;
        if (digit > 9) {
          digit -= 9;
        }
      }
      
      sum += digit;
      isEven = !isEven;
    }
    
    if (sum % 10 != 0) {
      return 'Invalid card number';
    }
    
    return null;
  }

  /// Generate strong password
  static String generateStrongPassword({
    int length = 16,
    bool includeUpperCase = true,
    bool includeLowerCase = true,
    bool includeDigits = true,
    bool includeSpecialChars = true,
  }) {
    const upperCase = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
    const lowerCase = 'abcdefghijklmnopqrstuvwxyz';
    const digits = '0123456789';
    const specialChars = '!@#\$%^&*()_+-=[]{}|;:,.<>?';
    
    var chars = '';
    if (includeUpperCase) chars += upperCase;
    if (includeLowerCase) chars += lowerCase;
    if (includeDigits) chars += digits;
    if (includeSpecialChars) chars += specialChars;
    
    if (chars.isEmpty) {
      throw ArgumentError('At least one character type must be included');
    }
    
    final random = DateTime.now().millisecondsSinceEpoch;
    final password = List.generate(length, (index) {
      final charIndex = (random + index * 7) % chars.length;
      return chars[charIndex];
    });
    
    // Shuffle the password
    password.shuffle();
    
    return password.join();
  }
}
````

## File: lib/shared/theme/app_spacing.dart
````dart
/// Design system spacing constants and utilities.
/// 
/// This module provides a comprehensive spacing system based on an 8-pixel
/// grid, ensuring visual consistency across the application. Includes
/// semantic spacing values, component-specific dimensions, responsive
/// breakpoints, and utility methods for adaptive layouts.
library;

/// Central spacing system for consistent layout and design.
/// 
/// This class provides a complete design system with:
/// - 8-pixel grid-based spacing scale for visual rhythm
/// - Semantic spacing aliases for intuitive usage
/// - Component-specific dimensions for UI elements
/// - Responsive breakpoints and adaptive utilities
/// - Layout constants for navigation and content areas
/// - Form, grid, and content spacing guidelines
/// - Animation timing constants
/// 
/// All spacing values are based on a base unit of 8 pixels,
/// following Material Design spacing principles.
class AppSpacing {
  /// Base spacing unit (8px) for the design system.
  /// 
  /// All spacing values are multiples of this base unit
  /// to maintain consistent visual rhythm.
  static const double _baseUnit = 8.0;

  /// Extra small spacing (4px) - minimal gaps.
  static const double xs = _baseUnit * 0.5;  // 4px
  
  /// Small spacing (8px) - base unit for tight layouts.
  static const double sm = _baseUnit;        // 8px
  
  /// Medium spacing (16px) - standard component spacing.
  static const double md = _baseUnit * 2;    // 16px
  
  /// Large spacing (24px) - section separators.
  static const double lg = _baseUnit * 3;    // 24px
  
  /// Extra large spacing (32px) - major layout gaps.
  static const double xl = _baseUnit * 4;    // 32px
  
  /// Double extra large spacing (48px) - large separations.
  static const double xxl = _baseUnit * 6;   // 48px
  
  /// Triple extra large spacing (64px) - maximum gaps.
  static const double xxxl = _baseUnit * 8;  // 64px

  /// Tiny spacing alias for minimal gaps.
  static const double tiny = xs;
  
  /// Small spacing alias for compact layouts.
  static const double small = sm;
  
  /// Medium spacing alias for standard spacing.
  static const double medium = md;
  
  /// Large spacing alias for generous spacing.
  static const double large = lg;
  
  /// Extra large spacing alias for major separations.
  static const double extraLarge = xl;
  
  /// Huge spacing alias for large layout gaps.
  static const double huge = xxl;
  
  /// Massive spacing alias for maximum separations.
  static const double massive = xxxl;

  /// Standard padding for card components.
  static const double cardPadding = md;
  
  /// Standard margin between cards.
  static const double cardMargin = sm;
  
  /// Padding for list item components.
  static const double listItemPadding = md;
  
  /// Internal padding for button components.
  static const double buttonPadding = md;
  
  /// Default screen edge padding.
  static const double screenPadding = md;
  
  /// Spacing between major screen sections.
  static const double sectionSpacing = lg;
  
  /// Width of navigation drawer in pixels.
  static const double drawerWidth = 280.0;
  
  /// Width of compact navigation rail.
  static const double railWidth = 72.0;
  
  /// Width of extended navigation rail with labels.
  static const double extendedRailWidth = 256.0;
  
  /// Standard application bar height.
  static const double appBarHeight = 56.0;
  
  /// Height of bottom navigation bar.
  static const double bottomNavHeight = 80.0;
  
  /// Spacing between form fields.
  static const double formFieldSpacing = md;
  
  /// Spacing between form sections.
  static const double formSectionSpacing = lg;
  
  /// Spacing above form action buttons.
  static const double formButtonSpacing = xl;
  
  /// Horizontal spacing between grid items.
  static const double gridSpacing = md;
  
  /// Vertical spacing between grid rows.
  static const double gridRunSpacing = md;
  
  /// Extra small icon size for inline text icons.
  static const double iconXs = 12.0;
  
  /// Small icon size for compact UI elements.
  static const double iconSm = 16.0;
  
  /// Medium icon size for standard buttons and lists.
  static const double iconMd = 24.0;
  
  /// Large icon size for prominent actions.
  static const double iconLg = 32.0;
  
  /// Extra large icon size for hero elements.
  static const double iconXl = 48.0;
  
  /// Double extra large icon size for feature graphics.
  static const double iconXxl = 64.0;
  
  /// Small avatar size for compact lists.
  static const double avatarSm = 24.0;
  
  /// Medium avatar size for standard profiles.
  static const double avatarMd = 40.0;
  
  /// Large avatar size for detailed views.
  static const double avatarLg = 56.0;
  
  /// Extra large avatar size for profile headers.
  static const double avatarXl = 72.0;
  
  /// Small button height for compact interfaces.
  static const double buttonHeightSm = 32.0;
  
  /// Medium button height for standard actions.
  static const double buttonHeightMd = 40.0;
  
  /// Large button height for prominent actions.
  static const double buttonHeightLg = 48.0;
  
  /// Extra large button height for hero CTAs.
  static const double buttonHeightXl = 56.0;
  
  /// Extra small border radius for subtle rounding.
  static const double radiusXs = 4.0;
  
  /// Small border radius for buttons and cards.
  static const double radiusSm = 8.0;
  
  /// Medium border radius for containers.
  static const double radiusMd = 12.0;
  
  /// Large border radius for prominent elements.
  static const double radiusLg = 16.0;
  
  /// Extra large border radius for special elements.
  static const double radiusXl = 24.0;
  
  /// Fully rounded border radius for circular elements.
  static const double radiusRound = 999.0;
  
  /// No elevation for flat surfaces.
  static const double elevation0 = 0.0;
  
  /// Minimal elevation for subtle depth.
  static const double elevation1 = 1.0;
  
  /// Low elevation for cards and buttons.
  static const double elevation2 = 2.0;
  
  /// Medium-low elevation for interactive elements.
  static const double elevation3 = 3.0;
  
  /// Medium elevation for floating elements.
  static const double elevation4 = 4.0;
  
  /// Medium-high elevation for prominent cards.
  static const double elevation6 = 6.0;
  
  /// High elevation for navigation elements.
  static const double elevation8 = 8.0;
  
  /// Very high elevation for modal elements.
  static const double elevation12 = 12.0;
  
  /// Maximum standard elevation for dialogs.
  static const double elevation16 = 16.0;
  
  /// Extreme elevation for special overlays.
  static const double elevation24 = 24.0;
  
  /// Screen width threshold for mobile devices.
  static const double mobileBreakpoint = 600.0;
  
  /// Screen width threshold for tablet devices.
  static const double tabletBreakpoint = 768.0;
  
  /// Screen width threshold for desktop devices.
  static const double desktopBreakpoint = 1024.0;
  
  /// Screen width threshold for large desktop displays.
  static const double largeDesktopBreakpoint = 1440.0;
  
  /// Maximum width for main content areas.
  static const double maxContentWidth = 1200.0;
  
  /// Maximum width for form containers.
  static const double maxFormWidth = 400.0;
  
  /// Maximum width for card components.
  static const double maxCardWidth = 600.0;
  
  /// Fast animation duration for micro-interactions.
  static const Duration animationFast = Duration(milliseconds: 150);
  
  /// Medium animation duration for standard transitions.
  static const Duration animationMedium = Duration(milliseconds: 300);
  
  /// Slow animation duration for complex transitions.
  static const Duration animationSlow = Duration(milliseconds: 500);
  
  /// Returns responsive spacing based on screen width.
  /// 
  /// Selects spacing value based on device breakpoints:
  /// - Desktop: >= 1024px
  /// - Tablet: >= 768px  
  /// - Mobile: < 768px
  /// 
  /// @param mobile Spacing for mobile devices
  /// @param tablet Spacing for tablet devices
  /// @param desktop Spacing for desktop devices
  /// @param screenWidth Current screen width in pixels
  /// @return Appropriate spacing value for screen size
  static double responsive(
    double mobile, 
    double tablet, 
    double desktop, 
    double screenWidth,
  ) {
    if (screenWidth >= desktopBreakpoint) {
      return desktop;
    } else if (screenWidth >= tabletBreakpoint) {
      return tablet;
    } else {
      return mobile;
    }
  }
  
  /// Returns responsive screen padding based on device size.
  /// 
  /// Provides appropriate edge padding:
  /// - Mobile: medium (16px)
  /// - Tablet: large (24px)
  /// - Desktop: extra large (32px)
  /// 
  /// @param screenWidth Current screen width in pixels
  /// @return Responsive padding value
  static double getScreenPadding(double screenWidth) {
    return responsive(md, lg, xl, screenWidth);
  }
  
  /// Returns responsive grid column count based on screen size.
  /// 
  /// Grid layout adaptation:
  /// - Large Desktop (≥1440px): 4 columns
  /// - Desktop (≥1024px): 3 columns
  /// - Tablet (≥768px): 2 columns
  /// - Mobile (<768px): 1 column
  /// 
  /// @param screenWidth Current screen width in pixels
  /// @return Number of grid columns for screen size
  static int getGridColumns(double screenWidth) {
    if (screenWidth >= largeDesktopBreakpoint) {
      return 4;
    } else if (screenWidth >= desktopBreakpoint) {
      return 3;
    } else if (screenWidth >= tabletBreakpoint) {
      return 2;
    } else {
      return 1;
    }
  }
  
  /// Calculates responsive card width based on grid layout.
  /// 
  /// Automatically calculates card width considering:
  /// - Screen padding on both sides
  /// - Grid spacing between cards
  /// - Number of columns for screen size
  /// 
  /// Desktop: (screen - padding - 2*spacing) / 3 columns
  /// Tablet: (screen - padding - spacing) / 2 columns  
  /// Mobile: screen - padding (full width)
  /// 
  /// @param screenWidth Current screen width in pixels
  /// @return Calculated card width for responsive grid
  static double getCardWidth(double screenWidth) {
    if (screenWidth >= desktopBreakpoint) {
      return (screenWidth - (getScreenPadding(screenWidth) * 2) - (gridSpacing * 2)) / 3;
    } else if (screenWidth >= tabletBreakpoint) {
      return (screenWidth - (getScreenPadding(screenWidth) * 2) - gridSpacing) / 2;
    } else {
      return screenWidth - (getScreenPadding(screenWidth) * 2);
    }
  }
}
````

## File: lib/shared/theme/app_theme.dart
````dart
/// Application theme configuration and utilities.
/// 
/// This module provides comprehensive theme configuration for both light and
/// dark modes, including Material 3 design compliance, educational-specific
/// color schemes, and utility methods for dynamic styling.
library;

import 'package:flutter/material.dart';

/// Central theme configuration for the application.
/// 
/// This class provides complete theme management with:
/// - Material 3 compliant light and dark themes
/// - Educational-specific color schemes and utilities
/// - Semantic color definitions for grades and priorities
/// - Subject-specific color coding for visual organization
/// - Custom component theming for consistency
/// - Utility methods for dynamic color selection
/// 
/// The theme follows Material 3 design principles while
/// incorporating educational context-specific styling.
class AppTheme {
  /// Primary brand color - Indigo for professional education feel.
  static const Color primaryColor = Color(0xFF3F51B5); // Indigo
  
  /// Secondary accent color - Teal for complementary contrast.
  static const Color secondaryColor = Color(0xFF009688); // Teal
  
  /// Error color for validation messages and alerts.
  static const Color errorColor = Color(0xFFE53935);
  
  /// Warning color for caution messages and notices.
  static const Color warningColor = Color(0xFFFF9800);
  
  /// Success color for positive feedback and confirmations.
  static const Color successColor = Color(0xFF4CAF50);

  /// Generates Material 3 color scheme from primary color.
  /// 
  /// Creates a harmonious color palette following Material 3
  /// design principles using the primary color as seed.
  /// 
  /// @param brightness Light or dark theme brightness
  /// @return Generated color scheme
  static ColorScheme _createColorScheme(Brightness brightness) {
    return ColorScheme.fromSeed(
      seedColor: primaryColor,
      brightness: brightness,
    );
  }

  /// Creates the light theme configuration.
  /// 
  /// Provides a clean, professional light theme suitable for
  /// educational environments with high readability and
  /// accessibility considerations.
  /// 
  /// @return Configured light theme data
  static ThemeData lightTheme() {
    final colorScheme = _createColorScheme(Brightness.light);
    
    return ThemeData(
      useMaterial3: true,
      colorScheme: colorScheme,
      brightness: Brightness.light,
      
      // App Bar Theme
      appBarTheme: AppBarTheme(
        centerTitle: true,
        elevation: 0,
        scrolledUnderElevation: 1,
        backgroundColor: colorScheme.surface,
        foregroundColor: colorScheme.onSurface,
        titleTextStyle: TextStyle(
          color: colorScheme.onSurface,
          fontSize: 20,
          fontWeight: FontWeight.w600,
        ),
      ),

      // Card Theme
      cardTheme: CardThemeData(
        color: colorScheme.surface,
        surfaceTintColor: colorScheme.surfaceTint,
        elevation: 1,
        shadowColor: colorScheme.shadow.withValues(alpha: 0.1),
        margin: const EdgeInsets.all(8),
        shape: RoundedRectangleBorder(
          borderRadius: BorderRadius.circular(12),
          side: BorderSide(color: colorScheme.outline.withValues(alpha: 0.2), width: 0.5),
        ),
      ),

      // Elevated Button Theme
      elevatedButtonTheme: ElevatedButtonThemeData(
        style: ElevatedButton.styleFrom(
          elevation: 2,
          padding: const EdgeInsets.symmetric(horizontal: 24, vertical: 12),
          shape: RoundedRectangleBorder(
            borderRadius: BorderRadius.circular(8),
          ),
        ),
      ),

      // Filled Button Theme
      filledButtonTheme: FilledButtonThemeData(
        style: FilledButton.styleFrom(
          padding: const EdgeInsets.symmetric(horizontal: 24, vertical: 12),
          shape: RoundedRectangleBorder(
            borderRadius: BorderRadius.circular(8),
          ),
        ),
      ),

      // Outlined Button Theme
      outlinedButtonTheme: OutlinedButtonThemeData(
        style: OutlinedButton.styleFrom(
          padding: const EdgeInsets.symmetric(horizontal: 24, vertical: 12),
          shape: RoundedRectangleBorder(
            borderRadius: BorderRadius.circular(8),
          ),
        ),
      ),

      // Text Button Theme
      textButtonTheme: TextButtonThemeData(
        style: TextButton.styleFrom(
          padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
          shape: RoundedRectangleBorder(
            borderRadius: BorderRadius.circular(8),
          ),
        ),
      ),

      // Input Decoration Theme
      inputDecorationTheme: InputDecorationTheme(
        filled: true,
        fillColor: colorScheme.surfaceContainerHighest.withValues(alpha: 0.5),
        border: OutlineInputBorder(
          borderRadius: BorderRadius.circular(12),
          borderSide: BorderSide(color: colorScheme.outline),
        ),
        enabledBorder: OutlineInputBorder(
          borderRadius: BorderRadius.circular(12),
          borderSide: BorderSide(color: colorScheme.outline),
        ),
        focusedBorder: OutlineInputBorder(
          borderRadius: BorderRadius.circular(12),
          borderSide: BorderSide(color: colorScheme.primary, width: 2),
        ),
        errorBorder: OutlineInputBorder(
          borderRadius: BorderRadius.circular(12),
          borderSide: BorderSide(color: colorScheme.error),
        ),
        focusedErrorBorder: OutlineInputBorder(
          borderRadius: BorderRadius.circular(12),
          borderSide: BorderSide(color: colorScheme.error, width: 2),
        ),
        contentPadding: const EdgeInsets.symmetric(horizontal: 16, vertical: 16),
      ),

      // List Tile Theme
      listTileTheme: ListTileThemeData(
        shape: RoundedRectangleBorder(
          borderRadius: BorderRadius.circular(8),
        ),
        contentPadding: const EdgeInsets.symmetric(horizontal: 16, vertical: 4),
      ),

      // Navigation Drawer Theme
      drawerTheme: DrawerThemeData(
        backgroundColor: colorScheme.surface,
        surfaceTintColor: colorScheme.surfaceTint,
      ),

      // Bottom Navigation Bar Theme
      bottomNavigationBarTheme: BottomNavigationBarThemeData(
        backgroundColor: colorScheme.surface,
        selectedItemColor: colorScheme.primary,
        unselectedItemColor: colorScheme.onSurfaceVariant,
        type: BottomNavigationBarType.fixed,
        elevation: 8,
      ),

      // Navigation Bar Theme (Material 3)
      navigationBarTheme: NavigationBarThemeData(
        backgroundColor: colorScheme.surface,
        indicatorColor: colorScheme.primaryContainer,
        labelTextStyle: WidgetStateProperty.resolveWith((states) {
          if (states.contains(WidgetState.selected)) {
            return TextStyle(
              color: colorScheme.onSurface,
              fontWeight: FontWeight.w600,
            );
          }
          return TextStyle(
            color: colorScheme.onSurfaceVariant,
          );
        }),
      ),

      // Chip Theme
      chipTheme: ChipThemeData(
        backgroundColor: colorScheme.surfaceContainerHighest,
        selectedColor: colorScheme.primaryContainer,
        labelStyle: TextStyle(color: colorScheme.onSurfaceVariant),
        shape: RoundedRectangleBorder(
          borderRadius: BorderRadius.circular(20),
        ),
      ),

      // Dialog Theme
      dialogTheme: DialogThemeData(
        backgroundColor: colorScheme.surface,
        surfaceTintColor: colorScheme.surfaceTint,
        shape: RoundedRectangleBorder(
          borderRadius: BorderRadius.circular(16),
        ),
      ),

      // Snack Bar Theme
      snackBarTheme: SnackBarThemeData(
        backgroundColor: colorScheme.inverseSurface,
        contentTextStyle: TextStyle(color: colorScheme.onInverseSurface),
        shape: RoundedRectangleBorder(
          borderRadius: BorderRadius.circular(8),
        ),
        behavior: SnackBarBehavior.floating,
      ),

      // Floating Action Button Theme
      floatingActionButtonTheme: FloatingActionButtonThemeData(
        backgroundColor: colorScheme.primaryContainer,
        foregroundColor: colorScheme.onPrimaryContainer,
        elevation: 6,
        focusElevation: 8,
        hoverElevation: 8,
        highlightElevation: 12,
        shape: RoundedRectangleBorder(
          borderRadius: BorderRadius.circular(16),
        ),
      ),
    );
  }

  /// Creates the dark theme configuration.
  /// 
  /// Provides a sleek black dark theme optimized for low-light
  /// environments with high contrast and modern Material 3
  /// design principles. Features true black surfaces for
  /// OLED displays and reduced eye strain.
  /// 
  /// @return Configured dark theme data
  static ThemeData darkTheme() {
    // Create a sleek black dark theme
    const surfaceBlack = Color(0xFF000000);
    const cardBlack = Color(0xFF0F0F0F);
    const containerBlack = Color(0xFF1C1C1C);
    const borderGrey = Color(0xFF2A2A2A);
    
    final colorScheme = ColorScheme.fromSeed(
      seedColor: primaryColor,
      brightness: Brightness.dark,
    ).copyWith(
      surface: surfaceBlack,
      onSurface: const Color(0xFFE5E5E5),
      surfaceContainerLowest: surfaceBlack,
      surfaceContainerLow: cardBlack,
      surfaceContainer: containerBlack,
      surfaceContainerHigh: const Color(0xFF252525),
      surfaceContainerHighest: const Color(0xFF303030),
      onSurfaceVariant: const Color(0xFFB3B3B3),
      outline: borderGrey,
      outlineVariant: const Color(0xFF1A1A1A),
      primary: const Color(0xFF6366F1), // Modern indigo
      onPrimary: Colors.white,
      secondary: const Color(0xFF10B981), // Modern emerald
      onSecondary: Colors.white,
      tertiary: const Color(0xFFF59E0B), // Modern amber
      onTertiary: Colors.black,
    );
    
    return ThemeData(
      useMaterial3: true,
      colorScheme: colorScheme,
      brightness: Brightness.dark,
      scaffoldBackgroundColor: surfaceBlack,
      
      // App Bar Theme
      appBarTheme: AppBarTheme(
        centerTitle: true,
        elevation: 0,
        scrolledUnderElevation: 1,
        backgroundColor: colorScheme.surface,
        foregroundColor: colorScheme.onSurface,
        titleTextStyle: TextStyle(
          color: colorScheme.onSurface,
          fontSize: 20,
          fontWeight: FontWeight.w600,
        ),
      ),

      // Card Theme
      cardTheme: CardThemeData(
        color: const Color(0xFF0F0F0F),
        surfaceTintColor: Colors.transparent,
        elevation: 0,
        shadowColor: Colors.transparent,
        margin: const EdgeInsets.all(8),
        shape: RoundedRectangleBorder(
          borderRadius: BorderRadius.circular(12),
          side: const BorderSide(color: Color(0xFF2A2A2A), width: 0.5),
        ),
      ),

      // Elevated Button Theme
      elevatedButtonTheme: ElevatedButtonThemeData(
        style: ElevatedButton.styleFrom(
          elevation: 2,
          padding: const EdgeInsets.symmetric(horizontal: 24, vertical: 12),
          shape: RoundedRectangleBorder(
            borderRadius: BorderRadius.circular(8),
          ),
        ),
      ),

      // Filled Button Theme
      filledButtonTheme: FilledButtonThemeData(
        style: FilledButton.styleFrom(
          padding: const EdgeInsets.symmetric(horizontal: 24, vertical: 12),
          shape: RoundedRectangleBorder(
            borderRadius: BorderRadius.circular(8),
          ),
        ),
      ),

      // Outlined Button Theme
      outlinedButtonTheme: OutlinedButtonThemeData(
        style: OutlinedButton.styleFrom(
          padding: const EdgeInsets.symmetric(horizontal: 24, vertical: 12),
          shape: RoundedRectangleBorder(
            borderRadius: BorderRadius.circular(8),
          ),
        ),
      ),

      // Text Button Theme
      textButtonTheme: TextButtonThemeData(
        style: TextButton.styleFrom(
          padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
          shape: RoundedRectangleBorder(
            borderRadius: BorderRadius.circular(8),
          ),
        ),
      ),

      // Input Decoration Theme
      inputDecorationTheme: InputDecorationTheme(
        filled: true,
        fillColor: colorScheme.surfaceContainerHighest.withValues(alpha: 0.5),
        border: OutlineInputBorder(
          borderRadius: BorderRadius.circular(12),
          borderSide: BorderSide(color: colorScheme.outline),
        ),
        enabledBorder: OutlineInputBorder(
          borderRadius: BorderRadius.circular(12),
          borderSide: BorderSide(color: colorScheme.outline),
        ),
        focusedBorder: OutlineInputBorder(
          borderRadius: BorderRadius.circular(12),
          borderSide: BorderSide(color: colorScheme.primary, width: 2),
        ),
        errorBorder: OutlineInputBorder(
          borderRadius: BorderRadius.circular(12),
          borderSide: BorderSide(color: colorScheme.error),
        ),
        focusedErrorBorder: OutlineInputBorder(
          borderRadius: BorderRadius.circular(12),
          borderSide: BorderSide(color: colorScheme.error, width: 2),
        ),
        contentPadding: const EdgeInsets.symmetric(horizontal: 16, vertical: 16),
      ),

      // List Tile Theme
      listTileTheme: ListTileThemeData(
        shape: RoundedRectangleBorder(
          borderRadius: BorderRadius.circular(8),
        ),
        contentPadding: const EdgeInsets.symmetric(horizontal: 16, vertical: 4),
      ),

      // Navigation Drawer Theme
      drawerTheme: DrawerThemeData(
        backgroundColor: colorScheme.surface,
        surfaceTintColor: colorScheme.surfaceTint,
      ),

      // Bottom Navigation Bar Theme
      bottomNavigationBarTheme: BottomNavigationBarThemeData(
        backgroundColor: colorScheme.surface,
        selectedItemColor: colorScheme.primary,
        unselectedItemColor: colorScheme.onSurfaceVariant,
        type: BottomNavigationBarType.fixed,
        elevation: 8,
      ),

      // Navigation Bar Theme (Material 3)
      navigationBarTheme: NavigationBarThemeData(
        backgroundColor: colorScheme.surface,
        indicatorColor: colorScheme.primaryContainer,
        labelTextStyle: WidgetStateProperty.resolveWith((states) {
          if (states.contains(WidgetState.selected)) {
            return TextStyle(
              color: colorScheme.onSurface,
              fontWeight: FontWeight.w600,
            );
          }
          return TextStyle(
            color: colorScheme.onSurfaceVariant,
          );
        }),
      ),

      // Chip Theme
      chipTheme: ChipThemeData(
        backgroundColor: colorScheme.surfaceContainerHighest,
        selectedColor: colorScheme.primaryContainer,
        labelStyle: TextStyle(color: colorScheme.onSurfaceVariant),
        shape: RoundedRectangleBorder(
          borderRadius: BorderRadius.circular(20),
        ),
      ),

      // Dialog Theme
      dialogTheme: DialogThemeData(
        backgroundColor: colorScheme.surface,
        surfaceTintColor: colorScheme.surfaceTint,
        shape: RoundedRectangleBorder(
          borderRadius: BorderRadius.circular(16),
        ),
      ),

      // Snack Bar Theme
      snackBarTheme: SnackBarThemeData(
        backgroundColor: colorScheme.inverseSurface,
        contentTextStyle: TextStyle(color: colorScheme.onInverseSurface),
        shape: RoundedRectangleBorder(
          borderRadius: BorderRadius.circular(8),
        ),
        behavior: SnackBarBehavior.floating,
      ),

      // Floating Action Button Theme
      floatingActionButtonTheme: FloatingActionButtonThemeData(
        backgroundColor: colorScheme.primaryContainer,
        foregroundColor: colorScheme.onPrimaryContainer,
        elevation: 6,
        focusElevation: 8,
        hoverElevation: 8,
        highlightElevation: 12,
        shape: RoundedRectangleBorder(
          borderRadius: BorderRadius.circular(16),
        ),
      ),
    );
  }

  /// Custom primary color material palette.
  /// 
  /// Full Material Color palette for the primary indigo color
  /// with all standard Material Design color stops from 50-900.
  /// Used for generating color variations and tonal palettes.
  static const MaterialColor customPrimary = MaterialColor(
    0xFF3F51B5,
    <int, Color>{
      50: Color(0xFFE8EAF6),
      100: Color(0xFFC5CAE9),
      200: Color(0xFF9FA8DA),
      300: Color(0xFF7986CB),
      400: Color(0xFF5C6BC0),
      500: Color(0xFF3F51B5),
      600: Color(0xFF3949AB),
      700: Color(0xFF303F9F),
      800: Color(0xFF283593),
      900: Color(0xFF1A237E),
    },
  );

  /// Excellent grade color (A) - Green for outstanding performance.
  static const Color gradeA = Color(0xFF4CAF50); // Green
  
  /// Good grade color (B) - Light green for above average performance.
  static const Color gradeB = Color(0xFF8BC34A); // Light Green
  
  /// Average grade color (C) - Yellow for satisfactory performance.
  static const Color gradeC = Color(0xFFFFEB3B); // Yellow
  
  /// Below average grade color (D) - Orange for needs improvement.
  static const Color gradeD = Color(0xFFFF9800); // Orange
  
  /// Failing grade color (F) - Red for unsatisfactory performance.
  static const Color gradeF = Color(0xFFE53935); // Red

  /// High priority color - Red for urgent tasks and deadlines.
  static const Color priorityHigh = Color(0xFFE53935);
  
  /// Medium priority color - Orange for standard priority items.
  static const Color priorityMedium = Color(0xFFFF9800);
  
  /// Low priority color - Green for optional or future tasks.
  static const Color priorityLow = Color(0xFF4CAF50);

  /// Subject-specific colors for visual organization and categorization.
  /// 
  /// Each subject gets a distinct color for easy visual identification
  /// in schedules, assignments, and navigation. Colors are chosen for
  /// accessibility and clear differentiation.
  static const List<Color> subjectColors = [
    Color(0xFF2196F3), // Blue - Mathematics
    Color(0xFF4CAF50), // Green - Science
    Color(0xFFFF9800), // Orange - English
    Color(0xFF9C27B0), // Purple - History
    Color(0xFFF44336), // Red - Physical Education
    Color(0xFF607D8B), // Blue Grey - Arts
    Color(0xFF795548), // Brown - Music
    Color(0xFF009688), // Teal - Foreign Language
  ];

  /// Returns subject color by index with cycling behavior.
  /// 
  /// Uses modulo operation to cycle through available colors
  /// when index exceeds the color list length. Ensures every
  /// subject gets a consistent color assignment.
  /// 
  /// @param index Subject index or identifier
  /// @return Color for the subject at the given index
  static Color getSubjectColor(int index) {
    return subjectColors[index % subjectColors.length];
  }

  /// Returns appropriate color for letter grade display.
  /// 
  /// Maps letter grades to semantic colors for visual feedback:
  /// - A grades (A+, A, A-): Green (excellent)
  /// - B grades (B+, B, B-): Light green (good)
  /// - C grades (C+, C, C-): Yellow (average)
  /// - D grades (D+, D, D-): Orange (below average)
  /// - F grade: Red (failing)
  /// - Other: Grey (ungraded/unknown)
  /// 
  /// @param grade Letter grade string (case-insensitive)
  /// @return Semantic color for the grade
  static Color getGradeColor(String grade) {
    switch (grade.toUpperCase()) {
      case 'A':
      case 'A+':
      case 'A-':
        return gradeA;
      case 'B':
      case 'B+':
      case 'B-':
        return gradeB;
      case 'C':
      case 'C+':
      case 'C-':
        return gradeC;
      case 'D':
      case 'D+':
      case 'D-':
        return gradeD;
      case 'F':
        return gradeF;
      default:
        return Colors.grey;
    }
  }

  /// Returns appropriate color for priority level display.
  /// 
  /// Maps priority levels to semantic colors for visual urgency:
  /// - "high": Red (urgent, immediate attention)
  /// - "medium": Orange (standard priority)
  /// - "low": Green (optional, future consideration)
  /// - Other: Grey (unspecified priority)
  /// 
  /// @param priority Priority level string (case-insensitive)
  /// @return Semantic color for the priority level
  static Color getPriorityColor(String priority) {
    switch (priority.toLowerCase()) {
      case 'high':
        return priorityHigh;
      case 'medium':
        return priorityMedium;
      case 'low':
        return priorityLow;
      default:
        return Colors.grey;
    }
  }
}
````

## File: lib/shared/theme/app_typography.dart
````dart
/// Typography system for consistent text styling.
/// 
/// This module provides a comprehensive typography system based on Material 3
/// design principles, including base text styles, educational-specific styling,
/// semantic color variations, and responsive text scaling utilities.
library;

import 'package:flutter/material.dart';

/// Central typography system for consistent text styling.
/// 
/// This class provides a complete typography design system with:
/// - Material 3 compliant text style hierarchy
/// - Custom educational-specific text styles
/// - Semantic color variations (success, warning, error, info)
/// - Grade-specific styling with color coding
/// - Priority and status text styling
/// - Responsive text scaling for different screen sizes
/// - Context-aware text theme generation
/// 
/// All styles use the Inter font family and follow Material 3
/// typography scale specifications.
class AppTypography {
  /// Primary font family for the application.
  /// 
  /// Inter is chosen for its excellent readability and
  /// comprehensive character set.
  static const String fontFamily = 'Inter';

  /// Light font weight for delicate text.
  static const FontWeight light = FontWeight.w300;
  
  /// Regular font weight for standard body text.
  static const FontWeight regular = FontWeight.w400;
  
  /// Medium font weight for emphasis and labels.
  static const FontWeight medium = FontWeight.w500;
  
  /// Semi-bold font weight for headings and titles.
  static const FontWeight semiBold = FontWeight.w600;
  
  /// Bold font weight for strong emphasis.
  static const FontWeight bold = FontWeight.w700;
  
  /// Extra bold font weight for hero text.
  static const FontWeight extraBold = FontWeight.w800;

  /// Large display text style for hero headings (57px).
  /// 
  /// Used for the largest text in the application,
  /// typically for landing pages or splash screens.
  static const TextStyle displayLarge = TextStyle(
    fontFamily: fontFamily,
    fontSize: 57,
    fontWeight: regular,
    height: 1.12,
    letterSpacing: -0.25,
  );

  /// Medium display text style for section headers (45px).
  /// 
  /// Used for prominent headings and feature titles.
  static const TextStyle displayMedium = TextStyle(
    fontFamily: fontFamily,
    fontSize: 45,
    fontWeight: regular,
    height: 1.16,
    letterSpacing: 0,
  );

  /// Small display text style for page titles (36px).
  /// 
  /// Used for main page headings and important announcements.
  static const TextStyle displaySmall = TextStyle(
    fontFamily: fontFamily,
    fontSize: 36,
    fontWeight: regular,
    height: 1.22,
    letterSpacing: 0,
  );

  /// Large headline text style for content headers (32px).
  /// 
  /// Used for major content section headers.
  static const TextStyle headlineLarge = TextStyle(
    fontFamily: fontFamily,
    fontSize: 32,
    fontWeight: regular,
    height: 1.25,
    letterSpacing: 0,
  );

  /// Medium headline text style for subsection headers (28px).
  /// 
  /// Used for subsection headings and card titles.
  static const TextStyle headlineMedium = TextStyle(
    fontFamily: fontFamily,
    fontSize: 28,
    fontWeight: regular,
    height: 1.29,
    letterSpacing: 0,
  );

  /// Small headline text style for component headers (24px).
  /// 
  /// Used for component-level headings and dialog titles.
  static const TextStyle headlineSmall = TextStyle(
    fontFamily: fontFamily,
    fontSize: 24,
    fontWeight: regular,
    height: 1.33,
    letterSpacing: 0,
  );

  /// Large title text style for prominent titles (22px).
  /// 
  /// Used for AppBar titles and major content titles.
  static const TextStyle titleLarge = TextStyle(
    fontFamily: fontFamily,
    fontSize: 22,
    fontWeight: regular,
    height: 1.27,
    letterSpacing: 0,
  );

  /// Medium title text style for standard titles (16px).
  /// 
  /// Used for list headers and card subtitles.
  static const TextStyle titleMedium = TextStyle(
    fontFamily: fontFamily,
    fontSize: 16,
    fontWeight: medium,
    height: 1.50,
    letterSpacing: 0.15,
  );

  /// Small title text style for minor titles (14px).
  /// 
  /// Used for small component titles and form labels.
  static const TextStyle titleSmall = TextStyle(
    fontFamily: fontFamily,
    fontSize: 14,
    fontWeight: medium,
    height: 1.43,
    letterSpacing: 0.1,
  );

  /// Large label text style for prominent labels (14px).
  /// 
  /// Used for button text and important labels.
  static const TextStyle labelLarge = TextStyle(
    fontFamily: fontFamily,
    fontSize: 14,
    fontWeight: medium,
    height: 1.43,
    letterSpacing: 0.1,
  );

  /// Medium label text style for standard labels (12px).
  /// 
  /// Used for form field labels and navigation items.
  static const TextStyle labelMedium = TextStyle(
    fontFamily: fontFamily,
    fontSize: 12,
    fontWeight: medium,
    height: 1.33,
    letterSpacing: 0.5,
  );

  /// Small label text style for compact labels (11px).
  /// 
  /// Used for dense UI elements and status indicators.
  static const TextStyle labelSmall = TextStyle(
    fontFamily: fontFamily,
    fontSize: 11,
    fontWeight: medium,
    height: 1.45,
    letterSpacing: 0.5,
  );

  /// Large body text style for prominent content (16px).
  /// 
  /// Used for main content text and descriptions.
  static const TextStyle bodyLarge = TextStyle(
    fontFamily: fontFamily,
    fontSize: 16,
    fontWeight: regular,
    height: 1.50,
    letterSpacing: 0.15,
  );

  /// Medium body text style for standard content (14px).
  /// 
  /// Used for regular body text and content.
  static const TextStyle bodyMedium = TextStyle(
    fontFamily: fontFamily,
    fontSize: 14,
    fontWeight: regular,
    height: 1.43,
    letterSpacing: 0.25,
  );

  /// Small body text style for compact content (12px).
  /// 
  /// Used for supporting text and captions.
  static const TextStyle bodySmall = TextStyle(
    fontFamily: fontFamily,
    fontSize: 12,
    fontWeight: regular,
    height: 1.33,
    letterSpacing: 0.4,
  );

  /// Grade display text style for prominent grade values.
  /// 
  /// Used for displaying letter grades and scores prominently.
  static const TextStyle gradeDisplay = TextStyle(
    fontFamily: fontFamily,
    fontSize: 24,
    fontWeight: bold,
    height: 1.0,
  );

  /// Subject title text style for course names.
  /// 
  /// Used for subject and course titles in lists and headers.
  static const TextStyle subjectTitle = TextStyle(
    fontFamily: fontFamily,
    fontSize: 18,
    fontWeight: semiBold,
    height: 1.22,
  );

  /// Assignment title text style for assignment names.
  /// 
  /// Used for assignment titles in lists and detail views.
  static const TextStyle assignmentTitle = TextStyle(
    fontFamily: fontFamily,
    fontSize: 16,
    fontWeight: medium,
    height: 1.25,
  );

  /// Card title text style for card component headers.
  /// 
  /// Used for titles within card components.
  static const TextStyle cardTitle = TextStyle(
    fontFamily: fontFamily,
    fontSize: 20,
    fontWeight: semiBold,
    height: 1.2,
  );

  /// Card subtitle text style for card supporting text.
  /// 
  /// Used for subtitles and descriptions within cards.
  static const TextStyle cardSubtitle = TextStyle(
    fontFamily: fontFamily,
    fontSize: 14,
    fontWeight: regular,
    height: 1.43,
  );


  /// Creates a Material 3 text theme with semantic colors.
  /// 
  /// Generates a complete text theme using the provided color scheme,
  /// applying appropriate semantic colors to each text style.
  /// 
  /// @param colorScheme The color scheme to apply to text styles
  /// @return Configured text theme for Material 3
  static TextTheme createTextTheme(ColorScheme colorScheme) {
    return TextTheme(
      displayLarge: displayLarge.copyWith(color: colorScheme.onSurface),
      displayMedium: displayMedium.copyWith(color: colorScheme.onSurface),
      displaySmall: displaySmall.copyWith(color: colorScheme.onSurface),
      headlineLarge: headlineLarge.copyWith(color: colorScheme.onSurface),
      headlineMedium: headlineMedium.copyWith(color: colorScheme.onSurface),
      headlineSmall: headlineSmall.copyWith(color: colorScheme.onSurface),
      titleLarge: titleLarge.copyWith(color: colorScheme.onSurface),
      titleMedium: titleMedium.copyWith(color: colorScheme.onSurface),
      titleSmall: titleSmall.copyWith(color: colorScheme.onSurfaceVariant),
      labelLarge: labelLarge.copyWith(color: colorScheme.primary),
      labelMedium: labelMedium.copyWith(color: colorScheme.onSurfaceVariant),
      labelSmall: labelSmall.copyWith(color: colorScheme.onSurfaceVariant),
      bodyLarge: bodyLarge.copyWith(color: colorScheme.onSurface),
      bodyMedium: bodyMedium.copyWith(color: colorScheme.onSurfaceVariant),
      bodySmall: bodySmall.copyWith(color: colorScheme.onSurfaceVariant),
    );
  }

  /// Gets responsive text scale factor based on screen size.
  /// 
  /// Adjusts text size for better readability across devices:
  /// - Desktop (≥1200px): 1.1x scale (slightly larger)
  /// - Tablet (≥768px): 1.0x scale (normal)
  /// - Mobile (<768px): 0.95x scale (slightly smaller)
  /// 
  /// @param context Build context for accessing screen dimensions
  /// @return Scale factor for responsive text sizing
  static double getScaleFactor(BuildContext context) {
    final screenWidth = MediaQuery.of(context).size.width;
    
    if (screenWidth >= 1200) {
      return 1.1; // Desktop - slightly larger
    } else if (screenWidth >= 768) {
      return 1.0; // Tablet - normal
    } else {
      return 0.95; // Mobile - slightly smaller
    }
  }

  /// Creates responsive text style with device-appropriate scaling.
  /// 
  /// Applies responsive scale factor to the base text style
  /// while preserving all other style properties.
  /// 
  /// @param context Build context for screen size detection
  /// @param baseStyle Base text style to make responsive
  /// @return Scaled text style for current device
  static TextStyle responsive(BuildContext context, TextStyle baseStyle) {
    final scaleFactor = getScaleFactor(context);
    return baseStyle.copyWith(
      fontSize: (baseStyle.fontSize ?? 14) * scaleFactor,
    );
  }

  /// Success text style with green semantic color.
  /// 
  /// Used for positive feedback and successful operations.
  /// 
  /// @param context Build context (required for API consistency)
  /// @return Text style with success color
  static TextStyle success(BuildContext context) {
    return bodyMedium.copyWith(
      color: const Color(0xFF4CAF50),
      fontWeight: medium,
    );
  }

  /// Warning text style with orange semantic color.
  /// 
  /// Used for caution messages and important notices.
  /// 
  /// @param context Build context (required for API consistency)
  /// @return Text style with warning color
  static TextStyle warning(BuildContext context) {
    return bodyMedium.copyWith(
      color: const Color(0xFFFF9800),
      fontWeight: medium,
    );
  }

  /// Error text style with theme-based error color.
  /// 
  /// Used for error messages and validation feedback.
  /// 
  /// @param context Build context for accessing theme colors
  /// @return Text style with error color
  static TextStyle error(BuildContext context) {
    return bodyMedium.copyWith(
      color: Theme.of(context).colorScheme.error,
      fontWeight: medium,
    );
  }

  /// Info text style with blue semantic color.
  /// 
  /// Used for informational messages and tips.
  /// 
  /// @param context Build context (required for API consistency)
  /// @return Text style with info color
  static TextStyle info(BuildContext context) {
    return bodyMedium.copyWith(
      color: const Color(0xFF2196F3),
      fontWeight: medium,
    );
  }

  /// Grade A text style with green color for excellent performance.
  /// 
  /// @param context Build context (required for API consistency)
  /// @return Text style for A grades
  static TextStyle gradeA(BuildContext context) {
    return gradeDisplay.copyWith(color: const Color(0xFF4CAF50));
  }

  /// Grade B text style with light green color for good performance.
  /// 
  /// @param context Build context (required for API consistency)
  /// @return Text style for B grades
  static TextStyle gradeB(BuildContext context) {
    return gradeDisplay.copyWith(color: const Color(0xFF8BC34A));
  }

  /// Grade C text style with yellow color for average performance.
  /// 
  /// @param context Build context (required for API consistency)
  /// @return Text style for C grades
  static TextStyle gradeC(BuildContext context) {
    return gradeDisplay.copyWith(color: const Color(0xFFFFEB3B));
  }

  /// Grade D text style with orange color for below average performance.
  /// 
  /// @param context Build context (required for API consistency)
  /// @return Text style for D grades
  static TextStyle gradeD(BuildContext context) {
    return gradeDisplay.copyWith(color: const Color(0xFFFF9800));
  }

  /// Grade F text style with red color for failing performance.
  /// 
  /// @param context Build context (required for API consistency)
  /// @return Text style for F grades
  static TextStyle gradeF(BuildContext context) {
    return gradeDisplay.copyWith(color: const Color(0xFFE53935));
  }

  /// Returns appropriate grade text style based on letter grade.
  /// 
  /// Automatically selects color-coded style based on grade letter:
  /// - A grades: Green (excellent)
  /// - B grades: Light green (good)
  /// - C grades: Yellow (average)
  /// - D grades: Orange (below average)
  /// - F grades: Red (failing)
  /// - Other: Default theme color
  /// 
  /// @param context Build context for accessing theme
  /// @param grade Letter grade string (A, B, C, D, F with optional +/-)
  /// @return Appropriate text style for the grade
  static TextStyle getGradeStyle(BuildContext context, String grade) {
    switch (grade.toUpperCase()) {
      case 'A':
      case 'A+':
      case 'A-':
        return gradeA(context);
      case 'B':
      case 'B+':
      case 'B-':
        return gradeB(context);
      case 'C':
      case 'C+':
      case 'C-':
        return gradeC(context);
      case 'D':
      case 'D+':
      case 'D-':
        return gradeD(context);
      case 'F':
        return gradeF(context);
      default:
        return gradeDisplay.copyWith(
          color: Theme.of(context).colorScheme.onSurfaceVariant,
        );
    }
  }

  /// High priority text style with red color and bold weight.
  /// 
  /// Used for urgent tasks and high-priority items.
  /// 
  /// @param context Build context (required for API consistency)
  /// @return Text style for high priority items
  static TextStyle priorityHigh(BuildContext context) {
    return labelMedium.copyWith(
      color: const Color(0xFFE53935),
      fontWeight: bold,
    );
  }

  /// Medium priority text style with orange color.
  /// 
  /// Used for standard priority tasks and items.
  /// 
  /// @param context Build context (required for API consistency)
  /// @return Text style for medium priority items
  static TextStyle priorityMedium(BuildContext context) {
    return labelMedium.copyWith(
      color: const Color(0xFFFF9800),
      fontWeight: medium,
    );
  }

  /// Low priority text style with green color.
  /// 
  /// Used for low-priority and optional tasks.
  /// 
  /// @param context Build context (required for API consistency)
  /// @return Text style for low priority items
  static TextStyle priorityLow(BuildContext context) {
    return labelMedium.copyWith(
      color: const Color(0xFF4CAF50),
      fontWeight: regular,
    );
  }

  /// Returns appropriate priority text style based on priority level.
  /// 
  /// Automatically selects color-coded style based on priority:
  /// - "high": Red with bold weight (urgent)
  /// - "medium": Orange with medium weight (standard)
  /// - "low": Green with regular weight (optional)
  /// - Other: Default theme color
  /// 
  /// @param context Build context for accessing theme
  /// @param priority Priority level string (case-insensitive)
  /// @return Appropriate text style for the priority level
  static TextStyle getPriorityStyle(BuildContext context, String priority) {
    switch (priority.toLowerCase()) {
      case 'high':
        return priorityHigh(context);
      case 'medium':
        return priorityMedium(context);
      case 'low':
        return priorityLow(context);
      default:
        return labelMedium.copyWith(
          color: Theme.of(context).colorScheme.onSurfaceVariant,
        );
    }
  }
}
````

## File: lib/shared/utils/error_handler.dart
````dart
import 'package:firebase_crashlytics/firebase_crashlytics.dart';
import 'package:flutter/foundation.dart';

class ErrorHandler {
  static Future<void> recordError(
    dynamic exception,
    StackTrace? stackTrace, {
    String? reason,
    bool fatal = false,
    Map<String, dynamic>? customKeys,
  }) async {
    try {
      if (!kIsWeb) {
        await FirebaseCrashlytics.instance.recordError(
          exception,
          stackTrace,
          reason: reason,
          fatal: fatal,
        );

        if (customKeys != null) {
          for (final entry in customKeys.entries) {
            await FirebaseCrashlytics.instance.setCustomKey(
              entry.key,
              entry.value,
            );
          }
        }
      } else {
        // For web, just log to console since Crashlytics isn't supported
        debugPrint('Error: $exception');
        if (stackTrace != null) {
          debugPrint('Stack trace: $stackTrace');
        }
        if (reason != null) {
          debugPrint('Reason: $reason');
        }
      }
    } catch (e) {
      debugPrint('Failed to record error to Crashlytics: $e');
    }
  }

  static Future<void> recordFlutterError(FlutterErrorDetails details) async {
    try {
      if (!kIsWeb) {
        await FirebaseCrashlytics.instance.recordFlutterError(details);
      } else {
        debugPrint('Flutter Error: ${details.exception}');
        debugPrint('Stack trace: ${details.stack}');
      }
    } catch (e) {
      debugPrint('Failed to record Flutter error to Crashlytics: $e');
    }
  }

  static Future<void> setUserIdentifier(String identifier) async {
    try {
      if (!kIsWeb) {
        await FirebaseCrashlytics.instance.setUserIdentifier(identifier);
      }
    } catch (e) {
      debugPrint('Failed to set user identifier: $e');
    }
  }

  static Future<void> log(String message) async {
    try {
      if (!kIsWeb) {
        await FirebaseCrashlytics.instance.log(message);
      } else {
        debugPrint('Log: $message');
      }
    } catch (e) {
      debugPrint('Failed to log message: $e');
    }
  }

  static Future<void> setCustomKey(String key, dynamic value) async {
    try {
      if (!kIsWeb) {
        await FirebaseCrashlytics.instance.setCustomKey(key, value);
      }
    } catch (e) {
      debugPrint('Failed to set custom key: $e');
    }
  }

  static Future<void> testCrash() async {
    try {
      if (!kIsWeb && !kDebugMode) {
        // Only test crash in release mode and not on web
        FirebaseCrashlytics.instance.crash();
      } else {
        debugPrint('Test crash not executed (debug mode or web platform)');
      }
    } catch (e) {
      debugPrint('Failed to test crash: $e');
    }
  }
}
````

## File: lib/shared/widgets/common/app_card.dart
````dart
/// Themed card component for consistent Material Design styling.
/// 
/// This module provides a customizable card component that follows the
/// application's design system with dark theme optimization, consistent
/// border styling, and flexible interaction support.
library;

import 'package:flutter/material.dart';
/// Customizable card component with consistent theming.
/// 
/// This widget provides a standardized card design that:
/// - Follows Material 3 design principles
/// - Integrates with the app's theme system
/// - Supports dark theme optimization
/// - Provides consistent border and elevation styling
/// - Offers optional tap interaction with visual feedback
/// - Allows customization while maintaining design consistency
/// 
/// Features:
/// - Automatic theme integration
/// - Configurable padding and margins
/// - Optional tap handling with InkWell effect
/// - Customizable background colors and borders
/// - Responsive elevation and shadows
/// - Consistent border radius and styling
/// 
/// Usage:
/// ```dart
/// AppCard(
///   onTap: () => print('Card tapped'),
///   child: Text('Card content'),
/// )
/// ```
class AppCard extends StatelessWidget {
  /// The widget to display inside the card.
  final Widget child;
  
  /// Internal padding around the child widget.
  /// 
  /// Defaults to EdgeInsets.all(16) if not specified.
  final EdgeInsets? padding;
  
  /// Callback function executed when the card is tapped.
  /// 
  /// When provided, the card becomes interactive with InkWell
  /// ripple effects. If null, the card is non-interactive.
  final VoidCallback? onTap;
  
  /// Custom background color override.
  /// 
  /// If not provided, uses the theme's card color automatically.
  final Color? backgroundColor;
  
  /// Whether to display the card border.
  /// 
  /// Defaults to true. When enabled, shows a subtle border
  /// that enhances card definition in dark themes.
  final bool hasBorder;
  
  /// Custom elevation override for shadow depth.
  /// 
  /// If not provided, uses the theme's card elevation.
  final double? elevation;
  
  /// Custom border radius override.
  /// 
  /// Defaults to BorderRadius.circular(12) if not specified.
  final BorderRadius? borderRadius;

  /// Creates a themed card with customizable properties.
  /// 
  /// @param child Content widget to display inside the card
  /// @param padding Internal padding (default: EdgeInsets.all(16))
  /// @param onTap Optional tap callback for interactivity
  /// @param backgroundColor Custom background color override
  /// @param hasBorder Whether to show card border (default: true)
  /// @param elevation Custom elevation override
  /// @param borderRadius Custom border radius override
  const AppCard({
    super.key,
    required this.child,
    this.padding,
    this.onTap,
    this.backgroundColor,
    this.hasBorder = true,
    this.elevation,
    this.borderRadius,
  });

  @override
  Widget build(BuildContext context) {
    // Access theme configuration for consistent styling
    final theme = Theme.of(context);
    final cardTheme = theme.cardTheme;
    
    return Card(
      // Apply background color with theme fallback
      color: backgroundColor ?? cardTheme.color,
      
      // Apply elevation with theme fallback
      elevation: elevation ?? cardTheme.elevation,
      
      // Use theme's surface tint and shadow colors
      surfaceTintColor: cardTheme.surfaceTintColor,
      shadowColor: cardTheme.shadowColor,
      
      // Apply theme's margin configuration
      margin: cardTheme.margin,
      
      // Configure card shape with border and radius
      shape: RoundedRectangleBorder(
        borderRadius: borderRadius ?? BorderRadius.circular(12),
        side: hasBorder 
            ? const BorderSide(color: Color(0xFF2A2A2A), width: 0.5)
            : BorderSide.none,
      ),
      
      // Conditionally wrap with InkWell for tap interaction
      child: onTap != null
          ? InkWell(
              onTap: onTap,
              borderRadius: borderRadius ?? BorderRadius.circular(12),
              child: Padding(
                padding: padding ?? const EdgeInsets.all(16),
                child: child,
              ),
            )
          : Padding(
              padding: padding ?? const EdgeInsets.all(16),
              child: child,
            ),
    );
  }
}
````

## File: lib/shared/widgets/common/common_widgets.dart
````dart
// Common widgets barrel file
export 'app_card.dart';
export 'stat_card.dart';
export 'status_badge.dart';
export 'custom_list_tile.dart';
export 'empty_state.dart';
````

## File: lib/shared/widgets/common/custom_list_tile.dart
````dart
/// Custom list tile widgets for educational data display.
/// 
/// This module provides specialized list tile components optimized for
/// the education platform with theme-aware styling, role-specific layouts,
/// and consistent Material Design patterns for student and class listings.
library;

import 'package:flutter/material.dart';

/// Customizable list tile with educational platform theming.
/// 
/// This widget provides a themed alternative to the standard ListTile with:
/// - Dark theme optimization and consistent border styling
/// - Selection state visualization with primary container colors
/// - Configurable padding, background colors, and border options
/// - Smooth tap interactions with proper accessibility support
/// - Consistent spacing and visual hierarchy
/// 
/// Features:
/// - Automatic theme integration with Material 3 colors
/// - Optional border display for enhanced definition
/// - Selection state with subtle background highlighting
/// - Custom padding and background color overrides
/// - Tap handling with visual feedback
/// 
/// Usage:
/// ```dart
/// CustomListTile(
///   leading: Icon(Icons.person),
///   title: Text('Student Name'),
///   subtitle: Text('student@school.edu'),
///   trailing: Icon(Icons.chevron_right),
///   isSelected: true,
///   onTap: () => navigateToDetail(),
/// )
/// ```
class CustomListTile extends StatelessWidget {
  /// Widget to display before the title (typically an icon or avatar).
  final Widget? leading;
  
  /// Primary content widget, usually displaying the main text or name.
  final Widget? title;
  
  /// Secondary content widget, typically showing additional details.
  final Widget? subtitle;
  
  /// Widget to display after the content (typically an action icon).
  final Widget? trailing;
  
  /// Callback function executed when the list tile is tapped.
  /// 
  /// If null, the list tile will not be interactive.
  final VoidCallback? onTap;
  
  /// Whether to display a subtle border around the list tile.
  /// 
  /// Defaults to false. When enabled, adds visual definition
  /// particularly useful in dark themes.
  final bool showBorder;
  
  /// Custom padding override for the list tile content.
  /// 
  /// If not provided, uses the theme's default list tile padding.
  final EdgeInsets? padding;
  
  /// Custom background color override.
  /// 
  /// If not provided, uses selection state color for selected items
  /// or transparent background for unselected items.
  final Color? backgroundColor;
  
  /// Whether this list tile is currently selected.
  /// 
  /// When true, applies a subtle background highlight using
  /// the theme's primary container color with transparency.
  final bool isSelected;

  /// Creates a custom themed list tile.
  /// 
  /// @param leading Widget to display before title (optional)
  /// @param title Primary content widget (optional)
  /// @param subtitle Secondary content widget (optional)
  /// @param trailing Widget to display after content (optional)
  /// @param onTap Tap callback for interactivity (optional)
  /// @param showBorder Whether to show border (default: false)
  /// @param padding Custom padding override (optional)
  /// @param backgroundColor Custom background color (optional)
  /// @param isSelected Whether tile is selected (default: false)
  const CustomListTile({
    super.key,
    this.leading,
    this.title,
    this.subtitle,
    this.trailing,
    this.onTap,
    this.showBorder = false,
    this.padding,
    this.backgroundColor,
    this.isSelected = false,
  });

  @override
  Widget build(BuildContext context) {
    // Access theme configuration for consistent styling
    final theme = Theme.of(context);
    final colorScheme = theme.colorScheme;
    final listTileTheme = theme.listTileTheme;

    return Container(
      // Add subtle vertical spacing between list items
      margin: const EdgeInsets.symmetric(vertical: 2),
      decoration: BoxDecoration(
        // Apply background color with selection state handling
        color: backgroundColor ?? 
               (isSelected ? colorScheme.primaryContainer.withValues(alpha: 0.1) : null),
        borderRadius: BorderRadius.circular(8),
        // Conditional border for enhanced definition
        border: showBorder 
            ? Border.all(color: const Color(0xFF2A2A2A), width: 0.5)
            : null,
      ),
      child: ListTile(
        leading: leading,
        title: title,
        subtitle: subtitle,
        trailing: trailing,
        onTap: onTap,
        shape: listTileTheme.shape,
        contentPadding: padding ?? listTileTheme.contentPadding,
        selected: isSelected,
        selectedTileColor: Colors.transparent, // We handle this with container
      ),
    );
  }
}

/// Specialized list tile for displaying student information.
/// 
/// This widget provides a standardized layout for student listings with:
/// - Automatic avatar generation from student name initials
/// - Grade display with appropriate formatting and colors
/// - Optional email display with theme-aware styling
/// - Status indicators for enrollment, attendance, or performance
/// - Consistent spacing and typography following Material Design
/// 
/// Features:
/// - Automatic fallback avatar with name initials
/// - Themed grade display with bold formatting
/// - Conditional email display for different contexts
/// - Status widget support for enrollment indicators
/// - Consistent chevron indicator for navigation
/// - Optimized for educational platform color schemes
/// 
/// Usage:
/// ```dart
/// StudentListTile(
///   name: 'John Smith',
///   email: 'john.smith@school.edu',
///   grade: 'A',
///   status: Icon(Icons.check_circle, color: Colors.green),
///   onTap: () => viewStudentProfile(),
/// )
/// ```
class StudentListTile extends StatelessWidget {
  /// Student's full name (required for display and avatar generation).
  final String name;
  
  /// Current grade or score to display (optional).
  /// 
  /// Typically shows letter grades (A, B, C) or percentage scores.
  /// Displayed with bold formatting in the trailing section.
  final String? grade;
  
  /// Student's email address (optional).
  /// 
  /// Shown in subtitle when showEmail is true and email is provided.
  /// Uses theme's onSurfaceVariant color for secondary appearance.
  final String? email;
  
  /// Custom avatar widget override (optional).
  /// 
  /// If not provided, generates a circular avatar with the student's
  /// initials using the theme's primary container colors.
  final Widget? avatar;
  
  /// Status indicator widget (optional).
  /// 
  /// Typically displays enrollment status, attendance indicators,
  /// or performance badges. Positioned before the chevron icon.
  final Widget? status;
  
  /// Callback function executed when the student tile is tapped.
  /// 
  /// Usually navigates to student detail view or profile screen.
  final VoidCallback? onTap;
  
  /// Whether to display the student's email in the subtitle.
  /// 
  /// Defaults to true. Set to false for compact views or when
  /// email display is not needed in the current context.
  final bool showEmail;

  /// Creates a student list tile with educational platform theming.
  /// 
  /// @param name Student's full name (required)
  /// @param grade Current grade or score (optional)
  /// @param email Student's email address (optional)
  /// @param avatar Custom avatar widget (optional)
  /// @param status Status indicator widget (optional)
  /// @param onTap Tap callback for navigation (optional)
  /// @param showEmail Whether to show email in subtitle (default: true)
  const StudentListTile({
    super.key,
    required this.name,
    this.grade,
    this.email,
    this.avatar,
    this.status,
    this.onTap,
    this.showEmail = true,
  });

  @override
  Widget build(BuildContext context) {
    // Access theme configuration for educational platform styling
    final theme = Theme.of(context);
    final textTheme = theme.textTheme;
    final colorScheme = theme.colorScheme;

    return CustomListTile(
      // Generate avatar with initials or use custom avatar
      leading: avatar ?? CircleAvatar(
        backgroundColor: colorScheme.primaryContainer,
        child: Text(
          name.isNotEmpty ? name[0].toUpperCase() : '?',
          style: textTheme.titleMedium?.copyWith(
            color: colorScheme.onPrimaryContainer,
            fontWeight: FontWeight.bold,
          ),
        ),
      ),
      // Display student name with medium weight
      title: Text(
        name,
        style: textTheme.titleMedium?.copyWith(
          fontWeight: FontWeight.w600,
        ),
      ),
      // Conditionally show email in subtitle
      subtitle: showEmail && email != null ? Text(
        email!,
        style: textTheme.bodySmall?.copyWith(
          color: colorScheme.onSurfaceVariant,
        ),
      ) : null,
      // Arrange grade, status, and navigation elements
      trailing: Row(
        mainAxisSize: MainAxisSize.min,
        children: [
          // Display grade with bold formatting
          if (grade != null) ...[
            Text(
              grade!,
              style: textTheme.titleMedium?.copyWith(
                fontWeight: FontWeight.bold,
              ),
            ),
            const SizedBox(width: 8),
          ],
          // Display status indicator
          if (status != null) ...[
            status!,
            const SizedBox(width: 8),
          ],
          // Standard navigation chevron
          const Icon(Icons.chevron_right),
        ],
      ),
      onTap: onTap,
    );
  }
}

/// Specialized list tile for displaying class information.
/// 
/// This widget provides a standardized layout for class listings with:
/// - Class icon with secondary container theming
/// - Class name display with appropriate typography
/// - Subject, student count, and schedule information
/// - Status indicators for class state or enrollment status
/// - Consistent layout matching educational platform design
/// 
/// Features:
/// - Themed class icon with secondary container colors
/// - Subject and schedule display in subtitle column
/// - Student count with primary color emphasis
/// - Status widget support for enrollment or activity indicators
/// - Consistent chevron indicator for navigation
/// - Optimized spacing and typography for class information
/// 
/// Usage:
/// ```dart
/// ClassListTile(
///   className: 'Advanced Mathematics',
///   subject: 'Mathematics',
///   studentCount: 28,
///   schedule: 'Mon, Wed, Fri 10:00 AM',
///   status: Icon(Icons.schedule, color: Colors.blue),
///   onTap: () => viewClassDetails(),
/// )
/// ```
class ClassListTile extends StatelessWidget {
  /// Class name or title (required for display).
  final String className;
  
  /// Subject area or discipline (optional).
  /// 
  /// Displayed in subtitle to provide additional context
  /// about the class content and academic area.
  final String? subject;
  
  /// Number of enrolled students (required).
  /// 
  /// Displayed with primary color emphasis to highlight
  /// enrollment metrics for teachers and administrators.
  final int studentCount;
  
  /// Class schedule information (optional).
  /// 
  /// Typically shows meeting times, days, or frequency.
  /// Displayed in subtitle with secondary text styling.
  final String? schedule;
  
  /// Status indicator widget (optional).
  /// 
  /// Shows class state, enrollment status, or activity indicators.
  /// Positioned before the chevron icon in the trailing section.
  final Widget? status;
  
  /// Callback function executed when the class tile is tapped.
  /// 
  /// Usually navigates to class detail view, roster, or gradebook.
  final VoidCallback? onTap;

  /// Creates a class list tile with educational platform theming.
  /// 
  /// @param className Class name or title (required)
  /// @param subject Subject area or discipline (optional)
  /// @param studentCount Number of enrolled students (required)
  /// @param schedule Class schedule information (optional)
  /// @param status Status indicator widget (optional)
  /// @param onTap Tap callback for navigation (optional)
  const ClassListTile({
    super.key,
    required this.className,
    this.subject,
    required this.studentCount,
    this.schedule,
    this.status,
    this.onTap,
  });

  @override
  Widget build(BuildContext context) {
    // Access theme configuration for educational platform styling
    final theme = Theme.of(context);
    final textTheme = theme.textTheme;
    final colorScheme = theme.colorScheme;

    return CustomListTile(
      // Class icon with secondary container theming
      leading: CircleAvatar(
        backgroundColor: colorScheme.secondaryContainer,
        child: Icon(
          Icons.class_,
          color: colorScheme.onSecondaryContainer,
        ),
      ),
      // Display class name with medium weight
      title: Text(
        className,
        style: textTheme.titleMedium?.copyWith(
          fontWeight: FontWeight.w600,
        ),
      ),
      // Organize class details in column layout
      subtitle: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          // Display subject if provided
          if (subject != null)
            Text(
              subject!,
              style: textTheme.bodySmall?.copyWith(
                color: colorScheme.onSurfaceVariant,
              ),
            ),
          // Student count with primary color emphasis
          Text(
            '$studentCount students',
            style: textTheme.bodySmall?.copyWith(
              color: colorScheme.primary,
            ),
          ),
          // Display schedule if provided
          if (schedule != null)
            Text(
              schedule!,
              style: textTheme.bodySmall?.copyWith(
                color: colorScheme.onSurfaceVariant,
              ),
            ),
        ],
      ),
      // Arrange status and navigation elements
      trailing: Row(
        mainAxisSize: MainAxisSize.min,
        children: [
          // Display status indicator
          if (status != null) ...[
            status!,
            const SizedBox(width: 8),
          ],
          // Standard navigation chevron
          const Icon(Icons.chevron_right),
        ],
      ),
      onTap: onTap,
    );
  }
}
````

## File: lib/shared/widgets/common/empty_state.dart
````dart
import 'package:flutter/material.dart';

/// Component for displaying empty states with optional action
class EmptyState extends StatelessWidget {
  final IconData icon;
  final String title;
  final String message;
  final String? actionLabel;
  final VoidCallback? onAction;
  final Widget? customIcon;
  final bool isLoading;

  const EmptyState({
    super.key,
    required this.icon,
    required this.title,
    required this.message,
    this.actionLabel,
    this.onAction,
    this.customIcon,
    this.isLoading = false,
  });

  /// Empty state for when no classes are available
  const EmptyState.noClasses({
    super.key,
    this.actionLabel = 'Create Class',
    this.onAction,
    this.isLoading = false,
  }) : icon = Icons.class_,
       title = 'No Classes Yet',
       message = 'Create your first class to start managing students and assignments.',
       customIcon = null;

  /// Empty state for when no students are available
  const EmptyState.noStudents({
    super.key,
    this.actionLabel = 'Add Student',
    this.onAction,
    this.isLoading = false,
  }) : icon = Icons.person_add,
       title = 'No Students Yet',
       message = 'Add students to this class to start tracking their progress.',
       customIcon = null;

  /// Empty state for when no assignments are available
  const EmptyState.noAssignments({
    super.key,
    this.actionLabel = 'Create Assignment',
    this.onAction,
    this.isLoading = false,
  }) : icon = Icons.assignment,
       title = 'No Assignments Yet',
       message = 'Create assignments to track student progress and grades.',
       customIcon = null;

  /// Empty state for when no grades are available
  const EmptyState.noGrades({
    super.key,
    this.actionLabel,
    this.onAction,
    this.isLoading = false,
  }) : icon = Icons.grade,
       title = 'No Grades Yet',
       message = 'Grades will appear here once assignments are submitted and graded.',
       customIcon = null;

  /// Empty state for when no messages are available
  const EmptyState.noMessages({
    super.key,
    this.actionLabel = 'Start Conversation',
    this.onAction,
    this.isLoading = false,
  }) : icon = Icons.message,
       title = 'No Messages',
       message = 'Start a conversation with students or parents.',
       customIcon = null;

  /// Empty state for search results
  const EmptyState.noSearchResults({
    super.key,
    required String searchTerm,
    this.actionLabel,
    this.onAction,
    this.isLoading = false,
  }) : icon = Icons.search_off,
       title = 'No Results Found',
       message = 'No results found for "$searchTerm". Try a different search term.',
       customIcon = null;

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final textTheme = theme.textTheme;
    final colorScheme = theme.colorScheme;

    if (isLoading) {
      return Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            CircularProgressIndicator(
              color: colorScheme.primary,
            ),
            const SizedBox(height: 16),
            Text(
              'Loading...',
              style: textTheme.bodyLarge?.copyWith(
                color: colorScheme.onSurfaceVariant,
              ),
            ),
          ],
        ),
      );
    }

    return Center(
      child: Padding(
        padding: const EdgeInsets.all(24),
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            customIcon ?? Icon(
              icon,
              size: 80,
              color: colorScheme.onSurfaceVariant.withValues(alpha: 0.6),
            ),
            const SizedBox(height: 24),
            Text(
              title,
              style: textTheme.headlineSmall?.copyWith(
                color: colorScheme.onSurface,
                fontWeight: FontWeight.w600,
              ),
              textAlign: TextAlign.center,
            ),
            const SizedBox(height: 8),
            Text(
              message,
              style: textTheme.bodyLarge?.copyWith(
                color: colorScheme.onSurfaceVariant,
              ),
              textAlign: TextAlign.center,
            ),
            if (actionLabel != null && onAction != null) ...[
              const SizedBox(height: 32),
              FilledButton.icon(
                onPressed: onAction,
                icon: Icon(_getActionIcon()),
                label: Text(actionLabel!),
              ),
            ],
          ],
        ),
      ),
    );
  }

  IconData _getActionIcon() {
    switch (actionLabel?.toLowerCase()) {
      case 'create class':
        return Icons.add;
      case 'add student':
        return Icons.person_add;
      case 'create assignment':
        return Icons.add;
      case 'start conversation':
        return Icons.send;
      default:
        return Icons.add;
    }
  }
}
````

## File: lib/shared/widgets/common/error_aware_stream_builder.dart
````dart
/// Error-aware stream builder widget that handles Firebase errors gracefully.
/// 
/// This widget wraps StreamBuilder to provide consistent error handling
/// for Firestore permission errors and other stream errors.
library;

import 'package:flutter/material.dart';
import '../../services/error_handler_service.dart';

/// A StreamBuilder that automatically handles errors with user-friendly messages.
/// 
/// Features:
/// - Automatic error detection and display
/// - Permission error handling with clear messages
/// - Network error handling
/// - Loading states
/// - Empty state handling
/// - Custom error widgets
class ErrorAwareStreamBuilder<T> extends StatelessWidget {
  /// The stream to listen to.
  final Stream<T> stream;
  
  /// Builder for the data state.
  final Widget Function(BuildContext context, T data) builder;
  
  /// Optional custom loading widget.
  final Widget? loadingWidget;
  
  /// Optional custom error widget builder.
  final Widget Function(BuildContext context, Object error)? errorBuilder;
  
  /// Optional custom empty state widget.
  final Widget? emptyWidget;
  
  /// Whether to show error as dialog instead of inline.
  final bool showErrorAsDialog;
  
  /// Optional retry callback.
  final VoidCallback? onRetry;
  
  /// Check if data is empty (for showing empty state).
  final bool Function(T data)? isDataEmpty;
  
  const ErrorAwareStreamBuilder({
    super.key,
    required this.stream,
    required this.builder,
    this.loadingWidget,
    this.errorBuilder,
    this.emptyWidget,
    this.showErrorAsDialog = false,
    this.onRetry,
    this.isDataEmpty,
  });
  
  @override
  Widget build(BuildContext context) {
    return StreamBuilder<T>(
      stream: stream,
      builder: (context, snapshot) {
        
        // Handle different states
        if (snapshot.hasError) {
          return _buildErrorState(context, snapshot.error!);
        }
        
        if (snapshot.connectionState == ConnectionState.waiting && !snapshot.hasData) {
          return _buildLoadingState(context);
        }
        
        if (!snapshot.hasData) {
          return _buildEmptyState(context);
        }
        
        // Build the data state
        return builder(context, snapshot.data as T);
      },
    );
  }
  
  Widget _buildLoadingState(BuildContext context) {
    return loadingWidget ?? const Center(
      child: CircularProgressIndicator(),
    );
  }
  
  Widget _buildErrorState(BuildContext context, Object error) {
    // Use custom error builder if provided
    if (errorBuilder != null) {
      return errorBuilder!(context, error);
    }
    
    // Check if it's a permission error
    final isPermissionError = ErrorHandlerService.isPermissionError(error);
    final errorMessage = ErrorHandlerService.getErrorMessage(error);
    
    // Show dialog if requested
    if (showErrorAsDialog) {
      WidgetsBinding.instance.addPostFrameCallback((_) {
        ErrorHandlerService.handleError(
          error,
          context: context,
          showAsDialog: true,
          onRetry: onRetry,
        );
      });
      return _buildLoadingState(context); // Show loading while dialog is shown
    }
    
    // Default inline error widget
    return Center(
      child: Padding(
        padding: const EdgeInsets.all(24.0),
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Icon(
              isPermissionError ? Icons.lock_outline : Icons.error_outline,
              size: 64,
              color: Theme.of(context).colorScheme.error,
            ),
            const SizedBox(height: 16),
            Text(
              isPermissionError ? 'Access Denied' : 'Error Loading Data',
              style: Theme.of(context).textTheme.headlineSmall,
              textAlign: TextAlign.center,
            ),
            const SizedBox(height: 8),
            Text(
              errorMessage,
              style: Theme.of(context).textTheme.bodyMedium,
              textAlign: TextAlign.center,
            ),
            if (onRetry != null) ...[
              const SizedBox(height: 24),
              FilledButton.icon(
                onPressed: onRetry,
                icon: const Icon(Icons.refresh),
                label: const Text('Retry'),
              ),
            ],
          ],
        ),
      ),
    );
  }
  
  Widget _buildEmptyState(BuildContext context) {
    return emptyWidget ?? Center(
      child: Column(
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          Icon(
            Icons.inbox_outlined,
            size: 64,
            color: Theme.of(context).colorScheme.onSurfaceVariant.withValues(alpha: 0.3),
          ),
          const SizedBox(height: 16),
          Text(
            'No data available',
            style: Theme.of(context).textTheme.titleMedium?.copyWith(
              color: Theme.of(context).colorScheme.onSurfaceVariant,
            ),
          ),
        ],
      ),
    );
  }
}

/// FutureBuilder with error handling
class ErrorAwareFutureBuilder<T> extends StatelessWidget {
  /// The future to listen to.
  final Future<T> future;
  
  /// Builder for the data state.
  final Widget Function(BuildContext context, T data) builder;
  
  /// Optional custom loading widget.
  final Widget? loadingWidget;
  
  /// Optional custom error widget builder.
  final Widget Function(BuildContext context, Object error)? errorBuilder;
  
  /// Whether to show error as dialog instead of inline.
  final bool showErrorAsDialog;
  
  /// Optional retry callback.
  final VoidCallback? onRetry;
  
  const ErrorAwareFutureBuilder({
    super.key,
    required this.future,
    required this.builder,
    this.loadingWidget,
    this.errorBuilder,
    this.showErrorAsDialog = false,
    this.onRetry,
  });
  
  @override
  Widget build(BuildContext context) {
    return FutureBuilder<T>(
      future: future,
      builder: (context, snapshot) {
        // Handle different states
        if (snapshot.hasError) {
          return _buildErrorState(context, snapshot.error!);
        }
        
        if (snapshot.connectionState == ConnectionState.waiting) {
          return _buildLoadingState(context);
        }
        
        if (!snapshot.hasData) {
          return const SizedBox.shrink();
        }
        
        // Build the data state
        return builder(context, snapshot.data as T);
      },
    );
  }
  
  Widget _buildLoadingState(BuildContext context) {
    return loadingWidget ?? const Center(
      child: CircularProgressIndicator(),
    );
  }
  
  Widget _buildErrorState(BuildContext context, Object error) {
    // Use custom error builder if provided
    if (errorBuilder != null) {
      return errorBuilder!(context, error);
    }
    
    // Check if it's a permission error
    final isPermissionError = ErrorHandlerService.isPermissionError(error);
    final errorMessage = ErrorHandlerService.getErrorMessage(error);
    
    // Show dialog if requested
    if (showErrorAsDialog) {
      WidgetsBinding.instance.addPostFrameCallback((_) {
        ErrorHandlerService.handleError(
          error,
          context: context,
          showAsDialog: true,
          onRetry: onRetry,
        );
      });
      return _buildLoadingState(context); // Show loading while dialog is shown
    }
    
    // Default inline error widget
    return Center(
      child: Padding(
        padding: const EdgeInsets.all(24.0),
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Icon(
              isPermissionError ? Icons.lock_outline : Icons.error_outline,
              size: 64,
              color: Theme.of(context).colorScheme.error,
            ),
            const SizedBox(height: 16),
            Text(
              isPermissionError ? 'Access Denied' : 'Error Loading Data',
              style: Theme.of(context).textTheme.headlineSmall,
              textAlign: TextAlign.center,
            ),
            const SizedBox(height: 8),
            Text(
              errorMessage,
              style: Theme.of(context).textTheme.bodyMedium,
              textAlign: TextAlign.center,
            ),
            if (onRetry != null) ...[
              const SizedBox(height: 24),
              FilledButton.icon(
                onPressed: onRetry,
                icon: const Icon(Icons.refresh),
                label: const Text('Retry'),
              ),
            ],
          ],
        ),
      ),
    );
  }
}
````

## File: lib/shared/widgets/common/firebase_error_boundary.dart
````dart
/// A widget that wraps content and handles Firebase errors globally.
/// 
/// This widget acts as an error boundary for Firebase operations,
/// catching and displaying errors in a user-friendly way.
library;

import 'package:flutter/material.dart';
import 'package:firebase_core/firebase_core.dart';
import '../../services/error_handler_service.dart';

/// Wraps child widgets to catch and handle Firebase errors.
/// 
/// This widget creates an error boundary that catches Firebase
/// exceptions that bubble up from child widgets and displays
/// them using the ErrorHandlerService.
class FirebaseErrorBoundary extends StatefulWidget {
  final Widget child;
  final VoidCallback? onRetry;
  
  const FirebaseErrorBoundary({
    super.key,
    required this.child,
    this.onRetry,
  });

  @override
  State<FirebaseErrorBoundary> createState() => _FirebaseErrorBoundaryState();
}

class _FirebaseErrorBoundaryState extends State<FirebaseErrorBoundary> {
  bool _hasError = false;
  dynamic _error;
  
  @override
  void initState() {
    super.initState();
    // Reset error state when widget rebuilds
    _hasError = false;
    _error = null;
  }
  
  void _handleError(dynamic error) {
    setState(() {
      _hasError = true;
      _error = error;
    });
  }
  
  void _retry() {
    setState(() {
      _hasError = false;
      _error = null;
    });
    widget.onRetry?.call();
  }
  
  @override
  Widget build(BuildContext context) {
    if (_hasError) {
      return _buildErrorWidget(context);
    }
    
    // Wrap child in error handler
    return ErrorBoundary(
      onError: _handleError,
      child: widget.child,
    );
  }
  
  Widget _buildErrorWidget(BuildContext context) {
    final theme = Theme.of(context);
    final isPermissionError = ErrorHandlerService.isPermissionError(_error);
    
    return Center(
      child: Padding(
        padding: const EdgeInsets.all(24.0),
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Icon(
              isPermissionError ? Icons.lock_outline : Icons.error_outline,
              size: 64,
              color: theme.colorScheme.error,
            ),
            const SizedBox(height: 16),
            Text(
              isPermissionError ? 'Access Denied' : 'Error',
              style: theme.textTheme.headlineSmall?.copyWith(
                color: theme.colorScheme.error,
              ),
            ),
            const SizedBox(height: 8),
            Text(
              ErrorHandlerService.getErrorMessage(_error),
              style: theme.textTheme.bodyLarge,
              textAlign: TextAlign.center,
            ),
            if (widget.onRetry != null) ...[
              const SizedBox(height: 24),
              FilledButton.icon(
                onPressed: _retry,
                icon: const Icon(Icons.refresh),
                label: const Text('Retry'),
              ),
            ],
          ],
        ),
      ),
    );
  }
}

/// Error boundary widget that catches errors in child widgets.
class ErrorBoundary extends StatefulWidget {
  final Widget child;
  final void Function(dynamic error)? onError;
  
  const ErrorBoundary({
    super.key,
    required this.child,
    this.onError,
  });
  
  @override
  State<ErrorBoundary> createState() => _ErrorBoundaryState();
}

class _ErrorBoundaryState extends State<ErrorBoundary> {
  @override
  Widget build(BuildContext context) {
    ErrorWidget.builder = (FlutterErrorDetails details) {
      // Check if this is a Firebase error
      if (details.exception is FirebaseException ||
          details.exception.toString().contains('permission-denied')) {
        widget.onError?.call(details.exception);
      }
      
      // Return a widget that displays the error
      return Container();
    };
    
    return widget.child;
  }
}
````

## File: lib/shared/widgets/common/global_error_handler.dart
````dart
/// Global error handler widget that listens for Firebase errors.
/// 
/// This widget should wrap the entire app to catch and display
/// Firebase permission errors and other errors globally.
library;

import 'package:flutter/material.dart';
import '../../services/error_handler_service.dart';

/// Global error handler that displays errors as snackbars or dialogs.
class GlobalErrorHandler extends StatefulWidget {
  final Widget child;
  
  const GlobalErrorHandler({
    super.key,
    required this.child,
  });

  @override
  State<GlobalErrorHandler> createState() => _GlobalErrorHandlerState();
}

class _GlobalErrorHandlerState extends State<GlobalErrorHandler> {
  @override
  Widget build(BuildContext context) {
    return widget.child;
  }
}

/// Mixin to add global error handling to any stateful widget.
mixin GlobalErrorHandlerMixin<T extends StatefulWidget> on State<T> {
  /// Show error message using the nearest scaffold.
  void showError(dynamic error, {VoidCallback? onRetry}) {
    if (!mounted) return;
    
    final message = ErrorHandlerService.getErrorMessage(error);
    final isPermissionError = ErrorHandlerService.isPermissionError(error);
    
    ScaffoldMessenger.of(context).showSnackBar(
      SnackBar(
        content: Row(
          children: [
            Icon(
              isPermissionError ? Icons.lock_outline : Icons.error_outline,
              color: Colors.white,
            ),
            const SizedBox(width: 12),
            Expanded(
              child: Text(message),
            ),
          ],
        ),
        backgroundColor: Theme.of(context).colorScheme.error,
        behavior: SnackBarBehavior.floating,
        duration: const Duration(seconds: 6),
        action: onRetry != null
            ? SnackBarAction(
                label: 'RETRY',
                textColor: Colors.white,
                onPressed: () {
                  ScaffoldMessenger.of(context).hideCurrentSnackBar();
                  onRetry();
                },
              )
            : null,
      ),
    );
  }
  
  /// Show permission error dialog.
  void showPermissionError({
    required String resource,
    String? additionalInfo,
  }) {
    if (!mounted) return;
    
    ErrorHandlerService.showPermissionDeniedDialog(
      context,
      resource: resource,
      additionalInfo: additionalInfo,
    );
  }
}

/// Extension to make showing errors easier from anywhere.
extension GlobalErrorContext on BuildContext {
  /// Show a Firebase error with appropriate UI.
  void showFirebaseError(dynamic error, {VoidCallback? onRetry}) {
    final message = ErrorHandlerService.getErrorMessage(error);
    final isPermissionError = ErrorHandlerService.isPermissionError(error);
    
    final messenger = ScaffoldMessenger.maybeOf(this);
    if (messenger != null) {
      messenger.showSnackBar(
        SnackBar(
          content: Row(
            children: [
              Icon(
                isPermissionError ? Icons.lock_outline : Icons.error_outline,
                color: Colors.white,
              ),
              const SizedBox(width: 12),
              Expanded(
                child: Text(message),
              ),
            ],
          ),
          backgroundColor: Theme.of(this).colorScheme.error,
          behavior: SnackBarBehavior.floating,
          duration: const Duration(seconds: 6),
          action: onRetry != null
              ? SnackBarAction(
                  label: 'RETRY',
                  textColor: Colors.white,
                  onPressed: () {
                    messenger.hideCurrentSnackBar();
                    onRetry();
                  },
                )
              : null,
        ),
      );
    } else {
      // Fallback to dialog if no scaffold
      showDialog(
        context: this,
        builder: (context) => AlertDialog(
          icon: Icon(
            isPermissionError ? Icons.lock_outline : Icons.error_outline,
            color: Theme.of(context).colorScheme.error,
            size: 48,
          ),
          title: Text(isPermissionError ? 'Access Denied' : 'Error'),
          content: Text(message),
          actions: [
            if (onRetry != null)
              TextButton(
                onPressed: () {
                  Navigator.of(context).pop();
                  onRetry();
                },
                child: const Text('RETRY'),
              ),
            TextButton(
              onPressed: () => Navigator.of(context).pop(),
              child: const Text('OK'),
            ),
          ],
        ),
      );
    }
  }
}
````

## File: lib/shared/widgets/common/responsive_layout.dart
````dart
/// Responsive layout system for adaptive UI design.
/// 
/// This module provides a comprehensive responsive design framework with
/// standardized breakpoints, adaptive widgets, and utility classes for
/// creating layouts that work across mobile, tablet, and desktop devices.
/// Follows Material Design responsive guidelines.
library;

import 'package:flutter/material.dart';
import '../../theme/app_spacing.dart';

/// Screen size breakpoints for responsive design.
/// 
/// Defines the four standard device categories used throughout
/// the application for responsive layout decisions.
enum ScreenSize {
  /// Mobile devices (< 768px) - phones in portrait/landscape.
  mobile,
  
  /// Tablet devices (768px - 1023px) - tablets and small laptops.
  tablet,
  
  /// Desktop devices (1024px - 1439px) - standard desktop displays.
  desktop,
  
  /// Large desktop devices (≥ 1440px) - wide monitors and displays.
  largeDesktop,
}

/// Responsive layout builder that provides screen size context.
/// 
/// Core responsive widget that determines the current screen size
/// based on available width and provides this context to child widgets
/// through a builder function. Used as the foundation for all other
/// responsive widgets in the system.
/// 
/// Usage:
/// ```dart
/// ResponsiveLayoutBuilder(
///   builder: (context, screenSize) {
///     if (screenSize == ScreenSize.mobile) {
///       return MobileLayout();
///     }
///     return DesktopLayout();
///   },
/// )
/// ```
class ResponsiveLayoutBuilder extends StatelessWidget {
  /// Builder function that receives screen size context.
  /// 
  /// Called whenever the layout constraints change, providing
  /// the appropriate screen size for responsive decisions.
  final Widget Function(BuildContext context, ScreenSize screenSize) builder;

  /// Creates a responsive layout builder.
  /// 
  /// @param builder Function to build widget based on screen size
  const ResponsiveLayoutBuilder({
    super.key,
    required this.builder,
  });

  @override
  Widget build(BuildContext context) {
    return LayoutBuilder(
      builder: (context, constraints) {
        final screenSize = _getScreenSize(constraints.maxWidth);
        return builder(context, screenSize);
      },
    );
  }

  /// Determines screen size category from available width.
  /// 
  /// Maps pixel width to semantic screen size categories
  /// using predefined breakpoints from AppSpacing.
  /// 
  /// @param width Available width in pixels
  /// @return Appropriate screen size category
  ScreenSize _getScreenSize(double width) {
    if (width >= AppSpacing.largeDesktopBreakpoint) {
      return ScreenSize.largeDesktop;
    } else if (width >= AppSpacing.desktopBreakpoint) {
      return ScreenSize.desktop;
    } else if (width >= AppSpacing.tabletBreakpoint) {
      return ScreenSize.tablet;
    } else {
      return ScreenSize.mobile;
    }
  }
}

/// Responsive widget that shows different widgets based on screen size.
/// 
/// Simplifies responsive design by allowing developers to specify
/// different widgets for each screen size. Falls back gracefully:
/// mobile is required, larger sizes fall back to smaller ones if not provided.
/// 
/// Usage:
/// ```dart
/// ResponsiveWidget(
///   mobile: Text('Mobile'),
///   tablet: Text('Tablet'),
///   desktop: Text('Desktop'),
/// )
/// ```
class ResponsiveWidget extends StatelessWidget {
  /// Widget to display on mobile devices (required).
  final Widget mobile;
  
  /// Widget to display on tablet devices (optional, falls back to mobile).
  final Widget? tablet;
  
  /// Widget to display on desktop devices (optional, falls back to tablet/mobile).
  final Widget? desktop;
  
  /// Widget to display on large desktop devices (optional, falls back to desktop/tablet/mobile).
  final Widget? largeDesktop;

  /// Creates a responsive widget with screen-specific layouts.
  /// 
  /// @param mobile Widget for mobile devices (required)
  /// @param tablet Widget for tablet devices (optional)
  /// @param desktop Widget for desktop devices (optional)
  /// @param largeDesktop Widget for large desktop devices (optional)
  const ResponsiveWidget({
    super.key,
    required this.mobile,
    this.tablet,
    this.desktop,
    this.largeDesktop,
  });

  @override
  Widget build(BuildContext context) {
    return ResponsiveLayoutBuilder(
      builder: (context, screenSize) {
        switch (screenSize) {
          case ScreenSize.largeDesktop:
            return largeDesktop ?? desktop ?? tablet ?? mobile;
          case ScreenSize.desktop:
            return desktop ?? tablet ?? mobile;
          case ScreenSize.tablet:
            return tablet ?? mobile;
          case ScreenSize.mobile:
            return mobile;
        }
      },
    );
  }
}

/// Responsive padding that adapts to screen size.
/// 
/// Provides different padding values for each screen size with
/// intelligent fallbacks. Defaults to standard spacing values
/// from AppSpacing if no custom padding is specified.
/// 
/// Usage:
/// ```dart
/// ResponsivePadding(
///   mobile: EdgeInsets.all(16),
///   desktop: EdgeInsets.all(32),
///   child: MyWidget(),
/// )
/// ```
class ResponsivePadding extends StatelessWidget {
  /// Child widget to wrap with responsive padding.
  final Widget child;
  
  /// Padding for mobile devices (falls back to AppSpacing.md).
  final EdgeInsets? mobile;
  
  /// Padding for tablet devices (falls back to mobile or AppSpacing.md).
  final EdgeInsets? tablet;
  
  /// Padding for desktop devices (falls back to tablet/mobile or AppSpacing.lg).
  final EdgeInsets? desktop;
  
  /// Padding for large desktop devices (falls back to desktop/tablet/mobile or AppSpacing.xl).
  final EdgeInsets? largeDesktop;

  /// Creates responsive padding wrapper.
  /// 
  /// @param child Widget to wrap with padding
  /// @param mobile Mobile device padding (optional)
  /// @param tablet Tablet device padding (optional)
  /// @param desktop Desktop device padding (optional)
  /// @param largeDesktop Large desktop padding (optional)
  const ResponsivePadding({
    super.key,
    required this.child,
    this.mobile,
    this.tablet,
    this.desktop,
    this.largeDesktop,
  });

  @override
  Widget build(BuildContext context) {
    return ResponsiveLayoutBuilder(
      builder: (context, screenSize) {
        EdgeInsets padding;
        
        switch (screenSize) {
          case ScreenSize.largeDesktop:
            padding = largeDesktop ?? 
                      desktop ?? 
                      tablet ?? 
                      mobile ?? 
                      const EdgeInsets.all(AppSpacing.xl);
            break;
          case ScreenSize.desktop:
            padding = desktop ?? 
                      tablet ?? 
                      mobile ?? 
                      const EdgeInsets.all(AppSpacing.lg);
            break;
          case ScreenSize.tablet:
            padding = tablet ?? 
                      mobile ?? 
                      const EdgeInsets.all(AppSpacing.md);
            break;
          case ScreenSize.mobile:
            padding = mobile ?? 
                      const EdgeInsets.all(AppSpacing.md);
            break;
        }
        
        return Padding(
          padding: padding,
          child: child,
        );
      },
    );
  }
}

/// Responsive grid that adapts column count to screen size.
/// 
/// Creates a grid layout that automatically adjusts the number of columns
/// based on screen size. Defaults to sensible column counts (1 mobile,
/// 2 tablet, 3 desktop, 4 large desktop) if not specified.
/// 
/// Usage:
/// ```dart
/// ResponsiveGrid(
///   mobileColumns: 1,
///   tabletColumns: 2,
///   desktopColumns: 3,
///   children: [Widget1(), Widget2(), Widget3()],
/// )
/// ```
class ResponsiveGrid extends StatelessWidget {
  /// List of child widgets to display in the grid.
  final List<Widget> children;
  
  /// Number of columns on mobile devices (default: 1).
  final int? mobileColumns;
  
  /// Number of columns on tablet devices (default: 2).
  final int? tabletColumns;
  
  /// Number of columns on desktop devices (default: 3).
  final int? desktopColumns;
  
  /// Number of columns on large desktop devices (default: 4).
  final int? largeDesktopColumns;
  
  /// Horizontal spacing between grid items.
  final double spacing;
  
  /// Vertical spacing between grid rows.
  final double runSpacing;
  
  /// Aspect ratio of grid children (width/height).
  final double? childAspectRatio;
  
  /// Whether grid should shrink-wrap its content.
  final bool shrinkWrap;
  
  /// Scroll physics for the grid view.
  final ScrollPhysics? physics;

  /// Creates a responsive grid layout.
  /// 
  /// @param children Widgets to display in grid
  /// @param mobileColumns Columns for mobile (default: 1)
  /// @param tabletColumns Columns for tablet (default: 2)
  /// @param desktopColumns Columns for desktop (default: 3)
  /// @param largeDesktopColumns Columns for large desktop (default: 4)
  /// @param spacing Horizontal spacing between items
  /// @param runSpacing Vertical spacing between rows
  /// @param childAspectRatio Aspect ratio of grid children
  /// @param shrinkWrap Whether to shrink-wrap content
  /// @param physics Scroll physics for grid
  const ResponsiveGrid({
    super.key,
    required this.children,
    this.mobileColumns,
    this.tabletColumns,
    this.desktopColumns,
    this.largeDesktopColumns,
    this.spacing = AppSpacing.md,
    this.runSpacing = AppSpacing.md,
    this.childAspectRatio,
    this.shrinkWrap = false,
    this.physics,
  });

  @override
  Widget build(BuildContext context) {
    return ResponsiveLayoutBuilder(
      builder: (context, screenSize) {
        int columns;
        
        switch (screenSize) {
          case ScreenSize.largeDesktop:
            columns = largeDesktopColumns ?? desktopColumns ?? tabletColumns ?? mobileColumns ?? 4;
            break;
          case ScreenSize.desktop:
            columns = desktopColumns ?? tabletColumns ?? mobileColumns ?? 3;
            break;
          case ScreenSize.tablet:
            columns = tabletColumns ?? mobileColumns ?? 2;
            break;
          case ScreenSize.mobile:
            columns = mobileColumns ?? 1;
            break;
        }
        
        return GridView.builder(
          shrinkWrap: shrinkWrap,
          physics: physics,
          gridDelegate: SliverGridDelegateWithFixedCrossAxisCount(
            crossAxisCount: columns,
            crossAxisSpacing: spacing,
            mainAxisSpacing: runSpacing,
            childAspectRatio: childAspectRatio ?? 1.0,
          ),
          itemCount: children.length,
          itemBuilder: (context, index) => children[index],
        );
      },
    );
  }
}

/// Responsive container with max width constraints.
/// 
/// Constrains content to a maximum width for better readability
/// on large screens. Optionally centers the content and applies
/// padding. Uses AppSpacing.maxContentWidth as default max width.
/// 
/// Usage:
/// ```dart
/// ResponsiveContainer(
///   maxWidth: 800,
///   child: MyContent(),
/// )
/// ```
class ResponsiveContainer extends StatelessWidget {
  /// Child widget to constrain and optionally center.
  final Widget child;
  
  /// Maximum width constraint (default: AppSpacing.maxContentWidth).
  final double? maxWidth;
  
  /// Whether to center the constrained content.
  final bool center;
  
  /// Optional padding to apply inside the container.
  final EdgeInsets? padding;

  /// Creates a responsive container with width constraints.
  /// 
  /// @param child Widget to constrain
  /// @param maxWidth Maximum width (default: AppSpacing.maxContentWidth)
  /// @param center Whether to center content (default: true)
  /// @param padding Optional internal padding
  const ResponsiveContainer({
    super.key,
    required this.child,
    this.maxWidth,
    this.center = true,
    this.padding,
  });

  @override
  Widget build(BuildContext context) {
    Widget container = Container(
      constraints: BoxConstraints(
        maxWidth: maxWidth ?? AppSpacing.maxContentWidth,
      ),
      padding: padding,
      child: child,
    );

    if (center) {
      container = Center(child: container);
    }

    return container;
  }
}

/// Responsive columns that stack on mobile.
/// 
/// Displays children as a horizontal row on larger screens
/// and stacks them vertically on mobile devices. Automatically
/// applies appropriate spacing between children.
/// 
/// Usage:
/// ```dart
/// ResponsiveColumns(
///   children: [Widget1(), Widget2(), Widget3()],
///   spacing: 16,
/// )
/// ```
class ResponsiveColumns extends StatelessWidget {
  /// List of child widgets to display as columns/stack.
  final List<Widget> children;
  
  /// Main axis alignment for row layout (larger screens).
  final MainAxisAlignment mainAxisAlignment;
  
  /// Cross axis alignment for both row and column layouts.
  final CrossAxisAlignment crossAxisAlignment;
  
  /// Spacing between children (horizontal for row, vertical for column).
  final double spacing;

  /// Creates responsive columns that adapt to screen size.
  /// 
  /// @param children Widgets to display
  /// @param mainAxisAlignment Main axis alignment for row layout
  /// @param crossAxisAlignment Cross axis alignment for both layouts
  /// @param spacing Spacing between children
  const ResponsiveColumns({
    super.key,
    required this.children,
    this.mainAxisAlignment = MainAxisAlignment.start,
    this.crossAxisAlignment = CrossAxisAlignment.start,
    this.spacing = AppSpacing.md,
  });

  @override
  Widget build(BuildContext context) {
    return ResponsiveLayoutBuilder(
      builder: (context, screenSize) {
        if (screenSize == ScreenSize.mobile) {
          // Stack vertically on mobile
          return Column(
            mainAxisAlignment: mainAxisAlignment,
            crossAxisAlignment: crossAxisAlignment,
            children: children
                .expand((child) => [child, SizedBox(height: spacing)])
                .take(children.length * 2 - 1)
                .toList(),
          );
        } else {
          // Display as row on larger screens
          return Row(
            mainAxisAlignment: mainAxisAlignment,
            crossAxisAlignment: crossAxisAlignment,
            children: children
                .expand((child) => [Expanded(child: child), SizedBox(width: spacing)])
                .take(children.length * 2 - 1)
                .toList(),
          );
        }
      },
    );
  }
}

/// Adaptive card that adjusts size based on screen.
/// 
/// Creates a Material Design card that adapts its padding and
/// margins based on screen size. Optionally constrains width
/// on larger screens for better visual hierarchy.
/// 
/// Usage:
/// ```dart
/// ResponsiveCard(
///   fullWidth: false,
///   child: CardContent(),
/// )
/// ```
class ResponsiveCard extends StatelessWidget {
  /// Child widget to display inside the card.
  final Widget child;
  
  /// Custom padding override (uses responsive defaults if not provided).
  final EdgeInsets? padding;
  
  /// Custom margin override (uses responsive defaults if not provided).
  final EdgeInsets? margin;
  
  /// Card elevation override.
  final double? elevation;
  
  /// Card background color override.
  final Color? color;
  
  /// Whether card should take full width on all screen sizes.
  final bool fullWidth;

  /// Creates an adaptive card with responsive sizing.
  /// 
  /// @param child Content to display in card
  /// @param padding Custom padding (optional)
  /// @param margin Custom margin (optional)
  /// @param elevation Card elevation (optional)
  /// @param color Card background color (optional)
  /// @param fullWidth Whether to take full width (default: false)
  const ResponsiveCard({
    super.key,
    required this.child,
    this.padding,
    this.margin,
    this.elevation,
    this.color,
    this.fullWidth = false,
  });

  @override
  Widget build(BuildContext context) {
    return ResponsiveLayoutBuilder(
      builder: (context, screenSize) {
        EdgeInsets cardPadding;
        EdgeInsets cardMargin;
        
        switch (screenSize) {
          case ScreenSize.largeDesktop:
          case ScreenSize.desktop:
            cardPadding = padding ?? const EdgeInsets.all(AppSpacing.lg);
            cardMargin = margin ?? const EdgeInsets.all(AppSpacing.sm);
            break;
          case ScreenSize.tablet:
            cardPadding = padding ?? const EdgeInsets.all(AppSpacing.md);
            cardMargin = margin ?? const EdgeInsets.all(AppSpacing.sm);
            break;
          case ScreenSize.mobile:
            cardPadding = padding ?? const EdgeInsets.all(AppSpacing.md);
            cardMargin = margin ?? const EdgeInsets.symmetric(
              horizontal: AppSpacing.sm,
              vertical: AppSpacing.xs,
            );
            break;
        }

        Widget card = Card(
          elevation: elevation,
          color: color,
          margin: cardMargin,
          child: Padding(
            padding: cardPadding,
            child: child,
          ),
        );

        if (!fullWidth && screenSize != ScreenSize.mobile) {
          card = ConstrainedBox(
            constraints: const BoxConstraints(
              maxWidth: AppSpacing.maxCardWidth,
            ),
            child: card,
          );
        }

        return card;
      },
    );
  }
}

/// Helper class for responsive values.
/// 
/// Generic container for screen-size-specific values with intelligent
/// fallback behavior. Useful for defining responsive properties that
/// aren't covered by the standard responsive widgets.
/// 
/// Usage:
/// ```dart
/// final fontSize = ResponsiveValue<double>(
///   mobile: 14,
///   tablet: 16,
///   desktop: 18,
/// );
/// final size = fontSize.getValue(context.screenSize);
/// ```
class ResponsiveValue<T> {
  /// Value for mobile devices (required).
  final T mobile;
  
  /// Value for tablet devices (falls back to mobile if not provided).
  final T? tablet;
  
  /// Value for desktop devices (falls back to tablet/mobile if not provided).
  final T? desktop;
  
  /// Value for large desktop devices (falls back to desktop/tablet/mobile if not provided).
  final T? largeDesktop;

  /// Creates a responsive value container.
  /// 
  /// @param mobile Value for mobile devices (required)
  /// @param tablet Value for tablet devices (optional)
  /// @param desktop Value for desktop devices (optional)
  /// @param largeDesktop Value for large desktop devices (optional)
  const ResponsiveValue({
    required this.mobile,
    this.tablet,
    this.desktop,
    this.largeDesktop,
  });

  /// Gets the appropriate value for the given screen size.
  /// 
  /// Implements fallback logic: if a value isn't defined for the
  /// current screen size, falls back to the next smaller size.
  /// 
  /// @param screenSize Current screen size category
  /// @return Appropriate value for the screen size
  T getValue(ScreenSize screenSize) {
    switch (screenSize) {
      case ScreenSize.largeDesktop:
        return largeDesktop ?? desktop ?? tablet ?? mobile;
      case ScreenSize.desktop:
        return desktop ?? tablet ?? mobile;
      case ScreenSize.tablet:
        return tablet ?? mobile;
      case ScreenSize.mobile:
        return mobile;
    }
  }
}

/// Extension to get screen size from BuildContext.
/// 
/// Provides convenient access to screen size information directly
/// from any BuildContext. Includes both the semantic screen size
/// and boolean helpers for common responsive checks.
/// 
/// Usage:
/// ```dart
/// if (context.isMobile) {
///   return MobileLayout();
/// }
/// ```
extension ScreenSizeExtension on BuildContext {
  /// Gets the current screen size category.
  /// 
  /// Determines screen size based on MediaQuery width and
  /// standard breakpoints defined in AppSpacing.
  ScreenSize get screenSize {
    final width = MediaQuery.of(this).size.width;
    
    if (width >= AppSpacing.largeDesktopBreakpoint) {
      return ScreenSize.largeDesktop;
    } else if (width >= AppSpacing.desktopBreakpoint) {
      return ScreenSize.desktop;
    } else if (width >= AppSpacing.tabletBreakpoint) {
      return ScreenSize.tablet;
    } else {
      return ScreenSize.mobile;
    }
  }

  /// Whether the current screen is mobile size.
  bool get isMobile => screenSize == ScreenSize.mobile;
  
  /// Whether the current screen is tablet size.
  bool get isTablet => screenSize == ScreenSize.tablet;
  
  /// Whether the current screen is desktop or larger.
  bool get isDesktop => screenSize == ScreenSize.desktop || screenSize == ScreenSize.largeDesktop;
  
  /// Whether the current screen is large desktop size.
  bool get isLargeDesktop => screenSize == ScreenSize.largeDesktop;
}
````

## File: lib/shared/widgets/common/stat_card.dart
````dart
import 'package:flutter/material.dart';
import 'app_card.dart';

/// Card component for displaying statistics and metrics
class StatCard extends StatelessWidget {
  final String title;
  final String value;
  final String? subtitle;
  final IconData? icon;
  final Color? iconColor;
  final Color? valueColor;
  final VoidCallback? onTap;
  final Widget? trailing;

  const StatCard({
    super.key,
    required this.title,
    required this.value,
    this.subtitle,
    this.icon,
    this.iconColor,
    this.valueColor,
    this.onTap,
    this.trailing,
  });

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final textTheme = theme.textTheme;
    final colorScheme = theme.colorScheme;

    return AppCard(
      onTap: onTap,
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        mainAxisSize: MainAxisSize.min,
        children: [
          Row(
            mainAxisAlignment: MainAxisAlignment.spaceBetween,
            children: [
              if (icon != null)
                Icon(
                  icon,
                  color: iconColor ?? colorScheme.primary,
                  size: 18,
                ),
              if (trailing != null) trailing!,
            ],
          ),
          const SizedBox(height: 8),
          Text(
            title,
            style: textTheme.bodySmall?.copyWith(
              color: colorScheme.onSurfaceVariant,
            ),
            maxLines: 1,
            overflow: TextOverflow.ellipsis,
          ),
          const SizedBox(height: 2),
          Text(
            value,
            style: textTheme.titleLarge?.copyWith(
              color: valueColor ?? colorScheme.onSurface,
              fontWeight: FontWeight.bold,
            ),
          ),
          if (subtitle != null) ...[
            const SizedBox(height: 2),
            Text(
              subtitle!,
              style: textTheme.labelSmall?.copyWith(
                color: colorScheme.onSurfaceVariant,
              ),
            ),
          ],
        ],
      ),
    );
  }
}
````

## File: lib/shared/widgets/common/status_badge.dart
````dart
import 'package:flutter/material.dart';
import '../../theme/app_theme.dart';

/// Badge component for displaying status information with appropriate colors
class StatusBadge extends StatelessWidget {
  final String label;
  final StatusType type;
  final String? customType;
  final Color? customColor;
  final IconData? icon;
  final bool isSmall;

  const StatusBadge({
    super.key,
    required this.label,
    required this.type,
    this.customType,
    this.customColor,
    this.icon,
    this.isSmall = false,
  });

  /// Create a grade badge
  const StatusBadge.grade({
    super.key,
    required String grade,
    this.icon,
    this.isSmall = false,
  }) : label = grade,
       type = StatusType.grade,
       customType = null,
       customColor = null;

  /// Create a priority badge
  const StatusBadge.priority({
    super.key,
    required String priority,
    this.icon,
    this.isSmall = false,
  }) : label = priority,
       type = StatusType.priority,
       customType = null,
       customColor = null;

  /// Create an assignment type badge
  const StatusBadge.assignmentType({
    super.key,
    required String type,
    this.icon,
    this.isSmall = false,
  }) : label = type,
       type = StatusType.assignmentType,
       customType = null,
       customColor = null;

  /// Create a custom badge
  const StatusBadge.custom({
    super.key,
    required this.label,
    required Color color,
    this.icon,
    this.isSmall = false,
  }) : type = StatusType.custom,
       customType = null,
       customColor = color;

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final colorScheme = theme.colorScheme;
    
    Color backgroundColor;
    Color textColor;

    switch (type) {
      case StatusType.grade:
        backgroundColor = AppTheme.getGradeColor(label);
        textColor = _getContrastColor(backgroundColor);
        break;
      case StatusType.priority:
        backgroundColor = AppTheme.getPriorityColor(label);
        textColor = _getContrastColor(backgroundColor);
        break;
      case StatusType.attendance:
        backgroundColor = _getAttendanceColor(label);
        textColor = _getContrastColor(backgroundColor);
        break;
      case StatusType.assignment:
        backgroundColor = _getAssignmentColor(label);
        textColor = _getContrastColor(backgroundColor);
        break;
      case StatusType.assignmentType:
        backgroundColor = _getAssignmentTypeColor(label);
        textColor = _getContrastColor(backgroundColor);
        break;
      case StatusType.custom:
        backgroundColor = customColor ?? colorScheme.primary;
        textColor = _getContrastColor(backgroundColor);
        break;
    }

    return Container(
      padding: EdgeInsets.symmetric(
        horizontal: isSmall ? 6 : 8,
        vertical: isSmall ? 2 : 4,
      ),
      decoration: BoxDecoration(
        color: backgroundColor,
        borderRadius: BorderRadius.circular(isSmall ? 8 : 12),
      ),
      child: Row(
        mainAxisSize: MainAxisSize.min,
        children: [
          if (icon != null) ...[
            Icon(
              icon,
              color: textColor,
              size: isSmall ? 12 : 14,
            ),
            SizedBox(width: isSmall ? 2 : 4),
          ],
          Text(
            label,
            style: theme.textTheme.labelSmall?.copyWith(
              color: textColor,
              fontWeight: FontWeight.w600,
              fontSize: isSmall ? 10 : 12,
            ),
          ),
        ],
      ),
    );
  }

  Color _getAttendanceColor(String status) {
    switch (status.toLowerCase()) {
      case 'present':
        return AppTheme.successColor;
      case 'absent':
        return AppTheme.errorColor;
      case 'late':
        return AppTheme.warningColor;
      case 'excused':
        return Colors.blue;
      default:
        return Colors.grey;
    }
  }

  Color _getAssignmentColor(String status) {
    switch (status.toLowerCase()) {
      case 'submitted':
      case 'complete':
        return AppTheme.successColor;
      case 'missing':
      case 'not submitted':
        return AppTheme.errorColor;
      case 'late':
        return AppTheme.warningColor;
      case 'in progress':
      case 'draft':
        return Colors.blue;
      case 'graded':
        return Colors.purple;
      default:
        return Colors.grey;
    }
  }

  Color _getAssignmentTypeColor(String type) {
    switch (type.toLowerCase()) {
      case 'homework':
        return Colors.green;
      case 'quiz':
        return Colors.blue;
      case 'test':
        return Colors.orange;
      case 'project':
        return Colors.purple;
      case 'exam':
        return Colors.red;
      default:
        return Colors.grey;
    }
  }

  Color _getContrastColor(Color backgroundColor) {
    // Simple contrast calculation
    final luminance = backgroundColor.computeLuminance();
    return luminance > 0.5 ? Colors.black : Colors.white;
  }
}

enum StatusType {
  grade,
  priority,
  attendance,
  assignment,
  assignmentType,
  custom,
}
````

## File: lib/shared/widgets/navigation/favorites_nav_bar.dart
````dart
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'package:go_router/go_router.dart';
import 'package:shared_preferences/shared_preferences.dart';
import '../../providers/navigation_provider.dart';
import '../../models/nav_item.dart';
import '../../services/navigation_service.dart';
import 'bottom_nav_bar.dart';

/// Customizable bottom navigation bar with favorites
class FavoritesNavBar extends StatelessWidget {
  const FavoritesNavBar({super.key});

  @override
  Widget build(BuildContext context) {
    final navigationProvider = context.watch<NavigationProvider>();
    final favoriteItems = navigationProvider.favoriteItems;
    final currentRoute = GoRouterState.of(context).matchedLocation;

    if (navigationProvider.isLoading) {
      // Show loading indicator
      return Container(
        height: 60,
        color: Theme.of(context).colorScheme.surface,
        child: const Center(
          child: CircularProgressIndicator(),
        ),
      );
    }

    if (favoriteItems.isEmpty) {
      // Fallback to default navigation
      return const BottomNavBar();
    }

    // Find current index
    int currentIndex =
        favoriteItems.indexWhere((item) => item.route == currentRoute);
    if (currentIndex == -1) currentIndex = 0;

    return GestureDetector(
      onLongPress: () => _showCustomizationSheet(context),
      child: Container(
        decoration: BoxDecoration(
          boxShadow: [
            BoxShadow(
              color: Colors.black.withAlpha(26),
              blurRadius: 4,
              offset: const Offset(0, -2),
            ),
          ],
        ),
        child: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            // Subtle hint bar with pulsing animation on first use
            _HintBar(),
            BottomNavigationBar(
              items: favoriteItems
                  .map((item) => BottomNavigationBarItem(
                        icon: Icon(item.icon),
                        activeIcon: Icon(item.activeIcon),
                        label: item.title,
                        tooltip: item.title,
                      ))
                  .toList(),
              currentIndex: currentIndex,
              type: BottomNavigationBarType.fixed,
              onTap: (index) {
                if (index < favoriteItems.length) {
                  context.go(favoriteItems[index].route);
                }
              },
              selectedItemColor: Theme.of(context).colorScheme.primary,
              unselectedItemColor:
                  Theme.of(context).colorScheme.onSurfaceVariant,
              showUnselectedLabels: true,
              selectedFontSize: 12,
              unselectedFontSize: 12,
            ),
          ],
        ),
      ),
    );
  }

  void _showCustomizationSheet(BuildContext context) {
    showModalBottomSheet(
      context: context,
      isScrollControlled: true,
      backgroundColor: Colors.transparent,
      builder: (context) => const NavigationCustomizationSheet(),
    );
  }
}

/// Floating action button for customizing navigation
class CustomizeNavFab extends StatelessWidget {
  const CustomizeNavFab({super.key});

  @override
  Widget build(BuildContext context) {
    return FloatingActionButton.small(
      onPressed: () => _showCustomizationSheet(context),
      tooltip: 'Customize Navigation',
      backgroundColor: Theme.of(context).colorScheme.secondaryContainer,
      foregroundColor: Theme.of(context).colorScheme.onSecondaryContainer,
      child: const Icon(Icons.edit),
    );
  }

  void _showCustomizationSheet(BuildContext context) {
    showModalBottomSheet(
      context: context,
      isScrollControlled: true,
      backgroundColor: Colors.transparent,
      builder: (context) => const NavigationCustomizationSheet(),
    );
  }
}

/// Bottom sheet for customizing navigation favorites
class NavigationCustomizationSheet extends StatefulWidget {
  const NavigationCustomizationSheet({super.key});

  @override
  State<NavigationCustomizationSheet> createState() =>
      _NavigationCustomizationSheetState();
}

class _NavigationCustomizationSheetState
    extends State<NavigationCustomizationSheet> {
  late List<String> _tempFavorites;
  String _selectedCategory = 'all';

  @override
  void initState() {
    super.initState();
    final navProvider = context.read<NavigationProvider>();
    _tempFavorites = List<String>.from(navProvider.favoriteIds);
  }

  @override
  Widget build(BuildContext context) {
    final navProvider = context.watch<NavigationProvider>();
    final theme = Theme.of(context);
    final availableItems = navProvider.availableItems;

    // Get categories
    final categories = {'all': 'All'};
    for (final item in availableItems) {
      categories[item.category] = _getCategoryName(item.category);
    }

    // Filter items by category
    final filteredItems = _selectedCategory == 'all'
        ? availableItems
        : availableItems
            .where((item) => item.category == _selectedCategory)
            .toList();

    return Container(
      constraints: BoxConstraints(
        maxHeight: MediaQuery.of(context).size.height * 0.8,
      ),
      decoration: BoxDecoration(
        color: theme.colorScheme.surface,
        borderRadius: const BorderRadius.vertical(top: Radius.circular(20)),
      ),
      child: Column(
        children: [
          // Handle
          Container(
            margin: const EdgeInsets.only(top: 12),
            width: 40,
            height: 4,
            decoration: BoxDecoration(
              color: theme.colorScheme.onSurfaceVariant.withAlpha(102),
              borderRadius: BorderRadius.circular(2),
            ),
          ),

          // Header
          Padding(
            padding: const EdgeInsets.all(16),
            child: Row(
              children: [
                Expanded(
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      Text(
                        'Customize Navigation',
                        style: theme.textTheme.headlineSmall?.copyWith(
                          fontWeight: FontWeight.bold,
                        ),
                      ),
                      const SizedBox(height: 4),
                      Text(
                        'Select up to 4 favorites for quick access',
                        style: theme.textTheme.bodyMedium?.copyWith(
                          color: theme.colorScheme.onSurfaceVariant,
                        ),
                      ),
                    ],
                  ),
                ),
                TextButton(
                  onPressed: () => _resetToDefaults(context),
                  child: const Text('Reset'),
                ),
              ],
            ),
          ),

          // Current favorites preview
          Container(
            height: 80,
            padding: const EdgeInsets.symmetric(horizontal: 16),
            child: Row(
              children: List.generate(4, (index) {
                if (index < _tempFavorites.length) {
                  final item = availableItems.firstWhere(
                    (item) => item.id == _tempFavorites[index],
                  );
                  return Expanded(
                    child: _FavoriteSlot(
                      item: item,
                      onRemove: () => _removeFavorite(index),
                    ),
                  );
                } else {
                  return Expanded(
                    child: _EmptySlot(index: index),
                  );
                }
              }),
            ),
          ),

          const Divider(height: 1),

          // Category filter
          Container(
            height: 40,
            margin: const EdgeInsets.symmetric(vertical: 8),
            child: ListView(
              scrollDirection: Axis.horizontal,
              padding: const EdgeInsets.symmetric(horizontal: 16),
              children: categories.entries.map((entry) {
                final isSelected = _selectedCategory == entry.key;
                return Padding(
                  padding: const EdgeInsets.only(right: 8),
                  child: FilterChip(
                    label: Text(entry.value),
                    selected: isSelected,
                    onSelected: (selected) {
                      setState(() {
                        _selectedCategory = entry.key;
                      });
                    },
                  ),
                );
              }).toList(),
            ),
          ),

          // Available items
          Expanded(
            child: ListView.builder(
              padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
              itemCount: filteredItems.length,
              itemBuilder: (context, index) {
                final item = filteredItems[index];
                final isFavorite = _tempFavorites.contains(item.id);

                return Card(
                  margin: const EdgeInsets.only(bottom: 8),
                  child: ListTile(
                    leading: Icon(
                      isFavorite ? item.activeIcon : item.icon,
                      color: isFavorite
                          ? theme.colorScheme.primary
                          : theme.colorScheme.onSurfaceVariant,
                    ),
                    title: Text(item.title),
                    subtitle: Text(_getCategoryName(item.category)),
                    trailing: isFavorite
                        ? IconButton(
                            icon: const Icon(Icons.star),
                            color: theme.colorScheme.primary,
                            onPressed: () => _removeFavoriteById(item.id),
                          )
                        : IconButton(
                            icon: const Icon(Icons.star_border),
                            onPressed: _tempFavorites.length < 4
                                ? () => _addFavorite(item.id)
                                : null,
                          ),
                    onTap: () {
                      if (isFavorite) {
                        _removeFavoriteById(item.id);
                      } else if (_tempFavorites.length < 4) {
                        _addFavorite(item.id);
                      }
                    },
                  ),
                );
              },
            ),
          ),

          // Save button
          Container(
            padding: const EdgeInsets.all(16),
            child: SizedBox(
              width: double.infinity,
              child: FilledButton(
                onPressed: () => _saveFavorites(context),
                child: const Text('Save Changes'),
              ),
            ),
          ),
        ],
      ),
    );
  }

  String _getCategoryName(String category) {
    switch (category) {
      case 'general':
        return 'General';
      case 'academic':
        return 'Academic';
      case 'communication':
        return 'Communication';
      case 'planning':
        return 'Planning';
      case 'teaching':
        return 'Teaching';
      case 'system':
        return 'System';
      default:
        return category;
    }
  }

  void _addFavorite(String itemId) {
    if (_tempFavorites.length < 4 && !_tempFavorites.contains(itemId)) {
      setState(() {
        _tempFavorites.add(itemId);
      });
    }
  }

  void _removeFavorite(int index) {
    if (index >= 0 && index < _tempFavorites.length) {
      setState(() {
        _tempFavorites.removeAt(index);
      });
    }
  }

  void _removeFavoriteById(String itemId) {
    setState(() {
      _tempFavorites.remove(itemId);
    });
  }

  void _resetToDefaults(BuildContext context) {
    final navProvider = context.read<NavigationProvider>();
    final role = navProvider.availableItems.first.roles.first;
    setState(() {
      _tempFavorites = NavigationService.getDefaultFavorites(role);
    });
  }

  void _saveFavorites(BuildContext context) async {
    final navProvider = context.read<NavigationProvider>();

    // Update favorites
    for (int i = 0; i < _tempFavorites.length; i++) {
      if (i < navProvider.favoriteIds.length) {
        await navProvider.replaceFavorite(i, _tempFavorites[i]);
      } else {
        await navProvider.addFavorite(_tempFavorites[i]);
      }
    }

    // Remove extras
    while (navProvider.favoriteIds.length > _tempFavorites.length) {
      await navProvider.removeFavorite(navProvider.favoriteIds.last);
    }

    if (mounted && context.mounted) {
      Navigator.of(context).pop();
    }
  }
}

/// Widget for displaying a favorite slot
class _FavoriteSlot extends StatelessWidget {
  final NavItem item;
  final VoidCallback onRemove;

  const _FavoriteSlot({
    required this.item,
    required this.onRemove,
  });

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);

    return Container(
      margin: const EdgeInsets.all(4),
      decoration: BoxDecoration(
        color: theme.colorScheme.primaryContainer,
        borderRadius: BorderRadius.circular(12),
      ),
      child: Stack(
        children: [
          Center(
            child: Column(
              mainAxisSize: MainAxisSize.min,
              children: [
                Icon(
                  item.activeIcon,
                  color: theme.colorScheme.onPrimaryContainer,
                ),
                const SizedBox(height: 4),
                Text(
                  item.title,
                  style: theme.textTheme.labelSmall?.copyWith(
                    color: theme.colorScheme.onPrimaryContainer,
                  ),
                  overflow: TextOverflow.ellipsis,
                ),
              ],
            ),
          ),
          Positioned(
            top: -4,
            right: -4,
            child: IconButton(
              icon: Icon(
                Icons.remove_circle,
                size: 20,
                color: theme.colorScheme.error,
              ),
              onPressed: onRemove,
            ),
          ),
        ],
      ),
    );
  }
}

/// Widget for displaying an empty favorite slot
class _EmptySlot extends StatelessWidget {
  final int index;

  const _EmptySlot({required this.index});

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);

    return Container(
      margin: const EdgeInsets.all(4),
      decoration: BoxDecoration(
        border: Border.all(
          color: theme.colorScheme.outline.withAlpha(77),
          width: 2,
          style: BorderStyle.solid,
        ),
        borderRadius: BorderRadius.circular(12),
      ),
      child: Center(
        child: Icon(
          Icons.add,
          color: theme.colorScheme.outline.withAlpha(128),
        ),
      ),
    );
  }
}

/// Subtle hint bar that shows users they can customize navigation
class _HintBar extends StatefulWidget {
  @override
  State<_HintBar> createState() => _HintBarState();
}

class _HintBarState extends State<_HintBar>
    with SingleTickerProviderStateMixin {
  late AnimationController _controller;
  late Animation<double> _animation;
  bool _hasBeenShown = false;

  @override
  void initState() {
    super.initState();
    _controller = AnimationController(
      duration: const Duration(seconds: 2),
      vsync: this,
    );

    _animation = Tween<double>(
      begin: 0.1,
      end: 0.3,
    ).animate(CurvedAnimation(
      parent: _controller,
      curve: Curves.easeInOut,
    ));

    // Check if hint has been shown before
    _loadHintStatus();
  }

  Future<void> _loadHintStatus() async {
    final prefs = await SharedPreferences.getInstance();
    _hasBeenShown = prefs.getBool('nav_hint_shown') ?? false;

    if (!_hasBeenShown) {
      _controller.repeat(reverse: true);
      // Mark as shown after first display
      prefs.setBool('nav_hint_shown', true);
    }
  }

  @override
  void dispose() {
    _controller.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);

    if (_hasBeenShown) {
      // Just show a static subtle bar
      return Container(
        width: double.infinity,
        height: 2,
        color: theme.colorScheme.primary.withAlpha(26),
      );
    }

    // Show animated hint for first-time users
    return AnimatedBuilder(
      animation: _animation,
      builder: (context, child) {
        return Container(
          width: double.infinity,
          height: 3,
          color: theme.colorScheme.primary.withAlpha((255 * _animation.value).round()),
        );
      },
    );
  }
}
````

## File: linux/.gitignore
````
flutter/ephemeral
````

## File: linux/CMakeLists.txt
````
# Project-level configuration.
cmake_minimum_required(VERSION 3.13)
project(runner LANGUAGES CXX)

# The name of the executable created for the application. Change this to change
# the on-disk name of your application.
set(BINARY_NAME "teacher_dashboard_flutter")
# The unique GTK application identifier for this application. See:
# https://wiki.gnome.org/HowDoI/ChooseApplicationID
set(APPLICATION_ID "com.teacherdashboard.teacher_dashboard_flutter")

# Explicitly opt in to modern CMake behaviors to avoid warnings with recent
# versions of CMake.
cmake_policy(SET CMP0063 NEW)

# Load bundled libraries from the lib/ directory relative to the binary.
set(CMAKE_INSTALL_RPATH "$ORIGIN/lib")

# Root filesystem for cross-building.
if(FLUTTER_TARGET_PLATFORM_SYSROOT)
  set(CMAKE_SYSROOT ${FLUTTER_TARGET_PLATFORM_SYSROOT})
  set(CMAKE_FIND_ROOT_PATH ${CMAKE_SYSROOT})
  set(CMAKE_FIND_ROOT_PATH_MODE_PROGRAM NEVER)
  set(CMAKE_FIND_ROOT_PATH_MODE_PACKAGE ONLY)
  set(CMAKE_FIND_ROOT_PATH_MODE_LIBRARY ONLY)
  set(CMAKE_FIND_ROOT_PATH_MODE_INCLUDE ONLY)
endif()

# Define build configuration options.
if(NOT CMAKE_BUILD_TYPE AND NOT CMAKE_CONFIGURATION_TYPES)
  set(CMAKE_BUILD_TYPE "Debug" CACHE
    STRING "Flutter build mode" FORCE)
  set_property(CACHE CMAKE_BUILD_TYPE PROPERTY STRINGS
    "Debug" "Profile" "Release")
endif()

# Compilation settings that should be applied to most targets.
#
# Be cautious about adding new options here, as plugins use this function by
# default. In most cases, you should add new options to specific targets instead
# of modifying this function.
function(APPLY_STANDARD_SETTINGS TARGET)
  target_compile_features(${TARGET} PUBLIC cxx_std_14)
  target_compile_options(${TARGET} PRIVATE -Wall -Werror)
  target_compile_options(${TARGET} PRIVATE "$<$<NOT:$<CONFIG:Debug>>:-O3>")
  target_compile_definitions(${TARGET} PRIVATE "$<$<NOT:$<CONFIG:Debug>>:NDEBUG>")
endfunction()

# Flutter library and tool build rules.
set(FLUTTER_MANAGED_DIR "${CMAKE_CURRENT_SOURCE_DIR}/flutter")
add_subdirectory(${FLUTTER_MANAGED_DIR})

# System-level dependencies.
find_package(PkgConfig REQUIRED)
pkg_check_modules(GTK REQUIRED IMPORTED_TARGET gtk+-3.0)

# Application build; see runner/CMakeLists.txt.
add_subdirectory("runner")

# Run the Flutter tool portions of the build. This must not be removed.
add_dependencies(${BINARY_NAME} flutter_assemble)

# Only the install-generated bundle's copy of the executable will launch
# correctly, since the resources must in the right relative locations. To avoid
# people trying to run the unbundled copy, put it in a subdirectory instead of
# the default top-level location.
set_target_properties(${BINARY_NAME}
  PROPERTIES
  RUNTIME_OUTPUT_DIRECTORY "${CMAKE_BINARY_DIR}/intermediates_do_not_run"
)


# Generated plugin build rules, which manage building the plugins and adding
# them to the application.
include(flutter/generated_plugins.cmake)


# === Installation ===
# By default, "installing" just makes a relocatable bundle in the build
# directory.
set(BUILD_BUNDLE_DIR "${PROJECT_BINARY_DIR}/bundle")
if(CMAKE_INSTALL_PREFIX_INITIALIZED_TO_DEFAULT)
  set(CMAKE_INSTALL_PREFIX "${BUILD_BUNDLE_DIR}" CACHE PATH "..." FORCE)
endif()

# Start with a clean build bundle directory every time.
install(CODE "
  file(REMOVE_RECURSE \"${BUILD_BUNDLE_DIR}/\")
  " COMPONENT Runtime)

set(INSTALL_BUNDLE_DATA_DIR "${CMAKE_INSTALL_PREFIX}/data")
set(INSTALL_BUNDLE_LIB_DIR "${CMAKE_INSTALL_PREFIX}/lib")

install(TARGETS ${BINARY_NAME} RUNTIME DESTINATION "${CMAKE_INSTALL_PREFIX}"
  COMPONENT Runtime)

install(FILES "${FLUTTER_ICU_DATA_FILE}" DESTINATION "${INSTALL_BUNDLE_DATA_DIR}"
  COMPONENT Runtime)

install(FILES "${FLUTTER_LIBRARY}" DESTINATION "${INSTALL_BUNDLE_LIB_DIR}"
  COMPONENT Runtime)

foreach(bundled_library ${PLUGIN_BUNDLED_LIBRARIES})
  install(FILES "${bundled_library}"
    DESTINATION "${INSTALL_BUNDLE_LIB_DIR}"
    COMPONENT Runtime)
endforeach(bundled_library)

# Copy the native assets provided by the build.dart from all packages.
set(NATIVE_ASSETS_DIR "${PROJECT_BUILD_DIR}native_assets/linux/")
install(DIRECTORY "${NATIVE_ASSETS_DIR}"
   DESTINATION "${INSTALL_BUNDLE_LIB_DIR}"
   COMPONENT Runtime)

# Fully re-copy the assets directory on each build to avoid having stale files
# from a previous install.
set(FLUTTER_ASSET_DIR_NAME "flutter_assets")
install(CODE "
  file(REMOVE_RECURSE \"${INSTALL_BUNDLE_DATA_DIR}/${FLUTTER_ASSET_DIR_NAME}\")
  " COMPONENT Runtime)
install(DIRECTORY "${PROJECT_BUILD_DIR}/${FLUTTER_ASSET_DIR_NAME}"
  DESTINATION "${INSTALL_BUNDLE_DATA_DIR}" COMPONENT Runtime)

# Install the AOT library on non-Debug builds only.
if(NOT CMAKE_BUILD_TYPE MATCHES "Debug")
  install(FILES "${AOT_LIBRARY}" DESTINATION "${INSTALL_BUNDLE_LIB_DIR}"
    COMPONENT Runtime)
endif()
````

## File: linux/flutter/CMakeLists.txt
````
# This file controls Flutter-level build steps. It should not be edited.
cmake_minimum_required(VERSION 3.10)

set(EPHEMERAL_DIR "${CMAKE_CURRENT_SOURCE_DIR}/ephemeral")

# Configuration provided via flutter tool.
include(${EPHEMERAL_DIR}/generated_config.cmake)

# TODO: Move the rest of this into files in ephemeral. See
# https://github.com/flutter/flutter/issues/57146.

# Serves the same purpose as list(TRANSFORM ... PREPEND ...),
# which isn't available in 3.10.
function(list_prepend LIST_NAME PREFIX)
    set(NEW_LIST "")
    foreach(element ${${LIST_NAME}})
        list(APPEND NEW_LIST "${PREFIX}${element}")
    endforeach(element)
    set(${LIST_NAME} "${NEW_LIST}" PARENT_SCOPE)
endfunction()

# === Flutter Library ===
# System-level dependencies.
find_package(PkgConfig REQUIRED)
pkg_check_modules(GTK REQUIRED IMPORTED_TARGET gtk+-3.0)
pkg_check_modules(GLIB REQUIRED IMPORTED_TARGET glib-2.0)
pkg_check_modules(GIO REQUIRED IMPORTED_TARGET gio-2.0)

set(FLUTTER_LIBRARY "${EPHEMERAL_DIR}/libflutter_linux_gtk.so")

# Published to parent scope for install step.
set(FLUTTER_LIBRARY ${FLUTTER_LIBRARY} PARENT_SCOPE)
set(FLUTTER_ICU_DATA_FILE "${EPHEMERAL_DIR}/icudtl.dat" PARENT_SCOPE)
set(PROJECT_BUILD_DIR "${PROJECT_DIR}/build/" PARENT_SCOPE)
set(AOT_LIBRARY "${PROJECT_DIR}/build/lib/libapp.so" PARENT_SCOPE)

list(APPEND FLUTTER_LIBRARY_HEADERS
  "fl_basic_message_channel.h"
  "fl_binary_codec.h"
  "fl_binary_messenger.h"
  "fl_dart_project.h"
  "fl_engine.h"
  "fl_json_message_codec.h"
  "fl_json_method_codec.h"
  "fl_message_codec.h"
  "fl_method_call.h"
  "fl_method_channel.h"
  "fl_method_codec.h"
  "fl_method_response.h"
  "fl_plugin_registrar.h"
  "fl_plugin_registry.h"
  "fl_standard_message_codec.h"
  "fl_standard_method_codec.h"
  "fl_string_codec.h"
  "fl_value.h"
  "fl_view.h"
  "flutter_linux.h"
)
list_prepend(FLUTTER_LIBRARY_HEADERS "${EPHEMERAL_DIR}/flutter_linux/")
add_library(flutter INTERFACE)
target_include_directories(flutter INTERFACE
  "${EPHEMERAL_DIR}"
)
target_link_libraries(flutter INTERFACE "${FLUTTER_LIBRARY}")
target_link_libraries(flutter INTERFACE
  PkgConfig::GTK
  PkgConfig::GLIB
  PkgConfig::GIO
)
add_dependencies(flutter flutter_assemble)

# === Flutter tool backend ===
# _phony_ is a non-existent file to force this command to run every time,
# since currently there's no way to get a full input/output list from the
# flutter tool.
add_custom_command(
  OUTPUT ${FLUTTER_LIBRARY} ${FLUTTER_LIBRARY_HEADERS}
    ${CMAKE_CURRENT_BINARY_DIR}/_phony_
  COMMAND ${CMAKE_COMMAND} -E env
    ${FLUTTER_TOOL_ENVIRONMENT}
    "${FLUTTER_ROOT}/packages/flutter_tools/bin/tool_backend.sh"
      ${FLUTTER_TARGET_PLATFORM} ${CMAKE_BUILD_TYPE}
  VERBATIM
)
add_custom_target(flutter_assemble DEPENDS
  "${FLUTTER_LIBRARY}"
  ${FLUTTER_LIBRARY_HEADERS}
)
````

## File: linux/flutter/generated_plugin_registrant.cc
````
//
//  Generated file. Do not edit.
//

// clang-format off

#include "generated_plugin_registrant.h"

#include <file_selector_linux/file_selector_plugin.h>
#include <flutter_webrtc/flutter_web_r_t_c_plugin.h>

void fl_register_plugins(FlPluginRegistry* registry) {
  g_autoptr(FlPluginRegistrar) file_selector_linux_registrar =
      fl_plugin_registry_get_registrar_for_plugin(registry, "FileSelectorPlugin");
  file_selector_plugin_register_with_registrar(file_selector_linux_registrar);
  g_autoptr(FlPluginRegistrar) flutter_webrtc_registrar =
      fl_plugin_registry_get_registrar_for_plugin(registry, "FlutterWebRTCPlugin");
  flutter_web_r_t_c_plugin_register_with_registrar(flutter_webrtc_registrar);
}
````

## File: linux/flutter/generated_plugin_registrant.h
````
//
//  Generated file. Do not edit.
//

// clang-format off

#ifndef GENERATED_PLUGIN_REGISTRANT_
#define GENERATED_PLUGIN_REGISTRANT_

#include <flutter_linux/flutter_linux.h>

// Registers Flutter plugins.
void fl_register_plugins(FlPluginRegistry* registry);

#endif  // GENERATED_PLUGIN_REGISTRANT_
````

## File: linux/flutter/generated_plugins.cmake
````
#
# Generated file, do not edit.
#

list(APPEND FLUTTER_PLUGIN_LIST
  file_selector_linux
  flutter_webrtc
)

list(APPEND FLUTTER_FFI_PLUGIN_LIST
)

set(PLUGIN_BUNDLED_LIBRARIES)

foreach(plugin ${FLUTTER_PLUGIN_LIST})
  add_subdirectory(flutter/ephemeral/.plugin_symlinks/${plugin}/linux plugins/${plugin})
  target_link_libraries(${BINARY_NAME} PRIVATE ${plugin}_plugin)
  list(APPEND PLUGIN_BUNDLED_LIBRARIES $<TARGET_FILE:${plugin}_plugin>)
  list(APPEND PLUGIN_BUNDLED_LIBRARIES ${${plugin}_bundled_libraries})
endforeach(plugin)

foreach(ffi_plugin ${FLUTTER_FFI_PLUGIN_LIST})
  add_subdirectory(flutter/ephemeral/.plugin_symlinks/${ffi_plugin}/linux plugins/${ffi_plugin})
  list(APPEND PLUGIN_BUNDLED_LIBRARIES ${${ffi_plugin}_bundled_libraries})
endforeach(ffi_plugin)
````

## File: linux/runner/CMakeLists.txt
````
cmake_minimum_required(VERSION 3.13)
project(runner LANGUAGES CXX)

# Define the application target. To change its name, change BINARY_NAME in the
# top-level CMakeLists.txt, not the value here, or `flutter run` will no longer
# work.
#
# Any new source files that you add to the application should be added here.
add_executable(${BINARY_NAME}
  "main.cc"
  "my_application.cc"
  "${FLUTTER_MANAGED_DIR}/generated_plugin_registrant.cc"
)

# Apply the standard set of build settings. This can be removed for applications
# that need different build settings.
apply_standard_settings(${BINARY_NAME})

# Add preprocessor definitions for the application ID.
add_definitions(-DAPPLICATION_ID="${APPLICATION_ID}")

# Add dependency libraries. Add any application-specific dependencies here.
target_link_libraries(${BINARY_NAME} PRIVATE flutter)
target_link_libraries(${BINARY_NAME} PRIVATE PkgConfig::GTK)

target_include_directories(${BINARY_NAME} PRIVATE "${CMAKE_SOURCE_DIR}")
````

## File: linux/runner/main.cc
````
#include "my_application.h"

int main(int argc, char** argv) {
  g_autoptr(MyApplication) app = my_application_new();
  return g_application_run(G_APPLICATION(app), argc, argv);
}
````

## File: linux/runner/my_application.cc
````
#include "my_application.h"

#include <flutter_linux/flutter_linux.h>
#ifdef GDK_WINDOWING_X11
#include <gdk/gdkx.h>
#endif

#include "flutter/generated_plugin_registrant.h"

struct _MyApplication {
  GtkApplication parent_instance;
  char** dart_entrypoint_arguments;
};

G_DEFINE_TYPE(MyApplication, my_application, GTK_TYPE_APPLICATION)

// Implements GApplication::activate.
static void my_application_activate(GApplication* application) {
  MyApplication* self = MY_APPLICATION(application);
  GtkWindow* window =
      GTK_WINDOW(gtk_application_window_new(GTK_APPLICATION(application)));

  // Use a header bar when running in GNOME as this is the common style used
  // by applications and is the setup most users will be using (e.g. Ubuntu
  // desktop).
  // If running on X and not using GNOME then just use a traditional title bar
  // in case the window manager does more exotic layout, e.g. tiling.
  // If running on Wayland assume the header bar will work (may need changing
  // if future cases occur).
  gboolean use_header_bar = TRUE;
#ifdef GDK_WINDOWING_X11
  GdkScreen* screen = gtk_window_get_screen(window);
  if (GDK_IS_X11_SCREEN(screen)) {
    const gchar* wm_name = gdk_x11_screen_get_window_manager_name(screen);
    if (g_strcmp0(wm_name, "GNOME Shell") != 0) {
      use_header_bar = FALSE;
    }
  }
#endif
  if (use_header_bar) {
    GtkHeaderBar* header_bar = GTK_HEADER_BAR(gtk_header_bar_new());
    gtk_widget_show(GTK_WIDGET(header_bar));
    gtk_header_bar_set_title(header_bar, "teacher_dashboard_flutter");
    gtk_header_bar_set_show_close_button(header_bar, TRUE);
    gtk_window_set_titlebar(window, GTK_WIDGET(header_bar));
  } else {
    gtk_window_set_title(window, "teacher_dashboard_flutter");
  }

  gtk_window_set_default_size(window, 1280, 720);
  gtk_widget_show(GTK_WIDGET(window));

  g_autoptr(FlDartProject) project = fl_dart_project_new();
  fl_dart_project_set_dart_entrypoint_arguments(project, self->dart_entrypoint_arguments);

  FlView* view = fl_view_new(project);
  gtk_widget_show(GTK_WIDGET(view));
  gtk_container_add(GTK_CONTAINER(window), GTK_WIDGET(view));

  fl_register_plugins(FL_PLUGIN_REGISTRY(view));

  gtk_widget_grab_focus(GTK_WIDGET(view));
}

// Implements GApplication::local_command_line.
static gboolean my_application_local_command_line(GApplication* application, gchar*** arguments, int* exit_status) {
  MyApplication* self = MY_APPLICATION(application);
  // Strip out the first argument as it is the binary name.
  self->dart_entrypoint_arguments = g_strdupv(*arguments + 1);

  g_autoptr(GError) error = nullptr;
  if (!g_application_register(application, nullptr, &error)) {
     g_warning("Failed to register: %s", error->message);
     *exit_status = 1;
     return TRUE;
  }

  g_application_activate(application);
  *exit_status = 0;

  return TRUE;
}

// Implements GApplication::startup.
static void my_application_startup(GApplication* application) {
  //MyApplication* self = MY_APPLICATION(object);

  // Perform any actions required at application startup.

  G_APPLICATION_CLASS(my_application_parent_class)->startup(application);
}

// Implements GApplication::shutdown.
static void my_application_shutdown(GApplication* application) {
  //MyApplication* self = MY_APPLICATION(object);

  // Perform any actions required at application shutdown.

  G_APPLICATION_CLASS(my_application_parent_class)->shutdown(application);
}

// Implements GObject::dispose.
static void my_application_dispose(GObject* object) {
  MyApplication* self = MY_APPLICATION(object);
  g_clear_pointer(&self->dart_entrypoint_arguments, g_strfreev);
  G_OBJECT_CLASS(my_application_parent_class)->dispose(object);
}

static void my_application_class_init(MyApplicationClass* klass) {
  G_APPLICATION_CLASS(klass)->activate = my_application_activate;
  G_APPLICATION_CLASS(klass)->local_command_line = my_application_local_command_line;
  G_APPLICATION_CLASS(klass)->startup = my_application_startup;
  G_APPLICATION_CLASS(klass)->shutdown = my_application_shutdown;
  G_OBJECT_CLASS(klass)->dispose = my_application_dispose;
}

static void my_application_init(MyApplication* self) {}

MyApplication* my_application_new() {
  // Set the program name to the application ID, which helps various systems
  // like GTK and desktop environments map this running application to its
  // corresponding .desktop file. This ensures better integration by allowing
  // the application to be recognized beyond its binary name.
  g_set_prgname(APPLICATION_ID);

  return MY_APPLICATION(g_object_new(my_application_get_type(),
                                     "application-id", APPLICATION_ID,
                                     "flags", G_APPLICATION_NON_UNIQUE,
                                     nullptr));
}
````

## File: linux/runner/my_application.h
````
#ifndef FLUTTER_MY_APPLICATION_H_
#define FLUTTER_MY_APPLICATION_H_

#include <gtk/gtk.h>

G_DECLARE_FINAL_TYPE(MyApplication, my_application, MY, APPLICATION,
                     GtkApplication)

/**
 * my_application_new:
 *
 * Creates a new Flutter-based application.
 *
 * Returns: a new #MyApplication.
 */
MyApplication* my_application_new();

#endif  // FLUTTER_MY_APPLICATION_H_
````

## File: macos/.gitignore
````
# Flutter-related
**/Flutter/ephemeral/
**/Pods/

# Xcode-related
**/dgph
**/xcuserdata/
````

## File: macos/Flutter/Flutter-Debug.xcconfig
````
#include "ephemeral/Flutter-Generated.xcconfig"
````

## File: macos/Flutter/Flutter-Release.xcconfig
````
#include "ephemeral/Flutter-Generated.xcconfig"
````

## File: macos/Runner.xcodeproj/project.pbxproj
````
// !$*UTF8*$!
{
	archiveVersion = 1;
	classes = {
	};
	objectVersion = 54;
	objects = {

/* Begin PBXAggregateTarget section */
		33CC111A2044C6BA0003C045 /* Flutter Assemble */ = {
			isa = PBXAggregateTarget;
			buildConfigurationList = 33CC111B2044C6BA0003C045 /* Build configuration list for PBXAggregateTarget "Flutter Assemble" */;
			buildPhases = (
				33CC111E2044C6BF0003C045 /* ShellScript */,
			);
			dependencies = (
			);
			name = "Flutter Assemble";
			productName = FLX;
		};
/* End PBXAggregateTarget section */

/* Begin PBXBuildFile section */
		331C80D8294CF71000263BE5 /* RunnerTests.swift in Sources */ = {isa = PBXBuildFile; fileRef = 331C80D7294CF71000263BE5 /* RunnerTests.swift */; };
		335BBD1B22A9A15E00E9071D /* GeneratedPluginRegistrant.swift in Sources */ = {isa = PBXBuildFile; fileRef = 335BBD1A22A9A15E00E9071D /* GeneratedPluginRegistrant.swift */; };
		33CC10F12044A3C60003C045 /* AppDelegate.swift in Sources */ = {isa = PBXBuildFile; fileRef = 33CC10F02044A3C60003C045 /* AppDelegate.swift */; };
		33CC10F32044A3C60003C045 /* Assets.xcassets in Resources */ = {isa = PBXBuildFile; fileRef = 33CC10F22044A3C60003C045 /* Assets.xcassets */; };
		33CC10F62044A3C60003C045 /* MainMenu.xib in Resources */ = {isa = PBXBuildFile; fileRef = 33CC10F42044A3C60003C045 /* MainMenu.xib */; };
		33CC11132044BFA00003C045 /* MainFlutterWindow.swift in Sources */ = {isa = PBXBuildFile; fileRef = 33CC11122044BFA00003C045 /* MainFlutterWindow.swift */; };
/* End PBXBuildFile section */

/* Begin PBXContainerItemProxy section */
		331C80D9294CF71000263BE5 /* PBXContainerItemProxy */ = {
			isa = PBXContainerItemProxy;
			containerPortal = 33CC10E52044A3C60003C045 /* Project object */;
			proxyType = 1;
			remoteGlobalIDString = 33CC10EC2044A3C60003C045;
			remoteInfo = Runner;
		};
		33CC111F2044C79F0003C045 /* PBXContainerItemProxy */ = {
			isa = PBXContainerItemProxy;
			containerPortal = 33CC10E52044A3C60003C045 /* Project object */;
			proxyType = 1;
			remoteGlobalIDString = 33CC111A2044C6BA0003C045;
			remoteInfo = FLX;
		};
/* End PBXContainerItemProxy section */

/* Begin PBXCopyFilesBuildPhase section */
		33CC110E2044A8840003C045 /* Bundle Framework */ = {
			isa = PBXCopyFilesBuildPhase;
			buildActionMask = 2147483647;
			dstPath = "";
			dstSubfolderSpec = 10;
			files = (
			);
			name = "Bundle Framework";
			runOnlyForDeploymentPostprocessing = 0;
		};
/* End PBXCopyFilesBuildPhase section */

/* Begin PBXFileReference section */
		331C80D5294CF71000263BE5 /* RunnerTests.xctest */ = {isa = PBXFileReference; explicitFileType = wrapper.cfbundle; includeInIndex = 0; path = RunnerTests.xctest; sourceTree = BUILT_PRODUCTS_DIR; };
		331C80D7294CF71000263BE5 /* RunnerTests.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = RunnerTests.swift; sourceTree = "<group>"; };
		333000ED22D3DE5D00554162 /* Warnings.xcconfig */ = {isa = PBXFileReference; lastKnownFileType = text.xcconfig; path = Warnings.xcconfig; sourceTree = "<group>"; };
		335BBD1A22A9A15E00E9071D /* GeneratedPluginRegistrant.swift */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.swift; path = GeneratedPluginRegistrant.swift; sourceTree = "<group>"; };
		33CC10ED2044A3C60003C045 /* teacher_dashboard_flutter.app */ = {isa = PBXFileReference; explicitFileType = wrapper.application; includeInIndex = 0; path = "teacher_dashboard_flutter.app"; sourceTree = BUILT_PRODUCTS_DIR; };
		33CC10F02044A3C60003C045 /* AppDelegate.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = AppDelegate.swift; sourceTree = "<group>"; };
		33CC10F22044A3C60003C045 /* Assets.xcassets */ = {isa = PBXFileReference; lastKnownFileType = folder.assetcatalog; name = Assets.xcassets; path = Runner/Assets.xcassets; sourceTree = "<group>"; };
		33CC10F52044A3C60003C045 /* Base */ = {isa = PBXFileReference; lastKnownFileType = file.xib; name = Base; path = Base.lproj/MainMenu.xib; sourceTree = "<group>"; };
		33CC10F72044A3C60003C045 /* Info.plist */ = {isa = PBXFileReference; lastKnownFileType = text.plist.xml; name = Info.plist; path = Runner/Info.plist; sourceTree = "<group>"; };
		33CC11122044BFA00003C045 /* MainFlutterWindow.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = MainFlutterWindow.swift; sourceTree = "<group>"; };
		33CEB47222A05771004F2AC0 /* Flutter-Debug.xcconfig */ = {isa = PBXFileReference; lastKnownFileType = text.xcconfig; path = "Flutter-Debug.xcconfig"; sourceTree = "<group>"; };
		33CEB47422A05771004F2AC0 /* Flutter-Release.xcconfig */ = {isa = PBXFileReference; lastKnownFileType = text.xcconfig; path = "Flutter-Release.xcconfig"; sourceTree = "<group>"; };
		33CEB47722A0578A004F2AC0 /* Flutter-Generated.xcconfig */ = {isa = PBXFileReference; lastKnownFileType = text.xcconfig; name = "Flutter-Generated.xcconfig"; path = "ephemeral/Flutter-Generated.xcconfig"; sourceTree = "<group>"; };
		33E51913231747F40026EE4D /* DebugProfile.entitlements */ = {isa = PBXFileReference; lastKnownFileType = text.plist.entitlements; path = DebugProfile.entitlements; sourceTree = "<group>"; };
		33E51914231749380026EE4D /* Release.entitlements */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = text.plist.entitlements; path = Release.entitlements; sourceTree = "<group>"; };
		33E5194F232828860026EE4D /* AppInfo.xcconfig */ = {isa = PBXFileReference; lastKnownFileType = text.xcconfig; path = AppInfo.xcconfig; sourceTree = "<group>"; };
		7AFA3C8E1D35360C0083082E /* Release.xcconfig */ = {isa = PBXFileReference; lastKnownFileType = text.xcconfig; path = Release.xcconfig; sourceTree = "<group>"; };
		9740EEB21CF90195004384FC /* Debug.xcconfig */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = text.xcconfig; path = Debug.xcconfig; sourceTree = "<group>"; };
/* End PBXFileReference section */

/* Begin PBXFrameworksBuildPhase section */
		331C80D2294CF70F00263BE5 /* Frameworks */ = {
			isa = PBXFrameworksBuildPhase;
			buildActionMask = 2147483647;
			files = (
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
		33CC10EA2044A3C60003C045 /* Frameworks */ = {
			isa = PBXFrameworksBuildPhase;
			buildActionMask = 2147483647;
			files = (
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
/* End PBXFrameworksBuildPhase section */

/* Begin PBXGroup section */
		331C80D6294CF71000263BE5 /* RunnerTests */ = {
			isa = PBXGroup;
			children = (
				331C80D7294CF71000263BE5 /* RunnerTests.swift */,
			);
			path = RunnerTests;
			sourceTree = "<group>";
		};
		33BA886A226E78AF003329D5 /* Configs */ = {
			isa = PBXGroup;
			children = (
				33E5194F232828860026EE4D /* AppInfo.xcconfig */,
				9740EEB21CF90195004384FC /* Debug.xcconfig */,
				7AFA3C8E1D35360C0083082E /* Release.xcconfig */,
				333000ED22D3DE5D00554162 /* Warnings.xcconfig */,
			);
			path = Configs;
			sourceTree = "<group>";
		};
		33CC10E42044A3C60003C045 = {
			isa = PBXGroup;
			children = (
				33FAB671232836740065AC1E /* Runner */,
				33CEB47122A05771004F2AC0 /* Flutter */,
				331C80D6294CF71000263BE5 /* RunnerTests */,
				33CC10EE2044A3C60003C045 /* Products */,
				D73912EC22F37F3D000D13A0 /* Frameworks */,
			);
			sourceTree = "<group>";
		};
		33CC10EE2044A3C60003C045 /* Products */ = {
			isa = PBXGroup;
			children = (
				33CC10ED2044A3C60003C045 /* teacher_dashboard_flutter.app */,
				331C80D5294CF71000263BE5 /* RunnerTests.xctest */,
			);
			name = Products;
			sourceTree = "<group>";
		};
		33CC11242044D66E0003C045 /* Resources */ = {
			isa = PBXGroup;
			children = (
				33CC10F22044A3C60003C045 /* Assets.xcassets */,
				33CC10F42044A3C60003C045 /* MainMenu.xib */,
				33CC10F72044A3C60003C045 /* Info.plist */,
			);
			name = Resources;
			path = ..;
			sourceTree = "<group>";
		};
		33CEB47122A05771004F2AC0 /* Flutter */ = {
			isa = PBXGroup;
			children = (
				335BBD1A22A9A15E00E9071D /* GeneratedPluginRegistrant.swift */,
				33CEB47222A05771004F2AC0 /* Flutter-Debug.xcconfig */,
				33CEB47422A05771004F2AC0 /* Flutter-Release.xcconfig */,
				33CEB47722A0578A004F2AC0 /* Flutter-Generated.xcconfig */,
			);
			path = Flutter;
			sourceTree = "<group>";
		};
		33FAB671232836740065AC1E /* Runner */ = {
			isa = PBXGroup;
			children = (
				33CC10F02044A3C60003C045 /* AppDelegate.swift */,
				33CC11122044BFA00003C045 /* MainFlutterWindow.swift */,
				33E51913231747F40026EE4D /* DebugProfile.entitlements */,
				33E51914231749380026EE4D /* Release.entitlements */,
				33CC11242044D66E0003C045 /* Resources */,
				33BA886A226E78AF003329D5 /* Configs */,
			);
			path = Runner;
			sourceTree = "<group>";
		};
		D73912EC22F37F3D000D13A0 /* Frameworks */ = {
			isa = PBXGroup;
			children = (
			);
			name = Frameworks;
			sourceTree = "<group>";
		};
/* End PBXGroup section */

/* Begin PBXNativeTarget section */
		331C80D4294CF70F00263BE5 /* RunnerTests */ = {
			isa = PBXNativeTarget;
			buildConfigurationList = 331C80DE294CF71000263BE5 /* Build configuration list for PBXNativeTarget "RunnerTests" */;
			buildPhases = (
				331C80D1294CF70F00263BE5 /* Sources */,
				331C80D2294CF70F00263BE5 /* Frameworks */,
				331C80D3294CF70F00263BE5 /* Resources */,
			);
			buildRules = (
			);
			dependencies = (
				331C80DA294CF71000263BE5 /* PBXTargetDependency */,
			);
			name = RunnerTests;
			productName = RunnerTests;
			productReference = 331C80D5294CF71000263BE5 /* RunnerTests.xctest */;
			productType = "com.apple.product-type.bundle.unit-test";
		};
		33CC10EC2044A3C60003C045 /* Runner */ = {
			isa = PBXNativeTarget;
			buildConfigurationList = 33CC10FB2044A3C60003C045 /* Build configuration list for PBXNativeTarget "Runner" */;
			buildPhases = (
				33CC10E92044A3C60003C045 /* Sources */,
				33CC10EA2044A3C60003C045 /* Frameworks */,
				33CC10EB2044A3C60003C045 /* Resources */,
				33CC110E2044A8840003C045 /* Bundle Framework */,
				3399D490228B24CF009A79C7 /* ShellScript */,
			);
			buildRules = (
			);
			dependencies = (
				33CC11202044C79F0003C045 /* PBXTargetDependency */,
			);
			name = Runner;
			productName = Runner;
			productReference = 33CC10ED2044A3C60003C045 /* teacher_dashboard_flutter.app */;
			productType = "com.apple.product-type.application";
		};
/* End PBXNativeTarget section */

/* Begin PBXProject section */
		33CC10E52044A3C60003C045 /* Project object */ = {
			isa = PBXProject;
			attributes = {
				BuildIndependentTargetsInParallel = YES;
				LastSwiftUpdateCheck = 0920;
				LastUpgradeCheck = 1510;
				ORGANIZATIONNAME = "";
				TargetAttributes = {
					331C80D4294CF70F00263BE5 = {
						CreatedOnToolsVersion = 14.0;
						TestTargetID = 33CC10EC2044A3C60003C045;
					};
					33CC10EC2044A3C60003C045 = {
						CreatedOnToolsVersion = 9.2;
						LastSwiftMigration = 1100;
						ProvisioningStyle = Automatic;
						SystemCapabilities = {
							com.apple.Sandbox = {
								enabled = 1;
							};
						};
					};
					33CC111A2044C6BA0003C045 = {
						CreatedOnToolsVersion = 9.2;
						ProvisioningStyle = Manual;
					};
				};
			};
			buildConfigurationList = 33CC10E82044A3C60003C045 /* Build configuration list for PBXProject "Runner" */;
			compatibilityVersion = "Xcode 9.3";
			developmentRegion = en;
			hasScannedForEncodings = 0;
			knownRegions = (
				en,
				Base,
			);
			mainGroup = 33CC10E42044A3C60003C045;
			productRefGroup = 33CC10EE2044A3C60003C045 /* Products */;
			projectDirPath = "";
			projectRoot = "";
			targets = (
				33CC10EC2044A3C60003C045 /* Runner */,
				331C80D4294CF70F00263BE5 /* RunnerTests */,
				33CC111A2044C6BA0003C045 /* Flutter Assemble */,
			);
		};
/* End PBXProject section */

/* Begin PBXResourcesBuildPhase section */
		331C80D3294CF70F00263BE5 /* Resources */ = {
			isa = PBXResourcesBuildPhase;
			buildActionMask = 2147483647;
			files = (
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
		33CC10EB2044A3C60003C045 /* Resources */ = {
			isa = PBXResourcesBuildPhase;
			buildActionMask = 2147483647;
			files = (
				33CC10F32044A3C60003C045 /* Assets.xcassets in Resources */,
				33CC10F62044A3C60003C045 /* MainMenu.xib in Resources */,
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
/* End PBXResourcesBuildPhase section */

/* Begin PBXShellScriptBuildPhase section */
		3399D490228B24CF009A79C7 /* ShellScript */ = {
			isa = PBXShellScriptBuildPhase;
			alwaysOutOfDate = 1;
			buildActionMask = 2147483647;
			files = (
			);
			inputFileListPaths = (
			);
			inputPaths = (
			);
			outputFileListPaths = (
			);
			outputPaths = (
			);
			runOnlyForDeploymentPostprocessing = 0;
			shellPath = /bin/sh;
			shellScript = "echo \"$PRODUCT_NAME.app\" > \"$PROJECT_DIR\"/Flutter/ephemeral/.app_filename && \"$FLUTTER_ROOT\"/packages/flutter_tools/bin/macos_assemble.sh embed\n";
		};
		33CC111E2044C6BF0003C045 /* ShellScript */ = {
			isa = PBXShellScriptBuildPhase;
			buildActionMask = 2147483647;
			files = (
			);
			inputFileListPaths = (
				Flutter/ephemeral/FlutterInputs.xcfilelist,
			);
			inputPaths = (
				Flutter/ephemeral/tripwire,
			);
			outputFileListPaths = (
				Flutter/ephemeral/FlutterOutputs.xcfilelist,
			);
			outputPaths = (
			);
			runOnlyForDeploymentPostprocessing = 0;
			shellPath = /bin/sh;
			shellScript = "\"$FLUTTER_ROOT\"/packages/flutter_tools/bin/macos_assemble.sh && touch Flutter/ephemeral/tripwire";
		};
/* End PBXShellScriptBuildPhase section */

/* Begin PBXSourcesBuildPhase section */
		331C80D1294CF70F00263BE5 /* Sources */ = {
			isa = PBXSourcesBuildPhase;
			buildActionMask = 2147483647;
			files = (
				331C80D8294CF71000263BE5 /* RunnerTests.swift in Sources */,
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
		33CC10E92044A3C60003C045 /* Sources */ = {
			isa = PBXSourcesBuildPhase;
			buildActionMask = 2147483647;
			files = (
				33CC11132044BFA00003C045 /* MainFlutterWindow.swift in Sources */,
				33CC10F12044A3C60003C045 /* AppDelegate.swift in Sources */,
				335BBD1B22A9A15E00E9071D /* GeneratedPluginRegistrant.swift in Sources */,
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
/* End PBXSourcesBuildPhase section */

/* Begin PBXTargetDependency section */
		331C80DA294CF71000263BE5 /* PBXTargetDependency */ = {
			isa = PBXTargetDependency;
			target = 33CC10EC2044A3C60003C045 /* Runner */;
			targetProxy = 331C80D9294CF71000263BE5 /* PBXContainerItemProxy */;
		};
		33CC11202044C79F0003C045 /* PBXTargetDependency */ = {
			isa = PBXTargetDependency;
			target = 33CC111A2044C6BA0003C045 /* Flutter Assemble */;
			targetProxy = 33CC111F2044C79F0003C045 /* PBXContainerItemProxy */;
		};
/* End PBXTargetDependency section */

/* Begin PBXVariantGroup section */
		33CC10F42044A3C60003C045 /* MainMenu.xib */ = {
			isa = PBXVariantGroup;
			children = (
				33CC10F52044A3C60003C045 /* Base */,
			);
			name = MainMenu.xib;
			path = Runner;
			sourceTree = "<group>";
		};
/* End PBXVariantGroup section */

/* Begin XCBuildConfiguration section */
		331C80DB294CF71000263BE5 /* Debug */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				BUNDLE_LOADER = "$(TEST_HOST)";
				CURRENT_PROJECT_VERSION = 1;
				GENERATE_INFOPLIST_FILE = YES;
				MARKETING_VERSION = 1.0;
				PRODUCT_BUNDLE_IDENTIFIER = com.teacherdashboard.teacherDashboardFlutter.RunnerTests;
				PRODUCT_NAME = "$(TARGET_NAME)";
				SWIFT_VERSION = 5.0;
				TEST_HOST = "$(BUILT_PRODUCTS_DIR)/teacher_dashboard_flutter.app/$(BUNDLE_EXECUTABLE_FOLDER_PATH)/teacher_dashboard_flutter";
			};
			name = Debug;
		};
		331C80DC294CF71000263BE5 /* Release */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				BUNDLE_LOADER = "$(TEST_HOST)";
				CURRENT_PROJECT_VERSION = 1;
				GENERATE_INFOPLIST_FILE = YES;
				MARKETING_VERSION = 1.0;
				PRODUCT_BUNDLE_IDENTIFIER = com.teacherdashboard.teacherDashboardFlutter.RunnerTests;
				PRODUCT_NAME = "$(TARGET_NAME)";
				SWIFT_VERSION = 5.0;
				TEST_HOST = "$(BUILT_PRODUCTS_DIR)/teacher_dashboard_flutter.app/$(BUNDLE_EXECUTABLE_FOLDER_PATH)/teacher_dashboard_flutter";
			};
			name = Release;
		};
		331C80DD294CF71000263BE5 /* Profile */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				BUNDLE_LOADER = "$(TEST_HOST)";
				CURRENT_PROJECT_VERSION = 1;
				GENERATE_INFOPLIST_FILE = YES;
				MARKETING_VERSION = 1.0;
				PRODUCT_BUNDLE_IDENTIFIER = com.teacherdashboard.teacherDashboardFlutter.RunnerTests;
				PRODUCT_NAME = "$(TARGET_NAME)";
				SWIFT_VERSION = 5.0;
				TEST_HOST = "$(BUILT_PRODUCTS_DIR)/teacher_dashboard_flutter.app/$(BUNDLE_EXECUTABLE_FOLDER_PATH)/teacher_dashboard_flutter";
			};
			name = Profile;
		};
		338D0CE9231458BD00FA5F75 /* Profile */ = {
			isa = XCBuildConfiguration;
			baseConfigurationReference = 7AFA3C8E1D35360C0083082E /* Release.xcconfig */;
			buildSettings = {
				ALWAYS_SEARCH_USER_PATHS = NO;
				ASSETCATALOG_COMPILER_GENERATE_SWIFT_ASSET_SYMBOL_EXTENSIONS = YES;
				CLANG_ANALYZER_NONNULL = YES;
				CLANG_ANALYZER_NUMBER_OBJECT_CONVERSION = YES_AGGRESSIVE;
				CLANG_CXX_LANGUAGE_STANDARD = "gnu++14";
				CLANG_CXX_LIBRARY = "libc++";
				CLANG_ENABLE_MODULES = YES;
				CLANG_ENABLE_OBJC_ARC = YES;
				CLANG_WARN_BLOCK_CAPTURE_AUTORELEASING = YES;
				CLANG_WARN_BOOL_CONVERSION = YES;
				CLANG_WARN_CONSTANT_CONVERSION = YES;
				CLANG_WARN_DEPRECATED_OBJC_IMPLEMENTATIONS = YES;
				CLANG_WARN_DIRECT_OBJC_ISA_USAGE = YES_ERROR;
				CLANG_WARN_DOCUMENTATION_COMMENTS = YES;
				CLANG_WARN_EMPTY_BODY = YES;
				CLANG_WARN_ENUM_CONVERSION = YES;
				CLANG_WARN_INFINITE_RECURSION = YES;
				CLANG_WARN_INT_CONVERSION = YES;
				CLANG_WARN_NON_LITERAL_NULL_CONVERSION = YES;
				CLANG_WARN_OBJC_LITERAL_CONVERSION = YES;
				CLANG_WARN_OBJC_ROOT_CLASS = YES_ERROR;
				CLANG_WARN_RANGE_LOOP_ANALYSIS = YES;
				CLANG_WARN_SUSPICIOUS_MOVE = YES;
				CODE_SIGN_IDENTITY = "-";
				COPY_PHASE_STRIP = NO;
				DEAD_CODE_STRIPPING = YES;
				DEBUG_INFORMATION_FORMAT = "dwarf-with-dsym";
				ENABLE_NS_ASSERTIONS = NO;
				ENABLE_STRICT_OBJC_MSGSEND = YES;
				ENABLE_USER_SCRIPT_SANDBOXING = NO;
				GCC_C_LANGUAGE_STANDARD = gnu11;
				GCC_NO_COMMON_BLOCKS = YES;
				GCC_WARN_64_TO_32_BIT_CONVERSION = YES;
				GCC_WARN_ABOUT_RETURN_TYPE = YES_ERROR;
				GCC_WARN_UNINITIALIZED_AUTOS = YES_AGGRESSIVE;
				GCC_WARN_UNUSED_FUNCTION = YES;
				GCC_WARN_UNUSED_VARIABLE = YES;
				MACOSX_DEPLOYMENT_TARGET = 10.14;
				MTL_ENABLE_DEBUG_INFO = NO;
				SDKROOT = macosx;
				SWIFT_COMPILATION_MODE = wholemodule;
				SWIFT_OPTIMIZATION_LEVEL = "-O";
			};
			name = Profile;
		};
		338D0CEA231458BD00FA5F75 /* Profile */ = {
			isa = XCBuildConfiguration;
			baseConfigurationReference = 33E5194F232828860026EE4D /* AppInfo.xcconfig */;
			buildSettings = {
				ASSETCATALOG_COMPILER_APPICON_NAME = AppIcon;
				CLANG_ENABLE_MODULES = YES;
				CODE_SIGN_ENTITLEMENTS = Runner/DebugProfile.entitlements;
				CODE_SIGN_STYLE = Automatic;
				COMBINE_HIDPI_IMAGES = YES;
				INFOPLIST_FILE = Runner/Info.plist;
				LD_RUNPATH_SEARCH_PATHS = (
					"$(inherited)",
					"@executable_path/../Frameworks",
				);
				PROVISIONING_PROFILE_SPECIFIER = "";
				SWIFT_VERSION = 5.0;
			};
			name = Profile;
		};
		338D0CEB231458BD00FA5F75 /* Profile */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				CODE_SIGN_STYLE = Manual;
				PRODUCT_NAME = "$(TARGET_NAME)";
			};
			name = Profile;
		};
		33CC10F92044A3C60003C045 /* Debug */ = {
			isa = XCBuildConfiguration;
			baseConfigurationReference = 9740EEB21CF90195004384FC /* Debug.xcconfig */;
			buildSettings = {
				ALWAYS_SEARCH_USER_PATHS = NO;
				ASSETCATALOG_COMPILER_GENERATE_SWIFT_ASSET_SYMBOL_EXTENSIONS = YES;
				CLANG_ANALYZER_NONNULL = YES;
				CLANG_ANALYZER_NUMBER_OBJECT_CONVERSION = YES_AGGRESSIVE;
				CLANG_CXX_LANGUAGE_STANDARD = "gnu++14";
				CLANG_CXX_LIBRARY = "libc++";
				CLANG_ENABLE_MODULES = YES;
				CLANG_ENABLE_OBJC_ARC = YES;
				CLANG_WARN_BLOCK_CAPTURE_AUTORELEASING = YES;
				CLANG_WARN_BOOL_CONVERSION = YES;
				CLANG_WARN_CONSTANT_CONVERSION = YES;
				CLANG_WARN_DEPRECATED_OBJC_IMPLEMENTATIONS = YES;
				CLANG_WARN_DIRECT_OBJC_ISA_USAGE = YES_ERROR;
				CLANG_WARN_DOCUMENTATION_COMMENTS = YES;
				CLANG_WARN_EMPTY_BODY = YES;
				CLANG_WARN_ENUM_CONVERSION = YES;
				CLANG_WARN_INFINITE_RECURSION = YES;
				CLANG_WARN_INT_CONVERSION = YES;
				CLANG_WARN_NON_LITERAL_NULL_CONVERSION = YES;
				CLANG_WARN_OBJC_LITERAL_CONVERSION = YES;
				CLANG_WARN_OBJC_ROOT_CLASS = YES_ERROR;
				CLANG_WARN_RANGE_LOOP_ANALYSIS = YES;
				CLANG_WARN_SUSPICIOUS_MOVE = YES;
				CODE_SIGN_IDENTITY = "-";
				COPY_PHASE_STRIP = NO;
				DEAD_CODE_STRIPPING = YES;
				DEBUG_INFORMATION_FORMAT = dwarf;
				ENABLE_STRICT_OBJC_MSGSEND = YES;
				ENABLE_TESTABILITY = YES;
				ENABLE_USER_SCRIPT_SANDBOXING = NO;
				GCC_C_LANGUAGE_STANDARD = gnu11;
				GCC_DYNAMIC_NO_PIC = NO;
				GCC_NO_COMMON_BLOCKS = YES;
				GCC_OPTIMIZATION_LEVEL = 0;
				GCC_PREPROCESSOR_DEFINITIONS = (
					"DEBUG=1",
					"$(inherited)",
				);
				GCC_WARN_64_TO_32_BIT_CONVERSION = YES;
				GCC_WARN_ABOUT_RETURN_TYPE = YES_ERROR;
				GCC_WARN_UNINITIALIZED_AUTOS = YES_AGGRESSIVE;
				GCC_WARN_UNUSED_FUNCTION = YES;
				GCC_WARN_UNUSED_VARIABLE = YES;
				MACOSX_DEPLOYMENT_TARGET = 10.14;
				MTL_ENABLE_DEBUG_INFO = YES;
				ONLY_ACTIVE_ARCH = YES;
				SDKROOT = macosx;
				SWIFT_ACTIVE_COMPILATION_CONDITIONS = DEBUG;
				SWIFT_OPTIMIZATION_LEVEL = "-Onone";
			};
			name = Debug;
		};
		33CC10FA2044A3C60003C045 /* Release */ = {
			isa = XCBuildConfiguration;
			baseConfigurationReference = 7AFA3C8E1D35360C0083082E /* Release.xcconfig */;
			buildSettings = {
				ALWAYS_SEARCH_USER_PATHS = NO;
				ASSETCATALOG_COMPILER_GENERATE_SWIFT_ASSET_SYMBOL_EXTENSIONS = YES;
				CLANG_ANALYZER_NONNULL = YES;
				CLANG_ANALYZER_NUMBER_OBJECT_CONVERSION = YES_AGGRESSIVE;
				CLANG_CXX_LANGUAGE_STANDARD = "gnu++14";
				CLANG_CXX_LIBRARY = "libc++";
				CLANG_ENABLE_MODULES = YES;
				CLANG_ENABLE_OBJC_ARC = YES;
				CLANG_WARN_BLOCK_CAPTURE_AUTORELEASING = YES;
				CLANG_WARN_BOOL_CONVERSION = YES;
				CLANG_WARN_CONSTANT_CONVERSION = YES;
				CLANG_WARN_DEPRECATED_OBJC_IMPLEMENTATIONS = YES;
				CLANG_WARN_DIRECT_OBJC_ISA_USAGE = YES_ERROR;
				CLANG_WARN_DOCUMENTATION_COMMENTS = YES;
				CLANG_WARN_EMPTY_BODY = YES;
				CLANG_WARN_ENUM_CONVERSION = YES;
				CLANG_WARN_INFINITE_RECURSION = YES;
				CLANG_WARN_INT_CONVERSION = YES;
				CLANG_WARN_NON_LITERAL_NULL_CONVERSION = YES;
				CLANG_WARN_OBJC_LITERAL_CONVERSION = YES;
				CLANG_WARN_OBJC_ROOT_CLASS = YES_ERROR;
				CLANG_WARN_RANGE_LOOP_ANALYSIS = YES;
				CLANG_WARN_SUSPICIOUS_MOVE = YES;
				CODE_SIGN_IDENTITY = "-";
				COPY_PHASE_STRIP = NO;
				DEAD_CODE_STRIPPING = YES;
				DEBUG_INFORMATION_FORMAT = "dwarf-with-dsym";
				ENABLE_NS_ASSERTIONS = NO;
				ENABLE_STRICT_OBJC_MSGSEND = YES;
				ENABLE_USER_SCRIPT_SANDBOXING = NO;
				GCC_C_LANGUAGE_STANDARD = gnu11;
				GCC_NO_COMMON_BLOCKS = YES;
				GCC_WARN_64_TO_32_BIT_CONVERSION = YES;
				GCC_WARN_ABOUT_RETURN_TYPE = YES_ERROR;
				GCC_WARN_UNINITIALIZED_AUTOS = YES_AGGRESSIVE;
				GCC_WARN_UNUSED_FUNCTION = YES;
				GCC_WARN_UNUSED_VARIABLE = YES;
				MACOSX_DEPLOYMENT_TARGET = 10.14;
				MTL_ENABLE_DEBUG_INFO = NO;
				SDKROOT = macosx;
				SWIFT_COMPILATION_MODE = wholemodule;
				SWIFT_OPTIMIZATION_LEVEL = "-O";
			};
			name = Release;
		};
		33CC10FC2044A3C60003C045 /* Debug */ = {
			isa = XCBuildConfiguration;
			baseConfigurationReference = 33E5194F232828860026EE4D /* AppInfo.xcconfig */;
			buildSettings = {
				ASSETCATALOG_COMPILER_APPICON_NAME = AppIcon;
				CLANG_ENABLE_MODULES = YES;
				CODE_SIGN_ENTITLEMENTS = Runner/DebugProfile.entitlements;
				CODE_SIGN_STYLE = Automatic;
				COMBINE_HIDPI_IMAGES = YES;
				INFOPLIST_FILE = Runner/Info.plist;
				LD_RUNPATH_SEARCH_PATHS = (
					"$(inherited)",
					"@executable_path/../Frameworks",
				);
				PROVISIONING_PROFILE_SPECIFIER = "";
				SWIFT_OPTIMIZATION_LEVEL = "-Onone";
				SWIFT_VERSION = 5.0;
			};
			name = Debug;
		};
		33CC10FD2044A3C60003C045 /* Release */ = {
			isa = XCBuildConfiguration;
			baseConfigurationReference = 33E5194F232828860026EE4D /* AppInfo.xcconfig */;
			buildSettings = {
				ASSETCATALOG_COMPILER_APPICON_NAME = AppIcon;
				CLANG_ENABLE_MODULES = YES;
				CODE_SIGN_ENTITLEMENTS = Runner/Release.entitlements;
				CODE_SIGN_STYLE = Automatic;
				COMBINE_HIDPI_IMAGES = YES;
				INFOPLIST_FILE = Runner/Info.plist;
				LD_RUNPATH_SEARCH_PATHS = (
					"$(inherited)",
					"@executable_path/../Frameworks",
				);
				PROVISIONING_PROFILE_SPECIFIER = "";
				SWIFT_VERSION = 5.0;
			};
			name = Release;
		};
		33CC111C2044C6BA0003C045 /* Debug */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				CODE_SIGN_STYLE = Manual;
				PRODUCT_NAME = "$(TARGET_NAME)";
			};
			name = Debug;
		};
		33CC111D2044C6BA0003C045 /* Release */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				CODE_SIGN_STYLE = Automatic;
				PRODUCT_NAME = "$(TARGET_NAME)";
			};
			name = Release;
		};
/* End XCBuildConfiguration section */

/* Begin XCConfigurationList section */
		331C80DE294CF71000263BE5 /* Build configuration list for PBXNativeTarget "RunnerTests" */ = {
			isa = XCConfigurationList;
			buildConfigurations = (
				331C80DB294CF71000263BE5 /* Debug */,
				331C80DC294CF71000263BE5 /* Release */,
				331C80DD294CF71000263BE5 /* Profile */,
			);
			defaultConfigurationIsVisible = 0;
			defaultConfigurationName = Release;
		};
		33CC10E82044A3C60003C045 /* Build configuration list for PBXProject "Runner" */ = {
			isa = XCConfigurationList;
			buildConfigurations = (
				33CC10F92044A3C60003C045 /* Debug */,
				33CC10FA2044A3C60003C045 /* Release */,
				338D0CE9231458BD00FA5F75 /* Profile */,
			);
			defaultConfigurationIsVisible = 0;
			defaultConfigurationName = Release;
		};
		33CC10FB2044A3C60003C045 /* Build configuration list for PBXNativeTarget "Runner" */ = {
			isa = XCConfigurationList;
			buildConfigurations = (
				33CC10FC2044A3C60003C045 /* Debug */,
				33CC10FD2044A3C60003C045 /* Release */,
				338D0CEA231458BD00FA5F75 /* Profile */,
			);
			defaultConfigurationIsVisible = 0;
			defaultConfigurationName = Release;
		};
		33CC111B2044C6BA0003C045 /* Build configuration list for PBXAggregateTarget "Flutter Assemble" */ = {
			isa = XCConfigurationList;
			buildConfigurations = (
				33CC111C2044C6BA0003C045 /* Debug */,
				33CC111D2044C6BA0003C045 /* Release */,
				338D0CEB231458BD00FA5F75 /* Profile */,
			);
			defaultConfigurationIsVisible = 0;
			defaultConfigurationName = Release;
		};
/* End XCConfigurationList section */
	};
	rootObject = 33CC10E52044A3C60003C045 /* Project object */;
}
````

## File: macos/Runner.xcworkspace/contents.xcworkspacedata
````
<?xml version="1.0" encoding="UTF-8"?>
<Workspace
   version = "1.0">
   <FileRef
      location = "group:Runner.xcodeproj">
   </FileRef>
</Workspace>
````

## File: macos/Runner/AppDelegate.swift
````swift
import Cocoa
import FlutterMacOS

@main
class AppDelegate: FlutterAppDelegate {
  override func applicationShouldTerminateAfterLastWindowClosed(_ sender: NSApplication) -> Bool {
    return true
  }

  override func applicationSupportsSecureRestorableState(_ app: NSApplication) -> Bool {
    return true
  }
}
````

## File: macos/Runner/Assets.xcassets/AppIcon.appiconset/Contents.json
````json
{
  "images" : [
    {
      "size" : "16x16",
      "idiom" : "mac",
      "filename" : "app_icon_16.png",
      "scale" : "1x"
    },
    {
      "size" : "16x16",
      "idiom" : "mac",
      "filename" : "app_icon_32.png",
      "scale" : "2x"
    },
    {
      "size" : "32x32",
      "idiom" : "mac",
      "filename" : "app_icon_32.png",
      "scale" : "1x"
    },
    {
      "size" : "32x32",
      "idiom" : "mac",
      "filename" : "app_icon_64.png",
      "scale" : "2x"
    },
    {
      "size" : "128x128",
      "idiom" : "mac",
      "filename" : "app_icon_128.png",
      "scale" : "1x"
    },
    {
      "size" : "128x128",
      "idiom" : "mac",
      "filename" : "app_icon_256.png",
      "scale" : "2x"
    },
    {
      "size" : "256x256",
      "idiom" : "mac",
      "filename" : "app_icon_256.png",
      "scale" : "1x"
    },
    {
      "size" : "256x256",
      "idiom" : "mac",
      "filename" : "app_icon_512.png",
      "scale" : "2x"
    },
    {
      "size" : "512x512",
      "idiom" : "mac",
      "filename" : "app_icon_512.png",
      "scale" : "1x"
    },
    {
      "size" : "512x512",
      "idiom" : "mac",
      "filename" : "app_icon_1024.png",
      "scale" : "2x"
    }
  ],
  "info" : {
    "version" : 1,
    "author" : "xcode"
  }
}
````

## File: macos/Runner/Base.lproj/MainMenu.xib
````
<?xml version="1.0" encoding="UTF-8"?>
<document type="com.apple.InterfaceBuilder3.Cocoa.XIB" version="3.0" toolsVersion="14490.70" targetRuntime="MacOSX.Cocoa" propertyAccessControl="none" useAutolayout="YES" customObjectInstantitationMethod="direct">
    <dependencies>
        <deployment identifier="macosx"/>
        <plugIn identifier="com.apple.InterfaceBuilder.CocoaPlugin" version="14490.70"/>
        <capability name="documents saved in the Xcode 8 format" minToolsVersion="8.0"/>
    </dependencies>
    <objects>
        <customObject id="-2" userLabel="File's Owner" customClass="NSApplication">
            <connections>
                <outlet property="delegate" destination="Voe-Tx-rLC" id="GzC-gU-4Uq"/>
            </connections>
        </customObject>
        <customObject id="-1" userLabel="First Responder" customClass="FirstResponder"/>
        <customObject id="-3" userLabel="Application" customClass="NSObject"/>
        <customObject id="Voe-Tx-rLC" customClass="AppDelegate" customModule="Runner" customModuleProvider="target">
            <connections>
                <outlet property="applicationMenu" destination="uQy-DD-JDr" id="XBo-yE-nKs"/>
                <outlet property="mainFlutterWindow" destination="QvC-M9-y7g" id="gIp-Ho-8D9"/>
            </connections>
        </customObject>
        <customObject id="YLy-65-1bz" customClass="NSFontManager"/>
        <menu title="Main Menu" systemMenu="main" id="AYu-sK-qS6">
            <items>
                <menuItem title="APP_NAME" id="1Xt-HY-uBw">
                    <modifierMask key="keyEquivalentModifierMask"/>
                    <menu key="submenu" title="APP_NAME" systemMenu="apple" id="uQy-DD-JDr">
                        <items>
                            <menuItem title="About APP_NAME" id="5kV-Vb-QxS">
                                <modifierMask key="keyEquivalentModifierMask"/>
                                <connections>
                                    <action selector="orderFrontStandardAboutPanel:" target="-1" id="Exp-CZ-Vem"/>
                                </connections>
                            </menuItem>
                            <menuItem isSeparatorItem="YES" id="VOq-y0-SEH"/>
                            <menuItem title="Preferences…" keyEquivalent="," id="BOF-NM-1cW"/>
                            <menuItem isSeparatorItem="YES" id="wFC-TO-SCJ"/>
                            <menuItem title="Services" id="NMo-om-nkz">
                                <modifierMask key="keyEquivalentModifierMask"/>
                                <menu key="submenu" title="Services" systemMenu="services" id="hz9-B4-Xy5"/>
                            </menuItem>
                            <menuItem isSeparatorItem="YES" id="4je-JR-u6R"/>
                            <menuItem title="Hide APP_NAME" keyEquivalent="h" id="Olw-nP-bQN">
                                <connections>
                                    <action selector="hide:" target="-1" id="PnN-Uc-m68"/>
                                </connections>
                            </menuItem>
                            <menuItem title="Hide Others" keyEquivalent="h" id="Vdr-fp-XzO">
                                <modifierMask key="keyEquivalentModifierMask" option="YES" command="YES"/>
                                <connections>
                                    <action selector="hideOtherApplications:" target="-1" id="VT4-aY-XCT"/>
                                </connections>
                            </menuItem>
                            <menuItem title="Show All" id="Kd2-mp-pUS">
                                <modifierMask key="keyEquivalentModifierMask"/>
                                <connections>
                                    <action selector="unhideAllApplications:" target="-1" id="Dhg-Le-xox"/>
                                </connections>
                            </menuItem>
                            <menuItem isSeparatorItem="YES" id="kCx-OE-vgT"/>
                            <menuItem title="Quit APP_NAME" keyEquivalent="q" id="4sb-4s-VLi">
                                <connections>
                                    <action selector="terminate:" target="-1" id="Te7-pn-YzF"/>
                                </connections>
                            </menuItem>
                        </items>
                    </menu>
                </menuItem>
                <menuItem title="Edit" id="5QF-Oa-p0T">
                    <modifierMask key="keyEquivalentModifierMask"/>
                    <menu key="submenu" title="Edit" id="W48-6f-4Dl">
                        <items>
                            <menuItem title="Undo" keyEquivalent="z" id="dRJ-4n-Yzg">
                                <connections>
                                    <action selector="undo:" target="-1" id="M6e-cu-g7V"/>
                                </connections>
                            </menuItem>
                            <menuItem title="Redo" keyEquivalent="Z" id="6dh-zS-Vam">
                                <connections>
                                    <action selector="redo:" target="-1" id="oIA-Rs-6OD"/>
                                </connections>
                            </menuItem>
                            <menuItem isSeparatorItem="YES" id="WRV-NI-Exz"/>
                            <menuItem title="Cut" keyEquivalent="x" id="uRl-iY-unG">
                                <connections>
                                    <action selector="cut:" target="-1" id="YJe-68-I9s"/>
                                </connections>
                            </menuItem>
                            <menuItem title="Copy" keyEquivalent="c" id="x3v-GG-iWU">
                                <connections>
                                    <action selector="copy:" target="-1" id="G1f-GL-Joy"/>
                                </connections>
                            </menuItem>
                            <menuItem title="Paste" keyEquivalent="v" id="gVA-U4-sdL">
                                <connections>
                                    <action selector="paste:" target="-1" id="UvS-8e-Qdg"/>
                                </connections>
                            </menuItem>
                            <menuItem title="Paste and Match Style" keyEquivalent="V" id="WeT-3V-zwk">
                                <modifierMask key="keyEquivalentModifierMask" option="YES" command="YES"/>
                                <connections>
                                    <action selector="pasteAsPlainText:" target="-1" id="cEh-KX-wJQ"/>
                                </connections>
                            </menuItem>
                            <menuItem title="Delete" id="pa3-QI-u2k">
                                <modifierMask key="keyEquivalentModifierMask"/>
                                <connections>
                                    <action selector="delete:" target="-1" id="0Mk-Ml-PaM"/>
                                </connections>
                            </menuItem>
                            <menuItem title="Select All" keyEquivalent="a" id="Ruw-6m-B2m">
                                <connections>
                                    <action selector="selectAll:" target="-1" id="VNm-Mi-diN"/>
                                </connections>
                            </menuItem>
                            <menuItem isSeparatorItem="YES" id="uyl-h8-XO2"/>
                            <menuItem title="Find" id="4EN-yA-p0u">
                                <modifierMask key="keyEquivalentModifierMask"/>
                                <menu key="submenu" title="Find" id="1b7-l0-nxx">
                                    <items>
                                        <menuItem title="Find…" tag="1" keyEquivalent="f" id="Xz5-n4-O0W">
                                            <connections>
                                                <action selector="performFindPanelAction:" target="-1" id="cD7-Qs-BN4"/>
                                            </connections>
                                        </menuItem>
                                        <menuItem title="Find and Replace…" tag="12" keyEquivalent="f" id="YEy-JH-Tfz">
                                            <modifierMask key="keyEquivalentModifierMask" option="YES" command="YES"/>
                                            <connections>
                                                <action selector="performFindPanelAction:" target="-1" id="WD3-Gg-5AJ"/>
                                            </connections>
                                        </menuItem>
                                        <menuItem title="Find Next" tag="2" keyEquivalent="g" id="q09-fT-Sye">
                                            <connections>
                                                <action selector="performFindPanelAction:" target="-1" id="NDo-RZ-v9R"/>
                                            </connections>
                                        </menuItem>
                                        <menuItem title="Find Previous" tag="3" keyEquivalent="G" id="OwM-mh-QMV">
                                            <connections>
                                                <action selector="performFindPanelAction:" target="-1" id="HOh-sY-3ay"/>
                                            </connections>
                                        </menuItem>
                                        <menuItem title="Use Selection for Find" tag="7" keyEquivalent="e" id="buJ-ug-pKt">
                                            <connections>
                                                <action selector="performFindPanelAction:" target="-1" id="U76-nv-p5D"/>
                                            </connections>
                                        </menuItem>
                                        <menuItem title="Jump to Selection" keyEquivalent="j" id="S0p-oC-mLd">
                                            <connections>
                                                <action selector="centerSelectionInVisibleArea:" target="-1" id="IOG-6D-g5B"/>
                                            </connections>
                                        </menuItem>
                                    </items>
                                </menu>
                            </menuItem>
                            <menuItem title="Spelling and Grammar" id="Dv1-io-Yv7">
                                <modifierMask key="keyEquivalentModifierMask"/>
                                <menu key="submenu" title="Spelling" id="3IN-sU-3Bg">
                                    <items>
                                        <menuItem title="Show Spelling and Grammar" keyEquivalent=":" id="HFo-cy-zxI">
                                            <connections>
                                                <action selector="showGuessPanel:" target="-1" id="vFj-Ks-hy3"/>
                                            </connections>
                                        </menuItem>
                                        <menuItem title="Check Document Now" keyEquivalent=";" id="hz2-CU-CR7">
                                            <connections>
                                                <action selector="checkSpelling:" target="-1" id="fz7-VC-reM"/>
                                            </connections>
                                        </menuItem>
                                        <menuItem isSeparatorItem="YES" id="bNw-od-mp5"/>
                                        <menuItem title="Check Spelling While Typing" id="rbD-Rh-wIN">
                                            <modifierMask key="keyEquivalentModifierMask"/>
                                            <connections>
                                                <action selector="toggleContinuousSpellChecking:" target="-1" id="7w6-Qz-0kB"/>
                                            </connections>
                                        </menuItem>
                                        <menuItem title="Check Grammar With Spelling" id="mK6-2p-4JG">
                                            <modifierMask key="keyEquivalentModifierMask"/>
                                            <connections>
                                                <action selector="toggleGrammarChecking:" target="-1" id="muD-Qn-j4w"/>
                                            </connections>
                                        </menuItem>
                                        <menuItem title="Correct Spelling Automatically" id="78Y-hA-62v">
                                            <modifierMask key="keyEquivalentModifierMask"/>
                                            <connections>
                                                <action selector="toggleAutomaticSpellingCorrection:" target="-1" id="2lM-Qi-WAP"/>
                                            </connections>
                                        </menuItem>
                                    </items>
                                </menu>
                            </menuItem>
                            <menuItem title="Substitutions" id="9ic-FL-obx">
                                <modifierMask key="keyEquivalentModifierMask"/>
                                <menu key="submenu" title="Substitutions" id="FeM-D8-WVr">
                                    <items>
                                        <menuItem title="Show Substitutions" id="z6F-FW-3nz">
                                            <modifierMask key="keyEquivalentModifierMask"/>
                                            <connections>
                                                <action selector="orderFrontSubstitutionsPanel:" target="-1" id="oku-mr-iSq"/>
                                            </connections>
                                        </menuItem>
                                        <menuItem isSeparatorItem="YES" id="gPx-C9-uUO"/>
                                        <menuItem title="Smart Copy/Paste" id="9yt-4B-nSM">
                                            <modifierMask key="keyEquivalentModifierMask"/>
                                            <connections>
                                                <action selector="toggleSmartInsertDelete:" target="-1" id="3IJ-Se-DZD"/>
                                            </connections>
                                        </menuItem>
                                        <menuItem title="Smart Quotes" id="hQb-2v-fYv">
                                            <modifierMask key="keyEquivalentModifierMask"/>
                                            <connections>
                                                <action selector="toggleAutomaticQuoteSubstitution:" target="-1" id="ptq-xd-QOA"/>
                                            </connections>
                                        </menuItem>
                                        <menuItem title="Smart Dashes" id="rgM-f4-ycn">
                                            <modifierMask key="keyEquivalentModifierMask"/>
                                            <connections>
                                                <action selector="toggleAutomaticDashSubstitution:" target="-1" id="oCt-pO-9gS"/>
                                            </connections>
                                        </menuItem>
                                        <menuItem title="Smart Links" id="cwL-P1-jid">
                                            <modifierMask key="keyEquivalentModifierMask"/>
                                            <connections>
                                                <action selector="toggleAutomaticLinkDetection:" target="-1" id="Gip-E3-Fov"/>
                                            </connections>
                                        </menuItem>
                                        <menuItem title="Data Detectors" id="tRr-pd-1PS">
                                            <modifierMask key="keyEquivalentModifierMask"/>
                                            <connections>
                                                <action selector="toggleAutomaticDataDetection:" target="-1" id="R1I-Nq-Kbl"/>
                                            </connections>
                                        </menuItem>
                                        <menuItem title="Text Replacement" id="HFQ-gK-NFA">
                                            <modifierMask key="keyEquivalentModifierMask"/>
                                            <connections>
                                                <action selector="toggleAutomaticTextReplacement:" target="-1" id="DvP-Fe-Py6"/>
                                            </connections>
                                        </menuItem>
                                    </items>
                                </menu>
                            </menuItem>
                            <menuItem title="Transformations" id="2oI-Rn-ZJC">
                                <modifierMask key="keyEquivalentModifierMask"/>
                                <menu key="submenu" title="Transformations" id="c8a-y6-VQd">
                                    <items>
                                        <menuItem title="Make Upper Case" id="vmV-6d-7jI">
                                            <modifierMask key="keyEquivalentModifierMask"/>
                                            <connections>
                                                <action selector="uppercaseWord:" target="-1" id="sPh-Tk-edu"/>
                                            </connections>
                                        </menuItem>
                                        <menuItem title="Make Lower Case" id="d9M-CD-aMd">
                                            <modifierMask key="keyEquivalentModifierMask"/>
                                            <connections>
                                                <action selector="lowercaseWord:" target="-1" id="iUZ-b5-hil"/>
                                            </connections>
                                        </menuItem>
                                        <menuItem title="Capitalize" id="UEZ-Bs-lqG">
                                            <modifierMask key="keyEquivalentModifierMask"/>
                                            <connections>
                                                <action selector="capitalizeWord:" target="-1" id="26H-TL-nsh"/>
                                            </connections>
                                        </menuItem>
                                    </items>
                                </menu>
                            </menuItem>
                            <menuItem title="Speech" id="xrE-MZ-jX0">
                                <modifierMask key="keyEquivalentModifierMask"/>
                                <menu key="submenu" title="Speech" id="3rS-ZA-NoH">
                                    <items>
                                        <menuItem title="Start Speaking" id="Ynk-f8-cLZ">
                                            <modifierMask key="keyEquivalentModifierMask"/>
                                            <connections>
                                                <action selector="startSpeaking:" target="-1" id="654-Ng-kyl"/>
                                            </connections>
                                        </menuItem>
                                        <menuItem title="Stop Speaking" id="Oyz-dy-DGm">
                                            <modifierMask key="keyEquivalentModifierMask"/>
                                            <connections>
                                                <action selector="stopSpeaking:" target="-1" id="dX8-6p-jy9"/>
                                            </connections>
                                        </menuItem>
                                    </items>
                                </menu>
                            </menuItem>
                        </items>
                    </menu>
                </menuItem>
                <menuItem title="View" id="H8h-7b-M4v">
                    <modifierMask key="keyEquivalentModifierMask"/>
                    <menu key="submenu" title="View" id="HyV-fh-RgO">
                        <items>
                            <menuItem title="Enter Full Screen" keyEquivalent="f" id="4J7-dP-txa">
                                <modifierMask key="keyEquivalentModifierMask" control="YES" command="YES"/>
                                <connections>
                                    <action selector="toggleFullScreen:" target="-1" id="dU3-MA-1Rq"/>
                                </connections>
                            </menuItem>
                        </items>
                    </menu>
                </menuItem>
                <menuItem title="Window" id="aUF-d1-5bR">
                    <modifierMask key="keyEquivalentModifierMask"/>
                    <menu key="submenu" title="Window" systemMenu="window" id="Td7-aD-5lo">
                        <items>
                            <menuItem title="Minimize" keyEquivalent="m" id="OY7-WF-poV">
                                <connections>
                                    <action selector="performMiniaturize:" target="-1" id="VwT-WD-YPe"/>
                                </connections>
                            </menuItem>
                            <menuItem title="Zoom" id="R4o-n2-Eq4">
                                <modifierMask key="keyEquivalentModifierMask"/>
                                <connections>
                                    <action selector="performZoom:" target="-1" id="DIl-cC-cCs"/>
                                </connections>
                            </menuItem>
                            <menuItem isSeparatorItem="YES" id="eu3-7i-yIM"/>
                            <menuItem title="Bring All to Front" id="LE2-aR-0XJ">
                                <modifierMask key="keyEquivalentModifierMask"/>
                                <connections>
                                    <action selector="arrangeInFront:" target="-1" id="DRN-fu-gQh"/>
                                </connections>
                            </menuItem>
                        </items>
                    </menu>
                </menuItem>
                <menuItem title="Help" id="EPT-qC-fAb">
                    <modifierMask key="keyEquivalentModifierMask"/>
                    <menu key="submenu" title="Help" systemMenu="help" id="rJ0-wn-3NY"/>
                </menuItem>
            </items>
            <point key="canvasLocation" x="142" y="-258"/>
        </menu>
        <window title="APP_NAME" allowsToolTipsWhenApplicationIsInactive="NO" autorecalculatesKeyViewLoop="NO" releasedWhenClosed="NO" animationBehavior="default" id="QvC-M9-y7g" customClass="MainFlutterWindow" customModule="Runner" customModuleProvider="target">
            <windowStyleMask key="styleMask" titled="YES" closable="YES" miniaturizable="YES" resizable="YES"/>
            <rect key="contentRect" x="335" y="390" width="800" height="600"/>
            <rect key="screenRect" x="0.0" y="0.0" width="2560" height="1577"/>
            <view key="contentView" wantsLayer="YES" id="EiT-Mj-1SZ">
                <rect key="frame" x="0.0" y="0.0" width="800" height="600"/>
                <autoresizingMask key="autoresizingMask"/>
            </view>
        </window>
    </objects>
</document>
````

## File: macos/Runner/Configs/AppInfo.xcconfig
````
// Application-level settings for the Runner target.
//
// This may be replaced with something auto-generated from metadata (e.g., pubspec.yaml) in the
// future. If not, the values below would default to using the project name when this becomes a
// 'flutter create' template.

// The application's name. By default this is also the title of the Flutter window.
PRODUCT_NAME = teacher_dashboard_flutter

// The application's bundle identifier
PRODUCT_BUNDLE_IDENTIFIER = com.teacherdashboard.teacherDashboardFlutter

// The copyright displayed in application information
PRODUCT_COPYRIGHT = Copyright © 2025 com.teacherdashboard. All rights reserved.
````

## File: macos/Runner/Configs/Debug.xcconfig
````
#include "../../Flutter/Flutter-Debug.xcconfig"
#include "Warnings.xcconfig"
````

## File: macos/Runner/Configs/Release.xcconfig
````
#include "../../Flutter/Flutter-Release.xcconfig"
#include "Warnings.xcconfig"
````

## File: macos/Runner/Configs/Warnings.xcconfig
````
WARNING_CFLAGS = -Wall -Wconditional-uninitialized -Wnullable-to-nonnull-conversion -Wmissing-method-return-type -Woverlength-strings
GCC_WARN_UNDECLARED_SELECTOR = YES
CLANG_UNDEFINED_BEHAVIOR_SANITIZER_NULLABILITY = YES
CLANG_WARN_UNGUARDED_AVAILABILITY = YES_AGGRESSIVE
CLANG_WARN__DUPLICATE_METHOD_MATCH = YES
CLANG_WARN_PRAGMA_PACK = YES
CLANG_WARN_STRICT_PROTOTYPES = YES
CLANG_WARN_COMMA = YES
GCC_WARN_STRICT_SELECTOR_MATCH = YES
CLANG_WARN_OBJC_REPEATED_USE_OF_WEAK = YES
CLANG_WARN_OBJC_IMPLICIT_RETAIN_SELF = YES
GCC_WARN_SHADOW = YES
CLANG_WARN_UNREACHABLE_CODE = YES
````

## File: macos/Runner/DebugProfile.entitlements
````
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>com.apple.security.app-sandbox</key>
	<true/>
	<key>com.apple.security.cs.allow-jit</key>
	<true/>
	<key>com.apple.security.network.server</key>
	<true/>
</dict>
</plist>
````

## File: macos/Runner/Info.plist
````
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>CFBundleDevelopmentRegion</key>
	<string>$(DEVELOPMENT_LANGUAGE)</string>
	<key>CFBundleExecutable</key>
	<string>$(EXECUTABLE_NAME)</string>
	<key>CFBundleIconFile</key>
	<string></string>
	<key>CFBundleIdentifier</key>
	<string>$(PRODUCT_BUNDLE_IDENTIFIER)</string>
	<key>CFBundleInfoDictionaryVersion</key>
	<string>6.0</string>
	<key>CFBundleName</key>
	<string>$(PRODUCT_NAME)</string>
	<key>CFBundlePackageType</key>
	<string>APPL</string>
	<key>CFBundleShortVersionString</key>
	<string>$(FLUTTER_BUILD_NAME)</string>
	<key>CFBundleVersion</key>
	<string>$(FLUTTER_BUILD_NUMBER)</string>
	<key>LSMinimumSystemVersion</key>
	<string>$(MACOSX_DEPLOYMENT_TARGET)</string>
	<key>NSHumanReadableCopyright</key>
	<string>$(PRODUCT_COPYRIGHT)</string>
	<key>NSMainNibFile</key>
	<string>MainMenu</string>
	<key>NSPrincipalClass</key>
	<string>NSApplication</string>
</dict>
</plist>
````

## File: macos/Runner/MainFlutterWindow.swift
````swift
import Cocoa
import FlutterMacOS

class MainFlutterWindow: NSWindow {
  override func awakeFromNib() {
    let flutterViewController = FlutterViewController()
    let windowFrame = self.frame
    self.contentViewController = flutterViewController
    self.setFrame(windowFrame, display: true)

    RegisterGeneratedPlugins(registry: flutterViewController)

    super.awakeFromNib()
  }
}
````

## File: macos/Runner/Release.entitlements
````
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>com.apple.security.app-sandbox</key>
	<true/>
</dict>
</plist>
````

## File: macos/RunnerTests/RunnerTests.swift
````swift
import Cocoa
import FlutterMacOS
import XCTest

class RunnerTests: XCTestCase {

  func testExample() {
    // If you add code to the Runner application, consider adding tests here.
    // See https://developer.apple.com/documentation/xctest for more information about using XCTest.
  }

}
````

## File: qodana.yaml
````yaml
version: "1.0"
linter: jetbrains/qodana-jvm:2025.1
profile:
  name: qodana.recommended
include:
  - name: CheckDependencyLicenses
````

## File: scripts/fetch_secrets.ps1
````powershell
# PowerShell script to fetch secrets from Google Secret Manager for development
# Usage: .\scripts\fetch_secrets.ps1

param(
    [string]$ProjectId = "your-gcp-project-id",
    [string]$EnvFile = ".env.local"
)

# Check if gcloud is installed
if (!(Get-Command gcloud -ErrorAction SilentlyContinue)) {
    Write-Error "Google Cloud SDK is not installed. Please install it first."
    Write-Host "Download from: https://cloud.google.com/sdk/docs/install"
    exit 1
}

# Check if authenticated
$authList = gcloud auth list --format="value(account)" 2>$null
if (!$authList) {
    Write-Host "Not authenticated. Running 'gcloud auth login'..."
    gcloud auth login
}

# Set the project
Write-Host "Setting project to: $ProjectId"
gcloud config set project $ProjectId

# List of secrets to fetch
$secrets = @(
    "firebase-api-key",
    "firebase-auth-domain",
    "firebase-project-id",
    "firebase-storage-bucket",
    "firebase-messaging-sender-id",
    "firebase-app-id",
    "firebase-measurement-id",
    "google-web-client-id"
)

# Create or clear the env file
"# Auto-generated from Google Secret Manager" | Out-File -FilePath $EnvFile -Encoding UTF8
"# Generated on: $(Get-Date)" | Out-File -FilePath $EnvFile -Append -Encoding UTF8
"" | Out-File -FilePath $EnvFile -Append -Encoding UTF8

# Fetch each secret
foreach ($secret in $secrets) {
    Write-Host "Fetching secret: $secret"
    try {
        $value = gcloud secrets versions access latest --secret=$secret 2>$null
        if ($LASTEXITCODE -eq 0) {
            $envVarName = $secret.ToUpper().Replace("-", "_")
            "$envVarName=$value" | Out-File -FilePath $EnvFile -Append -Encoding UTF8
            Write-Host "[OK] Successfully fetched $secret" -ForegroundColor Green
        } else {
            Write-Host "[!] Secret '$secret' not found" -ForegroundColor Yellow
        }
    } catch {
        Write-Host "X Error fetching ${secret}: $_" -ForegroundColor Red
    }
}

Write-Host "`nSecrets have been written to: $EnvFile" -ForegroundColor Cyan
Write-Host "Remember to add $EnvFile to your .gitignore!" -ForegroundColor Yellow
````

## File: scripts/fetch_secrets.sh
````bash
#!/bin/bash
# Bash script to fetch secrets from Google Secret Manager for development
# Usage: ./scripts/fetch_secrets.sh

PROJECT_ID="${1:-your-gcp-project-id}"
ENV_FILE="${2:-.env.local}"

# Check if gcloud is installed
if ! command -v gcloud &> /dev/null; then
    echo "Error: Google Cloud SDK is not installed. Please install it first."
    echo "Visit: https://cloud.google.com/sdk/docs/install"
    exit 1
fi

# Check if authenticated
if ! gcloud auth list --format="value(account)" &> /dev/null; then
    echo "Not authenticated. Running 'gcloud auth login'..."
    gcloud auth login
fi

# Set the project
echo "Setting project to: $PROJECT_ID"
gcloud config set project "$PROJECT_ID"

# List of secrets to fetch
secrets=(
    "firebase-api-key"
    "firebase-auth-domain"
    "firebase-project-id"
    "firebase-storage-bucket"
    "firebase-messaging-sender-id"
    "firebase-app-id"
    "firebase-measurement-id"
    "google-web-client-id"
)

# Create or clear the env file
cat > "$ENV_FILE" << EOF
# Auto-generated from Google Secret Manager
# Generated on: $(date)

EOF

# Fetch each secret
for secret in "${secrets[@]}"; do
    echo "Fetching secret: $secret"
    if value=$(gcloud secrets versions access latest --secret="$secret" 2>/dev/null); then
        env_var_name=$(echo "$secret" | tr '[:lower:]-' '[:upper:]_')
        echo "${env_var_name}=${value}" >> "$ENV_FILE"
        echo "✓ Successfully fetched $secret"
    else
        echo "✗ Secret '$secret' not found"
    fi
done

echo -e "\nSecrets have been written to: $ENV_FILE"
echo "Remember to add $ENV_FILE to your .gitignore!"
````

## File: scripts/setup_secrets.ps1
````powershell
# PowerShell script to set up secrets in Google Secret Manager
# Usage: .\scripts\setup_secrets.ps1 -ProjectId "your-project-id"

param(
    [Parameter(Mandatory=$true)]
    [string]$ProjectId
)

Write-Host "Setting up Google Cloud Secret Manager for project: $ProjectId" -ForegroundColor Cyan

# Enable Secret Manager API
Write-Host "`nEnabling Secret Manager API..." -ForegroundColor Yellow
& gcloud services enable secretmanager.googleapis.com --project=$ProjectId

# Function to create or update a secret
function Set-GCPSecret {
    param(
        [string]$SecretName,
        [string]$SecretValue
    )
    
    Write-Host "`nCreating/updating secret: $SecretName" -ForegroundColor Yellow
    
    # Check if secret exists
    $exists = & gcloud secrets describe $SecretName --project=$ProjectId 2>$null
    
    if ($LASTEXITCODE -eq 0) {
        # Secret exists, create new version
        $SecretValue | & gcloud secrets versions add $SecretName --data-file=- --project=$ProjectId
        Write-Host "[OK] Updated secret: $SecretName" -ForegroundColor Green
    } else {
        # Create new secret
        & gcloud secrets create $SecretName --project=$ProjectId --replication-policy="automatic"
        $SecretValue | & gcloud secrets versions add $SecretName --data-file=- --project=$ProjectId
        Write-Host "[OK] Created secret: $SecretName" -ForegroundColor Green
    }
}

# Read current .env file if it exists
$envFile = ".env"
if (Test-Path $envFile) {
    Write-Host "`nReading existing .env file..." -ForegroundColor Yellow
    $envContent = Get-Content $envFile
    
    foreach ($line in $envContent) {
        if ($line -match "^([A-Z_]+)=(.+)$") {
            $key = $matches[1]
            $value = $matches[2]
            
            # Convert env var name to secret name (FIREBASE_API_KEY -> firebase-api-key)
            $secretName = $key.ToLower().Replace("_", "-")
            
            Set-GCPSecret -SecretName $secretName -SecretValue $value
        }
    }
} else {
    Write-Host "`nNo .env file found. Let's create secrets manually:" -ForegroundColor Yellow
    Write-Host "Example: Set-GCPSecret -SecretName 'firebase-api-key' -SecretValue 'your-api-key-here'"
}

Write-Host "`nSecret Manager setup complete!" -ForegroundColor Green
Write-Host "You can now use .\scripts\fetch_secrets.ps1 to fetch these secrets for local development." -ForegroundColor Cyan
````

## File: sonar-project.properties
````
sonar.projectKey=Sallvainian_teacher-dashboard-flutter-firebase
sonar.organization=sallvainian

# This is the name and version displayed in the SonarCloud UI.
sonar.projectName=teacher-dashboard-flutter-firebase
sonar.projectVersion=1.0

# Path is relative to the sonar-project.properties file. Replace "\" by "/" on Windows.
sonar.sources=lib
sonar.tests=test

# Flutter/Dart specific settings
sonar.dart.file.suffixes=.dart
sonar.exclusions=**/*.g.dart,**/*.freezed.dart,**/*.mocks.dart,**/generated/**,**/build/**

# Test coverage
sonar.dart.coverage.reportPaths=coverage/lcov.info

# Encoding of the source code. Default is default system encoding
sonar.sourceEncoding=UTF-8
````

## File: tools/README.md
````markdown
# Tools Directory

This directory contains utility scripts and test programs that are not part of the main application.

## Contents

- `test_db_simple.dart` - Simple Firebase database connection test
- `test_db_direct.dart` - Direct Firebase database access test  
- `setup_test_data.dart` - Script to populate Firebase with test data

## Usage

These are standalone Dart programs that can be run directly:

```bash
dart run tools/setup_test_data.dart
```

**Note**: These scripts require proper Firebase configuration and credentials to run.
````

## File: web/manifest.json
````json
{
    "name": "teacher_dashboard_flutter",
    "short_name": "teacher_dashboard_flutter",
    "start_url": ".",
    "display": "standalone",
    "background_color": "#0175C2",
    "theme_color": "#0175C2",
    "description": "A new Flutter project.",
    "orientation": "portrait-primary",
    "prefer_related_applications": false,
    "icons": [
        {
            "src": "icons/Icon-192.png",
            "sizes": "192x192",
            "type": "image/png"
        },
        {
            "src": "icons/Icon-512.png",
            "sizes": "512x512",
            "type": "image/png"
        },
        {
            "src": "icons/Icon-maskable-192.png",
            "sizes": "192x192",
            "type": "image/png",
            "purpose": "maskable"
        },
        {
            "src": "icons/Icon-maskable-512.png",
            "sizes": "512x512",
            "type": "image/png",
            "purpose": "maskable"
        }
    ]
}
````

## File: web/web_server_config.md
````markdown
# Web Server Configuration for Teacher Dashboard

## For Development (flutter run -d web-server)

The Flutter development server doesn't support custom headers. The console warnings you see are mostly informational and don't affect functionality:

- `developer_patch.dart:96` - Normal in development, goes away in production builds
- `-ms-high-contrast` deprecation - Browser warning, not from your code
- `GSI_LOGGER` messages - Normal Google Sign-In logging
- `Tracking Prevention` - Browser privacy feature, use Incognito mode or adjust browser settings
- `Cross-Origin-Opener-Policy` - Google's OAuth popup handling, not blocking functionality

## For Production Deployment

If deploying to a server that supports headers (Apache, Nginx, Firebase Hosting), add these:

### Apache (.htaccess)
```apache
Header set Cross-Origin-Opener-Policy "same-origin-allow-popups"
Header set X-Content-Type-Options "nosniff"
Header set X-Frame-Options "SAMEORIGIN"
```

### Nginx
```nginx
add_header Cross-Origin-Opener-Policy "same-origin-allow-popups";
add_header X-Content-Type-Options "nosniff";
add_header X-Frame-Options "SAMEORIGIN";
```

### Firebase Hosting (firebase.json)
```json
{
  "hosting": {
    "headers": [{
      "source": "**",
      "headers": [{
        "key": "Cross-Origin-Opener-Policy",
        "value": "same-origin-allow-popups"
      }]
    }]
  }
}
```

## Browser Settings for Development

To reduce tracking prevention warnings during development:
1. Use Chrome instead of Edge
2. Or in Edge: Settings > Privacy > Tracking prevention > Set to "Basic" or turn off
3. Or use InPrivate/Incognito mode

## Summary

These console warnings are **normal in development** and don't indicate actual problems with your code. They come from:
- Flutter's development mode
- Browser security features
- Third-party libraries (Google Sign-In)

Your authentication is working correctly despite these warnings.
````

## File: windows/.gitignore
````
flutter/ephemeral/

# Visual Studio user-specific files.
*.suo
*.user
*.userosscache
*.sln.docstates

# Visual Studio build-related files.
x64/
x86/

# Visual Studio cache files
# files ending in .cache can be ignored
*.[Cc]ache
# but keep track of directories ending in .cache
!*.[Cc]ache/
````

## File: windows/flutter/generated_plugin_registrant.cc
````
//
//  Generated file. Do not edit.
//

// clang-format off

#include "generated_plugin_registrant.h"

#include <cloud_firestore/cloud_firestore_plugin_c_api.h>
#include <file_selector_windows/file_selector_windows.h>
#include <firebase_auth/firebase_auth_plugin_c_api.h>
#include <firebase_core/firebase_core_plugin_c_api.h>
#include <firebase_storage/firebase_storage_plugin_c_api.h>
#include <flutter_webrtc/flutter_web_r_t_c_plugin.h>
#include <permission_handler_windows/permission_handler_windows_plugin.h>

void RegisterPlugins(flutter::PluginRegistry* registry) {
  CloudFirestorePluginCApiRegisterWithRegistrar(
      registry->GetRegistrarForPlugin("CloudFirestorePluginCApi"));
  FileSelectorWindowsRegisterWithRegistrar(
      registry->GetRegistrarForPlugin("FileSelectorWindows"));
  FirebaseAuthPluginCApiRegisterWithRegistrar(
      registry->GetRegistrarForPlugin("FirebaseAuthPluginCApi"));
  FirebaseCorePluginCApiRegisterWithRegistrar(
      registry->GetRegistrarForPlugin("FirebaseCorePluginCApi"));
  FirebaseStoragePluginCApiRegisterWithRegistrar(
      registry->GetRegistrarForPlugin("FirebaseStoragePluginCApi"));
  FlutterWebRTCPluginRegisterWithRegistrar(
      registry->GetRegistrarForPlugin("FlutterWebRTCPlugin"));
  PermissionHandlerWindowsPluginRegisterWithRegistrar(
      registry->GetRegistrarForPlugin("PermissionHandlerWindowsPlugin"));
}
````

## File: windows/flutter/generated_plugin_registrant.h
````
//
//  Generated file. Do not edit.
//

// clang-format off

#ifndef GENERATED_PLUGIN_REGISTRANT_
#define GENERATED_PLUGIN_REGISTRANT_

#include <flutter/plugin_registry.h>

// Registers Flutter plugins.
void RegisterPlugins(flutter::PluginRegistry* registry);

#endif  // GENERATED_PLUGIN_REGISTRANT_
````

## File: windows/runner/CMakeLists.txt
````
cmake_minimum_required(VERSION 3.14)
project(runner LANGUAGES CXX)

# Define the application target. To change its name, change BINARY_NAME in the
# top-level CMakeLists.txt, not the value here, or `flutter run` will no longer
# work.
#
# Any new source files that you add to the application should be added here.
add_executable(${BINARY_NAME} WIN32
  "flutter_window.cpp"
  "main.cpp"
  "utils.cpp"
  "win32_window.cpp"
  "${FLUTTER_MANAGED_DIR}/generated_plugin_registrant.cc"
  "Runner.rc"
  "runner.exe.manifest"
)

# Apply the standard set of build settings. This can be removed for applications
# that need different build settings.
apply_standard_settings(${BINARY_NAME})

# Add preprocessor definitions for the build version.
target_compile_definitions(${BINARY_NAME} PRIVATE "FLUTTER_VERSION=\"${FLUTTER_VERSION}\"")
target_compile_definitions(${BINARY_NAME} PRIVATE "FLUTTER_VERSION_MAJOR=${FLUTTER_VERSION_MAJOR}")
target_compile_definitions(${BINARY_NAME} PRIVATE "FLUTTER_VERSION_MINOR=${FLUTTER_VERSION_MINOR}")
target_compile_definitions(${BINARY_NAME} PRIVATE "FLUTTER_VERSION_PATCH=${FLUTTER_VERSION_PATCH}")
target_compile_definitions(${BINARY_NAME} PRIVATE "FLUTTER_VERSION_BUILD=${FLUTTER_VERSION_BUILD}")

# Disable Windows macros that collide with C++ standard library functions.
target_compile_definitions(${BINARY_NAME} PRIVATE "NOMINMAX")

# Add dependency libraries and include directories. Add any application-specific
# dependencies here.
target_link_libraries(${BINARY_NAME} PRIVATE flutter flutter_wrapper_app)
target_link_libraries(${BINARY_NAME} PRIVATE "dwmapi.lib")
target_include_directories(${BINARY_NAME} PRIVATE "${CMAKE_SOURCE_DIR}")

# Run the Flutter tool portions of the build. This must not be removed.
add_dependencies(${BINARY_NAME} flutter_assemble)
````

## File: windows/runner/flutter_window.cpp
````cpp
#include "flutter_window.h"

#include <optional>

#include "flutter/generated_plugin_registrant.h"

FlutterWindow::FlutterWindow(const flutter::DartProject& project)
    : project_(project) {}

FlutterWindow::~FlutterWindow() {}

bool FlutterWindow::OnCreate() {
  if (!Win32Window::OnCreate()) {
    return false;
  }

  RECT frame = GetClientArea();

  // The size here must match the window dimensions to avoid unnecessary surface
  // creation / destruction in the startup path.
  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(
      frame.right - frame.left, frame.bottom - frame.top, project_);
  // Ensure that basic setup of the controller was successful.
  if (!flutter_controller_->engine() || !flutter_controller_->view()) {
    return false;
  }
  RegisterPlugins(flutter_controller_->engine());
  SetChildContent(flutter_controller_->view()->GetNativeWindow());

  flutter_controller_->engine()->SetNextFrameCallback([&]() {
    this->Show();
  });

  // Flutter can complete the first frame before the "show window" callback is
  // registered. The following call ensures a frame is pending to ensure the
  // window is shown. It is a no-op if the first frame hasn't completed yet.
  flutter_controller_->ForceRedraw();

  return true;
}

void FlutterWindow::OnDestroy() {
  if (flutter_controller_) {
    flutter_controller_ = nullptr;
  }

  Win32Window::OnDestroy();
}

LRESULT
FlutterWindow::MessageHandler(HWND hwnd, UINT const message,
                              WPARAM const wparam,
                              LPARAM const lparam) noexcept {
  // Give Flutter, including plugins, an opportunity to handle window messages.
  if (flutter_controller_) {
    std::optional<LRESULT> result =
        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,
                                                      lparam);
    if (result) {
      return *result;
    }
  }

  switch (message) {
    case WM_FONTCHANGE:
      flutter_controller_->engine()->ReloadSystemFonts();
      break;
  }

  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);
}
````

## File: windows/runner/flutter_window.h
````
#ifndef RUNNER_FLUTTER_WINDOW_H_
#define RUNNER_FLUTTER_WINDOW_H_

#include <flutter/dart_project.h>
#include <flutter/flutter_view_controller.h>

#include <memory>

#include "win32_window.h"

// A window that does nothing but host a Flutter view.
class FlutterWindow : public Win32Window {
 public:
  // Creates a new FlutterWindow hosting a Flutter view running |project|.
  explicit FlutterWindow(const flutter::DartProject& project);
  virtual ~FlutterWindow();

 protected:
  // Win32Window:
  bool OnCreate() override;
  void OnDestroy() override;
  LRESULT MessageHandler(HWND window, UINT const message, WPARAM const wparam,
                         LPARAM const lparam) noexcept override;

 private:
  // The project to run.
  flutter::DartProject project_;

  // The Flutter instance hosted by this window.
  std::unique_ptr<flutter::FlutterViewController> flutter_controller_;
};

#endif  // RUNNER_FLUTTER_WINDOW_H_
````

## File: windows/runner/main.cpp
````cpp
#include <flutter/dart_project.h>
#include <flutter/flutter_view_controller.h>
#include <windows.h>

#include "flutter_window.h"
#include "utils.h"

int APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,
                      _In_ wchar_t *command_line, _In_ int show_command) {
  // Attach to console when present (e.g., 'flutter run') or create a
  // new console when running with a debugger.
  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {
    CreateAndAttachConsole();
  }

  // Initialize COM, so that it is available for use in the library and/or
  // plugins.
  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);

  flutter::DartProject project(L"data");

  std::vector<std::string> command_line_arguments =
      GetCommandLineArguments();

  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));

  FlutterWindow window(project);
  Win32Window::Point origin(10, 10);
  Win32Window::Size size(1280, 720);
  if (!window.Create(L"teacher_dashboard_flutter", origin, size)) {
    return EXIT_FAILURE;
  }
  window.SetQuitOnClose(true);

  ::MSG msg;
  while (::GetMessage(&msg, nullptr, 0, 0)) {
    ::TranslateMessage(&msg);
    ::DispatchMessage(&msg);
  }

  ::CoUninitialize();
  return EXIT_SUCCESS;
}
````

## File: windows/runner/resource.h
````
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by Runner.rc
//
#define IDI_APP_ICON                    101

// Next default values for new objects
//
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        102
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1001
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
````

## File: windows/runner/runner.exe.manifest
````
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<assembly xmlns="urn:schemas-microsoft-com:asm.v1" manifestVersion="1.0">
  <application xmlns="urn:schemas-microsoft-com:asm.v3">
    <windowsSettings>
      <dpiAwareness xmlns="http://schemas.microsoft.com/SMI/2016/WindowsSettings">PerMonitorV2</dpiAwareness>
    </windowsSettings>
  </application>
  <compatibility xmlns="urn:schemas-microsoft-com:compatibility.v1">
    <application>
      <!-- Windows 10 and Windows 11 -->
      <supportedOS Id="{8e0f7a12-bfb3-4fe8-b9a5-48fd50a15a9a}"/>
    </application>
  </compatibility>
</assembly>
````

## File: windows/runner/Runner.rc
````
// Microsoft Visual C++ generated resource script.
//
#pragma code_page(65001)
#include "resource.h"

#define APSTUDIO_READONLY_SYMBOLS
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 2 resource.
//
#include "winres.h"

/////////////////////////////////////////////////////////////////////////////
#undef APSTUDIO_READONLY_SYMBOLS

/////////////////////////////////////////////////////////////////////////////
// English (United States) resources

#if !defined(AFX_RESOURCE_DLL) || defined(AFX_TARG_ENU)
LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US

#ifdef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// TEXTINCLUDE
//

1 TEXTINCLUDE
BEGIN
    "resource.h\0"
END

2 TEXTINCLUDE
BEGIN
    "#include ""winres.h""\r\n"
    "\0"
END

3 TEXTINCLUDE
BEGIN
    "\r\n"
    "\0"
END

#endif    // APSTUDIO_INVOKED


/////////////////////////////////////////////////////////////////////////////
//
// Icon
//

// Icon with lowest ID value placed first to ensure application icon
// remains consistent on all systems.
IDI_APP_ICON            ICON                    "resources\\app_icon.ico"


/////////////////////////////////////////////////////////////////////////////
//
// Version
//

#if defined(FLUTTER_VERSION_MAJOR) && defined(FLUTTER_VERSION_MINOR) && defined(FLUTTER_VERSION_PATCH) && defined(FLUTTER_VERSION_BUILD)
#define VERSION_AS_NUMBER FLUTTER_VERSION_MAJOR,FLUTTER_VERSION_MINOR,FLUTTER_VERSION_PATCH,FLUTTER_VERSION_BUILD
#else
#define VERSION_AS_NUMBER 1,0,0,0
#endif

#if defined(FLUTTER_VERSION)
#define VERSION_AS_STRING FLUTTER_VERSION
#else
#define VERSION_AS_STRING "1.0.0"
#endif

VS_VERSION_INFO VERSIONINFO
 FILEVERSION VERSION_AS_NUMBER
 PRODUCTVERSION VERSION_AS_NUMBER
 FILEFLAGSMASK VS_FFI_FILEFLAGSMASK
#ifdef _DEBUG
 FILEFLAGS VS_FF_DEBUG
#else
 FILEFLAGS 0x0L
#endif
 FILEOS VOS__WINDOWS32
 FILETYPE VFT_APP
 FILESUBTYPE 0x0L
BEGIN
    BLOCK "StringFileInfo"
    BEGIN
        BLOCK "040904e4"
        BEGIN
            VALUE "CompanyName", "com.teacherdashboard" "\0"
            VALUE "FileDescription", "teacher_dashboard_flutter" "\0"
            VALUE "FileVersion", VERSION_AS_STRING "\0"
            VALUE "InternalName", "teacher_dashboard_flutter" "\0"
            VALUE "LegalCopyright", "Copyright (C) 2025 com.teacherdashboard. All rights reserved." "\0"
            VALUE "OriginalFilename", "teacher_dashboard_flutter.exe" "\0"
            VALUE "ProductName", "teacher_dashboard_flutter" "\0"
            VALUE "ProductVersion", VERSION_AS_STRING "\0"
        END
    END
    BLOCK "VarFileInfo"
    BEGIN
        VALUE "Translation", 0x409, 1252
    END
END

#endif    // English (United States) resources
/////////////////////////////////////////////////////////////////////////////



#ifndef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 3 resource.
//


/////////////////////////////////////////////////////////////////////////////
#endif    // not APSTUDIO_INVOKED
````

## File: windows/runner/utils.cpp
````cpp
#include "utils.h"

#include <flutter_windows.h>
#include <io.h>
#include <stdio.h>
#include <windows.h>

#include <iostream>

void CreateAndAttachConsole() {
  if (::AllocConsole()) {
    FILE *unused;
    if (freopen_s(&unused, "CONOUT$", "w", stdout)) {
      _dup2(_fileno(stdout), 1);
    }
    if (freopen_s(&unused, "CONOUT$", "w", stderr)) {
      _dup2(_fileno(stdout), 2);
    }
    std::ios::sync_with_stdio();
    FlutterDesktopResyncOutputStreams();
  }
}

std::vector<std::string> GetCommandLineArguments() {
  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.
  int argc;
  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);
  if (argv == nullptr) {
    return std::vector<std::string>();
  }

  std::vector<std::string> command_line_arguments;

  // Skip the first argument as it's the binary name.
  for (int i = 1; i < argc; i++) {
    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));
  }

  ::LocalFree(argv);

  return command_line_arguments;
}

std::string Utf8FromUtf16(const wchar_t* utf16_string) {
  if (utf16_string == nullptr) {
    return std::string();
  }
  unsigned int target_length = ::WideCharToMultiByte(
      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,
      -1, nullptr, 0, nullptr, nullptr)
    -1; // remove the trailing null character
  int input_length = (int)wcslen(utf16_string);
  std::string utf8_string;
  if (target_length == 0 || target_length > utf8_string.max_size()) {
    return utf8_string;
  }
  utf8_string.resize(target_length);
  int converted_length = ::WideCharToMultiByte(
      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,
      input_length, utf8_string.data(), target_length, nullptr, nullptr);
  if (converted_length == 0) {
    return std::string();
  }
  return utf8_string;
}
````

## File: windows/runner/utils.h
````
#ifndef RUNNER_UTILS_H_
#define RUNNER_UTILS_H_

#include <string>
#include <vector>

// Creates a console for the process, and redirects stdout and stderr to
// it for both the runner and the Flutter library.
void CreateAndAttachConsole();

// Takes a null-terminated wchar_t* encoded in UTF-16 and returns a std::string
// encoded in UTF-8. Returns an empty std::string on failure.
std::string Utf8FromUtf16(const wchar_t* utf16_string);

// Gets the command line arguments passed in as a std::vector<std::string>,
// encoded in UTF-8. Returns an empty std::vector<std::string> on failure.
std::vector<std::string> GetCommandLineArguments();

#endif  // RUNNER_UTILS_H_
````

## File: windows/runner/win32_window.cpp
````cpp
#include "win32_window.h"

#include <dwmapi.h>
#include <flutter_windows.h>

#include "resource.h"

namespace {

/// Window attribute that enables dark mode window decorations.
///
/// Redefined in case the developer's machine has a Windows SDK older than
/// version 10.0.22000.0.
/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute
#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE
#define DWMWA_USE_IMMERSIVE_DARK_MODE 20
#endif

constexpr const wchar_t kWindowClassName[] = L"FLUTTER_RUNNER_WIN32_WINDOW";

/// Registry key for app theme preference.
///
/// A value of 0 indicates apps should use dark mode. A non-zero or missing
/// value indicates apps should use light mode.
constexpr const wchar_t kGetPreferredBrightnessRegKey[] =
  L"Software\\Microsoft\\Windows\\CurrentVersion\\Themes\\Personalize";
constexpr const wchar_t kGetPreferredBrightnessRegValue[] = L"AppsUseLightTheme";

// The number of Win32Window objects that currently exist.
static int g_active_window_count = 0;

using EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);

// Scale helper to convert logical scaler values to physical using passed in
// scale factor
int Scale(int source, double scale_factor) {
  return static_cast<int>(source * scale_factor);
}

// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.
// This API is only needed for PerMonitor V1 awareness mode.
void EnableFullDpiSupportIfAvailable(HWND hwnd) {
  HMODULE user32_module = LoadLibraryA("User32.dll");
  if (!user32_module) {
    return;
  }
  auto enable_non_client_dpi_scaling =
      reinterpret_cast<EnableNonClientDpiScaling*>(
          GetProcAddress(user32_module, "EnableNonClientDpiScaling"));
  if (enable_non_client_dpi_scaling != nullptr) {
    enable_non_client_dpi_scaling(hwnd);
  }
  FreeLibrary(user32_module);
}

}  // namespace

// Manages the Win32Window's window class registration.
class WindowClassRegistrar {
 public:
  ~WindowClassRegistrar() = default;

  // Returns the singleton registrar instance.
  static WindowClassRegistrar* GetInstance() {
    if (!instance_) {
      instance_ = new WindowClassRegistrar();
    }
    return instance_;
  }

  // Returns the name of the window class, registering the class if it hasn't
  // previously been registered.
  const wchar_t* GetWindowClass();

  // Unregisters the window class. Should only be called if there are no
  // instances of the window.
  void UnregisterWindowClass();

 private:
  WindowClassRegistrar() = default;

  static WindowClassRegistrar* instance_;

  bool class_registered_ = false;
};

WindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;

const wchar_t* WindowClassRegistrar::GetWindowClass() {
  if (!class_registered_) {
    WNDCLASS window_class{};
    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);
    window_class.lpszClassName = kWindowClassName;
    window_class.style = CS_HREDRAW | CS_VREDRAW;
    window_class.cbClsExtra = 0;
    window_class.cbWndExtra = 0;
    window_class.hInstance = GetModuleHandle(nullptr);
    window_class.hIcon =
        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));
    window_class.hbrBackground = 0;
    window_class.lpszMenuName = nullptr;
    window_class.lpfnWndProc = Win32Window::WndProc;
    RegisterClass(&window_class);
    class_registered_ = true;
  }
  return kWindowClassName;
}

void WindowClassRegistrar::UnregisterWindowClass() {
  UnregisterClass(kWindowClassName, nullptr);
  class_registered_ = false;
}

Win32Window::Win32Window() {
  ++g_active_window_count;
}

Win32Window::~Win32Window() {
  --g_active_window_count;
  Destroy();
}

bool Win32Window::Create(const std::wstring& title,
                         const Point& origin,
                         const Size& size) {
  Destroy();

  const wchar_t* window_class =
      WindowClassRegistrar::GetInstance()->GetWindowClass();

  const POINT target_point = {static_cast<LONG>(origin.x),
                              static_cast<LONG>(origin.y)};
  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);
  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);
  double scale_factor = dpi / 96.0;

  HWND window = CreateWindow(
      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,
      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),
      Scale(size.width, scale_factor), Scale(size.height, scale_factor),
      nullptr, nullptr, GetModuleHandle(nullptr), this);

  if (!window) {
    return false;
  }

  UpdateTheme(window);

  return OnCreate();
}

bool Win32Window::Show() {
  return ShowWindow(window_handle_, SW_SHOWNORMAL);
}

// static
LRESULT CALLBACK Win32Window::WndProc(HWND const window,
                                      UINT const message,
                                      WPARAM const wparam,
                                      LPARAM const lparam) noexcept {
  if (message == WM_NCCREATE) {
    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);
    SetWindowLongPtr(window, GWLP_USERDATA,
                     reinterpret_cast<LONG_PTR>(window_struct->lpCreateParams));

    auto that = static_cast<Win32Window*>(window_struct->lpCreateParams);
    EnableFullDpiSupportIfAvailable(window);
    that->window_handle_ = window;
  } else if (Win32Window* that = GetThisFromHandle(window)) {
    return that->MessageHandler(window, message, wparam, lparam);
  }

  return DefWindowProc(window, message, wparam, lparam);
}

LRESULT
Win32Window::MessageHandler(HWND hwnd,
                            UINT const message,
                            WPARAM const wparam,
                            LPARAM const lparam) noexcept {
  switch (message) {
    case WM_DESTROY:
      window_handle_ = nullptr;
      Destroy();
      if (quit_on_close_) {
        PostQuitMessage(0);
      }
      return 0;

    case WM_DPICHANGED: {
      auto newRectSize = reinterpret_cast<RECT*>(lparam);
      LONG newWidth = newRectSize->right - newRectSize->left;
      LONG newHeight = newRectSize->bottom - newRectSize->top;

      SetWindowPos(hwnd, nullptr, newRectSize->left, newRectSize->top, newWidth,
                   newHeight, SWP_NOZORDER | SWP_NOACTIVATE);

      return 0;
    }
    case WM_SIZE: {
      RECT rect = GetClientArea();
      if (child_content_ != nullptr) {
        // Size and position the child window.
        MoveWindow(child_content_, rect.left, rect.top, rect.right - rect.left,
                   rect.bottom - rect.top, TRUE);
      }
      return 0;
    }

    case WM_ACTIVATE:
      if (child_content_ != nullptr) {
        SetFocus(child_content_);
      }
      return 0;

    case WM_DWMCOLORIZATIONCOLORCHANGED:
      UpdateTheme(hwnd);
      return 0;
  }

  return DefWindowProc(window_handle_, message, wparam, lparam);
}

void Win32Window::Destroy() {
  OnDestroy();

  if (window_handle_) {
    DestroyWindow(window_handle_);
    window_handle_ = nullptr;
  }
  if (g_active_window_count == 0) {
    WindowClassRegistrar::GetInstance()->UnregisterWindowClass();
  }
}

Win32Window* Win32Window::GetThisFromHandle(HWND const window) noexcept {
  return reinterpret_cast<Win32Window*>(
      GetWindowLongPtr(window, GWLP_USERDATA));
}

void Win32Window::SetChildContent(HWND content) {
  child_content_ = content;
  SetParent(content, window_handle_);
  RECT frame = GetClientArea();

  MoveWindow(content, frame.left, frame.top, frame.right - frame.left,
             frame.bottom - frame.top, true);

  SetFocus(child_content_);
}

RECT Win32Window::GetClientArea() {
  RECT frame;
  GetClientRect(window_handle_, &frame);
  return frame;
}

HWND Win32Window::GetHandle() {
  return window_handle_;
}

void Win32Window::SetQuitOnClose(bool quit_on_close) {
  quit_on_close_ = quit_on_close;
}

bool Win32Window::OnCreate() {
  // No-op; provided for subclasses.
  return true;
}

void Win32Window::OnDestroy() {
  // No-op; provided for subclasses.
}

void Win32Window::UpdateTheme(HWND const window) {
  DWORD light_mode;
  DWORD light_mode_size = sizeof(light_mode);
  LSTATUS result = RegGetValue(HKEY_CURRENT_USER, kGetPreferredBrightnessRegKey,
                               kGetPreferredBrightnessRegValue,
                               RRF_RT_REG_DWORD, nullptr, &light_mode,
                               &light_mode_size);

  if (result == ERROR_SUCCESS) {
    BOOL enable_dark_mode = light_mode == 0;
    DwmSetWindowAttribute(window, DWMWA_USE_IMMERSIVE_DARK_MODE,
                          &enable_dark_mode, sizeof(enable_dark_mode));
  }
}
````

## File: windows/runner/win32_window.h
````
#ifndef RUNNER_WIN32_WINDOW_H_
#define RUNNER_WIN32_WINDOW_H_

#include <windows.h>

#include <functional>
#include <memory>
#include <string>

// A class abstraction for a high DPI-aware Win32 Window. Intended to be
// inherited from by classes that wish to specialize with custom
// rendering and input handling
class Win32Window {
 public:
  struct Point {
    unsigned int x;
    unsigned int y;
    Point(unsigned int x, unsigned int y) : x(x), y(y) {}
  };

  struct Size {
    unsigned int width;
    unsigned int height;
    Size(unsigned int width, unsigned int height)
        : width(width), height(height) {}
  };

  Win32Window();
  virtual ~Win32Window();

  // Creates a win32 window with |title| that is positioned and sized using
  // |origin| and |size|. New windows are created on the default monitor. Window
  // sizes are specified to the OS in physical pixels, hence to ensure a
  // consistent size this function will scale the inputted width and height as
  // as appropriate for the default monitor. The window is invisible until
  // |Show| is called. Returns true if the window was created successfully.
  bool Create(const std::wstring& title, const Point& origin, const Size& size);

  // Show the current window. Returns true if the window was successfully shown.
  bool Show();

  // Release OS resources associated with window.
  void Destroy();

  // Inserts |content| into the window tree.
  void SetChildContent(HWND content);

  // Returns the backing Window handle to enable clients to set icon and other
  // window properties. Returns nullptr if the window has been destroyed.
  HWND GetHandle();

  // If true, closing this window will quit the application.
  void SetQuitOnClose(bool quit_on_close);

  // Return a RECT representing the bounds of the current client area.
  RECT GetClientArea();

 protected:
  // Processes and route salient window messages for mouse handling,
  // size change and DPI. Delegates handling of these to member overloads that
  // inheriting classes can handle.
  virtual LRESULT MessageHandler(HWND window,
                                 UINT const message,
                                 WPARAM const wparam,
                                 LPARAM const lparam) noexcept;

  // Called when CreateAndShow is called, allowing subclass window-related
  // setup. Subclasses should return false if setup fails.
  virtual bool OnCreate();

  // Called when Destroy is called.
  virtual void OnDestroy();

 private:
  friend class WindowClassRegistrar;

  // OS callback called by message pump. Handles the WM_NCCREATE message which
  // is passed when the non-client area is being created and enables automatic
  // non-client DPI scaling so that the non-client area automatically
  // responds to changes in DPI. All other messages are handled by
  // MessageHandler.
  static LRESULT CALLBACK WndProc(HWND const window,
                                  UINT const message,
                                  WPARAM const wparam,
                                  LPARAM const lparam) noexcept;

  // Retrieves a class instance pointer for |window|
  static Win32Window* GetThisFromHandle(HWND const window) noexcept;

  // Update the window frame's theme to match the system theme.
  static void UpdateTheme(HWND const window);

  bool quit_on_close_ = false;

  // window handle for top level window.
  HWND window_handle_ = nullptr;

  // window handle for hosted content.
  HWND child_content_ = nullptr;
};

#endif  // RUNNER_WIN32_WINDOW_H_
````

## File: .github/workflows/build.yml
````yaml
name: Build
on:
  push:
    branches:
      - main
  pull_request:
    types: [opened, synchronize, reopened]

jobs:
  sonarqube:
    name: SonarQube
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Shallow clones should be disabled for a better relevancy of analysis
      
      # Set up Flutter
      - name: Setup Flutter
        uses: subosito/flutter-action@v2
        with:
          flutter-version: 'stable'
      
      # Get Flutter dependencies
      - name: Get dependencies
        run: flutter pub get

      - name: Generate macOS ephemeral files
        run: flutter build macos --debug
      
      # Run Flutter analyze
      - name: Analyze code
        run: flutter analyze
      
      # Run Flutter tests
      - name: Run tests
        run: flutter test --coverage
      
      # Build the Flutter project
      - name: Build
        run: |
          flutter build web
          flutter build apk --debug
      
      # SonarQube Scan
      - name: SonarQube Scan
        uses: SonarSource/sonarqube-scan-action@v5
        env:
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
          SONAR_HOST_URL: ${{ secrets.SONAR_HOST_URL }}
````

## File: android/app/proguard-rules.pro
````
-keep class com.teacherdashboard.teacher_dashboard_flutter_firebase.MainActivity { *; }
-keep class io.flutter.embedding.android.FlutterActivity { *; }
-keep class io.flutter.app.** { *; }
-keep class io.flutter.plugin.**  { *; }
-keep class io.flutter.util.**  { *; }
-keep class io.flutter.view.**  { *; }
-keep class io.flutter.**  { *; }
-keep class io.flutter.plugins.**  { *; }

# Google Play Core
-keep class com.google.android.play.core.** { *; }
-keep class com.google.android.play.core.splitcompat.** { *; }
-keep class com.google.android.play.core.splitinstall.** { *; }
-keep class com.google.android.play.core.tasks.** { *; }

# Firebase
-keep class com.google.firebase.** { *; }
-keep class com.google.android.gms.** { *; }
````

## File: android/settings.gradle.kts
````
pluginManagement {
    val flutterSdkPath = run {
        val properties = java.util.Properties()
        file("local.properties").inputStream().use { properties.load(it) }
        val flutterSdkPath = properties.getProperty("flutter.sdk")
        require(flutterSdkPath != null) { "flutter.sdk not set in local.properties" }
        flutterSdkPath
    }

    includeBuild("$flutterSdkPath/packages/flutter_tools/gradle")

    repositories {
        google()
        mavenCentral()
        gradlePluginPortal()
    }
}

plugins {
    id("dev.flutter.flutter-plugin-loader") version "1.0.0"
    id("com.android.application") version "8.10.1" apply false
    id("org.jetbrains.kotlin.android") version "2.1.0" apply false
    id("com.google.gms.google-services") version "4.4.2" apply false
}

include(":app")
````

## File: ios/Flutter/Debug.xcconfig
````
#include "Generated.xcconfig"

// Enable Crashlytics for debug builds
DEBUG_INFORMATION_FORMAT = dwarf-with-dsym
````

## File: ios/Flutter/Release.xcconfig
````
#include "Generated.xcconfig"

// Enable Crashlytics for release builds
DEBUG_INFORMATION_FORMAT = dwarf-with-dsym
````

## File: ios/Runner/AppDelegate.swift
````swift
import Flutter
import UIKit
import Firebase
import PushKit
import CallKit
import flutter_callkit_incoming

@main
@objc class AppDelegate: FlutterAppDelegate {
  private var voipRegistry: PKPushRegistry?
  
  override func application(
    _ application: UIApplication,
    didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?
  ) -> Bool {
    FirebaseApp.configure()
    GeneratedPluginRegistrant.register(with: self)
    
    // Initialize PushKit for VoIP
    self.voipRegistration()
    
    // Register for remote notifications
    UNUserNotificationCenter.current().delegate = self
    application.registerForRemoteNotifications()
    
    return super.application(application, didFinishLaunchingWithOptions: launchOptions)
  }
  
  // MARK: - PushKit VoIP Registration
  
  func voipRegistration() {
    voipRegistry = PKPushRegistry(queue: DispatchQueue.main)
    voipRegistry?.delegate = self
    voipRegistry?.desiredPushTypes = [.voIP]
  }
}

// MARK: - PKPushRegistryDelegate

extension AppDelegate: PKPushRegistryDelegate {
  
  // Handle updated PushKit token
  func pushRegistry(_ registry: PKPushRegistry, didUpdate pushCredentials: PKPushCredentials, for type: PKPushType) {
    if type == .voIP {
      let token = pushCredentials.token.map { String(format: "%02.2hhx", $0) }.joined()
      print("VoIP push token: \(token)")
      
      // Send token to Flutter side
      SwiftFlutterCallkitIncomingPlugin.sharedInstance?.setDevicePushTokenVoIP(token)
    }
  }
  
  // Handle incoming VoIP push notification
  func pushRegistry(_ registry: PKPushRegistry, didReceiveIncomingPushWith payload: PKPushPayload, for type: PKPushType, completion: @escaping () -> Void) {
    guard type == .voIP else { return }
    
    // Extract call information from payload
    if let data = payload.dictionaryPayload as? [String: Any] {
      let callId = data["callId"] as? String ?? UUID().uuidString
      let callerName = data["callerName"] as? String ?? "Unknown Caller"
      let callerPhoto = data["callerPhotoUrl"] as? String
      let isVideo = data["isVideo"] as? Bool ?? false
      let handle = data["callerId"] as? String ?? ""
      
      // Configure call data
      let callData = flutter_callkit_incoming.Data(
        id: callId,
        nameCaller: callerName,
        handle: handle,
        type: isVideo ? 1 : 0
      )
      
      // Additional configuration
      callData.appName = "Teacher Dashboard"
      callData.avatar = callerPhoto
      callData.duration = 30000 // 30 seconds
      callData.extra = data
      
      // Show incoming call UI
      SwiftFlutterCallkitIncomingPlugin.sharedInstance?.showCallkitIncoming(callData, fromPushKit: true)
    }
    
    completion()
  }
  
  // Handle invalid VoIP token
  func pushRegistry(_ registry: PKPushRegistry, didInvalidatePushTokenFor type: PKPushType) {
    if type == .voIP {
      print("VoIP push token invalidated")
    }
  }
}
````

## File: lib/features/assignments/data/services/assignment_service.dart
````dart
/// Assignment and grade management service for the education platform.
/// 
/// This service provides comprehensive functionality for managing
/// assignments and grades including CRUD operations, batch processing,
/// and statistical analysis.
library;

import 'package:cloud_firestore/cloud_firestore.dart';
import '../../domain/models/assignment.dart';
import '../../../grades/domain/models/grade.dart';
import '../../../notifications/data/services/notification_service.dart';

/// Core service for managing assignments and grades in Firestore.
/// 
/// This service handles:
/// - Assignment lifecycle management (create, read, update, delete)
/// - Grade management and tracking
/// - Batch operations for efficient bulk processing
/// - Statistical analysis and reporting
/// - Scheduled assignment publishing
/// - Class-wide grade initialization
/// 
/// The service uses dependency injection for Firestore instance,
/// supporting both production and testing environments.
class AssignmentService {
  /// Firestore database instance for batch operations.
  final FirebaseFirestore _firestore;
  
  /// Reference to the assignments collection in Firestore.
  final CollectionReference _assignmentsCollection;
  
  /// Reference to the grades collection in Firestore.
  final CollectionReference _gradesCollection;

  /// Creates an AssignmentService instance.
  /// 
  /// Accepts optional [firestore] parameter for dependency injection,
  /// defaulting to the singleton instance if not provided.
  /// This pattern supports both production use and unit testing.
  AssignmentService({FirebaseFirestore? firestore})
      : _firestore = firestore ?? FirebaseFirestore.instance,
        _assignmentsCollection = (firestore ?? FirebaseFirestore.instance).collection('assignments'),
        _gradesCollection = (firestore ?? FirebaseFirestore.instance).collection('grades');

  // --- Assignment CRUD Operations ---

  /// Creates a new assignment in Firestore.
  /// 
  /// Adds the assignment to the database and returns it with
  /// the generated document ID. The assignment's status and
  /// publication state should be set before calling this method.
  /// 
  /// @param assignment Assignment model to create
  /// @return Created assignment with generated ID
  /// @throws Exception if creation fails
  Future<Assignment> createAssignment(Assignment assignment) async {
    try {
      final docRef = await _assignmentsCollection.add(assignment.toFirestore());
      final createdAssignment = assignment.copyWith(id: docRef.id);
      
      // Schedule notification reminder for due date
      final notificationService = NotificationService();
      await notificationService.scheduleAssignmentReminder(createdAssignment);
      
      return createdAssignment;
    } catch (e) {
      // Error creating assignment: $e
      rethrow;
    }
  }

  /// Retrieves a single assignment by ID.
  /// 
  /// Fetches the assignment document from Firestore and converts
  /// it to an Assignment model. Returns null if the assignment
  /// doesn't exist.
  /// 
  /// @param assignmentId Unique identifier of the assignment
  /// @return Assignment instance or null if not found
  /// @throws Exception if retrieval fails
  Future<Assignment?> getAssignment(String assignmentId) async {
    try {
      final doc = await _assignmentsCollection.doc(assignmentId).get();
      if (!doc.exists) return null;
      return Assignment.fromFirestore(doc);
    } catch (e) {
      // Error getting assignment: $e
      rethrow;
    }
  }

  /// Streams published assignments for a specific class.
  /// 
  /// Returns a real-time stream of assignments that are:
  /// - Associated with the given class
  /// - Published (visible to students)
  /// - Ordered by due date (earliest first)
  /// 
  /// @param classId Class identifier to filter assignments
  /// @return Stream of assignment lists, updated in real-time
  Stream<List<Assignment>> getAssignmentsForClass(String classId) {
    return _assignmentsCollection
        .where('classId', isEqualTo: classId)
        .where('isPublished', isEqualTo: true)
        .orderBy('dueDate', descending: false)
        .snapshots()
        .map((snapshot) => snapshot.docs
            .map((doc) => Assignment.fromFirestore(doc))
            .toList());
  }

  /// Streams all assignments created by a specific teacher.
  /// 
  /// Returns a real-time stream of assignments:
  /// - Created by the given teacher
  /// - Ordered by creation date (newest first)
  /// - Including both published and draft assignments
  /// 
  /// @param teacherId Teacher identifier to filter assignments
  /// @return Stream of assignment lists for the teacher
  Stream<List<Assignment>> getAssignmentsForTeacher(String teacherId) {
    return _assignmentsCollection
        .where('teacherId', isEqualTo: teacherId)
        .orderBy('createdAt', descending: true)
        .snapshots()
        .map((snapshot) => snapshot.docs
            .map((doc) => Assignment.fromFirestore(doc))
            .toList());
  }

  /// Updates an existing assignment in Firestore.
  /// 
  /// Overwrites the entire assignment document with the provided
  /// data. Ensure all required fields are present in the
  /// assignment model before updating.
  /// 
  /// @param assignment Assignment model with updated data
  /// @throws Exception if update fails or assignment doesn't exist
  Future<void> updateAssignment(Assignment assignment) async {
    try {
      await _assignmentsCollection
          .doc(assignment.id)
          .update(assignment.toFirestore());
    } catch (e) {
      // Error updating assignment: $e
      rethrow;
    }
  }

  /// Deletes an assignment and all associated grades.
  /// 
  /// Performs a cascading delete that:
  /// 1. Finds all grades for the assignment
  /// 2. Deletes all grade documents
  /// 3. Deletes the assignment document
  /// 
  /// Uses batch operations for atomicity - either all deletions
  /// succeed or none do.
  /// 
  /// @param assignmentId ID of the assignment to delete
  /// @throws Exception if deletion fails
  Future<void> deleteAssignment(String assignmentId) async {
    try {
      // Delete all grades for this assignment first
      final grades = await _gradesCollection
          .where('assignmentId', isEqualTo: assignmentId)
          .get();
      
      final batch = _firestore.batch();
      for (final doc in grades.docs) {
        batch.delete(doc.reference);
      }
      batch.delete(_assignmentsCollection.doc(assignmentId));
      
      await batch.commit();
    } catch (e) {
      // Error deleting assignment: $e
      rethrow;
    }
  }

  // --- Grade CRUD Operations ---

  /// Creates a new grade record in Firestore.
  /// 
  /// Adds the grade to the database and returns it with
  /// the generated document ID. The grade should have all
  /// required fields set before creation.
  /// 
  /// @param grade Grade model to create
  /// @return Created grade with generated ID
  /// @throws Exception if creation fails
  Future<Grade> createGrade(Grade grade) async {
    try {
      final docRef = await _gradesCollection.add(grade.toFirestore());
      return grade.copyWith(id: docRef.id);
    } catch (e) {
      // Error creating grade: $e
      rethrow;
    }
  }

  /// Retrieves a single grade by ID.
  /// 
  /// Fetches the grade document from Firestore and converts
  /// it to a Grade model. Returns null if the grade
  /// doesn't exist.
  /// 
  /// @param gradeId Unique identifier of the grade
  /// @return Grade instance or null if not found
  /// @throws Exception if retrieval fails
  Future<Grade?> getGrade(String gradeId) async {
    try {
      final doc = await _gradesCollection.doc(gradeId).get();
      if (!doc.exists) return null;
      return Grade.fromFirestore(doc);
    } catch (e) {
      // Error getting grade: $e
      rethrow;
    }
  }

  /// Retrieves a grade for a specific student-assignment pair.
  /// 
  /// Queries for the unique grade record matching both the
  /// student and assignment IDs. Returns null if no grade
  /// exists (e.g., assignment not yet graded).
  /// 
  /// @param studentId ID of the student
  /// @param assignmentId ID of the assignment
  /// @return Grade instance or null if not found
  /// @throws Exception if query fails
  Future<Grade?> getGradeForStudentAndAssignment(String studentId, String assignmentId) async {
    try {
      final query = await _gradesCollection
          .where('studentId', isEqualTo: studentId)
          .where('assignmentId', isEqualTo: assignmentId)
          .limit(1)
          .get();
      
      if (query.docs.isEmpty) return null;
      return Grade.fromFirestore(query.docs.first);
    } catch (e) {
      // Error getting grade: $e
      rethrow;
    }
  }

  /// Streams all grades for a specific assignment.
  /// 
  /// Returns a real-time stream of grades for the given
  /// assignment. Useful for teachers viewing all student
  /// grades for an assignment.
  /// 
  /// @param assignmentId Assignment to get grades for
  /// @return Stream of grade lists, updated in real-time
  Stream<List<Grade>> getGradesForAssignment(String assignmentId) {
    return _gradesCollection
        .where('assignmentId', isEqualTo: assignmentId)
        .snapshots()
        .map((snapshot) => snapshot.docs
            .map((doc) => Grade.fromFirestore(doc))
            .toList());
  }

  /// Streams all grades for a specific student.
  /// 
  /// Returns a real-time stream of grades:
  /// - For the given student across all assignments
  /// - Ordered by creation date (newest first)
  /// - Including all grade statuses
  /// 
  /// @param studentId Student to get grades for
  /// @return Stream of grade lists for the student
  Stream<List<Grade>> getGradesForStudent(String studentId) {
    return _gradesCollection
        .where('studentId', isEqualTo: studentId)
        .orderBy('createdAt', descending: true)
        .snapshots()
        .map((snapshot) => snapshot.docs
            .map((doc) => Grade.fromFirestore(doc))
            .toList());
  }

  /// Updates an existing grade in Firestore.
  /// 
  /// Automatically updates the modification timestamp
  /// before saving. All grade fields are overwritten
  /// with the provided data.
  /// 
  /// @param grade Grade model with updated data
  /// @throws Exception if update fails
  Future<void> updateGrade(Grade grade) async {
    try {
      grade.updatedAt = DateTime.now();
      await _gradesCollection
          .doc(grade.id)
          .update(grade.toFirestore());
    } catch (e) {
      // Error updating grade: $e
      rethrow;
    }
  }

  /// Deletes a single grade record.
  /// 
  /// Permanently removes the grade from Firestore.
  /// This operation cannot be undone.
  /// 
  /// @param gradeId ID of the grade to delete
  /// @throws Exception if deletion fails
  Future<void> deleteGrade(String gradeId) async {
    try {
      await _gradesCollection.doc(gradeId).delete();
    } catch (e) {
      // Error deleting grade: $e
      rethrow;
    }
  }

  // --- Batch Operations ---

  /// Creates multiple grades in a single batch operation.
  /// 
  /// Efficiently creates multiple grade records using Firestore
  /// batch writes. Each grade gets a generated document ID.
  /// All writes succeed or fail together (atomic operation).
  /// 
  /// @param grades List of Grade models to create
  /// @throws Exception if batch creation fails
  Future<void> bulkCreateGrades(List<Grade> grades) async {
    try {
      final batch = _firestore.batch();
      
      for (final grade in grades) {
        final docRef = _gradesCollection.doc();
        batch.set(docRef, grade.copyWith(id: docRef.id).toFirestore());
      }
      
      await batch.commit();
    } catch (e) {
      // Error bulk creating grades: $e
      rethrow;
    }
  }

  /// Updates multiple grades in a single batch operation.
  /// 
  /// Efficiently updates multiple grade records using Firestore
  /// batch writes. All grades get the same updated timestamp.
  /// All updates succeed or fail together (atomic operation).
  /// 
  /// @param grades List of Grade models with updated data
  /// @throws Exception if batch update fails
  Future<void> bulkUpdateGrades(List<Grade> grades) async {
    try {
      final batch = _firestore.batch();
      final now = DateTime.now();
      
      for (final grade in grades) {
        grade.updatedAt = now;
        batch.update(
          _gradesCollection.doc(grade.id),
          grade.toFirestore(),
        );
      }
      
      await batch.commit();
    } catch (e) {
      // Error bulk updating grades: $e
      rethrow;
    }
  }

  // --- Statistics Operations ---

  /// Calculates statistical summary for an assignment's grades.
  /// 
  /// Retrieves all graded submissions for an assignment and
  /// computes statistics including:
  /// - Average, median, highest, lowest scores
  /// - Grade distribution by letter grade
  /// - Total number of graded submissions
  /// 
  /// Only includes grades with 'graded' status.
  /// 
  /// @param assignmentId Assignment to analyze
  /// @return GradeStatistics with calculated metrics
  /// @throws Exception if calculation fails
  Future<GradeStatistics> calculateAssignmentStatistics(String assignmentId) async {
    try {
      final querySnapshot = await _gradesCollection
          .where('assignmentId', isEqualTo: assignmentId)
          .where('status', isEqualTo: GradeStatus.graded.name)
          .get();

      final grades = querySnapshot.docs
          .map((doc) => Grade.fromFirestore(doc))
          .toList();

      return GradeStatistics.fromGrades(grades);
    } catch (e) {
      // Error calculating statistics: $e
      rethrow;
    }
  }

  /// Calculates statistical summary for a student's grades.
  /// 
  /// Computes grade statistics for a student across all
  /// assignments or within a specific class. Includes:
  /// - Overall performance metrics
  /// - Grade distribution
  /// - Progress tracking
  /// 
  /// @param studentId Student to analyze
  /// @param classId Optional class filter
  /// @return GradeStatistics with student performance data
  /// @throws Exception if calculation fails
  Future<GradeStatistics> calculateStudentStatistics(String studentId, {String? classId}) async {
    try {
      Query query = _gradesCollection
          .where('studentId', isEqualTo: studentId)
          .where('status', isEqualTo: GradeStatus.graded.name);
      
      if (classId != null) {
        query = query.where('classId', isEqualTo: classId);
      }

      final querySnapshot = await query.get();

      final grades = querySnapshot.docs
          .map((doc) => Grade.fromFirestore(doc))
          .toList();

      return GradeStatistics.fromGrades(grades);
    } catch (e) {
      // Error calculating student statistics: $e
      rethrow;
    }
  }

  // --- Helper Methods ---

  /// Publishes a draft assignment, making it visible to students.
  /// 
  /// Updates the assignment's published status and timestamp.
  /// Once published, students can view and submit work for
  /// the assignment.
  /// 
  /// @param assignmentId ID of assignment to publish
  /// @throws Exception if publication fails
  Future<void> publishAssignment(String assignmentId) async {
    try {
      await _assignmentsCollection.doc(assignmentId).update({
        'isPublished': true,
        'updatedAt': FieldValue.serverTimestamp(),
      });
    } catch (e) {
      // Error publishing assignment: $e
      rethrow;
    }
  }

  /// Unpublishes an assignment, hiding it from students.
  /// 
  /// Reverts a published assignment back to draft status.
  /// Students will no longer see the assignment, but existing
  /// submissions and grades are preserved.
  /// 
  /// @param assignmentId ID of assignment to unpublish
  /// @throws Exception if unpublishing fails
  Future<void> unpublishAssignment(String assignmentId) async {
    try {
      await _assignmentsCollection.doc(assignmentId).update({
        'isPublished': false,
        'updatedAt': FieldValue.serverTimestamp(),
      });
    } catch (e) {
      // Error unpublishing assignment: $e
      rethrow;
    }
  }

  /// Publishes assignments scheduled for automatic release.
  /// 
  /// Queries for unpublished assignments with publishAt timestamps
  /// in the past and publishes them. This method should be called
  /// periodically (e.g., via cron job or scheduled function).
  /// 
  /// Updates assignment status to 'active' and sets publication flag.
  /// Uses batch operations for efficiency when multiple assignments
  /// need publishing.
  /// 
  /// @throws Exception if scheduled publishing fails
  Future<void> publishScheduledAssignments() async {
    try {
      final now = DateTime.now();
      
      // Query for assignments that should be published
      final querySnapshot = await _assignmentsCollection
          .where('isPublished', isEqualTo: false)
          .where('publishAt', isLessThanOrEqualTo: Timestamp.fromDate(now))
          .get();
      
      if (querySnapshot.docs.isEmpty) return;
      
      final batch = _firestore.batch();
      
      for (final doc in querySnapshot.docs) {
        batch.update(doc.reference, {
          'isPublished': true,
          'status': AssignmentStatus.active.toString().split('.').last,
          'updatedAt': FieldValue.serverTimestamp(),
        });
      }
      
      await batch.commit();
      // Published ${querySnapshot.docs.length} scheduled assignments
    } catch (e) {
      // Error publishing scheduled assignments: $e
      rethrow;
    }
  }

  /// Initializes grade records for all students in a class.
  /// 
  /// When a new assignment is created, this method creates
  /// placeholder grade records for every student in the class.
  /// Each grade starts with:
  /// - Status: pending
  /// - Points earned: 0
  /// - No feedback or grade assigned
  /// 
  /// This ensures every student has a grade entry for tracking
  /// and prevents missing grades in reports.
  /// 
  /// @param assignmentId Assignment to create grades for
  /// @param classId Class containing the students
  /// @param teacherId Teacher who owns the assignment
  /// @throws Exception if initialization fails
  Future<void> initializeGradesForAssignment(String assignmentId, String classId, String teacherId) async {
    try {
      // Get all students in the class
      final studentsSnapshot = await _firestore
          .collection('students')
          .where('classIds', arrayContains: classId)
          .get();

      final grades = studentsSnapshot.docs.map((studentDoc) {
        final studentData = studentDoc.data();
        final studentName = studentData['displayName'] ?? 'Unknown Student';
        return Grade(
          id: '', // Will be set during batch creation
          assignmentId: assignmentId,
          studentId: studentDoc.id,
          studentName: studentName,
          teacherId: teacherId,
          classId: classId,
          pointsEarned: 0,
          pointsPossible: 0, // Will be set from assignment
          percentage: 0,
          letterGrade: null,
          feedback: null,
          status: GradeStatus.pending,
          gradedAt: null,
          returnedAt: null,
          createdAt: DateTime.now(),
          updatedAt: DateTime.now(),
          rubricScores: null,
          attachmentUrls: null,
        );
      }).toList();

      await bulkCreateGrades(grades);
    } catch (e) {
      // Error initializing grades: $e
      rethrow;
    }
  }
}
````

## File: lib/features/assignments/presentation/screens/student/assignment_submission_screen.dart
````dart
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:provider/provider.dart';
import 'package:go_router/go_router.dart';
import 'package:file_picker/file_picker.dart';
import '../../../domain/models/assignment.dart';
import '../../../domain/models/submission.dart';
import '../../../../../features/auth/presentation/providers/auth_provider.dart';
import '../../providers/student_assignment_provider.dart';
import '../../../../../shared/widgets/common/adaptive_layout.dart';
import '../../../../../shared/widgets/common/responsive_layout.dart';

class AssignmentSubmissionScreen extends StatefulWidget {
  final String assignmentId;

  const AssignmentSubmissionScreen({
    super.key,
    required this.assignmentId,
  });

  @override
  State<AssignmentSubmissionScreen> createState() => _AssignmentSubmissionScreenState();
}

class _AssignmentSubmissionScreenState extends State<AssignmentSubmissionScreen> {
  final _textController = TextEditingController();
  final _formKey = GlobalKey<FormState>();
  StudentAssignment? _studentAssignment;
  bool _isLoading = true;
  bool _isSubmitting = false;
  PlatformFile? _selectedFile;
  String? _fileError;

  @override
  void initState() {
    super.initState();
    _loadAssignment();
  }

  @override
  void dispose() {
    _textController.dispose();
    super.dispose();
  }

  Future<void> _loadAssignment() async {
    final studentProvider = context.read<StudentAssignmentProvider>();
    
    try {
      await studentProvider.loadAssignmentDetails(widget.assignmentId);
      final assignment = studentProvider.getAssignmentById(widget.assignmentId);
      
      if (mounted) {
        setState(() {
          _studentAssignment = assignment;
          _isLoading = false;
          
          // If there's an existing submission, load its content
          if (assignment?.submission?.textContent != null) {
            _textController.text = assignment!.submission!.textContent!;
          }
        });
      }
    } catch (e) {
      if (mounted) {
        setState(() => _isLoading = false);
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('Error loading assignment: $e'),
            backgroundColor: Colors.red,
          ),
        );
      }
    }
  }

  Future<void> _pickFile() async {
    try {
      setState(() => _fileError = null);
      
      final result = await FilePicker.platform.pickFiles(
        type: FileType.custom,
        allowedExtensions: ['pdf', 'doc', 'docx', 'txt', 'png', 'jpg', 'jpeg'],
        withData: true,
      );

      if (result != null && result.files.isNotEmpty) {
        final file = result.files.first;
        
        // Check file size (max 10MB)
        if (file.size > 10 * 1024 * 1024) {
          setState(() => _fileError = 'File size must be less than 10MB');
          return;
        }
        
        setState(() => _selectedFile = file);
      }
    } catch (e) {
      setState(() => _fileError = 'Error selecting file: $e');
    }
  }

  Future<void> _submitAssignment() async {
    if (!_formKey.currentState!.validate()) return;
    
    if (_textController.text.trim().isEmpty && _selectedFile == null) {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(
          content: Text('Please provide text content or upload a file'),
          backgroundColor: Colors.red,
        ),
      );
      return;
    }

    setState(() => _isSubmitting = true);

    try {
      final authProvider = context.read<AuthProvider>();
      final studentProvider = context.read<StudentAssignmentProvider>();
      
      final success = await studentProvider.submitAssignment(
        assignmentId: widget.assignmentId,
        studentName: authProvider.userModel?.displayName ?? 'Student',
        textContent: _textController.text.trim(),
        file: _selectedFile,
      );

      if (mounted) {
        if (success) {
          ScaffoldMessenger.of(context).showSnackBar(
            const SnackBar(
              content: Text('Assignment submitted successfully'),
              backgroundColor: Colors.green,
            ),
          );
          context.pop();
        } else {
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(
              content: Text('Failed to submit: ${studentProvider.error}'),
              backgroundColor: Colors.red,
            ),
          );
        }
      }
    } finally {
      if (mounted) {
        setState(() => _isSubmitting = false);
      }
    }
  }

  Future<void> _updateSubmission() async {
    if (!_formKey.currentState!.validate()) return;
    
    setState(() => _isSubmitting = true);

    try {
      // This would need to be implemented in the provider
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(
          content: Text('Update functionality coming soon'),
          backgroundColor: Colors.orange,
        ),
      );
    } finally {
      if (mounted) {
        setState(() => _isSubmitting = false);
      }
    }
  }

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);

    if (_isLoading) {
      return const Scaffold(
        body: Center(child: CircularProgressIndicator()),
      );
    }

    if (_studentAssignment == null) {
      return Scaffold(
        appBar: AppBar(title: const Text('Assignment Not Found')),
        body: const Center(
          child: Text('Assignment not found or you don\'t have access to it.'),
        ),
      );
    }

    final assignment = _studentAssignment!.assignment;
    final isSubmitted = _studentAssignment!.isSubmitted;
    final isOverdue = _studentAssignment!.isOverdue;
    final canSubmit = !isOverdue || assignment.allowLateSubmissions;

    return AdaptiveLayout(
      title: isSubmitted ? 'View Submission' : 'Submit Assignment',
      body: ResponsiveContainer(
        child: Form(
          key: _formKey,
          child: SingleChildScrollView(
            padding: const EdgeInsets.all(16),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                // Assignment Info Card
                _buildAssignmentInfoCard(theme, assignment),
                const SizedBox(height: 16),

                // Submission Status Card (if already submitted)
                if (isSubmitted && _studentAssignment!.submission != null)
                  _buildSubmissionStatusCard(theme),
                const SizedBox(height: 16),

                // Submission Form
                if (!isSubmitted || _studentAssignment!.submission?.status == SubmissionStatus.submitted)
                  _buildSubmissionForm(theme, assignment, canSubmit),

                // Grading Info (if graded)
                if (_studentAssignment!.isGraded)
                  _buildGradingCard(theme),
              ],
            ),
          ),
        ),
      ),
    );
  }

  Widget _buildAssignmentInfoCard(ThemeData theme, Assignment assignment) {
    return Card(
      child: Padding(
        padding: const EdgeInsets.all(16),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Row(
              children: [
                Icon(
                  _getAssignmentIcon(assignment.type),
                  color: theme.colorScheme.primary,
                  size: 28,
                ),
                const SizedBox(width: 12),
                Expanded(
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      Text(
                        assignment.title,
                        style: theme.textTheme.titleLarge?.copyWith(
                          fontWeight: FontWeight.bold,
                        ),
                      ),
                      Text(
                        '${assignment.category} • ${assignment.teacherName}',
                        style: theme.textTheme.bodyMedium?.copyWith(
                          color: theme.colorScheme.onSurfaceVariant,
                        ),
                      ),
                    ],
                  ),
                ),
              ],
            ),
            const SizedBox(height: 16),
            _buildInfoRow(
              Icons.calendar_today,
              'Due Date',
              _formatDateTime(assignment.dueDate),
              _studentAssignment!.isOverdue ? Colors.red : null,
            ),
            _buildInfoRow(
              Icons.star,
              'Points',
              '${assignment.totalPoints.toInt()} points',
              Colors.blue,
            ),
            if (assignment.allowLateSubmissions)
              _buildInfoRow(
                Icons.warning,
                'Late Policy',
                '${assignment.latePenaltyPercentage}% penalty per day',
                Colors.orange,
              ),
          ],
        ),
      ),
    );
  }

  Widget _buildSubmissionStatusCard(ThemeData theme) {
    final submission = _studentAssignment!.submission!;
    
    return Card(
      color: theme.colorScheme.primaryContainer,
      child: Padding(
        padding: const EdgeInsets.all(16),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Row(
              children: [
                Icon(
                  Icons.check_circle,
                  color: theme.colorScheme.onPrimaryContainer,
                ),
                const SizedBox(width: 8),
                Text(
                  'Submitted',
                  style: theme.textTheme.titleMedium?.copyWith(
                    fontWeight: FontWeight.bold,
                    color: theme.colorScheme.onPrimaryContainer,
                  ),
                ),
              ],
            ),
            const SizedBox(height: 8),
            Text(
              'Submitted on ${_formatDateTime(submission.submittedAt)}',
              style: theme.textTheme.bodyMedium?.copyWith(
                color: theme.colorScheme.onPrimaryContainer,
              ),
            ),
            if (submission.fileName != null) ...[
              const SizedBox(height: 8),
              Row(
                children: [
                  Icon(
                    Icons.attach_file,
                    size: 16,
                    color: theme.colorScheme.onPrimaryContainer,
                  ),
                  const SizedBox(width: 4),
                  Expanded(
                    child: Text(
                      submission.fileName!,
                      style: theme.textTheme.bodySmall?.copyWith(
                        color: theme.colorScheme.onPrimaryContainer,
                      ),
                      overflow: TextOverflow.ellipsis,
                    ),
                  ),
                ],
              ),
            ],
          ],
        ),
      ),
    );
  }

  Widget _buildSubmissionForm(ThemeData theme, Assignment assignment, bool canSubmit) {
    return Card(
      child: Padding(
        padding: const EdgeInsets.all(16),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(
              'Your Submission',
              style: theme.textTheme.titleLarge?.copyWith(
                fontWeight: FontWeight.bold,
              ),
            ),
            const SizedBox(height: 16),
            
            // Instructions
            Container(
              padding: const EdgeInsets.all(12),
              decoration: BoxDecoration(
                color: theme.colorScheme.surfaceContainerHighest,
                borderRadius: BorderRadius.circular(8),
              ),
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Text(
                    'Instructions',
                    style: theme.textTheme.titleSmall?.copyWith(
                      fontWeight: FontWeight.bold,
                    ),
                  ),
                  const SizedBox(height: 4),
                  Text(
                    assignment.instructions,
                    style: theme.textTheme.bodyMedium,
                  ),
                ],
              ),
            ),
            const SizedBox(height: 16),

            // Text Input
            TextFormField(
              controller: _textController,
              enabled: canSubmit && !_isSubmitting,
              decoration: InputDecoration(
                labelText: 'Answer / Text Submission',
                hintText: 'Type your answer or paste your work here...',
                alignLabelWithHint: true,
                border: const OutlineInputBorder(),
                counterText: '${_textController.text.length} characters',
              ),
              maxLines: 10,
              minLines: 5,
              maxLength: 5000,
              maxLengthEnforcement: MaxLengthEnforcement.enforced,
              validator: (value) {
                if ((value == null || value.trim().isEmpty) && _selectedFile == null) {
                  return 'Please provide an answer or upload a file';
                }
                return null;
              },
              onChanged: (value) => setState(() {}),
            ),
            const SizedBox(height: 16),

            // File Upload Section
            Row(
              children: [
                Expanded(
                  child: OutlinedButton.icon(
                    onPressed: canSubmit && !_isSubmitting ? _pickFile : null,
                    icon: const Icon(Icons.attach_file),
                    label: Text(_selectedFile == null ? 'Attach File' : 'Change File'),
                  ),
                ),
                if (_selectedFile != null) ...[
                  const SizedBox(width: 8),
                  IconButton(
                    onPressed: canSubmit && !_isSubmitting
                        ? () => setState(() => _selectedFile = null)
                        : null,
                    icon: const Icon(Icons.clear),
                    tooltip: 'Remove file',
                  ),
                ],
              ],
            ),
            
            // Selected File Display
            if (_selectedFile != null) ...[
              const SizedBox(height: 8),
              Container(
                padding: const EdgeInsets.all(12),
                decoration: BoxDecoration(
                  color: theme.colorScheme.surfaceContainerHighest,
                  borderRadius: BorderRadius.circular(8),
                ),
                child: Row(
                  children: [
                    Icon(
                      Icons.insert_drive_file,
                      color: theme.colorScheme.primary,
                    ),
                    const SizedBox(width: 8),
                    Expanded(
                      child: Column(
                        crossAxisAlignment: CrossAxisAlignment.start,
                        children: [
                          Text(
                            _selectedFile!.name,
                            style: theme.textTheme.bodyMedium?.copyWith(
                              fontWeight: FontWeight.w600,
                            ),
                            overflow: TextOverflow.ellipsis,
                          ),
                          Text(
                            _formatFileSize(_selectedFile!.size),
                            style: theme.textTheme.bodySmall?.copyWith(
                              color: theme.colorScheme.onSurfaceVariant,
                            ),
                          ),
                        ],
                      ),
                    ),
                  ],
                ),
              ),
            ],

            // File Error
            if (_fileError != null) ...[
              const SizedBox(height: 8),
              Text(
                _fileError!,
                style: theme.textTheme.bodySmall?.copyWith(
                  color: theme.colorScheme.error,
                ),
              ),
            ],

            const SizedBox(height: 8),
            Text(
              'Accepted formats: PDF, DOC, DOCX, TXT, PNG, JPG, JPEG (Max 10MB)',
              style: theme.textTheme.bodySmall?.copyWith(
                color: theme.colorScheme.onSurfaceVariant,
              ),
            ),
            const SizedBox(height: 24),

            // Submit Button
            SizedBox(
              width: double.infinity,
              child: FilledButton.icon(
                onPressed: canSubmit && !_isSubmitting
                    ? (_studentAssignment!.isSubmitted ? _updateSubmission : _submitAssignment)
                    : null,
                icon: _isSubmitting
                    ? const SizedBox(
                        width: 20,
                        height: 20,
                        child: CircularProgressIndicator(strokeWidth: 2),
                      )
                    : Icon(_studentAssignment!.isSubmitted ? Icons.update : Icons.upload),
                label: Text(
                  _isSubmitting
                      ? 'Submitting...'
                      : (_studentAssignment!.isSubmitted ? 'Update Submission' : 'Submit Assignment'),
                ),
                style: FilledButton.styleFrom(
                  padding: const EdgeInsets.all(16),
                ),
              ),
            ),

            if (!canSubmit && _studentAssignment!.isOverdue) ...[
              const SizedBox(height: 8),
              Container(
                padding: const EdgeInsets.all(12),
                decoration: BoxDecoration(
                  color: theme.colorScheme.errorContainer,
                  borderRadius: BorderRadius.circular(8),
                ),
                child: Row(
                  children: [
                    Icon(
                      Icons.error_outline,
                      color: theme.colorScheme.onErrorContainer,
                    ),
                    const SizedBox(width: 8),
                    Expanded(
                      child: Text(
                        'This assignment is overdue and late submissions are not allowed.',
                        style: theme.textTheme.bodyMedium?.copyWith(
                          color: theme.colorScheme.onErrorContainer,
                        ),
                      ),
                    ),
                  ],
                ),
              ),
            ],
          ],
        ),
      ),
    );
  }

  Widget _buildGradingCard(ThemeData theme) {
    return Card(
      child: Padding(
        padding: const EdgeInsets.all(16),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Row(
              children: [
                Icon(
                  Icons.grade,
                  color: theme.colorScheme.primary,
                ),
                const SizedBox(width: 8),
                Text(
                  'Grading',
                  style: theme.textTheme.titleLarge?.copyWith(
                    fontWeight: FontWeight.bold,
                  ),
                ),
              ],
            ),
            const SizedBox(height: 16),
            Row(
              children: [
                // Grade Circle
                Container(
                  width: 80,
                  height: 80,
                  decoration: BoxDecoration(
                    shape: BoxShape.circle,
                    color: _getGradeColor(_studentAssignment!.letterGrade ?? 'N/A').withValues(alpha: 0.2),
                  ),
                  child: Center(
                    child: Column(
                      mainAxisSize: MainAxisSize.min,
                      children: [
                        Text(
                          _studentAssignment!.letterGrade ?? 'N/A',
                          style: TextStyle(
                            fontSize: 24,
                            fontWeight: FontWeight.bold,
                            color: _getGradeColor(_studentAssignment!.letterGrade ?? 'N/A'),
                          ),
                        ),
                        Text(
                          '${_studentAssignment!.percentage?.toStringAsFixed(1) ?? 0}%',
                          style: TextStyle(
                            fontSize: 12,
                            color: _getGradeColor(_studentAssignment!.letterGrade ?? 'N/A'),
                          ),
                        ),
                      ],
                    ),
                  ),
                ),
                const SizedBox(width: 24),
                // Grade Details
                Expanded(
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      _buildGradeRow(
                        'Points Earned',
                        '${_studentAssignment!.earnedPoints?.toInt() ?? 0} / ${_studentAssignment!.assignment.totalPoints.toInt()}',
                      ),
                      const SizedBox(height: 8),
                      if (_studentAssignment!.submission?.gradedAt != null)
                        _buildGradeRow(
                          'Graded On',
                          _formatDate(_studentAssignment!.submission!.gradedAt!),
                        ),
                    ],
                  ),
                ),
              ],
            ),
            if (_studentAssignment!.feedback != null) ...[
              const SizedBox(height: 16),
              const Divider(),
              const SizedBox(height: 16),
              Text(
                'Teacher Feedback',
                style: theme.textTheme.titleMedium?.copyWith(
                  fontWeight: FontWeight.bold,
                ),
              ),
              const SizedBox(height: 8),
              Container(
                padding: const EdgeInsets.all(12),
                decoration: BoxDecoration(
                  color: theme.colorScheme.surfaceContainerHighest,
                  borderRadius: BorderRadius.circular(8),
                ),
                child: Text(
                  _studentAssignment!.feedback!,
                  style: theme.textTheme.bodyMedium,
                ),
              ),
            ],
          ],
        ),
      ),
    );
  }

  Widget _buildInfoRow(IconData icon, String label, String value, Color? color) {
    return Padding(
      padding: const EdgeInsets.symmetric(vertical: 4),
      child: Row(
        children: [
          Icon(icon, size: 16, color: color ?? Colors.grey),
          const SizedBox(width: 8),
          Text(
            '$label: ',
            style: TextStyle(
              color: color ?? Colors.grey,
              fontWeight: FontWeight.w500,
            ),
          ),
          Expanded(
            child: Text(
              value,
              style: TextStyle(
                color: color,
                fontWeight: FontWeight.w600,
              ),
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildGradeRow(String label, String value) {
    return Row(
      mainAxisAlignment: MainAxisAlignment.spaceBetween,
      children: [
        Text(
          label,
          style: const TextStyle(color: Colors.grey),
        ),
        Text(
          value,
          style: const TextStyle(fontWeight: FontWeight.w600),
        ),
      ],
    );
  }

  IconData _getAssignmentIcon(AssignmentType type) {
    switch (type) {
      case AssignmentType.homework:
        return Icons.home_work_outlined;
      case AssignmentType.essay:
        return Icons.article_outlined;
      case AssignmentType.quiz:
        return Icons.quiz_outlined;
      case AssignmentType.test:
      case AssignmentType.exam:
        return Icons.assignment_outlined;
      case AssignmentType.lab:
        return Icons.science_outlined;
      case AssignmentType.project:
        return Icons.folder_special_outlined;
      case AssignmentType.presentation:
        return Icons.present_to_all_outlined;
      case AssignmentType.classwork:
        return Icons.work_outline;
      default:
        return Icons.assignment_outlined;
    }
  }

  Color _getGradeColor(String grade) {
    if (grade.startsWith('A')) return Colors.green;
    if (grade.startsWith('B')) return Colors.blue;
    if (grade.startsWith('C')) return Colors.orange;
    if (grade.startsWith('D')) return Colors.red;
    if (grade.startsWith('F')) return Colors.red[800]!;
    return Colors.grey;
  }

  String _formatDate(DateTime date) {
    final months = [
      'Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun',
      'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'
    ];
    return '${months[date.month - 1]} ${date.day}, ${date.year}';
  }

  String _formatDateTime(DateTime date) {
    final time = TimeOfDay.fromDateTime(date);
    return '${_formatDate(date)} at ${time.format(context)}';
  }

  String _formatFileSize(int bytes) {
    const units = ['B', 'KB', 'MB', 'GB'];
    int unitIndex = 0;
    double size = bytes.toDouble();
    
    while (size >= 1024 && unitIndex < units.length - 1) {
      size /= 1024;
      unitIndex++;
    }
    
    return '${size.toStringAsFixed(1)} ${units[unitIndex]}';
  }
}
````

## File: lib/features/assignments/presentation/screens/student/assignments_list_screen.dart
````dart
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'package:go_router/go_router.dart';
import '../../../../../main.dart';
import '../../../../../shared/widgets/common/adaptive_layout.dart';
import '../../../../../shared/widgets/common/responsive_layout.dart';
import '../../../../../shared/widgets/common/error_aware_stream_builder.dart';
import '../../../../../features/auth/presentation/providers/auth_provider.dart';
import '../../providers/student_assignment_provider.dart';
import '../../../domain/models/assignment.dart';

class StudentAssignmentsScreen extends StatefulWidget {
  const StudentAssignmentsScreen({super.key});

  @override
  State<StudentAssignmentsScreen> createState() => _StudentAssignmentsScreenState();
}

class _StudentAssignmentsScreenState extends State<StudentAssignmentsScreen> with SingleTickerProviderStateMixin {
  late TabController _tabController;
  final _searchController = TextEditingController();
  String _selectedSubject = 'All Subjects';
  String _sortBy = 'Due Date';
  Future<void>? _initializationFuture;
  
  @override
  void initState() {
    super.initState();
    _tabController = TabController(length: 4, vsync: this, initialIndex: 0);
    
    // Initialize the provider with student data
    WidgetsBinding.instance.addPostFrameCallback((_) {
      final authProvider = context.read<AuthProvider>();
      if (authProvider.userModel != null) {
        _initializationFuture = context
            .read<StudentAssignmentProvider>()
            .initializeForStudent(authProvider.userModel!.uid);
        setState(() {});
      }
    });
  }

  @override
  void dispose() {
    _tabController.dispose();
    _searchController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final studentProvider = context.watch<StudentAssignmentProvider>();

    return AdaptiveLayout(
      title: 'Assignments',
      bottom: TabBar(
        controller: _tabController,
        isScrollable: true,
        tabs: const [
          Tab(text: 'Pending'),
          Tab(text: 'Submitted'),
          Tab(text: 'Graded'),
          Tab(text: 'All'),
        ],
      ),
      body: FutureBuilder<void>(
        future: _initializationFuture,
        builder: (context, snapshot) {
          if (snapshot.connectionState == ConnectionState.waiting) {
            return const Center(child: CircularProgressIndicator());
          }

          if (snapshot.hasError) {
            return Center(
              child: Text('Error initializing assignments: ${snapshot.error}'),
            );
          }

          // Check if Firebase is initialized
          if (!isFirebaseInitialized) {
            return Center(
              child: Column(
                mainAxisAlignment: MainAxisAlignment.center,
                children: [
                  Icon(
                    Icons.cloud_off,
                    size: 64,
                    color: theme.colorScheme.error,
                  ),
                  const SizedBox(height: 16),
                  Text(
                    'Firebase not available',
                    style: theme.textTheme.titleLarge?.copyWith(
                      color: theme.colorScheme.error,
                    ),
                  ),
                  const SizedBox(height: 8),
                  Text(
                    'Running in offline mode',
                    style: theme.textTheme.bodyLarge?.copyWith(
                      color: theme.colorScheme.onSurfaceVariant,
                    ),
                  ),
                ],
              ),
            );
          }
          
          return ErrorAwareStreamBuilder<List<StudentAssignment>>(
            stream: studentProvider.assignmentsStream,
            onRetry: () => studentProvider.refresh(),
            // Don't check if data is empty - let tabs handle their own empty states
            builder: (context, assignments) {
              return Column(
                children: [
                  // Search and Filters
                  Container(
                    padding: const EdgeInsets.all(16),
                    child: Column(
                      children: [
                        // Search Bar
                        TextField(
                          controller: _searchController,
                          decoration: InputDecoration(
                            hintText: 'Search assignments...',
                            prefixIcon: const Icon(Icons.search),
                            suffixIcon: _searchController.text.isNotEmpty
                                ? IconButton(
                                    icon: const Icon(Icons.clear),
                                    onPressed: () {
                                      setState(() {
                                        _searchController.clear();
                                      });
                                    },
                                  )
                                : null,
                            border: const OutlineInputBorder(),
                            contentPadding: const EdgeInsets.symmetric(
                              horizontal: 16,
                              vertical: 12,
                            ),
                          ),
                          onChanged: (value) => setState(() {}),
                        ),
                        const SizedBox(height: 12),
                        // Filter Row
                        Row(
                          children: [
                            // Subject Filter
                            Expanded(
                              child: Container(
                                padding: const EdgeInsets.symmetric(horizontal: 12),
                                decoration: BoxDecoration(
                                  border: Border.all(color: theme.colorScheme.outline),
                                  borderRadius: BorderRadius.circular(8),
                                ),
                                child: DropdownButtonHideUnderline(
                                  child: DropdownButton<String>(
                                    value: _selectedSubject,
                                    isExpanded: true,
                                    items: _getSubjectsList(assignments).map((subject) {
                                      return DropdownMenuItem(
                                        value: subject,
                                        child: Text(subject),
                                      );
                                    }).toList(),
                                    onChanged: (value) {
                                      setState(() {
                                        _selectedSubject = value!;
                                      });
                                    },
                                  ),
                                ),
                              ),
                            ),
                            const SizedBox(width: 12),
                            // Sort Dropdown
                            Container(
                              padding: const EdgeInsets.symmetric(horizontal: 12),
                              decoration: BoxDecoration(
                                border: Border.all(color: theme.colorScheme.outline),
                                borderRadius: BorderRadius.circular(8),
                              ),
                              child: DropdownButtonHideUnderline(
                                child: DropdownButton<String>(
                                  value: _sortBy,
                                  items: [
                                    'Due Date',
                                    'Subject',
                                    'Priority',
                                    'Points',
                                  ].map((sort) {
                                    return DropdownMenuItem(
                                      value: sort,
                                      child: Row(
                                        children: [
                                          const Icon(Icons.sort, size: 18),
                                          const SizedBox(width: 8),
                                          Text(sort),
                                        ],
                                      ),
                                    );
                                  }).toList(),
                                  onChanged: (value) {
                                    setState(() {
                                      _sortBy = value!;
                                    });
                                  },
                                ),
                              ),
                            ),
                          ],
                        ),
                      ],
                    ),
                  ),
                  // Assignments List
                  Expanded(
                    child: TabBarView(
                      controller: _tabController,
                      children: [
                        _buildAssignmentsList(
                          _filterAssignments(_getPendingAssignments(assignments)),
                          emptyMessage: 'No pending assignments! 🎉',
                          emptyIcon: Icons.celebration_outlined,
                        ),
                        _buildAssignmentsList(
                          _filterAssignments(_getSubmittedAssignments(assignments)),
                          emptyMessage: 'No assignments waiting for grades',
                          emptyIcon: Icons.hourglass_empty,
                        ),
                        _buildAssignmentsList(
                          _filterAssignments(_getGradedAssignments(assignments)),
                          emptyMessage: 'No graded assignments yet',
                          emptyIcon: Icons.grade_outlined,
                        ),
                        _buildAssignmentsList(
                          _filterAssignments(assignments),
                          emptyMessage: 'No assignments yet',
                          emptyIcon: Icons.assignment_outlined,
                        ),
                      ],
                    ),
                  ),
                ],
              );
            },
          );
        },
      ),
    );
  }

  List<String> _getSubjectsList(List<StudentAssignment> assignments) {
    final subjects = <String>{'All Subjects'};
    for (final assignment in assignments) {
      subjects.add(assignment.assignment.category);
    }
    return subjects.toList()..sort();
  }
  
  List<StudentAssignment> _getPendingAssignments(List<StudentAssignment> assignments) {
    return assignments.where((a) => !a.isSubmitted && !a.isOverdue).toList();
  }
  
  List<StudentAssignment> _getSubmittedAssignments(List<StudentAssignment> assignments) {
    return assignments.where((a) => a.isSubmitted && !a.isGraded).toList();
  }
  
  List<StudentAssignment> _getGradedAssignments(List<StudentAssignment> assignments) {
    return assignments.where((a) => a.isGraded).toList();
  }

  List<StudentAssignment> _filterAssignments(List<StudentAssignment> assignments) {
    var filtered = assignments;
    
    // Apply search filter
    if (_searchController.text.isNotEmpty) {
      final query = _searchController.text.toLowerCase();
      filtered = filtered.where((a) {
        return a.assignment.title.toLowerCase().contains(query) ||
               a.assignment.description.toLowerCase().contains(query) ||
               a.assignment.category.toLowerCase().contains(query);
      }).toList();
    }
    
    // Apply subject filter
    if (_selectedSubject != 'All Subjects') {
      filtered = filtered.where((a) => a.assignment.category == _selectedSubject).toList();
    }
    
    // Apply sorting
    switch (_sortBy) {
      case 'Due Date':
        filtered.sort((a, b) => a.assignment.dueDate.compareTo(b.assignment.dueDate));
        break;
      case 'Subject':
        filtered.sort((a, b) => a.assignment.title.compareTo(b.assignment.title));
        break;
      case 'Priority':
        // Sort by due date as proxy for priority
        filtered.sort((a, b) => a.assignment.dueDate.compareTo(b.assignment.dueDate));
        break;
      case 'Points':
        filtered.sort((a, b) => b.assignment.totalPoints.compareTo(a.assignment.totalPoints));
        break;
    }
    
    return filtered;
  }

  Widget _buildAssignmentsList(
    List<StudentAssignment> assignments, {
    required String emptyMessage,
    IconData emptyIcon = Icons.assignment_outlined,
  }) {
    if (assignments.isEmpty) {
      return Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Icon(
              emptyIcon,
              size: 64,
              color: Theme.of(context).colorScheme.primary.withAlpha(102),
            ),
            const SizedBox(height: 16),
            Text(
              emptyMessage,
              style: Theme.of(context).textTheme.titleMedium?.copyWith(
                color: Theme.of(context).colorScheme.onSurfaceVariant,
                fontWeight: FontWeight.w500,
              ),
            ),
          ],
        ),
      );
    }

    return ResponsiveContainer(
      child: RefreshIndicator(
        onRefresh: () => context.read<StudentAssignmentProvider>().refresh(),
        child: ListView.builder(
          padding: const EdgeInsets.all(16),
          itemCount: assignments.length,
          itemBuilder: (context, index) {
            final studentAssignment = assignments[index];
            return _buildAssignmentCard(studentAssignment);
          },
        ),
      ),
    );
  }

  Widget _buildAssignmentCard(StudentAssignment studentAssignment) {
    final theme = Theme.of(context);
    final assignment = studentAssignment.assignment;
    final dueDate = assignment.dueDate;
    final isOverdue = studentAssignment.isOverdue;
    final isDueSoon = studentAssignment.isDueSoon;

    Color priorityColor = _getPriorityColor(assignment);
    Color statusColor = _getStatusColor(studentAssignment.status);
    IconData statusIcon = _getStatusIcon(studentAssignment.status);

    return Card(
      margin: const EdgeInsets.only(bottom: 12),
      child: InkWell(
        onTap: () => _showAssignmentDetails(studentAssignment),
        borderRadius: BorderRadius.circular(12),
        child: Padding(
          padding: const EdgeInsets.all(16),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              // Header Row
              Row(
                children: [
                  // Assignment Type Icon
                  Container(
                    padding: const EdgeInsets.all(8),
                    decoration: BoxDecoration(
                      color: theme.colorScheme.primaryContainer,
                      borderRadius: BorderRadius.circular(8),
                    ),
                    child: Icon(
                      _getAssignmentIcon(assignment.type),
                      color: theme.colorScheme.onPrimaryContainer,
                    ),
                  ),
                  const SizedBox(width: 12),
                  // Title and Class
                  Expanded(
                    child: Column(
                      crossAxisAlignment: CrossAxisAlignment.start,
                      children: [
                        Text(
                          assignment.title,
                          style: theme.textTheme.titleMedium?.copyWith(
                            fontWeight: FontWeight.bold,
                          ),
                        ),
                        Text(
                          '${assignment.category} • ${assignment.teacherName}',
                          style: theme.textTheme.bodyMedium?.copyWith(
                            color: theme.colorScheme.onSurfaceVariant,
                          ),
                        ),
                      ],
                    ),
                  ),
                  // Priority Badge
                  Container(
                    padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
                    decoration: BoxDecoration(
                      color: priorityColor.withAlpha(26),
                      borderRadius: BorderRadius.circular(12),
                    ),
                    child: Text(
                      _getPriorityText(assignment),
                      style: TextStyle(
                        color: priorityColor,
                        fontWeight: FontWeight.w600,
                        fontSize: 12,
                      ),
                    ),
                  ),
                ],
              ),
              const SizedBox(height: 12),

              // Status and Due Date Row
              Row(
                children: [
                  // Status
                  Container(
                    padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 6),
                    decoration: BoxDecoration(
                      color: statusColor.withAlpha(26),
                      borderRadius: BorderRadius.circular(20),
                    ),
                    child: Row(
                      mainAxisSize: MainAxisSize.min,
                      children: [
                        Icon(statusIcon, size: 16, color: statusColor),
                        const SizedBox(width: 4),
                        Text(
                          studentAssignment.status,
                          style: TextStyle(
                            color: statusColor,
                            fontWeight: FontWeight.w600,
                            fontSize: 12,
                          ),
                        ),
                      ],
                    ),
                  ),
                  const Spacer(),
                  // Due Date
                  Row(
                    children: [
                      Icon(
                        Icons.calendar_today,
                        size: 16,
                        color: isOverdue ? Colors.red : theme.colorScheme.onSurfaceVariant,
                      ),
                      const SizedBox(width: 4),
                      Text(
                        _formatDueDate(dueDate),
                        style: TextStyle(
                          color: isOverdue ? Colors.red : theme.colorScheme.onSurfaceVariant,
                          fontWeight: isDueSoon ? FontWeight.bold : FontWeight.normal,
                        ),
                      ),
                    ],
                  ),
                ],
              ),
              const SizedBox(height: 12),

              // Points and Grade (if graded)
              Row(
                children: [
                  // Points
                  _buildInfoChip(
                    icon: Icons.star_outline,
                    label: '${assignment.totalPoints.toInt()} pts',
                    color: Colors.blue,
                  ),
                  if (studentAssignment.isGraded && studentAssignment.earnedPoints != null) ...[
                    const SizedBox(width: 8),
                    _buildInfoChip(
                      icon: Icons.grade,
                      label: '${studentAssignment.earnedPoints!.toInt()}/${assignment.totalPoints.toInt()}',
                      color: Colors.green,
                    ),
                    const SizedBox(width: 8),
                    _buildInfoChip(
                      icon: Icons.school,
                      label: studentAssignment.letterGrade ?? 'N/A',
                      color: _getGradeColor(studentAssignment.letterGrade ?? 'N/A'),
                    ),
                  ],
                ],
              ),

              // Action Buttons
              const SizedBox(height: 12),
              Row(
                mainAxisAlignment: MainAxisAlignment.end,
                children: [
                  if (!studentAssignment.isSubmitted && !studentAssignment.isOverdue)
                    TextButton.icon(
                      onPressed: () {
                        context.push('/student/assignments/${studentAssignment.assignment.id}/submit');
                      },
                      icon: const Icon(Icons.upload, size: 18),
                      label: const Text('Submit'),
                    ),
                  if (studentAssignment.isSubmitted)
                    TextButton.icon(
                      onPressed: () {
                        context.push('/student/assignments/${studentAssignment.assignment.id}/submit');
                      },
                      icon: const Icon(Icons.description, size: 18),
                      label: const Text('View Submission'),
                    ),
                  if (studentAssignment.isGraded && studentAssignment.feedback != null)
                    TextButton.icon(
                      onPressed: () {
                        _showFeedbackDialog(studentAssignment);
                      },
                      icon: const Icon(Icons.feedback, size: 18),
                      label: const Text('Feedback'),
                    ),
                  TextButton.icon(
                    onPressed: () {
                      _showAssignmentDetails(studentAssignment);
                    },
                    icon: const Icon(Icons.visibility, size: 18),
                    label: const Text('View'),
                  ),
                ],
              ),
            ],
          ),
        ),
      ),
    );
  }

  Widget _buildInfoChip({
    required IconData icon,
    required String label,
    required Color color,
  }) {
    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
      decoration: BoxDecoration(
        color: color.withAlpha(26),
        borderRadius: BorderRadius.circular(12),
      ),
      child: Row(
        mainAxisSize: MainAxisSize.min,
        children: [
          Icon(icon, size: 14, color: color),
          const SizedBox(width: 4),
          Text(
            label,
            style: TextStyle(
              color: color,
              fontWeight: FontWeight.w600,
              fontSize: 12,
            ),
          ),
        ],
      ),
    );
  }

  IconData _getAssignmentIcon(AssignmentType type) {
    switch (type) {
      case AssignmentType.homework:
        return Icons.home_work_outlined;
      case AssignmentType.essay:
        return Icons.article_outlined;
      case AssignmentType.quiz:
        return Icons.quiz_outlined;
      case AssignmentType.test:
      case AssignmentType.exam:
        return Icons.assignment_outlined;
      case AssignmentType.lab:
        return Icons.science_outlined;
      case AssignmentType.project:
        return Icons.folder_special_outlined;
      case AssignmentType.presentation:
        return Icons.present_to_all_outlined;
      case AssignmentType.classwork:
        return Icons.work_outline;
      default:
        return Icons.assignment_outlined;
    }
  }

  Color _getPriorityColor(Assignment assignment) {
    final daysUntilDue = assignment.dueDate.difference(DateTime.now()).inDays;
    if (daysUntilDue <= 1) return Colors.red;
    if (daysUntilDue <= 3) return Colors.orange;
    return Colors.green;
  }

  String _getPriorityText(Assignment assignment) {
    final daysUntilDue = assignment.dueDate.difference(DateTime.now()).inDays;
    if (daysUntilDue <= 1) return 'High';
    if (daysUntilDue <= 3) return 'Medium';
    return 'Low';
  }

  Color _getStatusColor(String status) {
    switch (status) {
      case 'Pending':
        return Colors.grey;
      case 'Overdue':
        return Colors.red;
      case 'Submitted':
        return Colors.orange;
      case 'Graded':
        return Colors.green;
      default:
        return Colors.grey;
    }
  }

  IconData _getStatusIcon(String status) {
    switch (status) {
      case 'Pending':
        return Icons.pending_outlined;
      case 'Overdue':
        return Icons.warning_outlined;
      case 'Submitted':
        return Icons.check_circle_outline;
      case 'Graded':
        return Icons.grade;
      default:
        return Icons.assignment_outlined;
    }
  }

  Color _getGradeColor(String grade) {
    if (grade.startsWith('A')) return Colors.green;
    if (grade.startsWith('B')) return Colors.blue;
    if (grade.startsWith('C')) return Colors.orange;
    if (grade.startsWith('D')) return Colors.red;
    if (grade.startsWith('F')) return Colors.red[800]!;
    return Colors.grey;
  }

  String _formatDueDate(DateTime date) {
    final now = DateTime.now();
    final difference = date.difference(now);

    if (difference.inDays == 0) {
      if (difference.inHours > 0) {
        return 'Due in ${difference.inHours}h';
      } else if (difference.inMinutes > 0) {
        return 'Due in ${difference.inMinutes}m';
      } else {
        return 'Due now';
      }
    } else if (difference.inDays == 1) {
      return 'Due tomorrow';
    } else if (difference.inDays == -1) {
      return 'Due yesterday';
    } else if (difference.inDays > 0 && difference.inDays < 7) {
      return 'Due in ${difference.inDays} days';
    } else if (difference.inDays < 0 && difference.inDays > -7) {
      return '${-difference.inDays} days overdue';
    } else {
      return 'Due ${date.day}/${date.month}/${date.year}';
    }
  }

  void _showAssignmentDetails(StudentAssignment studentAssignment) {
    showModalBottomSheet(
      context: context,
      isScrollControlled: true,
      backgroundColor: Colors.transparent,
      builder: (context) => AssignmentDetailSheet(studentAssignment: studentAssignment),
    );
  }

  void _showFeedbackDialog(StudentAssignment studentAssignment) {
    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        title: const Text('Teacher Feedback'),
        content: Column(
          mainAxisSize: MainAxisSize.min,
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(
              'Grade: ${studentAssignment.letterGrade ?? 'N/A'}',
              style: const TextStyle(
                fontSize: 18,
                fontWeight: FontWeight.bold,
              ),
            ),
            const SizedBox(height: 8),
            Text('Points: ${studentAssignment.earnedPoints?.toInt() ?? 0}/${studentAssignment.assignment.totalPoints.toInt()}'),
            const SizedBox(height: 16),
            const Text(
              'Feedback:',
              style: TextStyle(fontWeight: FontWeight.w600),
            ),
            const SizedBox(height: 8),
            Text(studentAssignment.feedback ?? 'No feedback provided'),
          ],
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(context),
            child: const Text('Close'),
          ),
        ],
      ),
    );
  }
}

// Assignment Detail Sheet
class AssignmentDetailSheet extends StatelessWidget {
  final StudentAssignment studentAssignment;

  const AssignmentDetailSheet({
    super.key,
    required this.studentAssignment,
  });

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final assignment = studentAssignment.assignment;

    return Container(
      decoration: BoxDecoration(
        color: theme.colorScheme.surface,
        borderRadius: const BorderRadius.vertical(top: Radius.circular(20)),
      ),
      child: DraggableScrollableSheet(
        initialChildSize: 0.7,
        minChildSize: 0.5,
        maxChildSize: 0.95,
        expand: false,
        builder: (context, scrollController) {
          return CustomScrollView(
            controller: scrollController,
            slivers: [
              // Handle Bar
              SliverToBoxAdapter(
                child: Center(
                  child: Container(
                    margin: const EdgeInsets.only(top: 12, bottom: 20),
                    width: 40,
                    height: 4,
                    decoration: BoxDecoration(
                      color: Theme.of(context).colorScheme.onSurfaceVariant.withAlpha(77),
                      borderRadius: BorderRadius.circular(2),
                    ),
                  ),
                ),
              ),
              // Content
              SliverPadding(
                padding: const EdgeInsets.symmetric(horizontal: 24),
                sliver: SliverList(
                  delegate: SliverChildListDelegate([
                    // Title and Status
                    Row(
                      children: [
                        Expanded(
                          child: Text(
                            assignment.title,
                            style: theme.textTheme.headlineSmall?.copyWith(
                              fontWeight: FontWeight.bold,
                            ),
                          ),
                        ),
                        _buildStatusBadge(studentAssignment.status),
                      ],
                    ),
                    const SizedBox(height: 8),
                    // Class and Teacher
                    Row(
                      children: [
                        Icon(
                          Icons.class_,
                          size: 16,
                          color: theme.colorScheme.onSurfaceVariant,
                        ),
                        const SizedBox(width: 4),
                        Text(
                          '${assignment.category} • ${assignment.teacherName}',
                          style: theme.textTheme.bodyLarge?.copyWith(
                            color: theme.colorScheme.onSurfaceVariant,
                          ),
                        ),
                      ],
                    ),
                    const SizedBox(height: 24),

                    // Description
                    if (assignment.description.isNotEmpty) ...[
                      Text(
                        'Description',
                        style: theme.textTheme.titleMedium?.copyWith(
                          fontWeight: FontWeight.bold,
                        ),
                      ),
                      const SizedBox(height: 8),
                      Text(
                        assignment.description,
                        style: theme.textTheme.bodyMedium,
                      ),
                      const SizedBox(height: 24),
                    ],

                    // Instructions
                    Text(
                      'Instructions',
                      style: theme.textTheme.titleMedium?.copyWith(
                        fontWeight: FontWeight.bold,
                      ),
                    ),
                    const SizedBox(height: 8),
                    Text(
                      assignment.instructions,
                      style: theme.textTheme.bodyMedium,
                    ),
                    const SizedBox(height: 24),

                    // Assignment Details
                    Text(
                      'Assignment Details',
                      style: theme.textTheme.titleMedium?.copyWith(
                        fontWeight: FontWeight.bold,
                      ),
                    ),
                    const SizedBox(height: 12),
                    _buildDetailRow('Type', assignment.type.name.toUpperCase()),
                    _buildDetailRow('Points', '${assignment.totalPoints.toInt()}'),
                    _buildDetailRow('Due Date', _formatDetailDate(assignment.dueDate)),
                    if (assignment.allowLateSubmissions)
                      _buildDetailRow('Late Penalty', '${assignment.latePenaltyPercentage}% per day'),

                    if (studentAssignment.isSubmitted) ...[
                      const SizedBox(height: 24),
                      Text(
                        'Submission Details',
                        style: theme.textTheme.titleMedium?.copyWith(
                          fontWeight: FontWeight.bold,
                        ),
                      ),
                      const SizedBox(height: 12),
                      if (studentAssignment.submission != null)
                        _buildDetailRow('Submitted', _formatDetailDate(studentAssignment.submission!.submittedAt)),
                      if (studentAssignment.isGraded) ...[
                        _buildDetailRow('Grade', studentAssignment.letterGrade ?? 'N/A'),
                        _buildDetailRow('Points Earned', '${studentAssignment.earnedPoints?.toInt() ?? 0}/${assignment.totalPoints.toInt()}'),
                        if (studentAssignment.feedback != null) ...[
                          const SizedBox(height: 16),
                          Text(
                            'Teacher Feedback',
                            style: theme.textTheme.titleMedium?.copyWith(
                              fontWeight: FontWeight.bold,
                            ),
                          ),
                          const SizedBox(height: 8),
                          Container(
                            padding: const EdgeInsets.all(12),
                            decoration: BoxDecoration(
                              color: theme.colorScheme.surfaceContainerHighest,
                              borderRadius: BorderRadius.circular(8),
                            ),
                            child: Text(studentAssignment.feedback!),
                          ),
                        ],
                      ],
                    ],

                    const SizedBox(height: 32),
                  ]),
                ),
              ),
            ],
          );
        },
      ),
    );
  }

  Widget _buildStatusBadge(String status) {
    Color color = _getStatusColor(status);

    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 6),
      decoration: BoxDecoration(
        color: color.withAlpha(26),
        borderRadius: BorderRadius.circular(20),
      ),
      child: Text(
        status,
        style: TextStyle(
          color: color,
          fontWeight: FontWeight.w600,
          fontSize: 12,
        ),
      ),
    );
  }

  Color _getStatusColor(String status) {
    switch (status) {
      case 'Pending':
        return Colors.grey;
      case 'Overdue':
        return Colors.red;
      case 'Submitted':
        return Colors.orange;
      case 'Graded':
        return Colors.green;
      default:
        return Colors.grey;
    }
  }

  Widget _buildDetailRow(String label, String value) {
    return Padding(
      padding: const EdgeInsets.symmetric(vertical: 4),
      child: Row(
        mainAxisAlignment: MainAxisAlignment.spaceBetween,
        children: [
          Text(
            label,
            style: const TextStyle(color: Colors.grey),
          ),
          Text(
            value,
            style: const TextStyle(fontWeight: FontWeight.w600),
          ),
        ],
      ),
    );
  }

  String _formatDetailDate(DateTime date) {
    final months = [
      'January', 'February', 'March', 'April', 'May', 'June',
      'July', 'August', 'September', 'October', 'November', 'December'
    ];
    return '${months[date.month - 1]} ${date.day}, ${date.year}';
  }
}
````

## File: lib/features/assignments/presentation/screens/teacher/assignment_create_screen.dart
````dart
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:provider/provider.dart';
import 'package:go_router/go_router.dart';
import '../../../domain/models/assignment.dart';
import '../../../../../features/auth/presentation/providers/auth_provider.dart';
import '../../providers/assignment_provider.dart';

class AssignmentCreateScreen extends StatefulWidget {
  final String? classId;
  
  const AssignmentCreateScreen({
    super.key,
    this.classId,
  });

  @override
  State<AssignmentCreateScreen> createState() => _AssignmentCreateScreenState();
}

class _AssignmentCreateScreenState extends State<AssignmentCreateScreen> {
  final _formKey = GlobalKey<FormState>();
  final _titleController = TextEditingController();
  final _descriptionController = TextEditingController();
  final _instructionsController = TextEditingController();
  final _maxPointsController = TextEditingController();
  
  DateTime _dueDate = DateTime.now().add(const Duration(days: 7));
  TimeOfDay _dueTime = const TimeOfDay(hour: 23, minute: 59);
  AssignmentType _selectedType = AssignmentType.essay;
  AssignmentStatus _selectedStatus = AssignmentStatus.draft;
  bool _isPublished = false;
  bool _allowLateSubmissions = true;
  int _latePenaltyPercentage = 10;
  bool _isLoading = false;
  
  // Scheduled publishing
  int _publishOption = 0; // 0: draft, 1: immediate, 2: scheduled
  DateTime _publishDate = DateTime.now();
  TimeOfDay _publishTime = TimeOfDay.now();


  @override
  void dispose() {
    _titleController.dispose();
    _descriptionController.dispose();
    _instructionsController.dispose();
    _maxPointsController.dispose();
    super.dispose();
  }

  Future<void> _selectDueDate() async {
    final DateTime? picked = await showDatePicker(
      context: context,
      initialDate: _dueDate,
      firstDate: DateTime.now(),
      lastDate: DateTime.now().add(const Duration(days: 365)),
    );
    if (picked != null && picked != _dueDate) {
      setState(() {
        _dueDate = picked;
      });
    }
  }

  Future<void> _selectDueTime() async {
    final TimeOfDay? picked = await showTimePicker(
      context: context,
      initialTime: _dueTime,
    );
    if (picked != null && picked != _dueTime) {
      setState(() {
        _dueTime = picked;
      });
    }
  }

  DateTime _combineDateAndTime() {
    return DateTime(
      _dueDate.year,
      _dueDate.month,
      _dueDate.day,
      _dueTime.hour,
      _dueTime.minute,
    );
  }

  Future<void> _createAssignment() async {
    if (!_formKey.currentState!.validate()) {
      return;
    }


    setState(() => _isLoading = true);

    try {
      final authProvider = context.read<AuthProvider>();
      final assignmentProvider = context.read<AssignmentProvider>();
      final user = authProvider.userModel;
      
      if (user == null) {
        throw Exception('User not authenticated');
      }

      // Determine publish at date based on publish option
      DateTime? publishAt;
      
      if (_publishOption == 1) {
        // Publish immediately
        publishAt = null;
      } else if (_publishOption == 2) {
        // Scheduled publishing
        publishAt = DateTime(
          _publishDate.year,
          _publishDate.month,
          _publishDate.day,
          _publishTime.hour,
          _publishTime.minute,
        );
      }
      
      final assignment = Assignment(
        id: '',
        title: _titleController.text.trim(),
        description: _descriptionController.text.trim(),
        instructions: _instructionsController.text.trim(),
        type: _selectedType,
        status: _selectedStatus,
        category: _selectedType.name.toUpperCase(),
        classId: widget.classId ?? '',
        teacherId: user.uid,
        teacherName: user.displayName,
        totalPoints: double.parse(_maxPointsController.text),
        maxPoints: double.parse(_maxPointsController.text),
        dueDate: _combineDateAndTime(),
        isPublished: _isPublished,
        allowLateSubmissions: _allowLateSubmissions,
        latePenaltyPercentage: _latePenaltyPercentage,
        createdAt: DateTime.now(),
        updatedAt: DateTime.now(),
        publishAt: publishAt,
      );

      final success = await assignmentProvider.createAssignment(assignment);

      if (success && mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('Assignment "${assignment.title}" created successfully'),
            backgroundColor: Colors.green,
          ),
        );
        context.pop();
      }
    } catch (e) {
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('Error creating assignment: $e'),
            backgroundColor: Colors.red,
          ),
        );
      }
    } finally {
      if (mounted) {
        setState(() => _isLoading = false);
      }
    }
  }

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    
    return Scaffold(
      appBar: AppBar(
        title: const Text('Create Assignment'),
        actions: [
          TextButton.icon(
            onPressed: _isLoading ? null : _createAssignment,
            icon: const Icon(Icons.save),
            label: const Text('Save'),
          ),
        ],
      ),
      body: Form(
        key: _formKey,
        child: ListView(
          padding: const EdgeInsets.all(16.0),
          children: [
            Card(
              child: Padding(
                padding: const EdgeInsets.all(16.0),
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Text(
                      'Basic Information',
                      style: theme.textTheme.titleLarge,
                    ),
                    const SizedBox(height: 16),
                    TextFormField(
                      controller: _titleController,
                      decoration: const InputDecoration(
                        labelText: 'Assignment Title',
                        prefixIcon: Icon(Icons.title),
                      ),
                      validator: (value) {
                        if (value == null || value.isEmpty) {
                          return 'Please enter a title';
                        }
                        return null;
                      },
                    ),
                    const SizedBox(height: 16),
                    TextFormField(
                      controller: _descriptionController,
                      decoration: const InputDecoration(
                        labelText: 'Brief Description',
                        prefixIcon: Icon(Icons.description),
                      ),
                      maxLines: 2,
                      validator: (value) {
                        if (value == null || value.isEmpty) {
                          return 'Please enter a description';
                        }
                        return null;
                      },
                    ),
                    const SizedBox(height: 16),
                    DropdownButtonFormField<AssignmentType>(
                      value: _selectedType,
                      decoration: const InputDecoration(
                        labelText: 'Assignment Type',
                        prefixIcon: Icon(Icons.category),
                      ),
                      items: AssignmentType.values.map((type) {
                        return DropdownMenuItem(
                          value: type,
                          child: Text(type.name.toUpperCase()),
                        );
                      }).toList(),
                      onChanged: (value) {
                        setState(() {
                          _selectedType = value!;
                        });
                      },
                    ),
                  ],
                ),
              ),
            ),
            const SizedBox(height: 16),
            Card(
              child: Padding(
                padding: const EdgeInsets.all(16.0),
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Text(
                      'Instructions',
                      style: theme.textTheme.titleLarge,
                    ),
                    const SizedBox(height: 16),
                    TextFormField(
                      controller: _instructionsController,
                      decoration: const InputDecoration(
                        labelText: 'Detailed Instructions',
                        hintText: 'Provide clear instructions for students...',
                        prefixIcon: Icon(Icons.article),
                        alignLabelWithHint: true,
                      ),
                      maxLines: 5,
                      validator: (value) {
                        if (value == null || value.isEmpty) {
                          return 'Please provide instructions';
                        }
                        return null;
                      },
                    ),
                  ],
                ),
              ),
            ),
            const SizedBox(height: 16),
            Card(
              child: Padding(
                padding: const EdgeInsets.all(16.0),
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Text(
                      'Grading & Submission',
                      style: theme.textTheme.titleLarge,
                    ),
                    const SizedBox(height: 16),
                    TextFormField(
                      controller: _maxPointsController,
                      decoration: const InputDecoration(
                        labelText: 'Maximum Points',
                        prefixIcon: Icon(Icons.score),
                      ),
                      keyboardType: TextInputType.number,
                      inputFormatters: [
                        FilteringTextInputFormatter.digitsOnly,
                      ],
                      validator: (value) {
                        if (value == null || value.isEmpty) {
                          return 'Enter points';
                        }
                        final points = int.tryParse(value);
                        if (points == null || points <= 0) {
                          return 'Invalid points';
                        }
                        return null;
                      },
                    ),
                    const SizedBox(height: 16),
                    Row(
                      children: [
                        Expanded(
                          child: InkWell(
                            onTap: _selectDueDate,
                            child: InputDecorator(
                              decoration: const InputDecoration(
                                labelText: 'Due Date',
                                prefixIcon: Icon(Icons.calendar_today),
                              ),
                              child: Text(
                                '${_dueDate.month}/${_dueDate.day}/${_dueDate.year}',
                              ),
                            ),
                          ),
                        ),
                        const SizedBox(width: 16),
                        Expanded(
                          child: InkWell(
                            onTap: _selectDueTime,
                            child: InputDecorator(
                              decoration: const InputDecoration(
                                labelText: 'Due Time',
                                prefixIcon: Icon(Icons.access_time),
                              ),
                              child: Text(
                                _dueTime.format(context),
                              ),
                            ),
                          ),
                        ),
                      ],
                    ),
                    const SizedBox(height: 16),
                    SwitchListTile(
                      title: const Text('Allow Late Submissions'),
                      subtitle: const Text('Students can submit after due date with penalty'),
                      value: _allowLateSubmissions,
                      onChanged: (value) {
                        setState(() {
                          _allowLateSubmissions = value;
                        });
                      },
                    ),
                    if (_allowLateSubmissions)
                      Padding(
                        padding: const EdgeInsets.only(left: 16.0),
                        child: Row(
                          children: [
                            const Text('Late Penalty: '),
                            SizedBox(
                              width: 100,
                              child: Slider(
                                value: _latePenaltyPercentage.toDouble(),
                                min: 0,
                                max: 50,
                                divisions: 10,
                                label: '$_latePenaltyPercentage%',
                                onChanged: (value) {
                                  setState(() {
                                    _latePenaltyPercentage = value.round();
                                  });
                                },
                              ),
                            ),
                            Text('$_latePenaltyPercentage% per day'),
                          ],
                        ),
                      ),
                  ],
                ),
              ),
            ),
            const SizedBox(height: 16),
            Card(
              child: Padding(
                padding: const EdgeInsets.all(16.0),
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Text(
                      'Publishing Options',
                      style: theme.textTheme.titleLarge,
                    ),
                    const SizedBox(height: 16),
                    RadioListTile<int>(
                      title: const Text('Save as Draft'),
                      subtitle: const Text('Assignment will not be visible to students'),
                      value: 0,
                      groupValue: _publishOption,
                      onChanged: (value) {
                        setState(() {
                          _publishOption = value!;
                          _isPublished = false;
                          _selectedStatus = AssignmentStatus.draft;
                        });
                      },
                    ),
                    RadioListTile<int>(
                      title: const Text('Publish Immediately'),
                      subtitle: const Text('Students can see and submit the assignment'),
                      value: 1,
                      groupValue: _publishOption,
                      onChanged: (value) {
                        setState(() {
                          _publishOption = value!;
                          _isPublished = true;
                          _selectedStatus = AssignmentStatus.active;
                        });
                      },
                    ),
                    RadioListTile<int>(
                      title: const Text('Schedule for Later'),
                      subtitle: const Text('Assignment will become visible at a future date'),
                      value: 2,
                      groupValue: _publishOption,
                      onChanged: (value) {
                        setState(() {
                          _publishOption = value!;
                          _isPublished = false;
                          _selectedStatus = AssignmentStatus.draft;
                        });
                      },
                    ),
                    if (_publishOption == 2) ...[
                      const SizedBox(height: 16),
                      Row(
                        children: [
                          Expanded(
                            child: InkWell(
                              onTap: () async {
                                final DateTime? picked = await showDatePicker(
                                  context: context,
                                  initialDate: _publishDate,
                                  firstDate: DateTime.now(),
                                  lastDate: _dueDate,
                                );
                                if (picked != null) {
                                  setState(() {
                                    _publishDate = picked;
                                  });
                                }
                              },
                              child: InputDecorator(
                                decoration: const InputDecoration(
                                  labelText: 'Publish Date',
                                  prefixIcon: Icon(Icons.calendar_today),
                                ),
                                child: Text(
                                  '${_publishDate.month}/${_publishDate.day}/${_publishDate.year}',
                                ),
                              ),
                            ),
                          ),
                          const SizedBox(width: 16),
                          Expanded(
                            child: InkWell(
                              onTap: () async {
                                final TimeOfDay? picked = await showTimePicker(
                                  context: context,
                                  initialTime: _publishTime,
                                );
                                if (picked != null) {
                                  setState(() {
                                    _publishTime = picked;
                                  });
                                }
                              },
                              child: InputDecorator(
                                decoration: const InputDecoration(
                                  labelText: 'Publish Time',
                                  prefixIcon: Icon(Icons.access_time),
                                ),
                                child: Text(
                                  _publishTime.format(context),
                                ),
                              ),
                            ),
                          ),
                        ],
                      ),
                    ],
                  ],
                ),
              ),
            ),
            const SizedBox(height: 32),
          ],
        ),
      ),
    );
  }
}
````

## File: lib/features/auth/data/repositories/auth_repository_impl.dart
````dart
/// Concrete implementation of the authentication repository.
/// 
/// This module implements the AuthRepository interface by delegating
/// all operations to the AuthService, providing a clean separation
/// between the repository pattern and service layer.
library;

import 'package:firebase_auth/firebase_auth.dart';
import '../../../../shared/models/user_model.dart';
import '../services/auth_service.dart';
import '../../domain/repositories/auth_repository.dart';

/// Concrete authentication repository implementation.
/// 
/// This class implements the AuthRepository interface by delegating
/// all authentication operations to the underlying AuthService.
/// It acts as an adapter between the repository pattern used by
/// the application and the service layer that handles the actual
/// authentication logic.
/// 
/// The repository pattern provides:
/// - Abstraction of data source implementation details
/// - Testability through interface-based design  
/// - Flexibility to switch authentication providers
/// - Consistent API for the application layer
class AuthRepositoryImpl extends AuthRepository {
  /// The authentication service handling actual auth operations.
  final AuthService _authService;
  
  /// Creates an authentication repository instance.
  /// 
  /// @param _authService Service instance for authentication
  AuthRepositoryImpl(this._authService);
  
  @override
  Stream<User?> get authStateChanges => _authService.authStateChanges;
  
  @override
  User? get currentUser => _authService.currentUser;
  
  @override
  Future<UserModel?> getCurrentUserModel() => _authService.getCurrentUserModel();
  
  @override
  Future<User?> signUpWithEmailOnly({
    required String email,
    required String password,
    required String displayName,
    required String firstName,
    required String lastName,
  }) =>
      _authService.signUpWithEmailOnly(
        email: email,
        password: password,
        displayName: displayName,
        firstName: firstName,
        lastName: lastName,
      );  
  @override
  Future<UserModel?> signUpWithEmail({
    required String email,
    required String password,
    required String displayName,
    UserRole? role,
    String? parentEmail,
    int? gradeLevel,
  }) =>
      _authService.signUpWithEmail(
        email: email,
        password: password,
        displayName: displayName,
        role: role,
        parentEmail: parentEmail,
        gradeLevel: gradeLevel,
      );
  
  @override
  Future<UserModel?> signInWithEmail({
    required String email,
    required String password,
  }) =>
      _authService.signInWithEmail(
        email: email,
        password: password,
      );
  
  @override
  Future<UserModel?> signInWithGoogle() => _authService.signInWithGoogle();  
  @override
  Future<UserModel?> completeGoogleSignUp({
    required UserRole role,
    String? parentEmail,
    int? gradeLevel,
  }) =>
      _authService.completeGoogleSignUp(
        role: role,
        parentEmail: parentEmail,
        gradeLevel: gradeLevel,
      );
  
  @override
  Future<void> signOut() => _authService.signOut();
  
  @override
  Future<void> resetPassword(String email) => _authService.resetPassword(email);
  
  @override
  Future<void> updateProfile({
    String? displayName,
    String? firstName,
    String? lastName,
    String? photoURL,
    bool updatePhoto = false,
  }) =>
      _authService.updateProfile(
        displayName: displayName,
        firstName: firstName,
        lastName: lastName,
        photoURL: photoURL,
        updatePhoto: updatePhoto,
      );
}
````

## File: lib/features/auth/data/repositories/user_repository_impl.dart
````dart
/// Concrete implementation of the user repository.
/// 
/// This module implements the UserRepository interface using
/// Firebase Firestore for data persistence, providing user
/// management functionality for the educational platform.
library;

import 'package:cloud_firestore/cloud_firestore.dart';
import '../../../../shared/models/user_model.dart';
import '../../domain/repositories/user_repository.dart';

/// Firebase implementation of UserRepository.
/// 
/// Manages user profiles in Firestore with support for:
/// - User creation and updates
/// - Role-based queries
/// - Search functionality
/// - Batch operations
class UserRepositoryImpl implements UserRepository {
  final FirebaseFirestore _firestore;
  static const String _collection = 'users';
  
  /// Creates repository with Firestore instance.
  UserRepositoryImpl(this._firestore);
  
  @override
  Future<UserModel?> getUserById(String userId) async {
    try {
      final doc = await _firestore.collection(_collection).doc(userId).get();
      
      if (!doc.exists) return null;
      
      return UserModel.fromFirestore(doc);
    } catch (e) {
      throw Exception('Failed to get user: $e');
    }
  }
  
  @override
  Future<UserModel?> getUserByEmail(String email) async {
    try {
      final query = await _firestore
          .collection(_collection)
          .where('email', isEqualTo: email)
          .limit(1)
          .get();
      
      if (query.docs.isEmpty) return null;
      
      return UserModel.fromFirestore(query.docs.first);
    } catch (e) {
      throw Exception('Failed to get user by email: $e');
    }
  }
  
  @override
  Future<void> createUser(UserModel user) async {
    try {
      await _firestore.collection(_collection).doc(user.uid).set(
        user.toFirestore(),
      );
    } catch (e) {
      throw Exception('Failed to create user: $e');
    }
  }
  
  @override
  Future<void> updateUser(UserModel user) async {
    try {
      await _firestore.collection(_collection).doc(user.uid).update(
        user.toFirestore(),
      );
    } catch (e) {
      throw Exception('Failed to update user: $e');
    }
  }
  
  @override
  Stream<List<UserModel>> getUsersByRole(String role) {
    return _firestore
        .collection(_collection)
        .where('role', isEqualTo: role)
        .snapshots()
        .map((snapshot) => snapshot.docs
            .map((doc) => UserModel.fromFirestore(doc))
            .toList());
  }
  
  @override
  Stream<List<UserModel>> getTeachers() {
    return getUsersByRole('teacher');
  }
  
  @override
  Stream<List<UserModel>> getStudents() {
    return getUsersByRole('student');
  }
  
  @override
  Future<void> updateLastActive(String userId) async {
    try {
      await _firestore.collection(_collection).doc(userId).update({
        'lastActive': FieldValue.serverTimestamp(),
      });
    } catch (e) {
      throw Exception('Failed to update last active: $e');
    }
  }
  
  @override
  Future<bool> userExists(String userId) async {
    try {
      final doc = await _firestore.collection(_collection).doc(userId).get();
      return doc.exists;
    } catch (e) {
      throw Exception('Failed to check user existence: $e');
    }
  }
  
  @override
  Future<void> deleteUser(String userId) async {
    try {
      await _firestore.collection(_collection).doc(userId).delete();
    } catch (e) {
      throw Exception('Failed to delete user: $e');
    }
  }
  
  @override
  Future<List<UserModel>> searchUsers(String query) async {
    try {
      final lowercaseQuery = query.toLowerCase();
      
      // Search by display name
      final nameQuery = await _firestore
          .collection(_collection)
          .where('displayNameLowercase', isGreaterThanOrEqualTo: lowercaseQuery)
          .where('displayNameLowercase', isLessThanOrEqualTo: '$lowercaseQuery\uf8ff')
          .limit(20)
          .get();
      
      // Search by email
      final emailQuery = await _firestore
          .collection(_collection)
          .where('email', isGreaterThanOrEqualTo: lowercaseQuery)
          .where('email', isLessThanOrEqualTo: '$lowercaseQuery\uf8ff')
          .limit(20)
          .get();
      
      // Combine and deduplicate results
      final userMap = <String, UserModel>{};
      
      for (final doc in nameQuery.docs) {
        final user = UserModel.fromFirestore(doc);
        userMap[user.uid] = user;
      }
      
      for (final doc in emailQuery.docs) {
        final user = UserModel.fromFirestore(doc);
        userMap[user.uid] = user;
      }
      
      return userMap.values.toList();
    } catch (e) {
      throw Exception('Failed to search users: $e');
    }
  }
  
  @override
  Future<List<UserModel>> getUsersByIds(List<String> userIds) async {
    try {
      if (userIds.isEmpty) return [];
      
      // Firestore has a limit of 10 for 'whereIn' queries
      final chunks = <List<String>>[];
      for (var i = 0; i < userIds.length; i += 10) {
        chunks.add(
          userIds.sublist(i, i + 10 > userIds.length ? userIds.length : i + 10),
        );
      }
      
      final users = <UserModel>[];
      
      for (final chunk in chunks) {
        final query = await _firestore
            .collection(_collection)
            .where(FieldPath.documentId, whereIn: chunk)
            .get();
        
        users.addAll(
          query.docs.map((doc) => UserModel.fromFirestore(doc)),
        );
      }
      
      return users;
    } catch (e) {
      throw Exception('Failed to get users by IDs: $e');
    }
  }
}
````

## File: lib/features/auth/data/services/auth_service.dart
````dart
/// Authentication service for managing user authentication and profiles.
/// 
/// This service provides comprehensive authentication functionality including:
/// - Email/password authentication
/// - Google OAuth authentication
/// - User profile management
/// - Role-based user creation
/// - Password reset functionality
library;

import 'dart:async';
import 'package:flutter/foundation.dart';
import 'package:firebase_auth/firebase_auth.dart';
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:google_sign_in/google_sign_in.dart';
import '../../../../shared/models/user_model.dart';
import 'google_sign_in_service.dart';
import '../../../../shared/services/logger_service.dart';

/// Core authentication service handling all auth-related operations.
/// 
/// This service manages the complete authentication lifecycle:
/// - User registration with role selection
/// - Multiple authentication methods (email, Google)
/// - Profile creation and updates
/// - Session management
/// - Error handling with user-friendly messages
/// 
/// The service gracefully handles Firebase initialization failures
/// for development environments without Firebase configuration.
class AuthService {
  /// Firebase Authentication instance for auth operations.
  /// Nullable to handle cases where Firebase is not initialized.
  FirebaseAuth? _auth;
  
  /// Firestore instance for user profile management.
  /// Nullable to handle cases where Firebase is not initialized.
  FirebaseFirestore? _firestore;
  
  /// Google Sign-In service instance.
  final GoogleSignInService _googleSignInService = GoogleSignInService();

  /// Initializes the authentication service.
  /// 
  /// Attempts to get Firebase instances with graceful fallback
  /// for development environments without Firebase configuration.
  /// Errors are caught and logged in debug mode without throwing.
  AuthService() {
    try {
      _auth = FirebaseAuth.instance;
      _firestore = FirebaseFirestore.instance;
    } catch (e) {
      LoggerService.debug('Firebase not available', tag: 'AuthService');
    }
  }
  

  /// Stream that emits auth state changes.
  /// 
  /// Provides real-time updates when:
  /// - User signs in
  /// - User signs out
  /// - User's auth token refreshes
  /// 
  /// Returns empty stream if Firebase Auth is not available.
  /// Catches and logs errors in debug mode for resilience.
  /// 
  /// @return Stream emitting current User or null
  Stream<User?> get authStateChanges {
    if (_auth == null) {
      LoggerService.debug('Firebase Auth not available', tag: 'AuthService');
      return Stream.value(null);
    }
    try {
      return _auth!.authStateChanges();
    } catch (e) {
      LoggerService.debug('Firebase Auth error', tag: 'AuthService');
      return Stream.value(null);
    }
  }

  /// Gets the currently authenticated Firebase user.
  /// 
  /// Returns null in the following cases:
  /// - No user is signed in
  /// - Firebase Auth is not available
  /// - An error occurs accessing the current user
  /// 
  /// Errors are caught and logged in debug mode.
  /// 
  /// @return Current Firebase User or null
  User? get currentUser {
    if (_auth == null) {
      LoggerService.debug('Firebase Auth not available', tag: 'AuthService');
      return null;
    }
    try {
      return _auth!.currentUser;
    } catch (e) {
      LoggerService.debug('Firebase Auth error', tag: 'AuthService');
      return null;
    }
  }

  /// Retrieves the complete UserModel for the current user.
  /// 
  /// Fetches the user's profile data from Firestore based on
  /// the current authentication state. This includes:
  /// - User role (teacher/student/admin)
  /// - Profile information
  /// - Settings and preferences
  /// 
  /// Returns null if:
  /// - No user is authenticated
  /// - Firestore is not available
  /// - User document doesn't exist
  /// - An error occurs during fetch
  /// 
  /// @return UserModel instance or null
  Future<UserModel?> getCurrentUserModel() async {
    if (_firestore == null) {
      LoggerService.debug('Firestore not available', tag: 'AuthService');
      return null;
    }
    
    final user = currentUser;
    if (user == null) return null;

    try {
      final doc = await _firestore!.collection('users').doc(user.uid).get();
      if (doc.exists) {
        return UserModel.fromFirestore(doc);
      }
      return null;
    } catch (e) {
      LoggerService.debug('Error getting user model', tag: 'AuthService');
      return null;
    }
  }

  /// Creates an authentication account without completing profile setup.
  /// 
  /// This method is used for the two-step registration process:
  /// 1. Create Firebase Auth account (this method)
  /// 2. Select role and complete profile (separate step)
  /// 
  /// Stores temporary user data in 'pending_users' collection
  /// for later profile completion. This allows role selection
  /// after initial account creation.
  /// 
  /// @param email User's email address
  /// @param password User's chosen password
  /// @param displayName Full display name
  /// @param firstName User's first name
  /// @param lastName User's last name
  /// @return Firebase User if successful, null otherwise
  /// @throws Exception if Firebase is not available
  /// @throws String error message for auth failures
  Future<User?> signUpWithEmailOnly({
    required String email,
    required String password,
    required String displayName,
    required String firstName,
    required String lastName,
  }) async {
    if (_auth == null) {
      throw Exception('Firebase not available - cannot sign up');
    }
    
    try {
      // Create auth user
      final credential = await _auth!.createUserWithEmailAndPassword(
        email: email,
        password: password,
      );

      if (credential.user == null) return null;

      // Update display name
      await credential.user!.updateDisplayName(displayName);
      
      // Store temporary user data in Firestore for role selection
      await _firestore!.collection('pending_users').doc(credential.user!.uid).set({
        'email': email,
        'displayName': displayName,
        'firstName': firstName,
        'lastName': lastName,
        'createdAt': FieldValue.serverTimestamp(),
      });

      return credential.user;
    } on FirebaseAuthException catch (e) {
      throw _handleAuthException(e);
    }
  }

  /// Creates a complete user account with authentication and profile.
  /// 
  /// This method performs full user registration:
  /// 1. Creates Firebase Auth account
  /// 2. Creates user profile in Firestore
  /// 3. Sets up role-specific fields
  /// 
  /// Automatically parses display name into first/last names
  /// and configures role-specific fields like teacherId/studentId.
  /// 
  /// @param email User's email address
  /// @param password User's chosen password
  /// @param displayName Full display name
  /// @param role User's role (teacher/student/admin)
  /// @param parentEmail Parent's email (students only)
  /// @param gradeLevel Student's grade level (students only)
  /// @return Complete UserModel if successful, null otherwise
  /// @throws Exception if Firebase is not available
  /// @throws String error message for auth failures
  Future<UserModel?> signUpWithEmail({
    required String email,
    required String password,
    required String displayName,
    UserRole? role,
    String? parentEmail,
    int? gradeLevel,
  }) async {
    if (_auth == null || _firestore == null) {
      throw Exception('Firebase not available - cannot sign up');
    }
    
    try {
      // Create auth user
      final credential = await _auth!.createUserWithEmailAndPassword(
        email: email,
        password: password,
      );

      if (credential.user == null) return null;

      // Update display name
      await credential.user!.updateDisplayName(displayName);

      // Parse first and last names from displayName
      final nameParts = displayName.split(' ');
      final firstName = nameParts.isNotEmpty ? nameParts.first : '';
      final lastName = nameParts.length > 1 ? nameParts.sublist(1).join(' ') : '';
      
      // Create user document in Firestore
      final userModel = UserModel(
        uid: credential.user!.uid,
        email: email,
        displayName: displayName,
        firstName: firstName,
        lastName: lastName,
        role: role,
        createdAt: DateTime.now(),
        lastActive: DateTime.now(),
        parentEmail: role == UserRole.student ? parentEmail : null,
        gradeLevel: role == UserRole.student ? gradeLevel : null,
        teacherId: role == UserRole.teacher ? credential.user!.uid : null,
        studentId: role == UserRole.student ? credential.user!.uid : null,
      );

      await _firestore!
          .collection('users')
          .doc(credential.user!.uid)
          .set(userModel.toFirestore());

      return userModel;
    } on FirebaseAuthException catch (e) {
      throw _handleAuthException(e);
    }
  }

  /// Authenticates a user with email and password.
  /// 
  /// Performs sign-in and automatically:
  /// - Updates the user's last active timestamp
  /// - Retrieves complete user profile from Firestore
  /// - Returns full UserModel with role information
  /// 
  /// @param email User's email address
  /// @param password User's password
  /// @return UserModel if successful, null if user not found
  /// @throws Exception if Firebase is not available
  /// @throws String error message for auth failures
  Future<UserModel?> signInWithEmail({
    required String email,
    required String password,
  }) async {
    if (_auth == null || _firestore == null) {
      throw Exception('Firebase not available - cannot sign in');
    }
    
    try {
      final credential = await _auth!.signInWithEmailAndPassword(
        email: email,
        password: password,
      );

      if (credential.user == null) return null;

      // Update last active
      await _updateLastActive(credential.user!.uid);

      return await getCurrentUserModel();
    } on FirebaseAuthException catch (e) {
      throw _handleAuthException(e);
    }
  }

  /// Authenticates a user using Google OAuth.
  /// 
  /// Implements Google Sign-In flow:
  /// 1. Triggers Google authentication popup
  /// 2. Obtains OAuth credentials
  /// 3. Signs in to Firebase with Google credential
  /// 4. Checks if user profile exists
  /// 
  /// For new Google users, returns null to trigger
  /// role selection flow. Existing users get their
  /// complete profile returned.
  /// 
  /// @return UserModel for existing users, null for new users
  /// @throws Exception if Firebase is not available or sign-in fails
  Future<UserModel?> signInWithGoogle() async {
    if (_auth == null || _firestore == null) {
      throw Exception('Firebase not available - cannot sign in with Google');
    }
    
    try {
      // For web platform, use Firebase Auth's OAuth flow
      if (kIsWeb) {
        // Use Firebase Auth's built-in Google provider for web
        final googleProvider = GoogleAuthProvider();
        final userCredential = await _auth!.signInWithPopup(googleProvider);
        
        if (userCredential.user == null) {
          throw Exception('Failed to sign in with Google');
        }

        // Check if user exists in Firestore
        final userDoc = await _firestore!
            .collection('users')
            .doc(userCredential.user!.uid)
            .get();

        if (!userDoc.exists) {
          // New user - need to set role
          return null; // Will handle role selection in UI
        }

        // Update last active
        await _updateLastActive(userCredential.user!.uid);

        return UserModel.fromFirestore(userDoc);
      }
      
      // For desktop platforms (Windows/Linux), google_sign_in is not supported
      // We'll need to implement a different approach for desktop
      if (!_googleSignInService.isPlatformSupported) {
        throw Exception('Google Sign-In is not supported on this platform. Please use email/password authentication or run as a web app.');
      }
      
      // For mobile platforms (Android/iOS/macOS), use the GoogleSignInService
      final GoogleSignInAccount? googleUser = await _googleSignInService.signIn();
      
      if (googleUser == null) {
        throw Exception('Google Sign-In was cancelled');
      }

      // Get authentication details from the account
      // In google_sign_in 7.x, authentication property is synchronous
      final GoogleSignInAuthentication googleAuth = googleUser.authentication;
      
      // Create a new credential using idToken
      // Note: In 7.x, access tokens are obtained separately via authorization
      // Ensure idToken is not null before creating credential
      final idToken = googleAuth.idToken;
      if (idToken == null) {
        throw Exception('Failed to get Google authentication token');
      }
      
      final credential = GoogleAuthProvider.credential(
        idToken: idToken,
        // accessToken is no longer available here - use authorization if needed
      );

      // Sign in to Firebase
      final userCredential = await _auth!.signInWithCredential(credential);
      if (userCredential.user == null) {
        throw Exception('Failed to sign in with Google credential');
      }

      // Check if user exists in Firestore
      final userDoc = await _firestore!
          .collection('users')
          .doc(userCredential.user!.uid)
          .get();

      if (!userDoc.exists) {
        // New user - need to set role
        return null; // Will handle role selection in UI
      }

      // Update last active
      await _updateLastActive(userCredential.user!.uid);

      return UserModel.fromFirestore(userDoc);
    } catch (e) {
      LoggerService.debug('Google sign in error', tag: 'AuthService');
      rethrow;
    }
  }

  /// Completes profile setup for Google-authenticated users.
  /// 
  /// Called after initial Google sign-in to:
  /// - Set user role (teacher/student)
  /// - Create complete user profile in Firestore
  /// - Migrate any pending user data
  /// - Configure role-specific fields
  /// 
  /// Handles both email signup users completing via Google
  /// and pure Google sign-in users setting up profiles.
  /// 
  /// @param role Selected user role
  /// @param parentEmail Parent's email (students only)
  /// @param gradeLevel Student's grade level (students only)
  /// @return Complete UserModel after profile creation
  /// @throws Exception if profile creation fails
  Future<UserModel?> completeGoogleSignUp({
    required UserRole role,
    String? parentEmail,
    int? gradeLevel,
  }) async {
    final user = currentUser;
    if (user == null) return null;

    try {
      // Check if we have pending user data (from email signup)
      // Handle potential null email case more safely
      final userEmail = user.email;
      if (userEmail == null) {
        throw Exception('User email is required for profile completion');
      }
      
      String firstName = '';
      String lastName = '';
      String displayName = user.displayName ?? userEmail.split('@')[0];
      
      final pendingUserDoc = await _firestore!.collection('pending_users').doc(user.uid).get();
      if (pendingUserDoc.exists) {
        final pendingData = pendingUserDoc.data();
        if (pendingData != null) {
          firstName = pendingData['firstName'] as String? ?? '';
          lastName = pendingData['lastName'] as String? ?? '';
          displayName = pendingData['displayName'] as String? ?? displayName;
        }
        
        // Delete the pending user data
        await _firestore!.collection('pending_users').doc(user.uid).delete();
      } else {
        // For Google sign-in, try to split the display name
        if (user.displayName != null) {
          final nameParts = user.displayName!.split(' ');
          firstName = nameParts.isNotEmpty ? nameParts.first : '';
          lastName = nameParts.length > 1 ? nameParts.sublist(1).join(' ') : '';
        }
      }
      
      final userModel = UserModel(
        uid: user.uid,
        email: userEmail,
        displayName: displayName,
        firstName: firstName,
        lastName: lastName,
        role: role,
        photoURL: user.photoURL,
        createdAt: DateTime.now(),
        lastActive: DateTime.now(),
        parentEmail: role == UserRole.student ? parentEmail : null,
        gradeLevel: role == UserRole.student ? gradeLevel : null,
        teacherId: role == UserRole.teacher ? user.uid : null,
        studentId: role == UserRole.student ? user.uid : null,
      );

      await _firestore!
          .collection('users')
          .doc(user.uid)
          .set(userModel.toFirestore());

      return userModel;
    } catch (e) {
      LoggerService.debug('Error completing Google sign up', tag: 'AuthService');
      rethrow;
    }
  }

  /// Signs out the current user from all auth providers.
  /// 
  /// Performs complete sign-out:
  /// - Signs out from Firebase Auth
  /// - Signs out from Google (if applicable)
  /// - Clears all authentication state
  /// 
  /// Handles partial failures gracefully using Future.wait
  /// to ensure all providers attempt sign-out.
  Future<void> signOut() async {
    final futures = <Future>[];
    if (_auth != null) futures.add(_auth!.signOut());
    
    // Sign out from Google using disconnect (clears cached auth)
    // Only attempt this on platforms that support google_sign_in
    if (_googleSignInService.isPlatformSupported) {
      try {
        // In 7.x, disconnect returns Future<void>
        futures.add(_googleSignInService.disconnect());
      } catch (e) {
        // Handle case where GoogleSignIn is not initialized
        LoggerService.debug('Google sign out error', tag: 'AuthService');
      }
    }
    
    await Future.wait(futures);
  }

  /// Sends a password reset email to the specified address.
  /// 
  /// Initiates Firebase's password reset flow:
  /// - Validates email exists in system
  /// - Sends reset link to email
  /// - User clicks link to set new password
  /// 
  /// @param email Email address to send reset link to
  /// @throws Exception if Firebase is not available
  /// @throws String error message for invalid email or other failures
  Future<void> resetPassword(String email) async {
    if (_auth == null) {
      throw Exception('Firebase not available - cannot reset password');
    }
    
    try {
      await _auth!.sendPasswordResetEmail(email: email);
    } on FirebaseAuthException catch (e) {
      throw _handleAuthException(e);
    }
  }

  /// Updates the current user's profile information.
  /// 
  /// Synchronizes changes across:
  /// - Firebase Auth profile (display name, photo)
  /// - Firestore user document
  /// 
  /// All parameters are optional - only provided fields
  /// are updated. Automatically updates last active timestamp.
  /// 
  /// @param displayName New display name
  /// @param firstName New first name
  /// @param lastName New last name
  /// @param photoURL New photo URL
  /// @param updatePhoto Whether to update the photo URL
  /// @throws Exception if update fails
  Future<void> updateProfile({
    String? displayName,
    String? firstName,
    String? lastName,
    String? photoURL,
    bool updatePhoto = false,
  }) async {
    final user = currentUser;
    if (user == null) return;

    try {
      // Update Firebase Auth profile
      if (displayName != null) {
        await user.updateDisplayName(displayName);
      }
      if (updatePhoto) {
        await user.updatePhotoURL(photoURL);
      }

      // Update Firestore document
      final updates = <String, dynamic>{};
      if (displayName != null) updates['displayName'] = displayName;
      if (firstName != null) updates['firstName'] = firstName;
      if (lastName != null) updates['lastName'] = lastName;
      if (updatePhoto) updates['photoURL'] = photoURL;
      updates['lastActive'] = FieldValue.serverTimestamp();

      await _firestore!.collection('users').doc(user.uid).update(updates);
    } catch (e) {
      LoggerService.debug('Error updating profile', tag: 'AuthService');
      rethrow;
    }
  }

  /// Updates the user's last active timestamp in Firestore.
  /// 
  /// Private helper method called during sign-in to track
  /// user activity. Uses server timestamp for consistency
  /// across different client time zones.
  /// 
  /// Fails silently with debug logging if update fails
  /// to avoid interrupting the sign-in flow.
  /// 
  /// @param uid User ID to update
  Future<void> _updateLastActive(String uid) async {
    if (_firestore == null) return;
    
    try {
      await _firestore!.collection('users').doc(uid).update({
        'lastActive': FieldValue.serverTimestamp(),
      });
    } catch (e) {
      LoggerService.debug('Error updating last active', tag: 'AuthService');
    }
  }

  /// Converts Firebase Auth exceptions to user-friendly error messages.
  /// 
  /// Maps Firebase error codes to human-readable messages that
  /// can be displayed in the UI. Covers all common auth errors:
  /// - Registration errors (weak password, email in use)
  /// - Sign-in errors (invalid credentials, disabled account)
  /// - Network and operational errors
  /// - Verification and OAuth errors
  /// 
  /// Falls back to generic message for unknown error codes.
  /// 
  /// @param e FirebaseAuthException to handle
  /// @return User-friendly error message string
  String _handleAuthException(FirebaseAuthException e) {
    switch (e.code) {
      case 'weak-password':
        return 'The password provided is too weak. Please use at least 6 characters.';
      case 'email-already-in-use':
        return 'An account already exists for this email. Please sign in instead.';
      case 'invalid-email':
        return 'The email address is invalid. Please check and try again.';
      case 'user-disabled':
        return 'This account has been disabled. Please contact support.';
      case 'user-not-found':
      case 'wrong-password':
      case 'invalid-credential':
        return 'Username or password invalid. Please try again.';
      case 'too-many-requests':
        return 'Too many failed attempts. Please try again later.';
      case 'operation-not-allowed':
        return 'Email/password accounts are not enabled. Please contact support.';
      case 'network-request-failed':
        return 'Network error. Please check your internet connection and try again.';
      case 'requires-recent-login':
        return 'This operation requires recent authentication. Please sign in again.';
      case 'invalid-verification-code':
        return 'The verification code is invalid. Please try again.';
      case 'invalid-verification-id':
        return 'The verification ID is invalid. Please try again.';
      case 'credential-already-in-use':
        return 'This credential is already associated with a different account.';
      case 'account-exists-with-different-credential':
        return 'An account already exists with the same email but different credentials.';
      default:
        return 'Authentication failed. Please try again.';
    }
  }
}
````

## File: lib/features/auth/domain/repositories/auth_repository.dart
````dart
/// Authentication repository interface for user management.
/// 
/// This module defines the contract for authentication operations
/// in the education platform, supporting multiple authentication
/// methods and user role management.
library;

import 'package:firebase_auth/firebase_auth.dart';
import '../../../../shared/models/user_model.dart';
import '../../../../shared/repositories/base_repository.dart';

/// Abstract repository defining authentication operations.
/// 
/// This interface provides a contract for authentication implementations,
/// supporting:
/// - Email/password authentication
/// - Google OAuth authentication
/// - User profile management
/// - Role-based user creation
/// - Password reset functionality
/// - Real-time auth state monitoring
/// 
/// Concrete implementations handle the actual authentication
/// logic with specific providers (e.g., Firebase Auth).
abstract class AuthRepository extends BaseRepository {
  /// Stream of authentication state changes.
  /// 
  /// Emits the current user when auth state changes (sign in/out).
  /// Emits null when no user is authenticated.
  Stream<User?> get authStateChanges;
  
  /// Gets the currently authenticated Firebase user.
  /// 
  /// Returns null if no user is signed in.
  User? get currentUser;
  
  /// Retrieves the current user's complete profile model.
  /// 
  /// Fetches the UserModel from the database for the currently
  /// authenticated user. Returns null if not authenticated or
  /// if the user profile doesn't exist.
  /// 
  /// @return Current user's profile or null
  /// @throws Exception if profile retrieval fails
  Future<UserModel?> getCurrentUserModel();
  
  /// Creates a new user account with email (Firebase Auth only).
  /// 
  /// This method only creates the Firebase Auth account without
  /// creating a user profile in Firestore. Used for initial
  /// account creation before role selection.
  /// 
  /// @param email User's email address
  /// @param password Account password
  /// @param displayName Full display name
  /// @param firstName User's first name
  /// @param lastName User's last name
  /// @return Created Firebase user or null on failure
  /// @throws Exception if account creation fails
  Future<User?> signUpWithEmailOnly({
    required String email,
    required String password,
    required String displayName,
    required String firstName,
    required String lastName,
  });
  
  /// Creates a complete user account with email and profile.
  /// 
  /// Creates both Firebase Auth account and Firestore user profile
  /// with role-specific information. Handles the complete signup
  /// flow including role assignment.
  /// 
  /// @param email User's email address
  /// @param password Account password
  /// @param displayName Full display name
  /// @param role User role (teacher/student/parent/admin)
  /// @param parentEmail Parent's email (for student accounts)
  /// @param gradeLevel Student's grade level (1-12)
  /// @return Created user profile or null on failure
  /// @throws Exception if signup fails
  Future<UserModel?> signUpWithEmail({
    required String email,
    required String password,
    required String displayName,
    UserRole? role,
    String? parentEmail,
    int? gradeLevel,
  });
  
  /// Signs in an existing user with email and password.
  /// 
  /// Authenticates the user and retrieves their profile from
  /// Firestore. Returns the complete user profile on success.
  /// 
  /// @param email User's email address
  /// @param password Account password
  /// @return User profile or null if authentication fails
  /// @throws Exception if sign-in fails
  Future<UserModel?> signInWithEmail({
    required String email,
    required String password,
  });
  
  /// Signs in using Google OAuth authentication.
  /// 
  /// Handles the Google sign-in flow. For new users, returns
  /// null to trigger role selection. For existing users,
  /// returns their complete profile.
  /// 
  /// @return User profile for existing users, null for new
  /// @throws Exception if Google sign-in fails
  Future<UserModel?> signInWithGoogle();
  
  /// Completes Google sign-up by creating user profile.
  /// 
  /// Called after successful Google authentication to create
  /// the Firestore user profile with role information. Used
  /// when a new Google user needs to select their role.
  /// 
  /// @param role Selected user role
  /// @param parentEmail Parent's email (for students)
  /// @param gradeLevel Student's grade (for students)
  /// @return Created user profile
  /// @throws Exception if profile creation fails
  Future<UserModel?> completeGoogleSignUp({
    required UserRole role,
    String? parentEmail,
    int? gradeLevel,
  });
  
  /// Signs out the current user.
  /// 
  /// Clears authentication state and local session data.
  /// The authStateChanges stream will emit null after signout.
  /// 
  /// @throws Exception if sign-out fails
  Future<void> signOut();
  
  /// Sends a password reset email to the specified address.
  /// 
  /// Initiates the password reset flow by sending an email
  /// with reset instructions. The user must have an account
  /// with the provided email address.
  /// 
  /// @param email Email address to send reset link
  /// @throws Exception if email sending fails
  Future<void> resetPassword(String email);
  
  /// Updates the current user's profile information.
  /// 
  /// Updates both Firebase Auth profile and Firestore user
  /// document. Only provided fields are updated; null values
  /// are ignored.
  /// 
  /// @param displayName New display name
  /// @param firstName New first name
  /// @param lastName New last name
  /// @param photoURL New profile photo URL
  /// @param updatePhoto Whether to update the photo
  /// @throws Exception if profile update fails
  Future<void> updateProfile({
    String? displayName,
    String? firstName,
    String? lastName,
    String? photoURL,
    bool updatePhoto = false,
  });
}
````

## File: lib/features/auth/domain/repositories/user_repository.dart
````dart
/// Abstract repository interface for user operations.
/// 
/// This module defines the contract for user data operations,
/// providing methods for managing user profiles and related
/// data in the educational platform.
library;

import '../../../../shared/models/user_model.dart';

/// Repository interface for user operations.
/// 
/// Provides abstract methods for user management including
/// profile retrieval, updates, and role-based queries.
abstract class UserRepository {
  /// Gets a user by their ID.
  Future<UserModel?> getUserById(String userId);
  
  /// Gets a user by their email.
  Future<UserModel?> getUserByEmail(String email);
  
  /// Creates a new user profile.
  Future<void> createUser(UserModel user);
  
  /// Updates an existing user profile.
  Future<void> updateUser(UserModel user);
  
  /// Gets all users with a specific role.
  Stream<List<UserModel>> getUsersByRole(String role);
  
  /// Gets all teachers.
  Stream<List<UserModel>> getTeachers();
  
  /// Gets all students.
  Stream<List<UserModel>> getStudents();
  
  /// Updates the last active timestamp for a user.
  Future<void> updateLastActive(String userId);
  
  /// Checks if a user exists.
  Future<bool> userExists(String userId);
  
  /// Deletes a user profile.
  Future<void> deleteUser(String userId);
  
  /// Searches users by name or email.
  Future<List<UserModel>> searchUsers(String query);
  
  /// Gets multiple users by their IDs.
  Future<List<UserModel>> getUsersByIds(List<String> userIds);
}
````

## File: lib/features/auth/presentation/screens/login_screen.dart
````dart
import 'package:flutter/material.dart';
import 'package:flutter/foundation.dart';
import 'package:provider/provider.dart';
import 'package:go_router/go_router.dart';
import '../providers/auth_provider.dart';
import '../widgets/auth_text_field.dart';

class LoginScreen extends StatefulWidget {
  const LoginScreen({super.key});

  @override
  State<LoginScreen> createState() => _LoginScreenState();
}

class _LoginScreenState extends State<LoginScreen> {
  final _formKey = GlobalKey<FormState>();
  final _emailController = TextEditingController();
  final _passwordController = TextEditingController();
  bool _obscurePassword = true;

  @override
  void initState() {
    super.initState();
    // Clear error when user starts typing
    _emailController.addListener(_clearError);
    _passwordController.addListener(_clearError);
    
    // On web, listen for Google Sign-In events
    if (kIsWeb) {
      _listenToGoogleSignInEvents();
    }
  }

  @override
  void dispose() {
    _emailController.dispose();
    _passwordController.dispose();
    super.dispose();
  }

  void _clearError() {
    final authProvider = context.read<AuthProvider>();
    if (authProvider.errorMessage != null) {
      authProvider.clearError();
    }
  }
  
  void _listenToGoogleSignInEvents() {
    // For web, Google Sign-In is handled by button click
    // No need for additional listeners
  }

  Future<void> _signIn() async {
    if (!_formKey.currentState!.validate()) return;

    final authProvider = context.read<AuthProvider>();
    final success = await authProvider.signInWithEmail(
      email: _emailController.text.trim(),
      password: _passwordController.text,
    );

    if (success && mounted) {
      context.go('/dashboard');
    }
  }

  Future<void> _signInWithGoogle() async {
    final authProvider = context.read<AuthProvider>();
    final success = await authProvider.signInWithGoogle();

    if (success && mounted) {
      if (authProvider.status == AuthStatus.authenticating) {
        // Need role selection
        context.go('/auth/role-selection');
      } else {
        context.go('/dashboard');
      }
    }
  }


  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    
    return Scaffold(
      body: SafeArea(
        child: Center(
          child: SingleChildScrollView(
            padding: const EdgeInsets.fromLTRB(24.0, 24.0, 24.0, 48.0), // Extra bottom padding
            child: ConstrainedBox(
              constraints: const BoxConstraints(maxWidth: 400),
              child: Column(
                mainAxisAlignment: MainAxisAlignment.center,
                crossAxisAlignment: CrossAxisAlignment.stretch,
                children: [
                  // Logo and Title
                  Icon(
                    Icons.school,
                    size: 80,
                    color: theme.colorScheme.primary,
                  ),
                  const SizedBox(height: 24),
                  Text(
                    'Welcome Back',
                    style: theme.textTheme.headlineMedium?.copyWith(
                      fontWeight: FontWeight.bold,
                    ),
                    textAlign: TextAlign.center,
                  ),
                  const SizedBox(height: 8),
                  Text(
                    'Sign in to your Teacher Dashboard',
                    style: theme.textTheme.bodyLarge?.copyWith(
                      color: theme.colorScheme.onSurfaceVariant,
                    ),
                    textAlign: TextAlign.center,
                  ),
                  const SizedBox(height: 48),

                  // Login Form
                  Form(
                    key: _formKey,
                    child: Column(
                      children: [
                        AuthTextField(
                          controller: _emailController,
                          label: 'Email',
                          keyboardType: TextInputType.emailAddress,
                          prefixIcon: Icons.email_outlined,
                          validator: (value) {
                            if (value == null || value.isEmpty) {
                              return 'Please enter your email';
                            }
                            if (!value.contains('@')) {
                              return 'Please enter a valid email';
                            }
                            return null;
                          },
                        ),
                        const SizedBox(height: 16),
                        AuthTextField(
                          controller: _passwordController,
                          label: 'Password',
                          obscureText: _obscurePassword,
                          prefixIcon: Icons.lock_outline,
                          suffixIcon: IconButton(
                            icon: Icon(_obscurePassword
                                ? Icons.visibility_outlined
                                : Icons.visibility_off_outlined),
                            onPressed: () {
                              setState(() {
                                _obscurePassword = !_obscurePassword;
                              });
                            },
                          ),
                          validator: (value) {
                            if (value == null || value.isEmpty) {
                              return 'Please enter your password';
                            }
                            return null;
                          },
                        ),
                      ],
                    ),
                  ),
                  const SizedBox(height: 8),

                  // Forgot Password
                  Align(
                    alignment: Alignment.centerRight,
                    child: TextButton(
                      onPressed: () => context.go('/auth/forgot-password'),
                      child: const Text('Forgot Password?'),
                    ),
                  ),
                  const SizedBox(height: 24),

                  // Sign In Button
                  Consumer<AuthProvider>(
                    builder: (context, authProvider, _) {
                      return FilledButton(
                        onPressed: authProvider.isLoading ? null : _signIn,
                        style: FilledButton.styleFrom(
                          minimumSize: const Size.fromHeight(56),
                        ),
                        child: authProvider.isLoading
                            ? const SizedBox(
                                height: 20,
                                width: 20,
                                child: CircularProgressIndicator(
                                  strokeWidth: 2,
                                  color: Colors.white,
                                ),
                              )
                            : const Text('Sign In'),
                      );
                    },
                  ),
                  const SizedBox(height: 16),

                  // Divider
                  Row(
                    children: [
                      const Expanded(child: Divider()),
                      Padding(
                        padding: const EdgeInsets.symmetric(horizontal: 16),
                        child: Text(
                          'OR',
                          style: theme.textTheme.bodyMedium?.copyWith(
                            color: theme.colorScheme.onSurfaceVariant,
                          ),
                        ),
                      ),
                      const Expanded(child: Divider()),
                    ],
                  ),
                  const SizedBox(height: 16),

                  // Google Sign In - use same button for all platforms
                  OutlinedButton.icon(
                    onPressed: _signInWithGoogle,
                    style: OutlinedButton.styleFrom(
                      minimumSize: const Size.fromHeight(56),
                    ),
                    icon: Image.network(
                      'https://www.gstatic.com/firebasejs/ui/2.0.0/images/auth/google.svg',
                      height: 24,
                      width: 24,
                      errorBuilder: (context, error, stackTrace) => 
                        const Icon(Icons.g_mobiledata, size: 24),
                    ),
                    label: const Text('Continue with Google'),
                  ),
                  const SizedBox(height: 24),

                  // Sign Up Link
                  Row(
                    mainAxisAlignment: MainAxisAlignment.center,
                    children: [
                      Text(
                        "Don't have an account? ",
                        style: theme.textTheme.bodyMedium,
                      ),
                      TextButton(
                        onPressed: () => context.go('/auth/signup'),
                        child: const Text('Sign Up'),
                      ),
                    ],
                  ),

                  // Error Message
                  Consumer<AuthProvider>(
                    builder: (context, authProvider, _) {
                      if (authProvider.errorMessage != null) {
                        return Container(
                          margin: const EdgeInsets.only(top: 16),
                          padding: const EdgeInsets.all(12),
                          decoration: BoxDecoration(
                            color: theme.colorScheme.errorContainer,
                            borderRadius: BorderRadius.circular(8),
                          ),
                          child: Row(
                            children: [
                              Icon(
                                Icons.error_outline,
                                color: theme.colorScheme.onErrorContainer,
                              ),
                              const SizedBox(width: 8),
                              Expanded(
                                child: Text(
                                  authProvider.errorMessage!,
                                  style: TextStyle(
                                    color: theme.colorScheme.onErrorContainer,
                                  ),
                                ),
                              ),
                            ],
                          ),
                        );
                      }
                      return const SizedBox.shrink();
                    },
                  ),
                ],
              ),
            ),
          ),
        ),
      ),
    );
  }
}
````

## File: lib/features/auth/presentation/screens/role_selection_screen.dart
````dart
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import '../../../../shared/models/user_model.dart';
import '../providers/auth_provider.dart';

class RoleSelectionScreen extends StatefulWidget {
  const RoleSelectionScreen({super.key});

  @override
  State<RoleSelectionScreen> createState() => _RoleSelectionScreenState();
}

class _RoleSelectionScreenState extends State<RoleSelectionScreen> {
  UserRole? _selectedRole;
  final _teacherPasswordController = TextEditingController();
  bool _isLoading = false;
  bool _obscurePassword = true;

  @override
  void dispose() {
    _teacherPasswordController.dispose();
    super.dispose();
  }

  Future<void> _completeSignUp() async {
    if (_selectedRole == null) {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(content: Text('Please select your role')),
      );
      return;
    }

    if (_selectedRole == UserRole.teacher && 
        _teacherPasswordController.text.isEmpty) {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(content: Text('Please enter the teacher password')),
      );
      return;
    }

    if (_selectedRole == UserRole.teacher && 
        _teacherPasswordController.text != 'fuzzyballs') {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(content: Text('Invalid teacher password')),
      );
      return;
    }

    // Students can proceed without additional info

    setState(() => _isLoading = true);

    try {
      final authProvider = context.read<AuthProvider>();
      final success = await authProvider.completeGoogleSignUp(
        role: _selectedRole!,
        parentEmail: null,
        gradeLevel: null,
      );

      if (success && mounted) {
        // Navigation will be handled by the AuthProvider state change
      } else if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(content: Text('Failed to complete sign up')),
        );
      }
    } catch (e) {
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(content: Text('Error: $e')),
        );
      }
    } finally {
      if (mounted) {
        setState(() => _isLoading = false);
      }
    }
  }

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    
    return Scaffold(
      appBar: AppBar(
        title: const Text('Complete Your Profile'),
        automaticallyImplyLeading: false,
      ),
      body: SingleChildScrollView(
        padding: const EdgeInsets.all(24.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.stretch,
          children: [
            Text(
              'Welcome!',
              style: theme.textTheme.headlineMedium?.copyWith(
                fontWeight: FontWeight.bold,
              ),
              textAlign: TextAlign.center,
            ),
            const SizedBox(height: 8),
            Text(
              'Select your role to get started',
              style: theme.textTheme.bodyLarge?.copyWith(
                color: theme.colorScheme.onSurfaceVariant,
              ),
              textAlign: TextAlign.center,
            ),
            const SizedBox(height: 32),

            // Role Selection
            Card(
              child: Padding(
                padding: const EdgeInsets.all(16.0),
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Text(
                      'I am a:',
                      style: theme.textTheme.titleMedium?.copyWith(
                        fontWeight: FontWeight.w600,
                      ),
                    ),
                    const SizedBox(height: 16),
                    
                    // Teacher Option
                    RadioListTile<UserRole>(
                      title: const Text('Teacher'),
                      subtitle: const Text('I teach and manage students (requires password)'),
                      value: UserRole.teacher,
                      groupValue: _selectedRole,
                      onChanged: (value) {
                        setState(() => _selectedRole = value);
                      },
                    ),
                    
                    // Student Option
                    RadioListTile<UserRole>(
                      title: const Text('Student'),
                      subtitle: const Text('Access your assignments and grades'),
                      value: UserRole.student,
                      groupValue: _selectedRole,
                      onChanged: (value) {
                        setState(() => _selectedRole = value);
                      },
                    ),
                  ],
                ),
              ),
            ),

            // Teacher Additional Fields
            if (_selectedRole == UserRole.teacher) ...[
              const SizedBox(height: 24),
              Card(
                child: Padding(
                  padding: const EdgeInsets.all(16.0),
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      Text(
                        'Teacher Verification',
                        style: theme.textTheme.titleMedium?.copyWith(
                          fontWeight: FontWeight.w600,
                        ),
                      ),
                      const SizedBox(height: 16),
                      
                      TextFormField(
                        controller: _teacherPasswordController,
                        obscureText: _obscurePassword,
                        decoration: InputDecoration(
                          labelText: 'Teacher Password',
                          hintText: 'Enter teacher password',
                          prefixIcon: const Icon(Icons.lock_outlined),
                          suffixIcon: IconButton(
                            icon: Icon(
                              _obscurePassword ? Icons.visibility_off : Icons.visibility,
                            ),
                            onPressed: () {
                              setState(() {
                                _obscurePassword = !_obscurePassword;
                              });
                            },
                          ),
                        ),
                      ),
                      const SizedBox(height: 8),
                      Text(
                        'Contact your administrator for the teacher password',
                        style: theme.textTheme.bodySmall?.copyWith(
                          color: theme.colorScheme.onSurfaceVariant,
                        ),
                      ),
                    ],
                  ),
                ),
              ),
            ],

            // Students don't need additional fields - straight to dashboard!

            const SizedBox(height: 32),

            // Complete Button
            FilledButton(
              onPressed: _isLoading ? null : _completeSignUp,
              style: FilledButton.styleFrom(
                minimumSize: const Size.fromHeight(56),
              ),
              child: _isLoading
                  ? const SizedBox(
                      height: 20,
                      width: 20,
                      child: CircularProgressIndicator(strokeWidth: 2),
                    )
                  : const Text('Complete Setup'),
            ),
          ],
        ),
      ),
    );
  }
}
````

## File: lib/features/auth/presentation/screens/signup_screen.dart
````dart
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'package:go_router/go_router.dart';
import '../providers/auth_provider.dart';
import '../widgets/auth_text_field.dart';

class SignupScreen extends StatefulWidget {
  const SignupScreen({super.key});

  @override
  State<SignupScreen> createState() => _SignupScreenState();
}

class _SignupScreenState extends State<SignupScreen> {
  final _formKey = GlobalKey<FormState>();
  final _emailController = TextEditingController();
  final _passwordController = TextEditingController();
  final _confirmPasswordController = TextEditingController();
  final _firstNameController = TextEditingController();
  final _lastNameController = TextEditingController();
  
  bool _obscurePassword = true;
  bool _obscureConfirmPassword = true;

  @override
  void initState() {
    super.initState();
    // Clear error when user starts typing
    _emailController.addListener(_clearError);
    _passwordController.addListener(_clearError);
    _confirmPasswordController.addListener(_clearError);
    _firstNameController.addListener(_clearError);
    _lastNameController.addListener(_clearError);
  }

  @override
  void dispose() {
    _emailController.dispose();
    _passwordController.dispose();
    _confirmPasswordController.dispose();
    _firstNameController.dispose();
    _lastNameController.dispose();
    super.dispose();
  }

  void _clearError() {
    final authProvider = context.read<AuthProvider>();
    if (authProvider.errorMessage != null) {
      authProvider.clearError();
    }
  }

  Future<void> _signUp() async {
    if (!_formKey.currentState!.validate()) return;

    final authProvider = context.read<AuthProvider>();
    final firstName = _firstNameController.text.trim();
    final lastName = _lastNameController.text.trim();
    final displayName = '$firstName $lastName'.trim();
    
    final success = await authProvider.signUpWithEmailOnly(
      email: _emailController.text.trim(),
      password: _passwordController.text,
      displayName: displayName,
      firstName: firstName,
      lastName: lastName,
    );

    if (success && mounted) {
      // Router will automatically redirect to role selection
      // No need to manually navigate - handled by main.dart redirect logic
    }
  }

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    
    return Scaffold(
      appBar: AppBar(
        leading: IconButton(
          icon: const Icon(Icons.arrow_back),
          onPressed: () => context.go('/auth/login'),
        ),
      ),
      body: SafeArea(
        child: Center(
          child: SingleChildScrollView(
            padding: const EdgeInsets.fromLTRB(24.0, 24.0, 24.0, 48.0), // Extra bottom padding
            child: ConstrainedBox(
              constraints: const BoxConstraints(maxWidth: 400),
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.stretch,
                children: [
                  // Title
                  Text(
                    'Create Account',
                    style: theme.textTheme.headlineMedium?.copyWith(
                      fontWeight: FontWeight.bold,
                    ),
                    textAlign: TextAlign.center,
                  ),
                  const SizedBox(height: 8),
                  Text(
                    'Join the Teacher Dashboard community',
                    style: theme.textTheme.bodyLarge?.copyWith(
                      color: theme.colorScheme.onSurfaceVariant,
                    ),
                    textAlign: TextAlign.center,
                  ),
                  const SizedBox(height: 32),

                  // Sign Up Form
                  Form(
                    key: _formKey,
                    child: Column(
                      children: [
                        Row(
                          children: [
                            Expanded(
                              child: AuthTextField(
                                controller: _firstNameController,
                                label: 'First Name',
                                prefixIcon: Icons.person_outline,
                                validator: (value) {
                                  if (value == null || value.isEmpty) {
                                    return 'Please enter your first name';
                                  }
                                  return null;
                                },
                              ),
                            ),
                            const SizedBox(width: 16),
                            Expanded(
                              child: AuthTextField(
                                controller: _lastNameController,
                                label: 'Last Name',
                                validator: (value) {
                                  if (value == null || value.isEmpty) {
                                    return 'Please enter your last name';
                                  }
                                  return null;
                                },
                              ),
                            ),
                          ],
                        ),
                        const SizedBox(height: 16),
                        AuthTextField(
                          controller: _emailController,
                          label: 'Email',
                          keyboardType: TextInputType.emailAddress,
                          prefixIcon: Icons.email_outlined,
                          validator: (value) {
                            if (value == null || value.isEmpty) {
                              return 'Please enter your email';
                            }
                            if (!value.contains('@')) {
                              return 'Please enter a valid email';
                            }
                            return null;
                          },
                        ),
                        const SizedBox(height: 16),
                        AuthTextField(
                          controller: _passwordController,
                          label: 'Password',
                          obscureText: _obscurePassword,
                          prefixIcon: Icons.lock_outline,
                          suffixIcon: IconButton(
                            icon: Icon(_obscurePassword
                                ? Icons.visibility_outlined
                                : Icons.visibility_off_outlined),
                            onPressed: () {
                              setState(() {
                                _obscurePassword = !_obscurePassword;
                              });
                            },
                          ),
                          validator: (value) {
                            if (value == null || value.isEmpty) {
                              return 'Please enter a password';
                            }
                            if (value.length < 6) {
                              return 'Password must be at least 6 characters';
                            }
                            return null;
                          },
                        ),
                        const SizedBox(height: 16),
                        AuthTextField(
                          controller: _confirmPasswordController,
                          label: 'Confirm Password',
                          obscureText: _obscureConfirmPassword,
                          prefixIcon: Icons.lock_outline,
                          suffixIcon: IconButton(
                            icon: Icon(_obscureConfirmPassword
                                ? Icons.visibility_outlined
                                : Icons.visibility_off_outlined),
                            onPressed: () {
                              setState(() {
                                _obscureConfirmPassword = !_obscureConfirmPassword;
                              });
                            },
                          ),
                          validator: (value) {
                            if (value == null || value.isEmpty) {
                              return 'Please confirm your password';
                            }
                            if (value != _passwordController.text) {
                              return 'Passwords do not match';
                            }
                            return null;
                          },
                        ),
                      ],
                    ),
                  ),
                  const SizedBox(height: 32),

                  // Sign Up Button
                  Consumer<AuthProvider>(
                    builder: (context, authProvider, _) {
                      return FilledButton(
                        onPressed: authProvider.isLoading ? null : _signUp,
                        style: FilledButton.styleFrom(
                          minimumSize: const Size.fromHeight(56),
                        ),
                        child: authProvider.isLoading
                            ? const SizedBox(
                                height: 20,
                                width: 20,
                                child: CircularProgressIndicator(
                                  strokeWidth: 2,
                                  color: Colors.white,
                                ),
                              )
                            : const Text('Create Account'),
                      );
                    },
                  ),
                  const SizedBox(height: 24),

                  // Sign In Link
                  Row(
                    mainAxisAlignment: MainAxisAlignment.center,
                    children: [
                      Text(
                        'Already have an account? ',
                        style: theme.textTheme.bodyMedium,
                      ),
                      TextButton(
                        onPressed: () => context.go('/auth/login'),
                        child: const Text('Sign In'),
                      ),
                    ],
                  ),

                  // Error Message
                  Consumer<AuthProvider>(
                    builder: (context, authProvider, _) {
                      if (authProvider.errorMessage != null) {
                        return Container(
                          margin: const EdgeInsets.only(top: 16),
                          padding: const EdgeInsets.all(12),
                          decoration: BoxDecoration(
                            color: theme.colorScheme.errorContainer,
                            borderRadius: BorderRadius.circular(8),
                          ),
                          child: Row(
                            children: [
                              Icon(
                                Icons.error_outline,
                                color: theme.colorScheme.onErrorContainer,
                              ),
                              const SizedBox(width: 8),
                              Expanded(
                                child: Text(
                                  authProvider.errorMessage!,
                                  style: TextStyle(
                                    color: theme.colorScheme.onErrorContainer,
                                  ),
                                ),
                              ),
                            ],
                          ),
                        );
                      }
                      return const SizedBox.shrink();
                    },
                  ),
                ],
              ),
            ),
          ),
        ),
      ),
    );
  }
}
````

## File: lib/features/calendar/data/services/device_calendar_service_interface.dart
````dart
import '../../domain/models/calendar_event.dart';
import '../../../assignments/domain/models/assignment.dart';

/// Abstract interface for device calendar service
abstract class DeviceCalendarServiceInterface {
  Future<bool> requestPermissions();
  Future<List<dynamic>> getDeviceCalendars();
  Future<String?> addCalendarEvent({
    required CalendarEvent event,
    String? calendarId,
  });
  Future<String?> addAssignmentToCalendar({
    required Assignment assignment,
    String? calendarId,
  });
  Future<bool> updateCalendarEvent({
    required String eventId,
    required CalendarEvent event,
    String? calendarId,
  });
  Future<bool> deleteCalendarEvent({
    required String eventId,
    String? calendarId,
  });
}
````

## File: lib/features/calendar/data/services/device_calendar_service_mobile.dart
````dart
import 'dart:io';
import 'package:flutter/foundation.dart';
import 'package:device_calendar/device_calendar.dart';
import 'package:permission_handler/permission_handler.dart';
import 'package:timezone/data/latest_all.dart' as tz;
import 'package:timezone/timezone.dart' as tz;
import '../../domain/models/calendar_event.dart';
import '../../../assignments/domain/models/assignment.dart';
import '../../../../shared/services/logger_service.dart';
import 'device_calendar_service_interface.dart';

/// Factory function for conditional imports
DeviceCalendarServiceInterface getDeviceCalendarService() {
  return DeviceCalendarServiceMobile();
}

/// Mobile implementation of device calendar service
class DeviceCalendarServiceMobile implements DeviceCalendarServiceInterface {
  static final DeviceCalendarServiceMobile _instance = DeviceCalendarServiceMobile._internal();
  factory DeviceCalendarServiceMobile() => _instance;
  DeviceCalendarServiceMobile._internal() {
    tz.initializeTimeZones();
  }

  final DeviceCalendarPlugin _deviceCalendarPlugin = DeviceCalendarPlugin();
  String? _defaultCalendarId;
  
  @override
  Future<bool> requestPermissions() async {
    try {
      // Request calendar permission
      final status = await Permission.calendarFullAccess.request();
      
      if (status.isGranted) {
        LoggerService.info('Calendar permissions granted', tag: 'DeviceCalendarService');
        return true;
      } else if (status.isPermanentlyDenied) {
        // Open app settings if permanently denied
        await openAppSettings();
      }
      
      LoggerService.warning('Calendar permissions denied', tag: 'DeviceCalendarService');
      return false;
    } catch (e) {
      LoggerService.error('Error requesting calendar permissions', 
          tag: 'DeviceCalendarService', error: e);
      return false;
    }
  }
  
  @override
  Future<List<dynamic>> getDeviceCalendars() async {
    try {
      final hasPermission = await requestPermissions();
      if (!hasPermission) return [];
      
      final calendarsResult = await _deviceCalendarPlugin.retrieveCalendars();
      if (calendarsResult.isSuccess && calendarsResult.data != null) {
        return calendarsResult.data!;
      }
      
      return [];
    } catch (e) {
      LoggerService.error('Error retrieving calendars', 
          tag: 'DeviceCalendarService', error: e);
      return [];
    }
  }
  
  /// Get or create default calendar for the app
  Future<String?> _getOrCreateDefaultCalendar() async {
    try {
      if (_defaultCalendarId != null) {
        return _defaultCalendarId;
      }
      
      final calendars = await getDeviceCalendars();
      final calendarList = calendars.cast<Calendar>();
      
      // Look for existing app calendar
      final appCalendar = calendarList.firstWhere(
        (cal) => cal.name == 'Teacher Dashboard',
        orElse: () => Calendar(name: '', id: ''),
      );
      
      if (appCalendar.id?.isNotEmpty == true) {
        _defaultCalendarId = appCalendar.id;
        return _defaultCalendarId;
      }
      
      // Create new calendar if not found
      if (!kIsWeb && Platform.isAndroid) {
        // On Android, use the first writable calendar
        final writableCalendar = calendarList.firstWhere(
          (cal) => cal.isReadOnly == false,
          orElse: () => Calendar(name: '', id: ''),
        );
        
        if (writableCalendar.id?.isNotEmpty == true) {
          _defaultCalendarId = writableCalendar.id;
          return _defaultCalendarId;
        }
      } else if (!kIsWeb && Platform.isIOS) {
        // On iOS, we can create a new calendar
        // For now, use the default calendar
        final defaultCalendar = calendarList.firstWhere(
          (cal) => cal.isDefault == true,
          orElse: () => calendarList.isNotEmpty ? calendarList.first : Calendar(name: '', id: ''),
        );
        
        if (defaultCalendar.id?.isNotEmpty == true) {
          _defaultCalendarId = defaultCalendar.id;
          return _defaultCalendarId;
        }
      }
      
      return null;
    } catch (e) {
      LoggerService.error('Error getting/creating default calendar', 
          tag: 'DeviceCalendarService', error: e);
      return null;
    }
  }
  
  @override
  Future<String?> addCalendarEvent({
    required CalendarEvent event,
    String? calendarId,
  }) async {
    try {
      final finalCalendarId = calendarId ?? await _getOrCreateDefaultCalendar();
      if (finalCalendarId == null) {
        LoggerService.warning('No calendar available for sync', 
            tag: 'DeviceCalendarService');
        return null;
      }
      
      // Create device event
      final deviceEvent = Event(
        finalCalendarId,
        eventId: event.id,
        title: event.title,
        description: event.description,
        start: tz.TZDateTime.from(event.startTime, tz.local),
        end: event.endTime != null 
            ? tz.TZDateTime.from(event.endTime!, tz.local)
            : tz.TZDateTime.from(event.startTime.add(const Duration(hours: 1)), tz.local),
        allDay: event.isAllDay,
      );
      
      // Set location if available
      if (event.location != null) {
        deviceEvent.location = event.location;
      }
      
      // Add reminder if enabled
      if (event.hasReminder && event.reminderMinutes != null) {
        deviceEvent.reminders = [
          Reminder(minutes: event.reminderMinutes!),
        ];
      }
      
      // Add recurrence if applicable
      if (event.recurrence != RecurrenceType.none) {
        deviceEvent.recurrenceRule = _createRecurrenceRule(event);
      }
      
      // Create or update event
      final result = await _deviceCalendarPlugin.createOrUpdateEvent(deviceEvent);
      
      if (result?.isSuccess == true) {
        LoggerService.info('Event synced to device calendar: ${event.title}', 
            tag: 'DeviceCalendarService');
        return result!.data;
      }
      
      LoggerService.warning('Failed to sync event to device calendar', 
          tag: 'DeviceCalendarService');
      return null;
    } catch (e) {
      LoggerService.error('Error syncing event to device calendar', 
          tag: 'DeviceCalendarService', error: e);
      return null;
    }
  }
  
  @override
  Future<String?> addAssignmentToCalendar({
    required Assignment assignment,
    String? calendarId,
  }) async {
    try {
      final finalCalendarId = calendarId ?? await _getOrCreateDefaultCalendar();
      if (finalCalendarId == null) {
        LoggerService.warning('No calendar available for sync', 
            tag: 'DeviceCalendarService');
        return null;
      }
      
      // Create device event for assignment
      final deviceEvent = Event(
        finalCalendarId,
        eventId: 'assignment_${assignment.id}',
        title: 'Due: ${assignment.title}',
        description: assignment.description,
        start: tz.TZDateTime.from(assignment.dueDate, tz.local),
        allDay: true,
      );
      
      // Add 24-hour reminder
      deviceEvent.reminders = [
        Reminder(minutes: 1440), // 24 hours
      ];
      
      // Create or update event
      final result = await _deviceCalendarPlugin.createOrUpdateEvent(deviceEvent);
      
      if (result?.isSuccess == true) {
        LoggerService.info('Assignment synced to device calendar: ${assignment.title}', 
            tag: 'DeviceCalendarService');
        return result!.data;
      }
      
      LoggerService.warning('Failed to sync assignment to device calendar', 
          tag: 'DeviceCalendarService');
      return null;
    } catch (e) {
      LoggerService.error('Error syncing assignment to device calendar', 
          tag: 'DeviceCalendarService', error: e);
      return null;
    }
  }
  
  @override
  Future<bool> updateCalendarEvent({
    required String eventId,
    required CalendarEvent event,
    String? calendarId,
  }) async {
    try {
      final finalCalendarId = calendarId ?? await _getOrCreateDefaultCalendar();
      if (finalCalendarId == null) return false;
      
      // Create updated device event
      final deviceEvent = Event(
        finalCalendarId,
        eventId: eventId,
        title: event.title,
        description: event.description,
        start: tz.TZDateTime.from(event.startTime, tz.local),
        end: event.endTime != null 
            ? tz.TZDateTime.from(event.endTime!, tz.local)
            : tz.TZDateTime.from(event.startTime.add(const Duration(hours: 1)), tz.local),
        allDay: event.isAllDay,
      );
      
      // Set location if available
      if (event.location != null) {
        deviceEvent.location = event.location;
      }
      
      // Add reminder if enabled
      if (event.hasReminder && event.reminderMinutes != null) {
        deviceEvent.reminders = [
          Reminder(minutes: event.reminderMinutes!),
        ];
      }
      
      // Add recurrence if applicable
      if (event.recurrence != RecurrenceType.none) {
        deviceEvent.recurrenceRule = _createRecurrenceRule(event);
      }
      
      // Update event
      final result = await _deviceCalendarPlugin.createOrUpdateEvent(deviceEvent);
      
      if (result?.isSuccess == true) {
        LoggerService.info('Event updated in device calendar: ${event.title}', 
            tag: 'DeviceCalendarService');
        return true;
      }
      
      return false;
    } catch (e) {
      LoggerService.error('Error updating event in device calendar', 
          tag: 'DeviceCalendarService', error: e);
      return false;
    }
  }
  
  @override
  Future<bool> deleteCalendarEvent({
    required String eventId,
    String? calendarId,
  }) async {
    try {
      final finalCalendarId = calendarId ?? await _getOrCreateDefaultCalendar();
      if (finalCalendarId == null) return false;
      
      final result = await _deviceCalendarPlugin.deleteEvent(finalCalendarId, eventId);
      
      if (result.isSuccess) {
        LoggerService.info('Event removed from device calendar: $eventId', 
            tag: 'DeviceCalendarService');
        return true;
      }
      
      return false;
    } catch (e) {
      LoggerService.error('Error removing event from device calendar', 
          tag: 'DeviceCalendarService', error: e);
      return false;
    }
  }
  
  /// Create recurrence rule based on CalendarEvent settings
  RecurrenceRule? _createRecurrenceRule(CalendarEvent event) {
    if (event.recurrence == RecurrenceType.none) return null;
    
    RecurrenceFrequency? frequency;
    switch (event.recurrence) {
      case RecurrenceType.daily:
        frequency = RecurrenceFrequency.Daily;
        break;
      case RecurrenceType.weekly:
        frequency = RecurrenceFrequency.Weekly;
        break;
      case RecurrenceType.monthly:
        frequency = RecurrenceFrequency.Monthly;
        break;
      case RecurrenceType.yearly:
        frequency = RecurrenceFrequency.Yearly;
        break;
      default:
        return null;
    }
    
    return RecurrenceRule(
      frequency,
      endDate: event.recurrenceEndDate,
    );
  }
}
````

## File: lib/features/calendar/data/services/device_calendar_service_web.dart
````dart
import '../../domain/models/calendar_event.dart';
import '../../../assignments/domain/models/assignment.dart';
import '../../../../shared/services/logger_service.dart';
import 'device_calendar_service_interface.dart';

/// Factory function for conditional imports
DeviceCalendarServiceInterface getDeviceCalendarService() {
  return DeviceCalendarServiceWeb();
}

/// Web implementation of device calendar service (stub)
class DeviceCalendarServiceWeb implements DeviceCalendarServiceInterface {
  static final DeviceCalendarServiceWeb _instance = DeviceCalendarServiceWeb._internal();
  factory DeviceCalendarServiceWeb() => _instance;
  DeviceCalendarServiceWeb._internal();

  @override
  Future<bool> requestPermissions() async {
    // Calendar permissions are not applicable on web
    LoggerService.info('Calendar permissions not required on web', tag: 'DeviceCalendarService');
    return false;
  }
  
  @override
  Future<List<dynamic>> getDeviceCalendars() async {
    // No device calendars available on web
    LoggerService.info('Device calendars not available on web', tag: 'DeviceCalendarService');
    return [];
  }
  
  @override
  Future<String?> addCalendarEvent({
    required CalendarEvent event,
    String? calendarId,
  }) async {
    // Calendar sync not available on web
    LoggerService.info('Calendar sync not available on web: ${event.title}', 
        tag: 'DeviceCalendarService');
    // Could potentially open Google Calendar web or create an .ics file
    // For now, just return null
    return null;
  }
  
  @override
  Future<String?> addAssignmentToCalendar({
    required Assignment assignment,
    String? calendarId,
  }) async {
    // Calendar sync not available on web
    LoggerService.info('Assignment calendar sync not available on web: ${assignment.title}', 
        tag: 'DeviceCalendarService');
    // Could potentially open Google Calendar web or create an .ics file
    // For now, just return null
    return null;
  }
  
  @override
  Future<bool> updateCalendarEvent({
    required String eventId,
    required CalendarEvent event,
    String? calendarId,
  }) async {
    // Calendar sync not available on web
    LoggerService.info('Calendar event update not available on web: ${event.title}', 
        tag: 'DeviceCalendarService');
    return false;
  }
  
  @override
  Future<bool> deleteCalendarEvent({
    required String eventId,
    String? calendarId,
  }) async {
    // Calendar sync not available on web
    LoggerService.info('Calendar event deletion not available on web: $eventId', 
        tag: 'DeviceCalendarService');
    return false;
  }
}
````

## File: lib/features/calendar/presentation/screens/calendar_screen.dart
````dart
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import '../../../../shared/widgets/common/adaptive_layout.dart';
import '../../../../shared/widgets/common/responsive_layout.dart';
import '../providers/calendar_provider.dart';
import '../../../auth/presentation/providers/auth_provider.dart';
import '../../domain/models/calendar_event.dart';
import '../../data/services/device_calendar_service_factory.dart';

class CalendarScreen extends StatefulWidget {
  const CalendarScreen({super.key});

  @override
  State<CalendarScreen> createState() => _CalendarScreenState();
}

class _CalendarScreenState extends State<CalendarScreen> with SingleTickerProviderStateMixin {
  late TabController _tabController;
  EventType? _selectedFilter;

  @override
  void initState() {
    super.initState();
    _tabController = TabController(length: 3, vsync: this, initialIndex: 0);
    
    // Initialize calendar provider with current user
    WidgetsBinding.instance.addPostFrameCallback((_) {
      final userId = context.read<AuthProvider>().userModel?.uid;
      if (userId != null) {
        context.read<CalendarProvider>().initialize(userId);
      }
    });
  }

  @override
  void dispose() {
    _tabController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);

    return AdaptiveLayout(
      title: 'Calendar',
      showBackButton: true,
      floatingActionButton: FloatingActionButton.extended(
        onPressed: () {
          _showCreateEventSheet(context);
        },
        icon: const Icon(Icons.add),
        label: const Text('New Event'),
      ),
      bottom: TabBar(
        controller: _tabController,
        tabs: const [
          Tab(text: 'Month'),
          Tab(text: 'Week'),
          Tab(text: 'Agenda'),
        ],
      ),
      body: Consumer<CalendarProvider>(
        builder: (context, provider, child) {
          if (provider.isLoading) {
            return const Center(child: CircularProgressIndicator());
          }

          if (provider.error != null) {
            return Center(
              child: Column(
                mainAxisAlignment: MainAxisAlignment.center,
                children: [
                  const Icon(Icons.error_outline, size: 48, color: Colors.red),
                  const SizedBox(height: 16),
                  Text('Error: ${provider.error}'),
                  const SizedBox(height: 16),
                  ElevatedButton(
                    onPressed: () => provider.loadUserEvents(),
                    child: const Text('Retry'),
                  ),
                ],
              ),
            );
          }

          return Column(
            children: [
              // Calendar Controls
              Container(
                padding: const EdgeInsets.all(16),
                child: Row(
                  children: [
                    // Month/Year Navigation
                    Expanded(
                      child: Row(
                        children: [
                          IconButton(
                            onPressed: () => provider.navigatePrevious(),
                            icon: const Icon(Icons.chevron_left),
                          ),
                          Expanded(
                            child: Text(
                              _formatMonthYear(provider.focusedDate),
                              style: theme.textTheme.titleLarge?.copyWith(
                                fontWeight: FontWeight.bold,
                              ),
                              textAlign: TextAlign.center,
                            ),
                          ),
                          IconButton(
                            onPressed: () => provider.navigateNext(),
                            icon: const Icon(Icons.chevron_right),
                          ),
                        ],
                      ),
                    ),
                    // Today Button
                    TextButton(
                      onPressed: () => provider.goToToday(),
                      child: const Text('Today'),
                    ),
                    const SizedBox(width: 8),
                    // Filter Button
                    Container(
                      decoration: BoxDecoration(
                        border: Border.all(color: theme.colorScheme.outline),
                        borderRadius: BorderRadius.circular(8),
                      ),
                      child: PopupMenuButton<EventType?>(
                        initialValue: _selectedFilter,
                        onSelected: (value) {
                          setState(() {
                            _selectedFilter = value;
                          });
                          provider.setFilterType(value);
                        },
                        itemBuilder: (context) => [
                          const PopupMenuItem(
                            value: null,
                            child: Text('All Events'),
                          ),
                          ...EventType.values.map((type) => PopupMenuItem(
                            value: type,
                            child: Text(type.displayName),
                          )),
                        ],
                        child: Padding(
                          padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 8),
                          child: Row(
                            children: [
                              const Icon(Icons.filter_list, size: 20),
                              const SizedBox(width: 8),
                              Text(_selectedFilter?.displayName ?? 'All'),
                              const Icon(Icons.arrow_drop_down),
                            ],
                          ),
                        ),
                      ),
                    ),
                  ],
                ),
              ),
              // Calendar Views
              Expanded(
                child: TabBarView(
                  controller: _tabController,
                  children: [
                    _buildMonthView(provider),
                    _buildWeekView(provider),
                    _buildAgendaView(provider),
                  ],
                ),
              ),
            ],
          );
        },
      ),
    );
  }

  Widget _buildMonthView(CalendarProvider provider) {
    return ResponsiveContainer(
      child: Column(
        children: [
          // Calendar Header (Days of Week)
          _buildCalendarHeader(),
          // Calendar Grid
          Expanded(
            child: _buildCalendarGrid(provider),
          ),
        ],
      ),
    );
  }

  Widget _buildCalendarHeader() {
    final theme = Theme.of(context);
    const daysOfWeek = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];

    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
      child: Row(
        children: daysOfWeek.map((day) {
          return Expanded(
            child: Center(
              child: Text(
                day,
                style: theme.textTheme.bodyMedium?.copyWith(
                  fontWeight: FontWeight.bold,
                  color: theme.colorScheme.onSurfaceVariant,
                ),
              ),
            ),
          );
        }).toList(),
      ),
    );
  }

  Widget _buildCalendarGrid(CalendarProvider provider) {
    final focusedDate = provider.focusedDate;
    final firstDayOfMonth = DateTime(focusedDate.year, focusedDate.month, 1);
    final firstDayOfCalendar = firstDayOfMonth.subtract(Duration(days: firstDayOfMonth.weekday % 7));
    
    return GridView.builder(
      padding: const EdgeInsets.symmetric(horizontal: 16),
      gridDelegate: const SliverGridDelegateWithFixedCrossAxisCount(
        crossAxisCount: 7,
        mainAxisSpacing: 4,
        crossAxisSpacing: 4,
        childAspectRatio: 1.0,
      ),
      itemCount: 42, // 6 weeks * 7 days
      itemBuilder: (context, index) {
        final date = firstDayOfCalendar.add(Duration(days: index));
        final isCurrentMonth = date.month == focusedDate.month;
        final isToday = _isSameDay(date, DateTime.now());
        final isSelected = _isSameDay(date, provider.selectedDate);
        final events = provider.getEventsForDate(date);
        final filteredEvents = _selectedFilter != null
            ? events.where((e) => e.type == _selectedFilter).toList()
            : events;

        return _buildCalendarDay(
          provider: provider,
          date: date,
          isCurrentMonth: isCurrentMonth,
          isToday: isToday,
          isSelected: isSelected,
          events: filteredEvents,
        );
      },
    );
  }

  Widget _buildCalendarDay({
    required CalendarProvider provider,
    required DateTime date,
    required bool isCurrentMonth,
    required bool isToday,
    required bool isSelected,
    required List<CalendarEvent> events,
  }) {
    final theme = Theme.of(context);

    return GestureDetector(
      onTap: () {
        provider.setSelectedDate(date);
        if (events.isNotEmpty) {
          _showDayEventsSheet(date, events);
        }
      },
      child: Container(
        decoration: BoxDecoration(
          color: isSelected 
              ? theme.colorScheme.primary
              : isToday 
                  ? theme.colorScheme.primaryContainer
                  : null,
          borderRadius: BorderRadius.circular(8),
          border: isToday && !isSelected
              ? Border.all(color: theme.colorScheme.primary, width: 2)
              : null,
        ),
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            // Date Number
            Text(
              '${date.day}',
              style: theme.textTheme.bodyMedium?.copyWith(
                color: isSelected
                    ? theme.colorScheme.onPrimary
                    : isToday
                        ? theme.colorScheme.onPrimaryContainer
                        : isCurrentMonth
                            ? theme.colorScheme.onSurface
                            : theme.colorScheme.onSurfaceVariant.withValues(alpha: 0.5),
                fontWeight: isToday || isSelected ? FontWeight.bold : FontWeight.normal,
              ),
            ),
            // Event Indicators
            if (events.isNotEmpty) ...[
              const SizedBox(height: 2),
              Wrap(
                spacing: 2,
                children: events.take(3).map((event) {
                  return Container(
                    width: 6,
                    height: 6,
                    decoration: BoxDecoration(
                      color: Color(int.parse(event.displayColor.substring(1), radix: 16) + 0xFF000000),
                      shape: BoxShape.circle,
                    ),
                  );
                }).toList(),
              ),
              if (events.length > 3)
                Text(
                  '+${events.length - 3}',
                  style: TextStyle(
                    fontSize: 8,
                    color: isSelected
                        ? theme.colorScheme.onPrimary
                        : theme.colorScheme.onSurfaceVariant,
                  ),
                ),
            ],
          ],
        ),
      ),
    );
  }

  Widget _buildWeekView(CalendarProvider provider) {
    return ResponsiveContainer(
      child: Column(
        children: [
          // Week Header
          _buildWeekHeader(provider),
          // Week Grid
          Expanded(
            child: _buildWeekGrid(provider),
          ),
        ],
      ),
    );
  }

  Widget _buildWeekHeader(CalendarProvider provider) {
    final theme = Theme.of(context);
    final selectedDate = provider.selectedDate;
    final startOfWeek = selectedDate.subtract(Duration(days: selectedDate.weekday % 7));
    
    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
      child: Row(
        children: List.generate(7, (index) {
          final date = startOfWeek.add(Duration(days: index));
          final isToday = _isSameDay(date, DateTime.now());
          
          return Expanded(
            child: Column(
              children: [
                Text(
                  ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'][index],
                  style: theme.textTheme.bodySmall?.copyWith(
                    color: theme.colorScheme.onSurfaceVariant,
                  ),
                ),
                const SizedBox(height: 4),
                Container(
                  width: 32,
                  height: 32,
                  decoration: BoxDecoration(
                    color: isToday ? theme.colorScheme.primary : null,
                    shape: BoxShape.circle,
                  ),
                  child: Center(
                    child: Text(
                      '${date.day}',
                      style: theme.textTheme.bodyMedium?.copyWith(
                        color: isToday 
                            ? theme.colorScheme.onPrimary
                            : theme.colorScheme.onSurface,
                        fontWeight: isToday ? FontWeight.bold : FontWeight.normal,
                      ),
                    ),
                  ),
                ),
              ],
            ),
          );
        }),
      ),
    );
  }

  Widget _buildWeekGrid(CalendarProvider provider) {
    final selectedDate = provider.selectedDate;
    final startOfWeek = selectedDate.subtract(Duration(days: selectedDate.weekday % 7));
    
    return ListView.builder(
      padding: const EdgeInsets.all(16),
      itemCount: 24, // 24 hours
      itemBuilder: (context, hour) {
        return _buildHourRow(provider, hour, startOfWeek);
      },
    );
  }

  Widget _buildHourRow(CalendarProvider provider, int hour, DateTime startOfWeek) {
    final theme = Theme.of(context);
    
    return Container(
      height: 60,
      margin: const EdgeInsets.only(bottom: 1),
      child: Row(
        children: [
          // Hour Label
          SizedBox(
            width: 60,
            child: Text(
              _formatHour(hour),
              style: theme.textTheme.bodySmall?.copyWith(
                color: theme.colorScheme.onSurfaceVariant,
              ),
              textAlign: TextAlign.center,
            ),
          ),
          // Week Days
          Expanded(
            child: Row(
              children: List.generate(7, (dayIndex) {
                final date = startOfWeek.add(Duration(days: dayIndex));
                final events = _getEventsForDateAndHour(provider, date, hour);
                
                return Expanded(
                  child: Container(
                    decoration: BoxDecoration(
                      border: Border.all(
                        color: theme.colorScheme.outlineVariant.withValues(alpha: 0.3),
                      ),
                    ),
                    child: events.isNotEmpty
                        ? _buildEventBlock(events.first)
                        : null,
                  ),
                );
              }),
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildEventBlock(CalendarEvent event) {
    final theme = Theme.of(context);
    final color = Color(int.parse(event.displayColor.substring(1), radix: 16) + 0xFF000000);
    
    return Container(
      margin: const EdgeInsets.all(1),
      padding: const EdgeInsets.all(4),
      decoration: BoxDecoration(
        color: color.withValues(alpha: 0.1),
        borderRadius: BorderRadius.circular(4),
        border: Border.all(color: color),
      ),
      child: Text(
        event.title,
        style: theme.textTheme.bodySmall?.copyWith(
          color: color,
          fontWeight: FontWeight.w600,
        ),
        overflow: TextOverflow.ellipsis,
        maxLines: 1,
      ),
    );
  }

  Widget _buildAgendaView(CalendarProvider provider) {
    final groupedEvents = provider.eventsByDate;
    final dates = groupedEvents.keys.toList()..sort();
    
    if (_selectedFilter != null) {
      // Filter dates that have events of the selected type
      dates.removeWhere((date) {
        final events = groupedEvents[date] ?? [];
        return !events.any((event) => event.type == _selectedFilter);
      });
    }
    
    return ResponsiveContainer(
      child: ListView.builder(
        padding: const EdgeInsets.all(16),
        itemCount: dates.length,
        itemBuilder: (context, index) {
          final date = dates[index];
          var dayEvents = groupedEvents[date] ?? [];
          
          if (_selectedFilter != null) {
            dayEvents = dayEvents.where((e) => e.type == _selectedFilter).toList();
          }
          
          return _buildAgendaDay(provider, date, dayEvents);
        },
      ),
    );
  }

  Widget _buildAgendaDay(CalendarProvider provider, DateTime date, List<CalendarEvent> events) {
    final theme = Theme.of(context);
    final isToday = _isSameDay(date, DateTime.now());
    
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        // Date Header
        Padding(
          padding: const EdgeInsets.symmetric(vertical: 8),
          child: Row(
            children: [
              Text(
                _formatAgendaDate(date),
                style: theme.textTheme.titleMedium?.copyWith(
                  fontWeight: FontWeight.bold,
                  color: isToday ? theme.colorScheme.primary : null,
                ),
              ),
              if (isToday) ...[
                const SizedBox(width: 8),
                Container(
                  padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 2),
                  decoration: BoxDecoration(
                    color: theme.colorScheme.primary,
                    borderRadius: BorderRadius.circular(12),
                  ),
                  child: Text(
                    'Today',
                    style: theme.textTheme.bodySmall?.copyWith(
                      color: theme.colorScheme.onPrimary,
                      fontWeight: FontWeight.w600,
                    ),
                  ),
                ),
              ],
            ],
          ),
        ),
        // Events
        ...events.map((event) => _buildAgendaEvent(provider, event)),
        const SizedBox(height: 16),
      ],
    );
  }

  Widget _buildAgendaEvent(CalendarProvider provider, CalendarEvent event) {
    final theme = Theme.of(context);
    final color = Color(int.parse(event.displayColor.substring(1), radix: 16) + 0xFF000000);
    
    return Card(
      margin: const EdgeInsets.only(bottom: 8),
      child: InkWell(
        onTap: () => _showEventDetails(provider, event),
        borderRadius: BorderRadius.circular(12),
        child: Padding(
          padding: const EdgeInsets.all(16),
          child: Row(
            children: [
              // Event Type Indicator
              Container(
                width: 4,
                height: 40,
                decoration: BoxDecoration(
                  color: color,
                  borderRadius: BorderRadius.circular(2),
                ),
              ),
              const SizedBox(width: 12),
              // Event Details
              Expanded(
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Text(
                      event.title,
                      style: theme.textTheme.titleMedium?.copyWith(
                        fontWeight: FontWeight.bold,
                      ),
                    ),
                    if (!event.isAllDay) ...[
                      const SizedBox(height: 4),
                      Row(
                        children: [
                          Icon(
                            Icons.access_time,
                            size: 16,
                            color: theme.colorScheme.onSurfaceVariant,
                          ),
                          const SizedBox(width: 4),
                          Text(
                            _formatTimeRange(event),
                            style: theme.textTheme.bodyMedium?.copyWith(
                              color: theme.colorScheme.onSurfaceVariant,
                            ),
                          ),
                        ],
                      ),
                    ],
                    if (event.location != null) ...[
                      const SizedBox(height: 4),
                      Row(
                        children: [
                          Icon(
                            Icons.location_on,
                            size: 16,
                            color: theme.colorScheme.onSurfaceVariant,
                          ),
                          const SizedBox(width: 4),
                          Expanded(
                            child: Text(
                              event.location!,
                              style: theme.textTheme.bodyMedium?.copyWith(
                                color: theme.colorScheme.onSurfaceVariant,
                              ),
                              overflow: TextOverflow.ellipsis,
                            ),
                          ),
                        ],
                      ),
                    ],
                  ],
                ),
              ),
              // Event Type Badge
              Container(
                padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
                decoration: BoxDecoration(
                  color: color.withValues(alpha: 0.1),
                  borderRadius: BorderRadius.circular(12),
                ),
                child: Text(
                  event.type.displayName,
                  style: TextStyle(
                    color: color,
                    fontWeight: FontWeight.w600,
                    fontSize: 12,
                  ),
                ),
              ),
            ],
          ),
        ),
      ),
    );
  }

  // Helper Methods
  bool _isSameDay(DateTime a, DateTime b) {
    return a.year == b.year && a.month == b.month && a.day == b.day;
  }

  String _formatMonthYear(DateTime date) {
    const months = [
      'January', 'February', 'March', 'April', 'May', 'June',
      'July', 'August', 'September', 'October', 'November', 'December'
    ];
    return '${months[date.month - 1]} ${date.year}';
  }

  String _formatHour(int hour) {
    if (hour == 0) return '12 AM';
    if (hour < 12) return '$hour AM';
    if (hour == 12) return '12 PM';
    return '${hour - 12} PM';
  }

  String _formatAgendaDate(DateTime date) {
    const months = [
      'Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun',
      'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'
    ];
    const days = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
    return '${days[date.weekday % 7]}, ${months[date.month - 1]} ${date.day}';
  }

  String _formatTimeRange(CalendarEvent event) {
    final startTime = TimeOfDay.fromDateTime(event.startTime);
    if (event.endTime == null) {
      return startTime.format(context);
    }
    final endTime = TimeOfDay.fromDateTime(event.endTime!);
    return '${startTime.format(context)} - ${endTime.format(context)}';
  }

  List<CalendarEvent> _getEventsForDateAndHour(CalendarProvider provider, DateTime date, int hour) {
    final events = provider.getEventsForDate(date);
    return events.where((event) {
      if (event.isAllDay) return false;
      return event.startTime.hour == hour;
    }).toList();
  }

  void _showDayEventsSheet(DateTime date, List<CalendarEvent> events) {
    showModalBottomSheet(
      context: context,
      isScrollControlled: true,
      backgroundColor: Colors.transparent,
      builder: (context) => DayEventsSheet(
        date: date,
        events: events,
        onEventTap: (event) => _showEventDetails(context.read<CalendarProvider>(), event),
      ),
    );
  }

  void _showEventDetails(CalendarProvider provider, CalendarEvent event) {
    showModalBottomSheet(
      context: context,
      isScrollControlled: true,
      backgroundColor: Colors.transparent,
      builder: (context) => EventDetailSheet(
        event: event,
        onEdit: () {
          Navigator.pop(context);
          _showEditEventSheet(provider, event);
        },
        onDelete: () async {
          Navigator.pop(context);
          try {
            await provider.deleteEvent(event.id);
            // ignore: use_build_context_synchronously
            ScaffoldMessenger.of(context).showSnackBar(
              const SnackBar(content: Text('Event deleted successfully')),
            );
          } catch (e) {
            // ignore: use_build_context_synchronously
            ScaffoldMessenger.of(context).showSnackBar(
              SnackBar(content: Text('Error deleting event: $e')),
            );
          }
        },
      ),
    );
  }

  void _showCreateEventSheet(BuildContext context) {
    showModalBottomSheet(
      context: context,
      isScrollControlled: true,
      backgroundColor: Colors.transparent,
      builder: (context) => CreateEventSheet(
        onEventCreated: (event) async {
          final provider = context.read<CalendarProvider>();
          try {
            await provider.createEvent(
              title: event['title'],
              type: event['type'],
              startTime: event['startTime'],
              endTime: event['endTime'],
              description: event['description'],
              location: event['location'],
              isAllDay: event['isAllDay'] ?? false,
              hasReminder: event['hasReminder'] ?? false,
              reminderMinutes: event['reminderMinutes'],
              syncToDeviceCalendar: event['syncToDeviceCalendar'] ?? false,
            );
            // ignore: use_build_context_synchronously
            ScaffoldMessenger.of(context).showSnackBar(
              const SnackBar(content: Text('Event created successfully')),
            );
          } catch (e) {
            // ignore: use_build_context_synchronously
            ScaffoldMessenger.of(context).showSnackBar(
              SnackBar(content: Text('Error creating event: $e')),
            );
          }
        },
      ),
    );
  }

  void _showEditEventSheet(CalendarProvider provider, CalendarEvent event) {
    // TODO: Implement edit event sheet
    ScaffoldMessenger.of(context).showSnackBar(
      const SnackBar(content: Text('Edit functionality coming soon')),
    );
  }
}

// Day Events Sheet
class DayEventsSheet extends StatelessWidget {
  final DateTime date;
  final List<CalendarEvent> events;
  final Function(CalendarEvent) onEventTap;

  const DayEventsSheet({
    super.key,
    required this.date,
    required this.events,
    required this.onEventTap,
  });

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);

    return Container(
      decoration: BoxDecoration(
        color: theme.colorScheme.surface,
        borderRadius: const BorderRadius.vertical(top: Radius.circular(20)),
      ),
      child: DraggableScrollableSheet(
        initialChildSize: 0.6,
        minChildSize: 0.4,
        maxChildSize: 0.9,
        expand: false,
        builder: (context, scrollController) {
          return Column(
            children: [
              // Handle Bar
              Center(
                child: Container(
                  margin: const EdgeInsets.only(top: 12, bottom: 8),
                  width: 40,
                  height: 4,
                  decoration: BoxDecoration(
                    color: theme.colorScheme.onSurfaceVariant.withValues(alpha: 0.3),
                    borderRadius: BorderRadius.circular(2),
                  ),
                ),
              ),
              // Header
              Padding(
                padding: const EdgeInsets.all(24),
                child: Row(
                  children: [
                    Expanded(
                      child: Text(
                        _formatDate(date),
                        style: theme.textTheme.headlineSmall?.copyWith(
                          fontWeight: FontWeight.bold,
                        ),
                      ),
                    ),
                    IconButton(
                      onPressed: () => Navigator.pop(context),
                      icon: const Icon(Icons.close),
                    ),
                  ],
                ),
              ),
              // Events List
              Expanded(
                child: ListView.builder(
                  controller: scrollController,
                  padding: const EdgeInsets.symmetric(horizontal: 24),
                  itemCount: events.length,
                  itemBuilder: (context, index) {
                    final event = events[index];
                    return _buildEventCard(context, event);
                  },
                ),
              ),
            ],
          );
        },
      ),
    );
  }

  Widget _buildEventCard(BuildContext context, CalendarEvent event) {
    final theme = Theme.of(context);
    final color = Color(int.parse(event.displayColor.substring(1), radix: 16) + 0xFF000000);

    return Card(
      margin: const EdgeInsets.only(bottom: 12),
      child: InkWell(
        onTap: () {
          Navigator.pop(context);
          onEventTap(event);
        },
        borderRadius: BorderRadius.circular(12),
        child: Padding(
          padding: const EdgeInsets.all(16),
          child: Row(
            children: [
              Container(
                width: 4,
                height: 40,
                decoration: BoxDecoration(
                  color: color,
                  borderRadius: BorderRadius.circular(2),
                ),
              ),
              const SizedBox(width: 12),
              Expanded(
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Text(
                      event.title,
                      style: theme.textTheme.titleMedium?.copyWith(
                        fontWeight: FontWeight.bold,
                      ),
                    ),
                    if (!event.isAllDay) ...[
                      const SizedBox(height: 4),
                      Text(
                        _formatTimeRange(context, event),
                        style: theme.textTheme.bodyMedium?.copyWith(
                          color: theme.colorScheme.onSurfaceVariant,
                        ),
                      ),
                    ],
                  ],
                ),
              ),
              Container(
                padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
                decoration: BoxDecoration(
                  color: color.withValues(alpha: 0.1),
                  borderRadius: BorderRadius.circular(12),
                ),
                child: Text(
                  event.type.displayName,
                  style: TextStyle(
                    color: color,
                    fontWeight: FontWeight.w600,
                    fontSize: 12,
                  ),
                ),
              ),
            ],
          ),
        ),
      ),
    );
  }

  String _formatDate(DateTime date) {
    const months = [
      'January', 'February', 'March', 'April', 'May', 'June',
      'July', 'August', 'September', 'October', 'November', 'December'
    ];
    const days = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
    return '${days[date.weekday % 7]}, ${months[date.month - 1]} ${date.day}';
  }

  String _formatTimeRange(BuildContext context, CalendarEvent event) {
    final startTime = TimeOfDay.fromDateTime(event.startTime);
    if (event.endTime == null) {
      return startTime.format(context);
    }
    final endTime = TimeOfDay.fromDateTime(event.endTime!);
    return '${startTime.format(context)} - ${endTime.format(context)}';
  }
}

// Event Detail Sheet
class EventDetailSheet extends StatelessWidget {
  final CalendarEvent event;
  final VoidCallback onEdit;
  final VoidCallback onDelete;

  const EventDetailSheet({
    super.key,
    required this.event,
    required this.onEdit,
    required this.onDelete,
  });

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final color = Color(int.parse(event.displayColor.substring(1), radix: 16) + 0xFF000000);

    return Container(
      decoration: BoxDecoration(
        color: theme.colorScheme.surface,
        borderRadius: const BorderRadius.vertical(top: Radius.circular(20)),
      ),
      child: DraggableScrollableSheet(
        initialChildSize: 0.6,
        minChildSize: 0.4,
        maxChildSize: 0.9,
        expand: false,
        builder: (context, scrollController) {
          return Column(
            children: [
              // Handle Bar
              Center(
                child: Container(
                  margin: const EdgeInsets.only(top: 12, bottom: 8),
                  width: 40,
                  height: 4,
                  decoration: BoxDecoration(
                    color: theme.colorScheme.onSurfaceVariant.withValues(alpha: 0.3),
                    borderRadius: BorderRadius.circular(2),
                  ),
                ),
              ),
              // Header
              Container(
                padding: const EdgeInsets.symmetric(horizontal: 24, vertical: 8),
                decoration: BoxDecoration(
                  border: Border(
                    bottom: BorderSide(
                      color: theme.colorScheme.outlineVariant,
                    ),
                  ),
                ),
                child: Row(
                  mainAxisAlignment: MainAxisAlignment.spaceBetween,
                  children: [
                    IconButton(
                      onPressed: () => Navigator.pop(context),
                      icon: const Icon(Icons.close),
                    ),
                    Row(
                      children: [
                        IconButton(
                          onPressed: () async {
                            // Show dialog to sync to device calendar
                            final shouldSync = await showDialog<bool>(
                              context: context,
                              builder: (context) => AlertDialog(
                                title: const Text('Sync to Device Calendar'),
                                content: const Text('Do you want to add this event to your device calendar?'),
                                actions: [
                                  TextButton(
                                    onPressed: () => Navigator.pop(context, false),
                                    child: const Text('Cancel'),
                                  ),
                                  TextButton(
                                    onPressed: () => Navigator.pop(context, true),
                                    child: const Text('Sync'),
                                  ),
                                ],
                              ),
                            );
                            
                            if (shouldSync == true) {
                              try {
                                final deviceCalendarService = DeviceCalendarServiceFactory.create();
                                final eventId = await deviceCalendarService.addCalendarEvent(event: event);
                                
                                if (context.mounted) {
                                  ScaffoldMessenger.of(context).showSnackBar(
                                    SnackBar(
                                      content: Text(
                                        eventId != null
                                          ? 'Event synced to device calendar' 
                                          : 'Failed to sync event to device calendar'
                                      ),
                                    ),
                                  );
                                }
                              } catch (e) {
                                if (context.mounted) {
                                  ScaffoldMessenger.of(context).showSnackBar(
                                    SnackBar(
                                      content: Text('Error syncing event: $e'),
                                    ),
                                  );
                                }
                              }
                            }
                          },
                          icon: const Icon(Icons.sync),
                          tooltip: 'Sync to Device Calendar',
                        ),
                        IconButton(
                          onPressed: onEdit,
                          icon: const Icon(Icons.edit_outlined),
                          tooltip: 'Edit',
                        ),
                        IconButton(
                          onPressed: () {
                            showDialog(
                              context: context,
                              builder: (context) => AlertDialog(
                                title: const Text('Delete Event'),
                                content: const Text('Are you sure you want to delete this event?'),
                                actions: [
                                  TextButton(
                                    onPressed: () => Navigator.pop(context),
                                    child: const Text('Cancel'),
                                  ),
                                  TextButton(
                                    onPressed: () {
                                      Navigator.pop(context);
                                      onDelete();
                                    },
                                    style: TextButton.styleFrom(
                                      foregroundColor: theme.colorScheme.error,
                                    ),
                                    child: const Text('Delete'),
                                  ),
                                ],
                              ),
                            );
                          },
                          icon: const Icon(Icons.delete_outline),
                          tooltip: 'Delete',
                        ),
                      ],
                    ),
                  ],
                ),
              ),
              // Content
              Expanded(
                child: SingleChildScrollView(
                  controller: scrollController,
                  padding: const EdgeInsets.all(24),
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      // Title
                      Text(
                        event.title,
                        style: theme.textTheme.headlineSmall?.copyWith(
                          fontWeight: FontWeight.bold,
                        ),
                      ),
                      const SizedBox(height: 16),
                      // Event Details
                      _buildDetailRow(
                        icon: Icons.category,
                        label: 'Type',
                        value: event.type.displayName,
                        color: color,
                      ),
                      if (!event.isAllDay)
                        _buildDetailRow(
                          icon: Icons.access_time,
                          label: 'Time',
                          value: _formatTimeRange(context, event),
                        ),
                      if (event.location != null)
                        _buildDetailRow(
                          icon: Icons.location_on,
                          label: 'Location',
                          value: event.location!,
                        ),
                      _buildDetailRow(
                        icon: Icons.calendar_today,
                        label: 'Date',
                        value: _formatDate(event.startTime),
                      ),
                      if (event.recurrence != RecurrenceType.none)
                        _buildDetailRow(
                          icon: Icons.repeat,
                          label: 'Recurrence',
                          value: _getRecurrenceText(event),
                        ),
                      if (event.hasReminder && event.reminderMinutes != null)
                        _buildDetailRow(
                          icon: Icons.notifications,
                          label: 'Reminder',
                          value: _getReminderText(event.reminderMinutes!),
                        ),
                      _buildDetailRow(
                        icon: Icons.person,
                        label: 'Created by',
                        value: event.createdByName,
                      ),
                      if (event.description != null) ...[
                        const SizedBox(height: 24),
                        Text(
                          'Description',
                          style: theme.textTheme.titleMedium?.copyWith(
                            fontWeight: FontWeight.bold,
                          ),
                        ),
                        const SizedBox(height: 8),
                        Container(
                          padding: const EdgeInsets.all(12),
                          decoration: BoxDecoration(
                            color: theme.colorScheme.surfaceContainerHighest,
                            borderRadius: BorderRadius.circular(8),
                          ),
                          child: Text(
                            event.description!,
                            style: theme.textTheme.bodyMedium,
                          ),
                        ),
                      ],
                    ],
                  ),
                ),
              ),
            ],
          );
        },
      ),
    );
  }

  Widget _buildDetailRow({
    required IconData icon,
    required String label,
    required String value,
    Color? color,
  }) {
    return Padding(
      padding: const EdgeInsets.symmetric(vertical: 8),
      child: Row(
        children: [
          Icon(
            icon,
            size: 20,
            color: color ?? Colors.grey,
          ),
          const SizedBox(width: 12),
          Expanded(
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Text(
                  label,
                  style: const TextStyle(
                    color: Colors.grey,
                    fontSize: 12,
                  ),
                ),
                Text(
                  value,
                  style: TextStyle(
                    fontWeight: FontWeight.w600,
                    color: color,
                  ),
                ),
              ],
            ),
          ),
        ],
      ),
    );
  }

  String _formatDate(DateTime date) {
    const months = [
      'January', 'February', 'March', 'April', 'May', 'June',
      'July', 'August', 'September', 'October', 'November', 'December'
    ];
    return '${months[date.month - 1]} ${date.day}, ${date.year}';
  }

  String _formatTimeRange(BuildContext context, CalendarEvent event) {
    final startTime = TimeOfDay.fromDateTime(event.startTime);
    if (event.endTime == null) {
      return startTime.format(context);
    }
    final endTime = TimeOfDay.fromDateTime(event.endTime!);
    return '${startTime.format(context)} - ${endTime.format(context)}';
  }

  String _getRecurrenceText(CalendarEvent event) {
    switch (event.recurrence) {
      case RecurrenceType.daily:
        return 'Daily';
      case RecurrenceType.weekly:
        return 'Weekly on ${_getDayName(event.startTime.weekday)}';
      case RecurrenceType.monthly:
        return 'Monthly on day ${event.startTime.day}';
      case RecurrenceType.yearly:
        return 'Yearly on ${_formatMonthDay(event.startTime)}';
      case RecurrenceType.custom:
        return 'Custom';
      case RecurrenceType.none:
        return 'Does not repeat';
    }
  }
  
  String _formatMonthDay(DateTime date) {
    const months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
    return '${months[date.month - 1]} ${date.day}';
  }

  String _getDayName(int weekday) {
    const days = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday'];
    return days[weekday - 1];
  }

  String _getReminderText(int minutes) {
    if (minutes < 60) {
      return '$minutes minutes before';
    } else if (minutes < 1440) {
      final hours = minutes ~/ 60;
      return '$hours ${hours == 1 ? 'hour' : 'hours'} before';
    } else {
      final days = minutes ~/ 1440;
      return '$days ${days == 1 ? 'day' : 'days'} before';
    }
  }
}

// Create Event Sheet
class CreateEventSheet extends StatefulWidget {
  final Function(Map<String, dynamic>) onEventCreated;

  const CreateEventSheet({
    super.key,
    required this.onEventCreated,
  });

  @override
  State<CreateEventSheet> createState() => _CreateEventSheetState();
}

class _CreateEventSheetState extends State<CreateEventSheet> {
  final _titleController = TextEditingController();
  final _descriptionController = TextEditingController();
  final _locationController = TextEditingController();
  EventType _selectedType = EventType.personal;
  DateTime _selectedDate = DateTime.now();
  TimeOfDay? _startTime;
  TimeOfDay? _endTime;
  bool _isAllDay = false;
  bool _hasReminder = false;
  int _reminderMinutes = 60;
  bool _syncToDeviceCalendar = false;

  @override
  void dispose() {
    _titleController.dispose();
    _descriptionController.dispose();
    _locationController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);

    return Container(
      height: MediaQuery.of(context).size.height * 0.9,
      decoration: BoxDecoration(
        color: theme.colorScheme.surface,
        borderRadius: const BorderRadius.vertical(top: Radius.circular(20)),
      ),
      child: Column(
        children: [
          // Handle Bar
          Center(
            child: Container(
              margin: const EdgeInsets.only(top: 12, bottom: 8),
              width: 40,
              height: 4,
              decoration: BoxDecoration(
                color: theme.colorScheme.onSurfaceVariant.withValues(alpha: 0.3),
                borderRadius: BorderRadius.circular(2),
              ),
            ),
          ),
          // Header
          Padding(
            padding: const EdgeInsets.symmetric(horizontal: 24, vertical: 16),
            child: Row(
              mainAxisAlignment: MainAxisAlignment.spaceBetween,
              children: [
                Text(
                  'New Event',
                  style: theme.textTheme.headlineSmall?.copyWith(
                    fontWeight: FontWeight.bold,
                  ),
                ),
                IconButton(
                  onPressed: () => Navigator.pop(context),
                  icon: const Icon(Icons.close),
                ),
              ],
            ),
          ),
          // Form
          Expanded(
            child: SingleChildScrollView(
              padding: const EdgeInsets.symmetric(horizontal: 24),
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  // Title Field
                  TextField(
                    controller: _titleController,
                    decoration: const InputDecoration(
                      labelText: 'Event Title',
                      hintText: 'Enter event title',
                      border: OutlineInputBorder(),
                    ),
                  ),
                  const SizedBox(height: 16),

                  // Type Dropdown
                  DropdownButtonFormField<EventType>(
                    value: _selectedType,
                    decoration: const InputDecoration(
                      labelText: 'Event Type',
                      border: OutlineInputBorder(),
                    ),
                    items: EventType.values.map((type) {
                      return DropdownMenuItem(
                        value: type,
                        child: Text(type.displayName),
                      );
                    }).toList(),
                    onChanged: (value) {
                      setState(() {
                        _selectedType = value!;
                      });
                    },
                  ),
                  const SizedBox(height: 16),

                  // Date Picker
                  InkWell(
                    onTap: () async {
                      final picked = await showDatePicker(
                        context: context,
                        initialDate: _selectedDate,
                        firstDate: DateTime.now(),
                        lastDate: DateTime.now().add(const Duration(days: 365)),
                      );
                      if (picked != null) {
                        setState(() {
                          _selectedDate = picked;
                        });
                      }
                    },
                    child: InputDecorator(
                      decoration: const InputDecoration(
                        labelText: 'Date',
                        border: OutlineInputBorder(),
                        suffixIcon: Icon(Icons.calendar_today),
                      ),
                      child: Text(
                        '${_selectedDate.day}/${_selectedDate.month}/${_selectedDate.year}',
                      ),
                    ),
                  ),
                  const SizedBox(height: 16),

                  // All Day Switch
                  SwitchListTile(
                    title: const Text('All Day Event'),
                    value: _isAllDay,
                    onChanged: (value) {
                      setState(() {
                        _isAllDay = value;
                        if (value) {
                          _startTime = null;
                          _endTime = null;
                        }
                      });
                    },
                  ),

                  if (!_isAllDay) ...[
                    // Start Time Picker
                    InkWell(
                      onTap: () async {
                        final picked = await showTimePicker(
                          context: context,
                          initialTime: _startTime ?? TimeOfDay.now(),
                        );
                        if (picked != null) {
                          setState(() {
                            _startTime = picked;
                          });
                        }
                      },
                      child: InputDecorator(
                        decoration: const InputDecoration(
                          labelText: 'Start Time',
                          border: OutlineInputBorder(),
                          suffixIcon: Icon(Icons.access_time),
                        ),
                        child: Text(
                          _startTime?.format(context) ?? 'Select start time',
                        ),
                      ),
                    ),
                    const SizedBox(height: 16),

                    // End Time Picker
                    InkWell(
                      onTap: () async {
                        final picked = await showTimePicker(
                          context: context,
                          initialTime: _endTime ?? _startTime ?? TimeOfDay.now(),
                        );
                        if (picked != null) {
                          setState(() {
                            _endTime = picked;
                          });
                        }
                      },
                      child: InputDecorator(
                        decoration: const InputDecoration(
                          labelText: 'End Time (Optional)',
                          border: OutlineInputBorder(),
                          suffixIcon: Icon(Icons.access_time),
                        ),
                        child: Text(
                          _endTime?.format(context) ?? 'Select end time',
                        ),
                      ),
                    ),
                    const SizedBox(height: 16),
                  ],

                  // Location Field
                  TextField(
                    controller: _locationController,
                    decoration: const InputDecoration(
                      labelText: 'Location (Optional)',
                      hintText: 'Enter location',
                      border: OutlineInputBorder(),
                      prefixIcon: Icon(Icons.location_on),
                    ),
                  ),
                  const SizedBox(height: 16),

                  // Reminder Switch
                  SwitchListTile(
                    title: const Text('Set Reminder'),
                    value: _hasReminder,
                    onChanged: (value) {
                      setState(() {
                        _hasReminder = value;
                      });
                    },
                  ),

                  if (_hasReminder) ...[
                    DropdownButtonFormField<int>(
                      value: _reminderMinutes,
                      decoration: const InputDecoration(
                        labelText: 'Reminder Time',
                        border: OutlineInputBorder(),
                      ),
                      items: const [
                        DropdownMenuItem(value: 15, child: Text('15 minutes before')),
                        DropdownMenuItem(value: 30, child: Text('30 minutes before')),
                        DropdownMenuItem(value: 60, child: Text('1 hour before')),
                        DropdownMenuItem(value: 120, child: Text('2 hours before')),
                        DropdownMenuItem(value: 1440, child: Text('1 day before')),
                      ],
                      onChanged: (value) {
                        setState(() {
                          _reminderMinutes = value!;
                        });
                      },
                    ),
                    const SizedBox(height: 16),
                  ],

                  // Device Calendar Sync Switch
                  SwitchListTile(
                    title: const Text('Sync to Device Calendar'),
                    subtitle: const Text('Add this event to your device calendar'),
                    value: _syncToDeviceCalendar,
                    onChanged: (value) {
                      setState(() {
                        _syncToDeviceCalendar = value;
                      });
                    },
                  ),
                  const SizedBox(height: 16),

                  // Description Field
                  TextField(
                    controller: _descriptionController,
                    maxLines: 4,
                    decoration: const InputDecoration(
                      labelText: 'Description (Optional)',
                      hintText: 'Enter event description',
                      border: OutlineInputBorder(),
                      alignLabelWithHint: true,
                    ),
                  ),
                  const SizedBox(height: 32),
                ],
              ),
            ),
          ),
          // Action Buttons
          Container(
            padding: const EdgeInsets.all(24),
            decoration: BoxDecoration(
              color: theme.colorScheme.surface,
              boxShadow: [
                BoxShadow(
                  color: Colors.black.withValues(alpha: 0.1),
                  blurRadius: 10,
                  offset: const Offset(0, -5),
                ),
              ],
            ),
            child: Row(
              children: [
                Expanded(
                  child: OutlinedButton(
                    onPressed: () => Navigator.pop(context),
                    style: OutlinedButton.styleFrom(
                      padding: const EdgeInsets.symmetric(vertical: 16),
                    ),
                    child: const Text('Cancel'),
                  ),
                ),
                const SizedBox(width: 16),
                Expanded(
                  child: FilledButton(
                    onPressed: () {
                      if (_titleController.text.isEmpty) {
                        ScaffoldMessenger.of(context).showSnackBar(
                          const SnackBar(
                            content: Text('Please enter an event title'),
                          ),
                        );
                        return;
                      }

                      DateTime? startDateTime;
                      DateTime? endDateTime;

                      if (!_isAllDay && _startTime != null) {
                        startDateTime = DateTime(
                          _selectedDate.year,
                          _selectedDate.month,
                          _selectedDate.day,
                          _startTime!.hour,
                          _startTime!.minute,
                        );

                        if (_endTime != null) {
                          endDateTime = DateTime(
                            _selectedDate.year,
                            _selectedDate.month,
                            _selectedDate.day,
                            _endTime!.hour,
                            _endTime!.minute,
                          );
                        }
                      } else {
                        startDateTime = DateTime(
                          _selectedDate.year,
                          _selectedDate.month,
                          _selectedDate.day,
                        );
                      }

                      widget.onEventCreated({
                        'title': _titleController.text,
                        'type': _selectedType,
                        'startTime': startDateTime,
                        'endTime': endDateTime,
                        'isAllDay': _isAllDay,
                        'location': _locationController.text.isEmpty ? null : _locationController.text,
                        'description': _descriptionController.text.isEmpty ? null : _descriptionController.text,
                        'hasReminder': _hasReminder,
                        'reminderMinutes': _hasReminder ? _reminderMinutes : null,
                        'syncToDeviceCalendar': _syncToDeviceCalendar,
                      });

                      Navigator.pop(context);
                    },
                    style: FilledButton.styleFrom(
                      padding: const EdgeInsets.symmetric(vertical: 16),
                    ),
                    child: const Text('Create Event'),
                  ),
                ),
              ],
            ),
          ),
        ],
      ),
    );
  }
}
````

## File: lib/features/chat/presentation/providers/chat_provider.dart
````dart
/// Chat and messaging state management provider.
/// 
/// This module manages real-time chat functionality for the education
/// platform, handling direct messages, group chats, and class-based
/// discussions with comprehensive state management.
library;

import 'dart:async';
import 'package:flutter/material.dart';
import '../../domain/models/message.dart';
import '../../domain/models/chat_room.dart';
import '../../domain/repositories/chat_repository.dart';
import '../../../../shared/core/service_locator.dart';
import '../../../auth/presentation/providers/auth_provider.dart';

/// Provider managing chat rooms and messages.
/// 
/// This provider serves as the central state manager for chat functionality,
/// coordinating real-time messaging features. Key capabilities:
/// - Direct and group chat management
/// - Real-time message streaming
/// - Read receipt tracking
/// - Message search functionality
/// - Chat room discovery and creation
/// - Automatic unread count management
/// 
/// Maintains active streams for chat rooms and messages with
/// automatic cleanup to prevent memory leaks.
class ChatProvider with ChangeNotifier {
  /// Repository for chat data operations.
  late final ChatRepository _chatRepository;
  
  /// Auth provider for user identification.
  late AuthProvider _authProvider;
  
  /// Creates chat provider with repository dependency.
  /// 
  /// Retrieves chat repository from dependency injection.
  /// Auth provider must be set separately via setAuthProvider.
  ChatProvider() {
    _chatRepository = getIt<ChatRepository>();
  }
  
  /// User's chat rooms list.
  List<ChatRoom> _chatRooms = [];
  
  /// Messages in current chat room.
  List<Message> _currentMessages = [];
  
  /// Currently active chat room.
  ChatRoom? _currentChatRoom;
  
  /// Loading state for async operations.
  bool _isLoading = false;
  
  /// Latest error message for UI display.
  String? _error;
  
  // Stream subscriptions
  
  /// Subscription for chat rooms list updates.
  StreamSubscription<List<ChatRoom>>? _chatRoomsSubscription;
  
  /// Subscription for current chat messages.
  StreamSubscription<List<Message>>? _messagesSubscription;
  
  /// Sets the authentication provider reference.
  /// 
  /// Required for user identification in chat operations.
  /// Must be called after provider initialization.
  /// 
  /// @param authProvider Authentication provider instance
  void setAuthProvider(AuthProvider authProvider) {
    _authProvider = authProvider;
  }

  // Getters
  
  /// List of user's chat rooms.
  List<ChatRoom> get chatRooms => _chatRooms;
  
  /// Messages in active chat room.
  List<Message> get currentMessages => _currentMessages;
  
  /// Currently selected chat room or null.
  ChatRoom? get currentChatRoom => _currentChatRoom;
  
  /// Whether an operation is in progress.
  bool get isLoading => _isLoading;
  
  /// Latest error message or null.
  String? get error => _error;

  /// Initializes real-time chat room monitoring.
  /// 
  /// Sets up stream subscription for user's chat rooms,
  /// automatically updating when rooms are added/removed
  /// or when last messages change. Cancels any existing
  /// subscription before creating new one.
  void initializeChatRooms() {
    // Cancel existing subscription before creating new one
    _chatRoomsSubscription?.cancel();
    
    // Store the subscription
    _chatRoomsSubscription = _chatRepository.getUserChatRooms().listen(
      (rooms) {
        _chatRooms = rooms;
        _error = null;
        notifyListeners();
      },
      onError: (error) {
        _error = error.toString();
        notifyListeners();
      },
    );
  }

  /// Loads and subscribes to messages for a chat room.
  /// 
  /// Sets up real-time stream for message updates including
  /// new messages, edits, and deletions. Returns latest 100
  /// messages ordered by most recent first.
  /// 
  /// @param chatRoomId Chat room to load messages from
  void loadChatMessages(String chatRoomId) {
    // Cancel existing subscription before creating new one
    _messagesSubscription?.cancel();
    
    // Store the subscription
    _messagesSubscription = _chatRepository.getChatMessages(chatRoomId).listen(
      (messages) {
        _currentMessages = messages;
        _error = null;
        notifyListeners();
      },
      onError: (error) {
        _error = error.toString();
        notifyListeners();
      },
    );
  }

  /// Sets the active chat room and loads its messages.
  /// 
  /// Automatically:
  /// - Loads message history
  /// - Marks unread messages as read
  /// - Updates UI state
  /// 
  /// @param chatRoom Chat room to activate
  void setCurrentChatRoom(ChatRoom chatRoom) {
    _currentChatRoom = chatRoom;
    loadChatMessages(chatRoom.id);
    markMessagesAsRead(chatRoom.id);
    notifyListeners();
  }
  
  /// Retrieves a specific chat room by ID.
  /// 
  /// Fetches fresh data from repository for accuracy.
  /// 
  /// @param chatRoomId Chat room identifier
  /// @return Chat room instance or null if not found/error
  Future<ChatRoom?> getChatRoom(String chatRoomId) async {
    try {
      return await _chatRepository.getChatRoom(chatRoomId);
    } catch (e) {
      _error = e.toString();
      notifyListeners();
      return null;
    }
  }

  /// Creates or retrieves existing direct chat.
  /// 
  /// Intelligent handling prevents duplicate direct chats:
  /// - Checks for existing chat between users
  /// - Returns existing if found
  /// - Creates new if none exists
  /// 
  /// Automatically loads messages and sets as current chat.
  /// 
  /// @param otherUserId ID of other participant
  /// @param otherUserName Display name of other user
  /// @param otherUserRole Role of other user
  /// @return Created or existing chat room
  /// @throws Exception if operation fails
  Future<ChatRoom> createOrGetDirectChat(
    String otherUserId,
    String otherUserName,
    String otherUserRole,
  ) async {
    _isLoading = true;
    _error = null;
    notifyListeners();

    try {
      final chatRoom = await _chatRepository.createOrGetDirectChat(
        otherUserId,
        otherUserName,
        otherUserRole,
      );
      _currentChatRoom = chatRoom;
      loadChatMessages(chatRoom.id);
      return chatRoom;
    } catch (e) {
      _error = e.toString();
      rethrow;
    } finally {
      _isLoading = false;
      notifyListeners();
    }
  }

  /// Creates a new group chat room.
  /// 
  /// Supports different group types:
  /// - 'group': General purpose groups
  /// - 'class': Class-specific discussions
  /// - 'announcement': Broadcast channels
  /// 
  /// @param name Display name for the group
  /// @param type Group type identifier
  /// @param participantIds List of participant user IDs
  /// @param participants List of participant info objects
  /// @param classId Optional class association
  /// @return Created group chat room
  /// @throws Exception if creation fails
  Future<ChatRoom> createGroupChat({
    required String name,
    required String type,
    required List<String> participantIds,
    required List<ParticipantInfo> participants,
    String? classId,
  }) async {
    _isLoading = true;
    _error = null;
    notifyListeners();

    try {
      final chatRoom = await _chatRepository.createGroupChat(
        name: name,
        type: type,
        participantIds: participantIds,
        participants: participants,
        classId: classId,
      );
      return chatRoom;
    } catch (e) {
      _error = e.toString();
      rethrow;
    } finally {
      _isLoading = false;
      notifyListeners();
    }
  }

  /// Sends a message to the current chat room.
  /// 
  /// Requires an active chat room to be set.
  /// Supports text messages and file attachments.
  /// Updates last message info and triggers real-time
  /// delivery to all participants.
  /// 
  /// @param content Message text content
  /// @param attachmentUrl Optional file attachment URL
  /// @param attachmentType Optional attachment MIME type
  /// @throws Exception if sending fails
  Future<void> sendMessage({
    required String content,
    String? attachmentUrl,
    String? attachmentType,
  }) async {
    if (_currentChatRoom == null) {
      return;
    }

    try {
      await _chatRepository.sendMessage(
        chatRoomId: _currentChatRoom!.id,
        content: content,
        attachmentUrl: attachmentUrl,
        attachmentType: attachmentType,
      );
      _error = null;
    } catch (e) {
      _error = e.toString();
      notifyListeners();
      rethrow;
    }
  }

  /// Marks all unread messages in a chat as read.
  /// 
  /// Updates message statuses and resets unread count
  /// for the current user. Called automatically when
  /// entering a chat room.
  /// 
  /// @param chatRoomId Chat room to mark as read
  Future<void> markMessagesAsRead(String chatRoomId) async {
    try {
      await _chatRepository.markMessagesAsRead(chatRoomId);
    } catch (e) {
      _error = e.toString();
      notifyListeners();
    }
  }

  /// Deletes a message from the current chat.
  /// 
  /// Permanently removes the message. Consider implementing
  /// soft deletion for audit trails in production.
  /// 
  /// @param messageId Message to delete
  /// @throws Exception if deletion fails
  Future<void> deleteMessage(String messageId) async {
    if (_currentChatRoom == null) return;

    try {
      await _chatRepository.deleteMessage(_currentChatRoom!.id, messageId);
      _error = null;
    } catch (e) {
      _error = e.toString();
      notifyListeners();
      rethrow;
    }
  }

  /// Removes current user from a chat room.
  /// 
  /// For group chats, removes user from participants.
  /// If leaving current chat, clears active state.
  /// Direct chats typically cannot be left.
  /// 
  /// @param chatRoomId Chat room to leave
  /// @throws Exception if leaving fails
  Future<void> leaveChatRoom(String chatRoomId) async {
    try {
      await _chatRepository.leaveChatRoom(chatRoomId);
      if (_currentChatRoom?.id == chatRoomId) {
        _currentChatRoom = null;
        _currentMessages = [];
      }
      _error = null;
      notifyListeners();
    } catch (e) {
      _error = e.toString();
      notifyListeners();
      rethrow;
    }
  }

  /// Toggles mute status for notifications in a chat room.
  /// 
  /// Adds or removes current user from mutedUsers list.
  /// Updates Firestore directly assuming repository method.
  /// 
  /// @param chatRoomId Chat room to toggle mute for
  Future<void> toggleMute(String chatRoomId) async {
    final currentUserId = _authProvider.userModel?.uid;
    if (currentUserId == null) return;

    try {
      final chatRoom = await getChatRoom(chatRoomId);
      if (chatRoom == null) return;

      final mutedUsers = List<String>.from(chatRoom.mutedUsers);
      if (mutedUsers.contains(currentUserId)) {
        mutedUsers.remove(currentUserId);
      } else {
        mutedUsers.add(currentUserId);
      }

      // Assuming _chatRepository has updateChatRoom, or implement directly
      final updatedChatRoom = chatRoom.copyWith(mutedUsers: mutedUsers);
await _chatRepository.updateChatRoom(chatRoomId, updatedChatRoom);
final index = _chatRooms.indexWhere((room) => room.id == chatRoomId);
if (index != -1) {
  _chatRooms[index] = updatedChatRoom;
}

      // Update local state if current
      if (_currentChatRoom?.id == chatRoomId) {
        _currentChatRoom = chatRoom.copyWith(mutedUsers: mutedUsers);
      }

      notifyListeners();
    } catch (e) {
      _error = e.toString();
      notifyListeners();
    }
  }

  /// Legacy wrapper for chat room creation.
  /// 
  /// Converts map-based participant format to structured
  /// ParticipantInfo objects. Maintained for backward
  /// compatibility with older UI code.
  /// 
  /// @param name Chat room name
  /// @param type Chat room type
  /// @param participants Map of user ID to display name
  /// @param classId Optional class association
  /// @return Created chat room ID or null
  /// @deprecated Use createGroupChat instead
  Future<String?> createChatRoom({
    required String name,
    required String type,
    required Map<String, String> participants,
    String? classId,
  }) async {
    final participantIds = participants.keys.toList();
    final participantInfoList = participants.entries.map((entry) => 
      ParticipantInfo(
        id: entry.key,
        name: entry.value,
        role: 'user', // Default role, can be enhanced later
      )
    ).toList();
    
    final chatRoom = await createGroupChat(
      name: name,
      type: type,
      participantIds: participantIds,
      participants: participantInfoList,
      classId: classId,
    );
    return chatRoom.id;
  }

  /// Searches for existing direct chat with a user.
  /// 
  /// Two-phase search:
  /// 1. Checks locally cached chat rooms for performance
  /// 2. Falls back to repository search if not found
  /// 
  /// @param otherUserId Other participant's ID
  /// @return Existing chat room or null if none exists
  Future<ChatRoom?> findDirectChat(String otherUserId) async {
    try {
      final currentUserId = _authProvider.userModel?.uid;
      if (currentUserId == null) return null;

      // Check loaded chat rooms first
      for (final chatRoom in _chatRooms) {
        if (chatRoom.type == 'direct' &&
            chatRoom.participantIds.contains(currentUserId) &&
            chatRoom.participantIds.contains(otherUserId) &&
            chatRoom.participantIds.length == 2) {
          return chatRoom;
        }
      }

      // If not found in loaded rooms, use repository to find it
      return await _chatRepository.findDirectChat(currentUserId, otherUserId);
    } catch (e) {
      _error = e.toString();
      notifyListeners();
      return null;
    }
  }

  /// Searches messages in current chat room.
  /// 
  /// Performs case-insensitive search through message content.
  /// Requires an active chat room. Current implementation
  /// searches client-side; consider server-side search for
  /// large message volumes.
  /// 
  /// @param query Search terms
  /// @return List of matching messages
  Future<List<Message>> searchMessages(String query) async {
    if (_currentChatRoom == null) return [];

    try {
      final results = await _chatRepository.searchMessages(
        _currentChatRoom!.id,
        query,
      );
      return results;
    } catch (e) {
      _error = e.toString();
      notifyListeners();
      return [];
    }
  }

  /// Clears the current chat selection.
  /// 
  /// Resets active chat room and message list.
  /// Useful when navigating away from chat views.
  void clearCurrentChat() {
    _currentChatRoom = null;
    _currentMessages = [];
    notifyListeners();
  }

  /// Cleans up resources when provider is disposed.
  /// 
  /// Cancels all stream subscriptions and disposes
  /// repository to prevent memory leaks.
  @override
  void dispose() {
    // Cancel all subscriptions
    _chatRoomsSubscription?.cancel();
    _messagesSubscription?.cancel();
    
    // Dispose repository
    _chatRepository.dispose();
    
    super.dispose();
  }
}
````

## File: lib/features/chat/presentation/screens/chat_list_screen.dart
````dart
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'package:go_router/go_router.dart';
import 'package:intl/intl.dart';
import 'package:cached_network_image/cached_network_image.dart';
import '../providers/chat_provider.dart';
import '../../../auth/presentation/providers/auth_provider.dart';
import '../../domain/models/chat_room.dart';
import '../../../../shared/widgets/common/adaptive_layout.dart';

class ChatListScreen extends StatefulWidget {
  const ChatListScreen({super.key});

  @override
  State<ChatListScreen> createState() => _ChatListScreenState();
}

class _ChatListScreenState extends State<ChatListScreen> {
  final TextEditingController _searchController = TextEditingController();
  String _searchQuery = '';

  @override
  void initState() {
    super.initState();
    WidgetsBinding.instance.addPostFrameCallback((_) {
      final chatProvider = context.read<ChatProvider>();
      final authProvider = context.read<AuthProvider>();
      chatProvider.setAuthProvider(authProvider);
      chatProvider.initializeChatRooms();
    });
  }

  @override
  void dispose() {
    _searchController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return AdaptiveLayout(
      title: 'Messages',
      showBackButton: true,
      onBackPressed: () => context.go('/dashboard'),
      actions: [
        IconButton(
          icon: const Icon(Icons.search),
          onPressed: () {
            _showSearchDialog();
          },
        ),
        IconButton(
          icon: const Icon(Icons.group_add),
          onPressed: () {
            _showNewChatDialog(context);
          },
        ),
      ],
      body: Consumer<ChatProvider>(
        builder: (context, chatProvider, child) {
          if (chatProvider.error != null) {
            return Center(
              child: Column(
                mainAxisAlignment: MainAxisAlignment.center,
                children: [
                  const Icon(Icons.error_outline, size: 64, color: Colors.red),
                  const SizedBox(height: 16),
                  Text('Error: ${chatProvider.error}'),
                  const SizedBox(height: 16),
                  ElevatedButton(
                    onPressed: () => chatProvider.initializeChatRooms(),
                    child: const Text('Retry'),
                  ),
                ],
              ),
            );
          }

          final allChatRooms = chatProvider.chatRooms;

          // Filter chat rooms based on search query
          final chatRooms = _searchQuery.isEmpty
              ? allChatRooms
              : allChatRooms.where((room) {
                  final authProvider = context.read<AuthProvider>();
                  final currentUserId = authProvider.userModel?.uid ?? '';
                  final displayName = room.getDisplayName(currentUserId);
                  
                  return displayName
                          .toLowerCase()
                          .contains(_searchQuery.toLowerCase()) ||
                      (room.lastMessage
                              ?.toLowerCase()
                              .contains(_searchQuery.toLowerCase()) ??
                          false);
                }).toList();

          if (chatRooms.isEmpty && _searchQuery.isNotEmpty) {
            return Center(
              child: Column(
                mainAxisAlignment: MainAxisAlignment.center,
                children: [
                  const Icon(Icons.search_off, size: 64),
                  const SizedBox(height: 16),
                  Text('No chats found for "$_searchQuery"'),
                  const SizedBox(height: 8),
                  TextButton(
                    onPressed: () {
                      setState(() {
                        _searchQuery = '';
                        _searchController.clear();
                      });
                    },
                    child: const Text('Clear search'),
                  ),
                ],
              ),
            );
          }

          if (chatRooms.isEmpty) {
            return const Center(
              child: Column(
                mainAxisAlignment: MainAxisAlignment.center,
                children: [
                  Icon(Icons.chat_bubble_outline, size: 64),
                  SizedBox(height: 16),
                  Text('No conversations yet'),
                  SizedBox(height: 8),
                  Text('Start a new chat to begin messaging'),
                ],
              ),
            );
          }

          return ListView.builder(
            itemCount: chatRooms.length,
            itemBuilder: (context, index) {
              final chatRoom = chatRooms[index];
              return _buildChatRoomTile(context, chatRoom);
            },
          );
        },
      ),
    );
  }

  Widget _buildChatRoomTile(BuildContext context, ChatRoom chatRoom) {
    final theme = Theme.of(context);
    final hasUnread = chatRoom.unreadCount > 0;
    final authProvider = context.read<AuthProvider>();
    final currentUserId = authProvider.userModel?.uid ?? '';
    
    // Get the display name and photo for this chat room from current user's perspective
    final displayName = chatRoom.getDisplayName(currentUserId);
    final displayPhotoUrl = chatRoom.getDisplayPhotoUrl(currentUserId);

    return ListTile(
      leading: CircleAvatar(
        backgroundColor: theme.colorScheme.primaryContainer,
        backgroundImage: displayPhotoUrl != null
            ? CachedNetworkImageProvider(displayPhotoUrl)
            : null,
        child: displayPhotoUrl == null
            ? Text(
                displayName.isNotEmpty ? displayName[0].toUpperCase() : '?',
                style: TextStyle(
                  color: theme.colorScheme.onPrimaryContainer,
                  fontWeight: FontWeight.bold,
                ),
              )
            : null,
      ),
      title: Row(
        children: [
          Expanded(
            child: Text(
              displayName,
              style: TextStyle(
                fontWeight: hasUnread ? FontWeight.bold : FontWeight.normal,
              ),
            ),
          ),
          if (chatRoom.lastMessageTime != null)
            Text(
              _formatTime(chatRoom.lastMessageTime!),
              style: theme.textTheme.bodySmall?.copyWith(
                color: hasUnread
                    ? theme.colorScheme.primary
                    : theme.colorScheme.onSurfaceVariant,
              ),
            ),
        ],
      ),
      subtitle: Row(
        children: [
          Expanded(
            child: Text(
              chatRoom.lastMessage ?? 'No messages yet',
              maxLines: 1,
              overflow: TextOverflow.ellipsis,
              style: TextStyle(
                color: hasUnread
                    ? theme.colorScheme.onSurface
                    : theme.colorScheme.onSurfaceVariant,
                fontWeight: hasUnread ? FontWeight.w500 : FontWeight.normal,
              ),
            ),
          ),
          if (hasUnread)
            Container(
              padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 2),
              decoration: BoxDecoration(
                color: theme.colorScheme.primary,
                borderRadius: BorderRadius.circular(12),
              ),
              child: Text(
                chatRoom.unreadCount.toString(),
                style: TextStyle(
                  color: theme.colorScheme.onPrimary,
                  fontSize: 12,
                  fontWeight: FontWeight.bold,
                ),
              ),
            ),
        ],
      ),
      onTap: () {
        context.read<ChatProvider>().setCurrentChatRoom(chatRoom);
        context.push('/chat/${chatRoom.id}');
      },
    );
  }

  String _formatTime(DateTime time) {
    final now = DateTime.now();
    final difference = now.difference(time);

    if (difference.inDays == 0) {
      return DateFormat('HH:mm').format(time);
    } else if (difference.inDays == 1) {
      return 'Yesterday';
    } else if (difference.inDays < 7) {
      return DateFormat('EEEE').format(time);
    } else {
      return DateFormat('dd/MM/yy').format(time);
    }
  }

  void _showNewChatDialog(BuildContext context) {
    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        title: const Text('New Chat'),
        content: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            ListTile(
              leading: const Icon(Icons.person),
              title: const Text('Direct Message'),
              onTap: () {
                Navigator.pop(context);
                context.push('/chat/user-selection');
              },
            ),
            ListTile(
              leading: const Icon(Icons.group),
              title: const Text('Group Chat'),
              onTap: () {
                Navigator.pop(context);
                context.push('/chat/group-creation');
              },
            ),
            ListTile(
              leading: const Icon(Icons.school),
              title: const Text('Class Chat'),
              onTap: () {
                Navigator.pop(context);
                context.push('/chat/class-selection');
              },
            ),
          ],
        ),
      ),
    );
  }

  void _showSearchDialog() {
    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        title: const Text('Search Chats'),
        content: TextField(
          controller: _searchController,
          autofocus: true,
          decoration: const InputDecoration(
            hintText: 'Search by name or message content',
            prefixIcon: Icon(Icons.search),
          ),
          onChanged: (value) {
            setState(() {
              _searchQuery = value;
            });
          },
        ),
        actions: [
          TextButton(
            onPressed: () {
              setState(() {
                _searchQuery = '';
                _searchController.clear();
              });
              Navigator.pop(context);
            },
            child: const Text('Clear'),
          ),
          TextButton(
            onPressed: () => Navigator.pop(context),
            child: const Text('Done'),
          ),
        ],
      ),
    );
  }
}
````

## File: lib/features/chat/presentation/screens/class_selection_screen.dart
````dart
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'package:go_router/go_router.dart';
import 'package:cloud_firestore/cloud_firestore.dart';
import '../../../auth/presentation/providers/auth_provider.dart';
import '../providers/chat_provider.dart';
import '../../domain/models/chat_room.dart';
import '../../../../shared/models/user_model.dart';
import '../../../../shared/widgets/common/adaptive_layout.dart';

class ClassSelectionScreen extends StatefulWidget {
  const ClassSelectionScreen({super.key});

  @override
  State<ClassSelectionScreen> createState() => _ClassSelectionScreenState();
}

class _ClassSelectionScreenState extends State<ClassSelectionScreen> {
  bool _isLoading = true;
  List<Map<String, dynamic>> _classes = [];
  String? _error;

  @override
  void initState() {
    super.initState();
    _loadClasses();
  }

  Future<void> _loadClasses() async {
    try {
      final authProvider = context.read<AuthProvider>();
      final userId = authProvider.userModel?.uid;
      final userRole = authProvider.userModel?.role;

      if (userId == null || userRole == null) {
        setState(() {
          _error = 'User not authenticated';
          _isLoading = false;
        });
        return;
      }

      Query query;
      if (userRole == UserRole.teacher) {
        // Teachers see classes they created
        query = FirebaseFirestore.instance
            .collection('classes')
            .where('teacherId', isEqualTo: userId);
      } else {
        // Students see classes they're enrolled in
        query = FirebaseFirestore.instance
            .collection('classes')
            .where('students', arrayContains: userId);
      }

      final querySnapshot = await query.get();
      final classes = querySnapshot.docs.map((doc) {
        final data = doc.data() as Map<String, dynamic>;
        return {
          'id': doc.id,
          'name': data['name'] ?? 'Unnamed Class',
          'teacherName': data['teacherName'] ?? '',
          'studentCount': (data['students'] as List?)?.length ?? 0,
          'hasChatRoom': data['chatRoomId'] != null,
          'chatRoomId': data['chatRoomId'],
          ...data,
        };
      }).toList();

      setState(() {
        _classes = classes;
        _isLoading = false;
      });
    } catch (e) {
      setState(() {
        _error = e.toString();
        _isLoading = false;
      });
    }
  }

  Future<void> _createOrJoinClassChat(Map<String, dynamic> classData) async {
    try {
      final chatProvider = context.read<ChatProvider>();

      if (classData['hasChatRoom'] && classData['chatRoomId'] != null) {
        // Chat room already exists, navigate to it
        context.go('/chat/${classData['chatRoomId']}');
      } else {
        // Create new class chat room
        setState(() => _isLoading = true);

        // Get all class participants
        final classDoc = await FirebaseFirestore.instance
            .collection('classes')
            .doc(classData['id'])
            .get();

        final classInfo = classDoc.data()!;
        final studentIds = List<String>.from(classInfo['students'] ?? []);
        final teacherId = classInfo['teacherId'] as String;

        // Get user details for all participants
        final userIds = [teacherId, ...studentIds];
        final userDocs = await Future.wait(
          userIds.map((id) =>
              FirebaseFirestore.instance.collection('users').doc(id).get()),
        );

        final participants = userDocs.where((doc) => doc.exists).map((doc) {
          final data = doc.data()!;
          return ParticipantInfo(
            id: doc.id,
            name: data['name'] ?? 'Unknown',
            role: data['role'] ?? 'student',
            photoUrl: data['photoUrl'],
          );
        }).toList();

        // Create the chat room
        final chatRoom = await chatProvider.createGroupChat(
          name: '${classData['name']} - Class Chat',
          type: 'class',
          participantIds: userIds,
          participants: participants,
          classId: classData['id'],
        );

        // Update class document with chat room ID
        await FirebaseFirestore.instance
            .collection('classes')
            .doc(classData['id'])
            .update({'chatRoomId': chatRoom.id});

        if (mounted) {
          context.go('/chat/${chatRoom.id}');
        }
      }
    } catch (e) {
      setState(() => _isLoading = false);
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(content: Text('Error creating class chat: $e')),
        );
      }
    }
  }

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final isTeacher =
        context.read<AuthProvider>().userModel?.role == UserRole.teacher;

    return AdaptiveLayout(
      title: 'Select Class for Chat',
      showBackButton: true,
      onBackPressed: () {
        if (context.canPop()) {
          context.pop();
        } else {
          context.go('/messages');
        }
      },
      body: _isLoading
          ? const Center(child: CircularProgressIndicator())
          : _error != null
              ? Center(
                  child: Column(
                    mainAxisAlignment: MainAxisAlignment.center,
                    children: [
                      const Icon(Icons.error_outline,
                          size: 64, color: Colors.red),
                      const SizedBox(height: 16),
                      Text('Error: $_error'),
                      const SizedBox(height: 16),
                      ElevatedButton(
                        onPressed: _loadClasses,
                        child: const Text('Retry'),
                      ),
                    ],
                  ),
                )
              : _classes.isEmpty
                  ? Center(
                      child: Column(
                        mainAxisAlignment: MainAxisAlignment.center,
                        children: [
                          Icon(
                            Icons.school_outlined,
                            size: 64,
                            color: theme.colorScheme.onSurfaceVariant,
                          ),
                          const SizedBox(height: 16),
                          Text(
                            isTeacher
                                ? 'No classes created yet'
                                : 'Not enrolled in any classes',
                            style: theme.textTheme.titleMedium,
                          ),
                          if (isTeacher) ...[
                            const SizedBox(height: 8),
                            ElevatedButton(
                              onPressed: () => context.go('/teacher/classes'),
                              child: const Text('Create a Class'),
                            ),
                          ],
                        ],
                      ),
                    )
                  : ListView.builder(
                      padding: const EdgeInsets.all(8),
                      itemCount: _classes.length,
                      itemBuilder: (context, index) {
                        final classData = _classes[index];
                        final hasChatRoom = classData['hasChatRoom'] as bool;

                        return Card(
                          child: ListTile(
                            leading: CircleAvatar(
                              backgroundColor:
                                  theme.colorScheme.primaryContainer,
                              child: Icon(
                                Icons.school,
                                color: theme.colorScheme.onPrimaryContainer,
                              ),
                            ),
                            title: Text(classData['name']),
                            subtitle: Text(
                              isTeacher
                                  ? '${classData['studentCount']} students'
                                  : 'Teacher: ${classData['teacherName']}',
                            ),
                            trailing: Row(
                              mainAxisSize: MainAxisSize.min,
                              children: [
                                if (hasChatRoom)
                                  Chip(
                                    label: const Text('Active Chat'),
                                    backgroundColor:
                                        theme.colorScheme.primaryContainer,
                                  ),
                                const SizedBox(width: 8),
                                const Icon(Icons.arrow_forward_ios),
                              ],
                            ),
                            onTap: () => _createOrJoinClassChat(classData),
                          ),
                        );
                      },
                    ),
    );
  }
}
````

## File: lib/features/chat/presentation/screens/group_creation_screen.dart
````dart
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'package:go_router/go_router.dart';
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:cached_network_image/cached_network_image.dart';
import '../../../auth/presentation/providers/auth_provider.dart';
import '../providers/chat_provider.dart';
import '../../domain/models/chat_room.dart';
import '../../../../shared/models/user_model.dart';
import '../../../../shared/widgets/common/adaptive_layout.dart';

class GroupCreationScreen extends StatefulWidget {
  const GroupCreationScreen({super.key});

  @override
  State<GroupCreationScreen> createState() => _GroupCreationScreenState();
}

class _GroupCreationScreenState extends State<GroupCreationScreen> {
  final _formKey = GlobalKey<FormState>();
  final _groupNameController = TextEditingController();
  final _searchController = TextEditingController();
  final Set<UserModel> _selectedUsers = {};
  List<UserModel> _searchResults = [];
  bool _isSearching = false;
  bool _isCreating = false;

  @override
  void dispose() {
    _groupNameController.dispose();
    _searchController.dispose();
    super.dispose();
  }

  Future<void> _searchUsers(String query) async {
    if (query.isEmpty) {
      setState(() {
        _searchResults = [];
        _isSearching = false;
      });
      return;
    }

    setState(() => _isSearching = true);

    try {
      final currentUserId = context.read<AuthProvider>().userModel?.uid;
      final querySnapshot = await FirebaseFirestore.instance
          .collection('users')
          .where('name', isGreaterThanOrEqualTo: query)
          .where('name', isLessThanOrEqualTo: '$query\uf8ff')
          .limit(20)
          .get();

      final users = querySnapshot.docs
          .map((doc) => UserModel.fromFirestore(doc))
          .where((user) => user.uid != currentUserId)
          .toList();

      setState(() {
        _searchResults = users;
        _isSearching = false;
      });
    } catch (e) {
      setState(() => _isSearching = false);
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(content: Text('Error searching users: $e')),
        );
      }
    }
  }

  Future<void> _createGroupChat() async {
    if (!_formKey.currentState!.validate()) return;
    if (_selectedUsers.isEmpty) {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(content: Text('Please select at least one user')),
      );
      return;
    }

    setState(() => _isCreating = true);

    try {
      final currentUser = context.read<AuthProvider>().userModel!;
      final chatProvider = context.read<ChatProvider>();

      // Prepare participants list
      final participantIds = [
        currentUser.uid,
        ..._selectedUsers.map((u) => u.uid)
      ];
      final participants = [
        ParticipantInfo(
          id: currentUser.uid,
          name: currentUser.name,
          role: currentUser.role?.name ?? 'user',
          photoUrl: currentUser.photoUrl,
        ),
        ..._selectedUsers.map((user) => ParticipantInfo(
              id: user.uid,
              name: user.name,
              role: user.role?.name ?? 'user',
              photoUrl: user.photoUrl,
            )),
      ];

      final chatRoom = await chatProvider.createGroupChat(
        name: _groupNameController.text.trim(),
        type: 'group',
        participantIds: participantIds,
        participants: participants,
      );

      if (mounted) {
        context.go('/chat/${chatRoom.id}');
      }
    } catch (e) {
      setState(() => _isCreating = false);
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(content: Text('Error creating group: $e')),
        );
      }
    }
  }

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);

    return AdaptiveLayout(
      title: 'Create Group Chat',
      showBackButton: true,
      onBackPressed: () {
        if (context.canPop()) {
          context.pop();
        } else {
          context.go('/messages');
        }
      },
      actions: [
        TextButton(
          onPressed: _isCreating ? null : _createGroupChat,
          child: const Text('Create'),
        ),
      ],
      body: Form(
        key: _formKey,
        child: Column(
          children: [
            Padding(
              padding: const EdgeInsets.all(16.0),
              child: TextFormField(
                controller: _groupNameController,
                decoration: const InputDecoration(
                  labelText: 'Group Name',
                  hintText: 'Enter group name',
                  prefixIcon: Icon(Icons.group),
                ),
                validator: (value) {
                  if (value == null || value.trim().isEmpty) {
                    return 'Please enter a group name';
                  }
                  return null;
                },
              ),
            ),
            Padding(
              padding: const EdgeInsets.symmetric(horizontal: 16.0),
              child: TextField(
                controller: _searchController,
                decoration: InputDecoration(
                  labelText: 'Search Users',
                  hintText: 'Search by name',
                  prefixIcon: const Icon(Icons.search),
                  suffixIcon: _isSearching
                      ? const SizedBox(
                          width: 20,
                          height: 20,
                          child: Padding(
                            padding: EdgeInsets.all(12.0),
                            child: CircularProgressIndicator(strokeWidth: 2),
                          ),
                        )
                      : null,
                ),
                onChanged: (value) => _searchUsers(value),
              ),
            ),
            if (_selectedUsers.isNotEmpty) ...[
              const SizedBox(height: 16),
              Container(
                height: 80,
                padding: const EdgeInsets.symmetric(horizontal: 16),
                child: ListView.builder(
                  scrollDirection: Axis.horizontal,
                  itemCount: _selectedUsers.length,
                  itemBuilder: (context, index) {
                    final user = _selectedUsers.elementAt(index);
                    return Padding(
                      padding: const EdgeInsets.only(right: 8.0),
                      child: Chip(
                        avatar: CircleAvatar(
                          backgroundColor: theme.colorScheme.primaryContainer,
                          child: Text(
                            user.name[0].toUpperCase(),
                            style: TextStyle(
                              color: theme.colorScheme.onPrimaryContainer,
                              fontSize: 12,
                            ),
                          ),
                        ),
                        label: Text(user.name),
                        onDeleted: () {
                          setState(() => _selectedUsers.remove(user));
                        },
                      ),
                    );
                  },
                ),
              ),
            ],
            const Divider(),
            Expanded(
              child: ListView.builder(
                itemCount: _searchResults.length,
                itemBuilder: (context, index) {
                  final user = _searchResults[index];
                  final isSelected = _selectedUsers.contains(user);

                  return ListTile(
                    leading: CircleAvatar(
                      backgroundColor: theme.colorScheme.primaryContainer,
                      backgroundImage: user.photoUrl != null
                          ? CachedNetworkImageProvider(user.photoUrl!)
                          : null,
                      child: user.photoUrl == null
                          ? Text(
                              user.name[0].toUpperCase(),
                              style: TextStyle(
                                color: theme.colorScheme.onPrimaryContainer,
                              ),
                            )
                          : null,
                    ),
                    title: Text(user.name),
                    subtitle: Text(user.role?.name ?? 'user'),
                    trailing: Checkbox(
                      value: isSelected,
                      onChanged: (value) {
                        setState(() {
                          if (value ?? false) {
                            _selectedUsers.add(user);
                          } else {
                            _selectedUsers.remove(user);
                          }
                        });
                      },
                    ),
                    onTap: () {
                      setState(() {
                        if (isSelected) {
                          _selectedUsers.remove(user);
                        } else {
                          _selectedUsers.add(user);
                        }
                      });
                    },
                  );
                },
              ),
            ),
          ],
        ),
      ),
    );
  }
}
````

## File: lib/features/chat/presentation/screens/user_selection_screen.dart
````dart
import 'package:flutter/material.dart';
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:firebase_auth/firebase_auth.dart';
import 'package:provider/provider.dart';
import 'package:go_router/go_router.dart';
import '../../../../shared/models/user_model.dart';
import '../../domain/models/chat_room.dart';
import '../providers/chat_provider.dart';
import '../../../auth/presentation/providers/auth_provider.dart' as app_auth;

class UserSelectionScreen extends StatefulWidget {
  const UserSelectionScreen({super.key});

  @override
  State<UserSelectionScreen> createState() => _UserSelectionScreenState();
}

class _UserSelectionScreenState extends State<UserSelectionScreen> {
  final TextEditingController _searchController = TextEditingController();
  List<UserModel> _users = [];
  List<UserModel> _filteredUsers = [];
  bool _isLoading = true;

  @override
  void initState() {
    super.initState();
    _loadUsers();
    _searchController.addListener(_filterUsers);
  }

  @override
  void dispose() {
    _searchController.dispose();
    super.dispose();
  }

  Future<void> _loadUsers() async {
    try {
      final currentUserId = FirebaseAuth.instance.currentUser?.uid;
      if (currentUserId == null) return;

      // Get users with optimized query - limit to avoid loading too many at once
      final allUsersSnapshot = await FirebaseFirestore.instance
          .collection('users')
          .limit(50) // Limit to avoid loading all users at once
          .get();

      // Filter out current user and process in chunks to avoid blocking UI
      final users = <UserModel>[];
      for (final doc in allUsersSnapshot.docs) {
        if (doc.id != currentUserId) {
          users.add(UserModel.fromFirestore(doc));
        }
        // Yield control back to the UI thread after every 10 users
        if (users.length % 10 == 0) {
          await Future.delayed(Duration.zero);
        }
      }

      if (mounted) {
        setState(() {
          _users = users;
          _filteredUsers = users;
          _isLoading = false;
        });
      }
    } catch (e) {
      if (mounted) {
        setState(() {
          _isLoading = false;
        });
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(content: Text('Error loading users: $e')),
        );
      }
    }
  }

  void _filterUsers() {
    final query = _searchController.text.toLowerCase();
    setState(() {
      _filteredUsers = _users.where((user) {
        final name = user.displayName.toLowerCase();
        final email = user.email.toLowerCase();
        return name.contains(query) || email.contains(query);
      }).toList();
    });
  }

  Future<void> _startChat(UserModel otherUser) async {
    try {
      final chatProvider = context.read<ChatProvider>();
      final authProvider = context.read<app_auth.AuthProvider>();
      final currentUser = authProvider.userModel;

      if (currentUser == null) return;

      // Show loading indicator
      showDialog(
        context: context,
        barrierDismissible: false,
        builder: (context) => const Center(
          child: CircularProgressIndicator(),
        ),
      );

      // Check if a direct chat already exists
      final existingChatRoom = await chatProvider.findDirectChat(otherUser.uid);

      if (existingChatRoom != null) {
        // Navigate to existing chat
        if (mounted) {
          Navigator.pop(context); // Close loading dialog
          context.go('/chat/${existingChatRoom.id}');
        }
      } else {
        // Create new chat room
        final participantIds = [currentUser.uid, otherUser.uid];
        final participantInfoList = [
          ParticipantInfo(
            id: currentUser.uid,
            name: currentUser.displayName,
            role: 'user',
          ),
          ParticipantInfo(
            id: otherUser.uid,
            name: otherUser.displayName,
            role: 'user',
          ),
        ];

        final chatRoom = await chatProvider.createGroupChat(
          name: otherUser.displayName,
          type: 'direct',
          participantIds: participantIds,
          participants: participantInfoList,
        );

        if (mounted) {
          Navigator.pop(context); // Close loading dialog
          context.go('/chat/${chatRoom.id}');
        }
      }
    } catch (e) {
      if (mounted) {
        Navigator.pop(context); // Close loading dialog
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(content: Text('Error starting chat: $e')),
        );
      }
    }
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        leading: IconButton(
          icon: const Icon(Icons.arrow_back),
          onPressed: () {
            if (context.canPop()) {
              context.pop();
            } else {
              context.go('/messages');
            }
          },
        ),
        title: const Text('Select User'),
        bottom: PreferredSize(
          preferredSize: const Size.fromHeight(60),
          child: Padding(
            padding: const EdgeInsets.all(8.0),
            child: TextField(
              controller: _searchController,
              decoration: InputDecoration(
                hintText: 'Search users...',
                prefixIcon: const Icon(Icons.search),
                border: OutlineInputBorder(
                  borderRadius: BorderRadius.circular(30),
                ),
                filled: true,
                fillColor: Theme.of(context).colorScheme.surface,
              ),
            ),
          ),
        ),
      ),
      body: _isLoading
          ? const Center(child: CircularProgressIndicator())
          : _filteredUsers.isEmpty
              ? Center(
                  child: Column(
                    mainAxisAlignment: MainAxisAlignment.center,
                    children: [
                      const Icon(Icons.person_search, size: 64),
                      const SizedBox(height: 16),
                      Text(
                        _searchController.text.isEmpty
                            ? 'No users found'
                            : 'No users match your search',
                        style: Theme.of(context).textTheme.titleMedium,
                      ),
                    ],
                  ),
                )
              : ListView.builder(
                  itemCount: _filteredUsers.length,
                  itemBuilder: (context, index) {
                    final user = _filteredUsers[index];
                    return ListTile(
                      leading: CircleAvatar(
                        backgroundImage: user.photoURL != null 
                            ? NetworkImage(user.photoURL!) 
                            : null,
                        child: user.photoURL == null 
                            ? Text(user.displayName.isNotEmpty ? user.displayName[0] : '?')
                            : null,
                      ),
                      title: Text(user.displayName),
                      subtitle: Text(user.email),
                      trailing: Chip(
                        label: Text(
                          user.role?.toString().split('.').last ?? 'user',
                          style: const TextStyle(fontSize: 12),
                        ),
                      ),
                      onTap: () => _startChat(user),
                    );
                  },
                ),
    );
  }
}
````

## File: lib/features/classes/domain/repositories/class_repository.dart
````dart
/// Class repository interface for academic class management.
/// 
/// This module defines the contract for class operations in the
/// education platform, supporting creation, enrollment, and
/// management of academic classes.
library;

import '../models/class_model.dart';
import '../../../../shared/models/user_model.dart';
import '../../../../shared/repositories/base_repository.dart';

/// Abstract repository defining class management operations.
/// 
/// This interface provides a comprehensive contract for class
/// implementations, supporting:
/// - CRUD operations for academic classes
/// - Student enrollment and management
/// - Teacher-class associations
/// - Class archiving and restoration
/// - Statistical analysis
/// - Academic year filtering
/// - Batch enrollment operations
/// 
/// Concrete implementations handle the actual data persistence
/// and business logic for class management.
abstract class ClassRepository extends BaseRepository {
  /// Creates a new academic class.
  /// 
  /// Initializes a class with subject, schedule, and teacher
  /// information. Returns the generated class ID.
  /// 
  /// @param classModel Class details to create
  /// @return Generated class ID
  /// @throws Exception if creation fails
  Future<String> createClass(ClassModel classModel);
  
  /// Retrieves a class by ID.
  /// 
  /// Fetches complete class details including metadata,
  /// schedule, and teacher information.
  /// 
  /// @param classId Unique class identifier
  /// @return Class instance or null if not found
  /// @throws Exception if retrieval fails
  Future<ClassModel?> getClass(String classId);
  
  /// Updates class information.
  /// 
  /// Modifies class details such as name, schedule,
  /// or description. Cannot change the teacher after
  /// creation without special permissions.
  /// 
  /// @param classId ID of class to update
  /// @param classModel Updated class information
  /// @throws Exception if update fails
  Future<void> updateClass(String classId, ClassModel classModel);
  
  /// Permanently deletes a class.
  /// 
  /// Removes the class and all associated data.
  /// This operation cannot be undone. Consider
  /// archiving instead for recoverable deletion.
  /// 
  /// @param classId ID of class to delete
  /// @throws Exception if deletion fails
  Future<void> deleteClass(String classId);
  
  /// Streams all classes taught by a teacher.
  /// 
  /// Returns real-time updates of classes where the
  /// specified teacher is the instructor. Includes
  /// both active and archived classes.
  /// 
  /// @param teacherId Teacher's user ID
  /// @return Stream of teacher's class lists
  Stream<List<ClassModel>> getTeacherClasses(String teacherId);
  
  /// Streams all classes a student is enrolled in.
  /// 
  /// Returns real-time updates of classes where the
  /// student is enrolled. Updates when enrollment changes.
  /// 
  /// @param studentId Student's user ID
  /// @return Stream of student's class lists
  Stream<List<ClassModel>> getStudentClasses(String studentId);
  
  /// Adds a student to a class.
  /// 
  /// Enrolls a student in the specified class.
  /// Updates enrollment count and student list.
  /// 
  /// @param classId Target class ID
  /// @param studentId Student to enroll
  /// @throws Exception if enrollment fails
  Future<void> addStudent(String classId, String studentId);
  
  /// Removes a student from a class.
  /// 
  /// Unenrolls a student from the specified class.
  /// Updates enrollment count accordingly.
  /// 
  /// @param classId Target class ID
  /// @param studentId Student to remove
  /// @throws Exception if removal fails
  Future<void> removeStudent(String classId, String studentId);
  
  /// Retrieves all students enrolled in a class.
  /// 
  /// Fetches complete list of students with their
  /// profile information for roster display.
  /// 
  /// @param classId Class to get students for
  /// @return List of enrolled student profiles
  /// @throws Exception if retrieval fails
  Future<List<UserModel>> getClassStudents(String classId);
  
  /// Checks if a student is enrolled in a class.
  /// 
  /// Quick verification without loading full student list.
  /// Useful for access control and validation.
  /// 
  /// @param classId Class to check
  /// @param studentId Student to verify
  /// @return true if enrolled, false otherwise
  /// @throws Exception if check fails
  Future<bool> isStudentEnrolled(String classId, String studentId);
  
  /// Calculates statistics for a class.
  /// 
  /// Generates aggregate data including:
  /// - Total enrollment count
  /// - Assignment completion rates
  /// - Average grades
  /// - Attendance statistics
  /// - Activity metrics
  /// 
  /// @param classId Class to analyze
  /// @return Map of statistical data
  /// @throws Exception if calculation fails
  Future<Map<String, dynamic>> getClassStats(String classId);
  
  /// Archives a class at end of term.
  /// 
  /// Moves the class to archived state, hiding it
  /// from active lists while preserving all data.
  /// Can be restored if needed.
  /// 
  /// @param classId ID of class to archive
  /// @throws Exception if archiving fails
  Future<void> archiveClass(String classId);
  
  /// Restores an archived class.
  /// 
  /// Returns the class to active state, making it
  /// visible in current class lists again.
  /// 
  /// @param classId ID of class to restore
  /// @throws Exception if restoration fails
  Future<void> restoreClass(String classId);
  
  /// Enrolls a single student in a class.
  /// 
  /// Alternative method for student enrollment with
  /// additional validation and notifications.
  /// 
  /// @param classId Target class ID
  /// @param studentId Student to enroll
  /// @throws Exception if enrollment fails
  Future<void> enrollStudent(String classId, String studentId);
  
  /// Unenrolls a single student from a class.
  /// 
  /// Alternative method for student removal with
  /// proper cleanup and notifications.
  /// 
  /// @param classId Target class ID
  /// @param studentId Student to unenroll
  /// @throws Exception if unenrollment fails
  Future<void> unenrollStudent(String classId, String studentId);
  
  /// Enrolls multiple students in batch.
  /// 
  /// Efficiently adds multiple students to a class
  /// using batch operations. All enrollments succeed
  /// or fail together.
  /// 
  /// @param classId Target class ID
  /// @param studentIds List of students to enroll
  /// @throws Exception if batch enrollment fails
  Future<void> enrollMultipleStudents(String classId, List<String> studentIds);
  
  /// Retrieves active classes for an academic year.
  /// 
  /// Fetches non-archived classes for a specific teacher
  /// and academic year. Useful for term-based filtering.
  /// 
  /// @param teacherId Teacher's user ID
  /// @param academicYear Academic year (e.g., "2023-2024")
  /// @return List of active classes
  /// @throws Exception if retrieval fails
  Future<List<ClassModel>> getActiveClasses(String teacherId, String academicYear);
  
  /// Finds a class by its enrollment code.
  /// 
  /// Used for student enrollment via code entry.
  /// Only returns active classes with valid codes.
  /// 
  /// @param enrollmentCode The enrollment code to search for
  /// @return Class instance or null if not found
  /// @throws Exception if search fails
  Future<ClassModel?> getClassByEnrollmentCode(String enrollmentCode);
  
  /// Enrolls a student using an enrollment code.
  /// 
  /// Validates the enrollment code and adds the student
  /// to the class if capacity allows.
  /// 
  /// @param studentId Student to enroll
  /// @param enrollmentCode Class enrollment code
  /// @return The enrolled class model
  /// @throws Exception if enrollment fails
  Future<ClassModel> enrollWithCode(String studentId, String enrollmentCode);
  
  /// Generates a new enrollment code for a class.
  /// 
  /// Creates a unique 6-character alphanumeric code
  /// and updates the class record.
  /// 
  /// @param classId Class to generate code for
  /// @return The new enrollment code
  /// @throws Exception if generation fails
  Future<String> regenerateEnrollmentCode(String classId);
}
````

## File: lib/features/classes/presentation/widgets/create_class_dialog.dart
````dart
/// Dialog widget for creating a new class.
/// 
/// This widget provides a form for teachers to create new classes
/// with all required information including enrollment code generation.
library;

import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import '../providers/class_provider.dart';
import '../../../auth/presentation/providers/auth_provider.dart';

/// Dialog for creating a new class with form validation.
/// 
/// Features:
/// - Subject selection from predefined list
/// - Grade level selection
/// - Schedule input
/// - Room location
/// - Academic year and semester
/// - Optional student capacity limit
/// - Auto-generated enrollment code
class CreateClassDialog extends StatefulWidget {
  const CreateClassDialog({super.key});

  @override
  State<CreateClassDialog> createState() => _CreateClassDialogState();
}

class _CreateClassDialogState extends State<CreateClassDialog> {
  final _formKey = GlobalKey<FormState>();
  final _nameController = TextEditingController();
  final _schoolController = TextEditingController();
  final _roomController = TextEditingController();
  final _periodController = TextEditingController();
  
  String _selectedGradeLevel = '6th Grade';
  
  bool _isLoading = false;
  
  // Grade levels
  final List<String> _gradeLevels = [
    '6th Grade',
    '7th Grade', 
    '8th Grade',
  ];
  
  @override
  void dispose() {
    _nameController.dispose();
    _schoolController.dispose();
    _roomController.dispose();
    _periodController.dispose();
    super.dispose();
  }
  
  String _getCurrentAcademicYear() {
    final now = DateTime.now();
    final year = now.year;
    final month = now.month;
    
    // If it's after July, we're in the next academic year
    if (month >= 7) {
      return '$year-${year + 1}';
    } else {
      return '${year - 1}-$year';
    }
  }
  
  Future<void> _createClass() async {
    if (!_formKey.currentState!.validate()) return;
    
    setState(() => _isLoading = true);
    
    try {
      final classProvider = context.read<ClassProvider>();
      final authProvider = context.read<AuthProvider>();
      final teacherId = authProvider.userModel?.uid;
      
      if (teacherId == null) {
        throw Exception('No teacher ID found');
      }
      
      final success = await classProvider.createClassFromParams(
        name: _nameController.text.trim(),
        subject: _nameController.text.trim(), // Use class name as subject
        gradeLevel: _selectedGradeLevel,
        description: _schoolController.text.trim().isEmpty 
            ? null 
            : 'School: ${_schoolController.text.trim()}',
        room: _roomController.text.trim().isEmpty 
            ? null 
            : _roomController.text.trim(),
        schedule: _periodController.text.trim().isEmpty 
            ? null 
            : 'Period ${_periodController.text.trim()}',
        academicYear: _getCurrentAcademicYear(),
        semester: 'Full Year',
        maxStudents: null,
        teacherId: teacherId,
      );
      
      if (mounted && success) {
        Navigator.of(context).pop(true);
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(
            content: Text('Class created successfully!'),
            backgroundColor: Colors.green,
          ),
        );
      }
    } catch (e) {
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('Error creating class: ${e.toString()}'),
            backgroundColor: Colors.red,
          ),
        );
      }
    } finally {
      if (mounted) {
        setState(() => _isLoading = false);
      }
    }
  }
  
  @override
  Widget build(BuildContext context) {
    final screenHeight = MediaQuery.of(context).size.height;
    final maxDialogHeight = screenHeight * 0.95; // Use 95% of screen height max
    
    final isWeb = Theme.of(context).platform == TargetPlatform.windows || 
                   Theme.of(context).platform == TargetPlatform.macOS || 
                   Theme.of(context).platform == TargetPlatform.linux;
    final screenWidth = MediaQuery.of(context).size.width;
    
    // Make dialog wider on web - 800px or 80% of screen width
    final dialogWidth = isWeb 
        ? (screenWidth > 1000 ? 800.0 : screenWidth * 0.8)
        : (screenWidth > 500 ? 500.0 : screenWidth * 0.9);
    
    return Dialog(
      insetPadding: EdgeInsets.symmetric(
        horizontal: isWeb ? 40 : 16, 
        vertical: 16
      ),
      child: Container(
        width: dialogWidth,
        constraints: BoxConstraints(
          maxHeight: maxDialogHeight,
          maxWidth: dialogWidth,
        ),
        child: Padding(
          padding: const EdgeInsets.all(16),
          child: Form(
            key: _formKey,
            child: Column(
              mainAxisSize: MainAxisSize.min,
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                // Header
                Row(
                  children: [
                    const Icon(Icons.add_circle_outline, size: 28),
                    const SizedBox(width: 12),
                    Expanded(
                      child: Text(
                        'Create New Class',
                        style: Theme.of(context).textTheme.titleLarge,
                      ),
                    ),
                    IconButton(
                      icon: const Icon(Icons.close),
                      onPressed: () => Navigator.of(context).pop(),
                      padding: EdgeInsets.zero,
                      constraints: const BoxConstraints(),
                    ),
                  ],
                ),
                const SizedBox(height: 12),
                
                // Form content
                Expanded(
                  child: SingleChildScrollView(
                    child: Column(
                      crossAxisAlignment: CrossAxisAlignment.start,
                      children: [
                        // Class Name
                        TextFormField(
                          controller: _nameController,
                          decoration: const InputDecoration(
                            labelText: 'Class Name*',
                            hintText: 'e.g., Advanced Mathematics',
                            prefixIcon: Icon(Icons.class_),
                          ),
                          validator: (value) {
                            if (value == null || value.trim().isEmpty) {
                              return 'Please enter a class name';
                            }
                            return null;
                          },
                          textCapitalization: TextCapitalization.words,
                        ),
                        const SizedBox(height: 12),
                        
                        // School and Grade Level
                        Row(
                          children: [
                            Expanded(
                              child: TextFormField(
                                controller: _schoolController,
                                decoration: const InputDecoration(
                                  labelText: 'School',
                                  hintText: 'e.g., Lincoln Middle School',
                                  prefixIcon: Icon(Icons.school),
                                ),
                                textCapitalization: TextCapitalization.words,
                              ),
                            ),
                            const SizedBox(width: 12),
                            Expanded(
                              child: DropdownButtonFormField<String>(
                                value: _selectedGradeLevel,
                                decoration: const InputDecoration(
                                  labelText: 'Grade Level*',
                                  prefixIcon: Icon(Icons.grade),
                                  isDense: true,
                                  contentPadding: EdgeInsets.symmetric(horizontal: 12, vertical: 8),
                                ),
                                isExpanded: true,
                                items: _gradeLevels.map((grade) {
                                  return DropdownMenuItem(
                                    value: grade,
                                    child: Text(
                                      grade,
                                      overflow: TextOverflow.ellipsis,
                                    ),
                                  );
                                }).toList(),
                                onChanged: (value) {
                                  setState(() => _selectedGradeLevel = value!);
                                },
                              ),
                            ),
                          ],
                        ),
                        const SizedBox(height: 12),
                        
                        // Room and Period
                        Row(
                          children: [
                            Expanded(
                              child: TextFormField(
                                controller: _roomController,
                                decoration: const InputDecoration(
                                  labelText: 'Room Number',
                                  hintText: 'e.g., 204',
                                  prefixIcon: Icon(Icons.room),
                                ),
                                textCapitalization: TextCapitalization.words,
                              ),
                            ),
                            const SizedBox(width: 12),
                            Expanded(
                              child: TextFormField(
                                controller: _periodController,
                                decoration: const InputDecoration(
                                  labelText: 'Period',
                                  hintText: 'e.g., 3',
                                  prefixIcon: Icon(Icons.schedule),
                                ),
                                keyboardType: TextInputType.number,
                              ),
                            ),
                          ],
                        ),
                        const SizedBox(height: 16),
                        
                        // Info box
                        Container(
                          padding: const EdgeInsets.all(12),
                          decoration: BoxDecoration(
                            color: Theme.of(context).colorScheme.surfaceContainerHighest,
                            borderRadius: BorderRadius.circular(8),
                          ),
                          child: Row(
                            children: [
                              Icon(
                                Icons.info_outline,
                                color: Theme.of(context).colorScheme.primary,
                              ),
                              const SizedBox(width: 12),
                              Expanded(
                                child: Text(
                                  'An enrollment code will be automatically generated for students to join this class.',
                                  style: Theme.of(context).textTheme.bodySmall,
                                ),
                              ),
                            ],
                          ),
                        ),
                      ],
                    ),
                  ),
                ),
                
                // Actions
                const SizedBox(height: 12),
                Row(
                  mainAxisAlignment: MainAxisAlignment.end,
                  children: [
                    TextButton(
                      onPressed: _isLoading ? null : () => Navigator.of(context).pop(),
                      child: const Text('Cancel'),
                    ),
                    const SizedBox(width: 12),
                    FilledButton(
                      onPressed: _isLoading ? null : _createClass,
                      child: _isLoading
                          ? const SizedBox(
                              width: 16,
                              height: 16,
                              child: CircularProgressIndicator(strokeWidth: 2),
                            )
                          : const Text('Create Class'),
                    ),
                  ],
                ),
              ],
            ),
          ),
        ),
      ),
    );
  }
}
````

## File: lib/features/discussions/presentation/screens/discussion_boards_screen.dart
````dart
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'package:go_router/go_router.dart';
import 'package:intl/intl.dart';
import '../../domain/models/discussion_board.dart';
import '../../../../shared/models/user_model.dart';
import '../../../../shared/widgets/common/adaptive_layout.dart';
import '../../../auth/presentation/providers/auth_provider.dart';
import '../providers/discussion_provider.dart';
import '../widgets/create_board_dialog.dart';

class DiscussionBoardsScreen extends StatefulWidget {
  const DiscussionBoardsScreen({super.key});

  @override
  State<DiscussionBoardsScreen> createState() => _DiscussionBoardsScreenState();
}

class _DiscussionBoardsScreenState extends State<DiscussionBoardsScreen> {
  @override
  void initState() {
    super.initState();
    // Initialize boards when screen loads
    WidgetsBinding.instance.addPostFrameCallback((_) {
      context.read<DiscussionProvider>().initializeBoards();
    });
  }

  @override
  Widget build(BuildContext context) {
    final isTeacher = context.watch<AuthProvider>().userModel?.role == UserRole.teacher;

    return AdaptiveLayout(
      title: 'Discussion Boards',
      showBackButton: true,
      actions: [
        if (isTeacher)
          IconButton(
            icon: const Icon(Icons.add),
            onPressed: () => _showCreateBoardDialog(context),
          ),
      ],
      body: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Padding(
            padding: const EdgeInsets.all(16),
            child: Text(
              'Join discussions, share ideas, and collaborate with your class',
              style: Theme.of(context).textTheme.bodyLarge,
            ),
          ),
          Expanded(
            child: _buildBoardsList(),
          ),
        ],
      ),
    );
  }

  Widget _buildBoardsList() {
    return Consumer<DiscussionProvider>(
      builder: (context, provider, child) {
        if (provider.isLoading && provider.boards.isEmpty) {
          return const Center(child: CircularProgressIndicator());
        }

        if (provider.error != null) {
          return Center(
            child: Column(
              mainAxisAlignment: MainAxisAlignment.center,
              children: [
                const Icon(Icons.error_outline, size: 48, color: Colors.red),
                const SizedBox(height: 16),
                Text('Error: ${provider.error}'),
                const SizedBox(height: 16),
                ElevatedButton(
                  onPressed: () => provider.initializeBoards(),
                  child: const Text('Retry'),
                ),
              ],
            ),
          );
        }

        if (provider.boards.isEmpty) {
          return Center(
            child: Column(
              mainAxisAlignment: MainAxisAlignment.center,
              children: [
                Icon(
                  Icons.forum_outlined,
                  size: 64,
                  color: Theme.of(context).colorScheme.onSurfaceVariant,
                ),
                const SizedBox(height: 16),
                Text(
                  'No discussion boards yet',
                  style: Theme.of(context).textTheme.titleMedium,
                ),
                const SizedBox(height: 8),
                Text(
                  'Create the first board to start discussions',
                  style: Theme.of(context).textTheme.bodyMedium?.copyWith(
                        color: Theme.of(context).colorScheme.onSurfaceVariant,
                      ),
                ),
              ],
            ),
          );
        }

        return ListView.builder(
          padding: const EdgeInsets.all(16),
          itemCount: provider.boards.length,
          itemBuilder: (context, index) {
            final board = provider.boards[index];
            return Padding(
              padding: const EdgeInsets.only(bottom: 12),
              child: _buildBoardCard(board: board),
            );
          },
        );
      },
    );
  }

  Widget _buildBoardCard({required DiscussionBoard board}) {
    final theme = Theme.of(context);
    return Card(
      child: InkWell(
        onTap: () {
          // Set current board in provider
          context.read<DiscussionProvider>().setCurrentBoard(board);
          
          context.go('/discussions/${board.id}?title=${Uri.encodeComponent(board.title)}');
        },
        borderRadius: BorderRadius.circular(12),
        child: Padding(
          padding: const EdgeInsets.all(16),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Row(
                children: [
                  if (board.isPinned) ...[
                    Icon(
                      Icons.push_pin,
                      size: 16,
                      color: theme.colorScheme.primary,
                    ),
                    const SizedBox(width: 8),
                  ],
                  Expanded(
                    child: Text(
                      board.title,
                      style: theme.textTheme.titleMedium?.copyWith(
                            fontWeight: FontWeight.bold,
                          ),
                    ),
                  ),
                  Container(
                    padding: const EdgeInsets.symmetric(
                      horizontal: 12,
                      vertical: 4,
                    ),
                    decoration: BoxDecoration(
                      color: theme.colorScheme.secondaryContainer,
                      borderRadius: BorderRadius.circular(12),
                    ),
                    child: Text(
                      '${board.threadCount} threads',
                      style: theme.textTheme.labelSmall,
                    ),
                  ),
                ],
              ),
              const SizedBox(height: 8),
              Text(
                board.description,
                style: theme.textTheme.bodyMedium,
                maxLines: 2,
                overflow: TextOverflow.ellipsis,
              ),
              if (board.tags.isNotEmpty) ...[
                const SizedBox(height: 8),
                Wrap(
                  spacing: 6,
                  runSpacing: 6,
                  children: board.tags.take(3).map((tag) {
                    return Chip(
                      label: Text(
                        tag,
                        style: theme.textTheme.labelSmall,
                      ),
                      visualDensity: VisualDensity.compact,
                      materialTapTargetSize: MaterialTapTargetSize.shrinkWrap,
                    );
                  }).toList(),
                ),
              ],
              const SizedBox(height: 12),
              Row(
                children: [
                  Icon(
                    Icons.access_time,
                    size: 14,
                    color: theme.colorScheme.onSurfaceVariant,
                  ),
                  const SizedBox(width: 4),
                  Text(
                    _formatLastActivity(board.updatedAt),
                    style: theme.textTheme.bodySmall?.copyWith(
                          color: theme.colorScheme.onSurfaceVariant,
                        ),
                  ),
                  const Spacer(),
                  Text(
                    'by ${board.createdByName}',
                    style: theme.textTheme.bodySmall?.copyWith(
                          color: theme.colorScheme.onSurfaceVariant,
                        ),
                  ),
                ],
              ),
            ],
          ),
        ),
      ),
    );
  }

  String _formatLastActivity(DateTime date) {
    final now = DateTime.now();
    final difference = now.difference(date);

    if (difference.inMinutes < 1) {
      return 'Active just now';
    } else if (difference.inMinutes < 60) {
      return 'Active ${difference.inMinutes} minutes ago';
    } else if (difference.inHours < 24) {
      return 'Active ${difference.inHours} hours ago';
    } else if (difference.inDays < 7) {
      return 'Active ${difference.inDays} days ago';
    } else {
      return 'Active on ${DateFormat('MMM d').format(date)}';
    }
  }

  void _showCreateBoardDialog(BuildContext context) {
    showDialog(
      context: context,
      builder: (context) => const CreateBoardDialog(),
    );
  }
}
````

## File: lib/features/grades/data/services/grade_analytics_service.dart
````dart
import 'dart:math';
import 'package:cloud_firestore/cloud_firestore.dart';
import '../../domain/models/grade_analytics.dart';
import '../../domain/models/grade.dart';
import '../../../assignments/domain/models/assignment.dart';
import '../../../student/domain/models/student.dart';
import '../../../assignments/domain/models/submission.dart';

class GradeAnalyticsService {
  final FirebaseFirestore _firestore = FirebaseFirestore.instance;

  /// Generate analytics for a specific class
  Future<GradeAnalytics> generateClassAnalytics(String classId) async {
    // Demo data for testing
    if (classId.startsWith('math-') || classId.startsWith('sci-') || 
        classId.startsWith('eng-') || classId.startsWith('hist-')) {
      return _generateDemoAnalytics(classId);
    }
    try {
      // Get class info
      final classDoc = await _firestore.collection('classes').doc(classId).get();
      if (!classDoc.exists) {
        throw Exception('Class not found');
      }
      final className = classDoc.data()?['name'] ?? 'Unknown Class';

      // Get all assignments for the class
      final assignmentsSnapshot = await _firestore
          .collection('assignments')
          .where('classId', isEqualTo: classId)
          .get();

      final assignments = assignmentsSnapshot.docs
          .map((doc) => Assignment.fromFirestore(doc))
          .toList();

      // Get all students in the class
      final studentIds = List<String>.from(classDoc.data()?['students'] ?? []);
      final students = <Student>[];
      
      for (final studentId in studentIds) {
        final studentDoc = await _firestore.collection('users').doc(studentId).get();
        if (studentDoc.exists) {
          students.add(Student.fromFirestore(studentDoc));
        }
      }

      // Get all submissions and grades
      final allGrades = <Grade>[];
      final submissionsByStudent = <String, List<Submission>>{};
      final gradesByStudent = <String, List<Grade>>{};

      for (final assignment in assignments) {
        final submissionsSnapshot = await _firestore
            .collection('submissions')
            .where('assignmentId', isEqualTo: assignment.id)
            .get();

        for (final submissionDoc in submissionsSnapshot.docs) {
          final submission = Submission.fromFirestore(submissionDoc);
          final studentId = submission.studentId;
          
          submissionsByStudent[studentId] ??= [];
          submissionsByStudent[studentId]!.add(submission);

          // Get grade if exists
          final gradeSnapshot = await submissionDoc.reference
              .collection('grades')
              .orderBy('gradedAt', descending: true)
              .limit(1)
              .get();

          if (gradeSnapshot.docs.isNotEmpty) {
            final grade = Grade.fromFirestore(gradeSnapshot.docs.first);
            allGrades.add(grade);
            gradesByStudent[studentId] ??= [];
            gradesByStudent[studentId]!.add(grade);
          }
        }
      }

      // Calculate analytics
      final analytics = _calculateAnalytics(
        classId: classId,
        className: className,
        assignments: assignments,
        students: students,
        allGrades: allGrades,
        submissionsByStudent: submissionsByStudent,
        gradesByStudent: gradesByStudent,
      );

      return analytics;
    } catch (e) {
      throw Exception('Failed to generate analytics: $e');
    }
  }

  /// Calculate analytics from raw data
  GradeAnalytics _calculateAnalytics({
    required String classId,
    required String className,
    required List<Assignment> assignments,
    required List<Student> students,
    required List<Grade> allGrades,
    required Map<String, List<Submission>> submissionsByStudent,
    required Map<String, List<Grade>> gradesByStudent,
  }) {
    // Calculate overall statistics
    final gradeValues = allGrades.map((g) => g.percentage).toList();
    final averageGrade = gradeValues.isEmpty ? 0.0 : 
        gradeValues.reduce((a, b) => a + b) / gradeValues.length;
    
    final medianGrade = _calculateMedian(gradeValues);
    
    // Calculate grade distribution
    final gradeDistribution = _calculateGradeDistribution(gradeValues);
    
    // Calculate category averages
    final categoryAverages = _calculateCategoryAverages(assignments, allGrades);
    
    // Calculate student performances
    final studentPerformances = _calculateStudentPerformances(
      students: students,
      assignments: assignments,
      submissionsByStudent: submissionsByStudent,
      gradesByStudent: gradesByStudent,
    );
    
    // Calculate assignment statistics
    final assignmentStats = _calculateAssignmentStats(
      assignments: assignments,
      allGrades: allGrades,
      submissionsByStudent: submissionsByStudent,
    );

    // Count pending submissions
    int pendingSubmissions = 0;
    for (final submissions in submissionsByStudent.values) {
      pendingSubmissions += submissions.where((s) => 
        s.status == SubmissionStatus.submitted && 
        !gradesByStudent.containsKey(s.studentId)
      ).length;
    }

    return GradeAnalytics(
      classId: classId,
      className: className,
      averageGrade: averageGrade,
      medianGrade: medianGrade,
      totalAssignments: assignments.length,
      gradedAssignments: allGrades.length,
      pendingSubmissions: pendingSubmissions,
      gradeDistribution: gradeDistribution,
      categoryAverages: categoryAverages,
      studentPerformances: studentPerformances,
      assignmentStats: assignmentStats,
      lastUpdated: DateTime.now(),
    );
  }

  /// Calculate median value
  double _calculateMedian(List<double> values) {
    if (values.isEmpty) return 0;
    
    final sorted = List<double>.from(values)..sort();
    final middle = sorted.length ~/ 2;
    
    if (sorted.length % 2 == 0) {
      return (sorted[middle - 1] + sorted[middle]) / 2;
    } else {
      return sorted[middle];
    }
  }

  /// Calculate grade distribution (A, B, C, etc.)
  Map<String, int> _calculateGradeDistribution(List<double> gradeValues) {
    final distribution = <String, int>{
      'A': 0, 'A-': 0, 'B+': 0, 'B': 0, 'B-': 0,
      'C+': 0, 'C': 0, 'C-': 0, 'D+': 0, 'D': 0, 'D-': 0, 'F': 0,
    };

    for (final grade in gradeValues) {
      final letterGrade = _getLetterGrade(grade);
      distribution[letterGrade] = (distribution[letterGrade] ?? 0) + 1;
    }

    return distribution;
  }

  /// Get letter grade from percentage
  String _getLetterGrade(double grade) {
    if (grade >= 93) return 'A';
    if (grade >= 90) return 'A-';
    if (grade >= 87) return 'B+';
    if (grade >= 83) return 'B';
    if (grade >= 80) return 'B-';
    if (grade >= 77) return 'C+';
    if (grade >= 73) return 'C';
    if (grade >= 70) return 'C-';
    if (grade >= 67) return 'D+';
    if (grade >= 63) return 'D';
    if (grade >= 60) return 'D-';
    return 'F';
  }

  /// Calculate average grades by category
  Map<String, double> _calculateCategoryAverages(
    List<Assignment> assignments,
    List<Grade> grades,
  ) {
    final categoryGrades = <String, List<double>>{};
    
    for (final grade in grades) {
      final assignment = assignments.firstWhere(
        (a) => a.id == grade.assignmentId,
        orElse: () => assignments.first,
      );
      
      categoryGrades[assignment.category] ??= [];
      categoryGrades[assignment.category]!.add(grade.percentage);
    }
    
    final categoryAverages = <String, double>{};
    categoryGrades.forEach((category, grades) {
      if (grades.isNotEmpty) {
        categoryAverages[category] = grades.reduce((a, b) => a + b) / grades.length;
      }
    });
    
    return categoryAverages;
  }

  /// Calculate individual student performances
  List<StudentPerformance> _calculateStudentPerformances({
    required List<Student> students,
    required List<Assignment> assignments,
    required Map<String, List<Submission>> submissionsByStudent,
    required Map<String, List<Grade>> gradesByStudent,
  }) {
    final performances = <StudentPerformance>[];
    
    for (final student in students) {
      final studentGrades = gradesByStudent[student.id] ?? [];
      final studentSubmissions = submissionsByStudent[student.id] ?? [];
      
      if (studentGrades.isEmpty && studentSubmissions.isEmpty) continue;
      
      // Calculate average grade
      final gradeValues = studentGrades.map((g) => g.percentage).toList();
      final averageGrade = gradeValues.isEmpty ? 0.0 :
          gradeValues.reduce((a, b) => a + b) / gradeValues.length;
      
      // Count missing assignments
      final submittedAssignmentIds = studentSubmissions.map((s) => s.assignmentId).toSet();
      final missingAssignments = assignments.where((a) => 
        !submittedAssignmentIds.contains(a.id) &&
        a.dueDate.isBefore(DateTime.now())
      ).length;
      
      // Count late submissions
      final lateSubmissions = studentSubmissions.where((s) {
        final assignment = assignments.firstWhere(
          (a) => a.id == s.assignmentId,
          orElse: () => assignments.first,
        );
        return s.submittedAt.isAfter(assignment.dueDate);
      }).length;
      
      // Calculate category scores
      final categoryScores = _calculateStudentCategoryScores(
        studentGrades,
        assignments,
      );
      
      // Calculate trend (simplified - comparing last 3 grades to overall average)
      final trend = _calculateStudentTrend(studentGrades);
      
      performances.add(StudentPerformance(
        studentId: student.id,
        studentName: student.displayName,
        averageGrade: averageGrade,
        completedAssignments: studentGrades.length,
        missingAssignments: missingAssignments,
        lateSubmissions: lateSubmissions,
        categoryScores: categoryScores,
        trend: trend,
        letterGrade: _getLetterGrade(averageGrade),
      ));
    }
    
    return performances;
  }

  /// Calculate student's average score by category
  Map<String, double> _calculateStudentCategoryScores(
    List<Grade> grades,
    List<Assignment> assignments,
  ) {
    final categoryGrades = <String, List<double>>{};
    
    for (final grade in grades) {
      final assignment = assignments.firstWhere(
        (a) => a.id == grade.assignmentId,
        orElse: () => assignments.first,
      );
      
      categoryGrades[assignment.category] ??= [];
      categoryGrades[assignment.category]!.add(grade.percentage);
    }
    
    final categoryScores = <String, double>{};
    categoryGrades.forEach((category, grades) {
      if (grades.isNotEmpty) {
        categoryScores[category] = grades.reduce((a, b) => a + b) / grades.length;
      }
    });
    
    return categoryScores;
  }

  /// Calculate student's grade trend
  double _calculateStudentTrend(List<Grade> grades) {
    if (grades.length < 2) return 0;
    
    // Sort by date, filtering out grades without gradedAt
    final sortedGrades = List<Grade>.from(
      grades.where((g) => g.gradedAt != null)
    )..sort((a, b) => a.gradedAt!.compareTo(b.gradedAt!));
    
    // Compare last 3 grades to first 3 grades
    final recentCount = sortedGrades.length < 3 ? sortedGrades.length : 3;
    final earlyCount = sortedGrades.length < 3 ? sortedGrades.length : 3;
    
    final recentAvg = sortedGrades
        .skip(sortedGrades.length - recentCount)
        .map((g) => g.percentage)
        .reduce((a, b) => a + b) / recentCount;
    
    final earlyAvg = sortedGrades
        .take(earlyCount)
        .map((g) => g.percentage)
        .reduce((a, b) => a + b) / earlyCount;
    
    return recentAvg - earlyAvg;
  }

  /// Calculate assignment statistics
  List<AssignmentStats> _calculateAssignmentStats({
    required List<Assignment> assignments,
    required List<Grade> allGrades,
    required Map<String, List<Submission>> submissionsByStudent,
  }) {
    final stats = <AssignmentStats>[];
    
    for (final assignment in assignments) {
      final assignmentGrades = allGrades
          .where((g) => g.assignmentId == assignment.id)
          .toList();
      
      if (assignmentGrades.isEmpty) continue;
      
      final scores = assignmentGrades.map((g) => g.percentage).toList();
      final averageScore = scores.reduce((a, b) => a + b) / scores.length;
      final medianScore = _calculateMedian(scores);
      final maxScore = scores.reduce((a, b) => a > b ? a : b);
      final minScore = scores.reduce((a, b) => a < b ? a : b);
      
      // Count total submissions for this assignment
      int totalSubmissions = 0;
      for (final submissions in submissionsByStudent.values) {
        totalSubmissions += submissions
            .where((s) => s.assignmentId == assignment.id)
            .length;
      }
      
      // Calculate score distribution
      final scoreDistribution = _calculateScoreDistribution(scores);
      
      stats.add(AssignmentStats(
        assignmentId: assignment.id,
        assignmentTitle: assignment.title,
        category: assignment.category,
        averageScore: averageScore,
        medianScore: medianScore,
        maxScore: maxScore,
        minScore: minScore,
        totalSubmissions: totalSubmissions,
        gradedSubmissions: assignmentGrades.length,
        dueDate: assignment.dueDate,
        scoreDistribution: scoreDistribution,
      ));
    }
    
    return stats;
  }

  /// Calculate score distribution for an assignment
  Map<String, int> _calculateScoreDistribution(List<double> scores) {
    final distribution = <String, int>{
      '90-100': 0,
      '80-89': 0,
      '70-79': 0,
      '60-69': 0,
      '0-59': 0,
    };
    
    for (final score in scores) {
      if (score >= 90) {
        distribution['90-100'] = (distribution['90-100'] ?? 0) + 1;
      } else if (score >= 80) {
        distribution['80-89'] = (distribution['80-89'] ?? 0) + 1;
      } else if (score >= 70) {
        distribution['70-79'] = (distribution['70-79'] ?? 0) + 1;
      } else if (score >= 60) {
        distribution['60-69'] = (distribution['60-69'] ?? 0) + 1;
      } else {
        distribution['0-59'] = (distribution['0-59'] ?? 0) + 1;
      }
    }
    
    return distribution;
  }

  /// Get grade trends over time for a class
  Future<List<GradeTrend>> getGradeTrends(String classId, {int days = 30}) async {
    final endDate = DateTime.now();
    final startDate = endDate.subtract(Duration(days: days));
    
    final gradesSnapshot = await _firestore
        .collectionGroup('grades')
        .where('classId', isEqualTo: classId)
        .where('gradedAt', isGreaterThanOrEqualTo: startDate)
        .orderBy('gradedAt')
        .get();
    
    final gradesByDate = <DateTime, List<double>>{};
    
    for (final doc in gradesSnapshot.docs) {
      final grade = Grade.fromFirestore(doc);
      if (grade.gradedAt == null) continue;
      
      final dateKey = DateTime(
        grade.gradedAt!.year,
        grade.gradedAt!.month,
        grade.gradedAt!.day,
      );
      
      gradesByDate[dateKey] ??= [];
      gradesByDate[dateKey]!.add(grade.percentage);
    }
    
    final trends = <GradeTrend>[];
    gradesByDate.forEach((date, grades) {
      final average = grades.reduce((a, b) => a + b) / grades.length;
      trends.add(GradeTrend(
        date: date,
        averageGrade: average,
        assignmentCount: grades.length,
      ));
    });
    
    return trends;
  }
  
  /// Generate demo analytics for testing
  GradeAnalytics _generateDemoAnalytics(String classId) {
    final random = Random();
    final className = _getClassNameFromId(classId);
    
    // Generate student performances
    final studentPerformances = List.generate(15, (index) {
      final avgGrade = 65 + random.nextDouble() * 35; // 65-100
      return StudentPerformance(
        studentId: 'student-$index',
        studentName: 'Student ${index + 1}',
        averageGrade: avgGrade,
        completedAssignments: 8 + random.nextInt(5),
        missingAssignments: random.nextInt(3),
        lateSubmissions: random.nextInt(2),
        categoryScores: {
          'Homework': avgGrade + random.nextDouble() * 10 - 5,
          'Quizzes': avgGrade + random.nextDouble() * 10 - 5,
          'Tests': avgGrade + random.nextDouble() * 10 - 5,
          'Projects': avgGrade + random.nextDouble() * 10 - 5,
        },
        trend: random.nextDouble() * 10 - 5, // -5 to +5
        letterGrade: _getLetterGrade(avgGrade),
      );
    });
    
    // Generate assignment stats
    final assignmentStats = List.generate(10, (index) {
      final avgScore = 70 + random.nextDouble() * 20;
      return AssignmentStats(
        assignmentId: 'assignment-$index',
        assignmentTitle: 'Assignment ${index + 1}',
        category: ['Homework', 'Quiz', 'Test', 'Project'][random.nextInt(4)],
        averageScore: avgScore,
        medianScore: avgScore + random.nextDouble() * 5 - 2.5,
        maxScore: 95 + random.nextDouble() * 5,
        minScore: 50 + random.nextDouble() * 20,
        totalSubmissions: 15,
        gradedSubmissions: 13 + random.nextInt(3),
        dueDate: DateTime.now().subtract(Duration(days: random.nextInt(30))),
        scoreDistribution: {
          'A': random.nextInt(5),
          'B': random.nextInt(5),
          'C': random.nextInt(4),
          'D': random.nextInt(2),
          'F': random.nextInt(2),
        },
      );
    });
    
    // Calculate averages
    final overallAvg = studentPerformances.map((s) => s.averageGrade)
        .reduce((a, b) => a + b) / studentPerformances.length;
    
    return GradeAnalytics(
      classId: classId,
      className: className,
      averageGrade: overallAvg,
      medianGrade: overallAvg - 2, // Simplified
      totalAssignments: 12,
      gradedAssignments: 10,
      pendingSubmissions: 8,
      gradeDistribution: {
        'A': 3,
        'B': 5,
        'C': 4,
        'D': 2,
        'F': 1,
      },
      categoryAverages: {
        'Homework': overallAvg + 2,
        'Quizzes': overallAvg - 1,
        'Tests': overallAvg - 3,
        'Projects': overallAvg + 1,
      },
      studentPerformances: studentPerformances,
      assignmentStats: assignmentStats,
      lastUpdated: DateTime.now(),
    );
  }
  
  String _getClassNameFromId(String classId) {
    final classNames = {
      'math-101': 'Mathematics 101',
      'sci-202': 'Science 202',
      'eng-303': 'English 303',
      'hist-404': 'History 404',
    };
    return classNames[classId] ?? 'Unknown Class';
  }
}
````

## File: lib/features/grades/presentation/providers/grade_provider.dart
````dart
/// Grade state management provider.
/// 
/// This module manages grade state for the education platform,
/// handling teacher grading workflows, student grade viewing,
/// statistical analysis, and batch operations.
library;

import 'dart:async';
import 'package:flutter/material.dart';
import '../../domain/models/grade.dart';
import '../../domain/repositories/grade_repository.dart';
import '../../../assignments/domain/repositories/assignment_repository.dart';
import '../../../../shared/core/service_locator.dart';

/// Provider managing grade state and operations.
/// 
/// This provider serves as the central state manager for grades,
/// coordinating between grade and assignment repositories. Key features:
/// - Real-time grade updates for assignments, students, and classes
/// - Grade submission and feedback management
/// - Batch grading operations for efficiency
/// - Statistical analysis and performance metrics
/// - Grade status workflows (pending, graded, returned)
/// - Automatic percentage and letter grade calculation
/// 
/// Maintains separate grade lists for different contexts with
/// automatic stream management and statistics calculation.
class GradeProvider with ChangeNotifier {
  /// Repository for grade data operations.
  late final GradeRepository _gradeRepository;
  
  /// Repository for assignment data operations.
  late final AssignmentRepository _assignmentRepository;
  
  // State variables
  
  /// Grades for a specific assignment (teacher view).
  List<Grade> _assignmentGrades = [];
  
  /// Grades for a specific student.
  List<Grade> _studentGrades = [];
  
  /// All grades for a class.
  List<Grade> _classGrades = [];
  
  /// Statistical analysis for assignment grades.
  GradeStatistics? _assignmentStatistics;
  
  /// Statistical analysis for student performance.
  GradeStatistics? _studentStatistics;
  
  /// Statistical analysis for class performance.
  GradeStatistics? _classStatistics;
  
  /// Loading state for async operations.
  bool _isLoading = false;
  
  /// Latest error message for UI display.
  String? _error;
  
  /// Selected grade for detail view.
  Grade? _selectedGrade;
  
  // Stream subscriptions
  
  /// Subscription for assignment grade updates.
  StreamSubscription<List<Grade>>? _assignmentGradesSubscription;
  
  /// Subscription for student grade updates.
  StreamSubscription<List<Grade>>? _studentGradesSubscription;
  
  /// Subscription for class grade updates.
  StreamSubscription<List<Grade>>? _classGradesSubscription;
  
  /// Creates grade provider with repository dependencies.
  /// 
  /// Retrieves repositories from dependency injection container.
  GradeProvider() {
    _gradeRepository = getIt<GradeRepository>();
    _assignmentRepository = getIt<AssignmentRepository>();
  }
  
  // Getters
  
  /// Grades for the selected assignment.
  List<Grade> get assignmentGrades => _assignmentGrades;
  
  /// Grades for the selected student.
  List<Grade> get studentGrades => _studentGrades;
  
  /// All grades for the selected class.
  List<Grade> get classGrades => _classGrades;
  
  /// Statistics for assignment performance.
  GradeStatistics? get assignmentStatistics => _assignmentStatistics;
  
  /// Statistics for student performance.
  GradeStatistics? get studentStatistics => _studentStatistics;
  
  /// Statistics for class performance.
  GradeStatistics? get classStatistics => _classStatistics;
  
  /// Whether an operation is in progress.
  bool get isLoading => _isLoading;
  
  /// Latest error message or null.
  String? get error => _error;
  
  /// Currently selected grade or null.
  Grade? get selectedGrade => _selectedGrade;
  
  /// Filters assignment grades by status.
  /// 
  /// Useful for categorized grading views.
  /// 
  /// @param status Grade status to filter by
  /// @return List of grades with matching status
  List<Grade> getGradesByStatus(GradeStatus status) {
    return _assignmentGrades.where((g) => g.status == status).toList();
  }
  
  /// Gets count of ungraded submissions.
  /// 
  /// Shows number of assignments awaiting grading.
  int get pendingGradesCount {
    return _assignmentGrades.where((g) => g.status == GradeStatus.pending).length;
  }
  
  /// Loads and subscribes to grades for an assignment.
  /// 
  /// Sets up real-time stream for grade updates and
  /// automatically calculates assignment statistics.
  /// Used in teacher grading views.
  /// 
  /// @param assignmentId Assignment to load grades for
  /// @throws Exception if loading fails
  Future<void> loadAssignmentGrades(String assignmentId) async {
    _setLoading(true);
    try {
      _assignmentGradesSubscription?.cancel();
      
      _assignmentGradesSubscription = _gradeRepository.getAssignmentGrades(assignmentId).listen(
        (gradeList) {
          _assignmentGrades = gradeList;
          _loadAssignmentStatistics(assignmentId);
          _setLoading(false);
          notifyListeners();
        },
        onError: (error) {
          _setError(error.toString());
          _setLoading(false);
        },
      );
    } catch (e) {
      _setError(e.toString());
      _setLoading(false);
    }
  }
  
  /// Loads and subscribes to all grades for a student.
  /// 
  /// Sets up real-time stream for student's grades
  /// across all classes and assignments.
  /// 
  /// @param studentId Student to load grades for
  /// @throws Exception if loading fails
  Future<void> loadStudentGrades(String studentId) async {
    _setLoading(true);
    try {
      _studentGradesSubscription?.cancel();
      
      _studentGradesSubscription = _gradeRepository.getStudentGrades(studentId).listen(
        (gradeList) {
          _studentGrades = gradeList;
          _setLoading(false);
          notifyListeners();
        },
        onError: (error) {
          _setError(error.toString());
          _setLoading(false);
        },
      );
    } catch (e) {
      _setError(e.toString());
      _setLoading(false);
    }
  }
  
  /// Loads grades for a student in a specific class.
  /// 
  /// Sets up real-time stream and calculates student's
  /// performance statistics within the class context.
  /// 
  /// @param studentId Student identifier
  /// @param classId Class identifier
  /// @throws Exception if loading fails
  Future<void> loadStudentClassGrades(String studentId, String classId) async {
    _setLoading(true);
    try {
      _studentGradesSubscription?.cancel();
      
      _studentGradesSubscription = _gradeRepository.getStudentClassGrades(studentId, classId).listen(
        (gradeList) {
          _studentGrades = gradeList;
          _loadStudentClassStatistics(studentId, classId);
          _setLoading(false);
          notifyListeners();
        },
        onError: (error) {
          _setError(error.toString());
          _setLoading(false);
        },
      );
    } catch (e) {
      _setError(e.toString());
      _setLoading(false);
    }
  }
  
  /// Loads all grades for all students in a class.
  /// 
  /// Sets up real-time stream for comprehensive class
  /// performance monitoring and statistics calculation.
  /// 
  /// @param classId Class to load grades for
  /// @throws Exception if loading fails
  Future<void> loadClassGrades(String classId) async {
    _setLoading(true);
    try {
      _classGradesSubscription?.cancel();
      
      _classGradesSubscription = _gradeRepository.getClassGrades(classId).listen(
        (gradeList) {
          _classGrades = gradeList;
          _loadClassStatistics(classId);
          _setLoading(false);
          notifyListeners();
        },
        onError: (error) {
          _setError(error.toString());
          _setLoading(false);
        },
      );
    } catch (e) {
      _setError(e.toString());
      _setLoading(false);
    }
  }
  
  /// Creates a new grade record.
  /// 
  /// Typically used when manually adding grades or
  /// for late submissions not auto-initialized.
  /// 
  /// @param grade Grade data to create
  /// @return true if creation successful
  Future<bool> createGrade(Grade grade) async {
    _setLoading(true);
    try {
      await _gradeRepository.createGrade(grade);
      _setLoading(false);
      return true;
    } catch (e) {
      _setError(e.toString());
      _setLoading(false);
      return false;
    }
  }
  
  /// Updates an existing grade record.
  /// 
  /// Modifies grade in Firestore and updates local cache
  /// for immediate UI response. Recalculates statistics.
  /// 
  /// @param gradeId Grade to update
  /// @param grade Updated grade data
  /// @return true if update successful
  Future<bool> updateGrade(String gradeId, Grade grade) async {
    _setLoading(true);
    try {
      await _gradeRepository.updateGrade(gradeId, grade);
      
      // Update local lists
      _updateLocalGrade(gradeId, grade);
      
      _setLoading(false);
      return true;
    } catch (e) {
      _setError(e.toString());
      _setLoading(false);
      return false;
    }
  }
  
  /// Submits a grade with points and optional feedback.
  /// 
  /// Automatically:
  /// - Calculates percentage and letter grade
  /// - Updates grade status to 'graded'
  /// - Records grading timestamp
  /// - Updates local cache and statistics
  /// 
  /// @param gradeId Grade to submit
  /// @param pointsEarned Points awarded
  /// @param feedback Optional teacher feedback
  /// @return true if submission successful
  Future<bool> submitGrade(String gradeId, double pointsEarned, String? feedback) async {
    _setLoading(true);
    try {
      final grade = _findGradeById(gradeId);
      if (grade == null) {
        throw Exception('Grade not found');
      }
      
      // Update local grade
      final updatedGrade = grade.copyWith(
        pointsEarned: pointsEarned,
        percentage: Grade.calculatePercentage(pointsEarned, grade.pointsPossible),
        letterGrade: Grade.calculateLetterGrade(
          Grade.calculatePercentage(pointsEarned, grade.pointsPossible)
        ),
        feedback: feedback,
        status: GradeStatus.graded,
        gradedAt: DateTime.now(),
        updatedAt: DateTime.now(),
      );
      
      await _gradeRepository.submitGrade(updatedGrade);
      
      _updateLocalGrade(gradeId, updatedGrade);
      
      _setLoading(false);
      return true;
    } catch (e) {
      _setError(e.toString());
      _setLoading(false);
      return false;
    }
  }
  
  /// Returns a graded assignment to student.
  /// 
  /// Changes status from 'graded' to 'returned',
  /// making the grade visible to the student.
  /// Records return timestamp.
  /// 
  /// @param gradeId Grade to return
  /// @return true if return successful
  Future<bool> returnGrade(String gradeId) async {
    _setLoading(true);
    try {
      await _gradeRepository.returnGrade(gradeId);
      
      // Update local grade
      final grade = _findGradeById(gradeId);
      if (grade != null) {
        final updatedGrade = grade.copyWith(
          status: GradeStatus.returned,
          returnedAt: DateTime.now(),
          updatedAt: DateTime.now(),
        );
        _updateLocalGrade(gradeId, updatedGrade);
      }
      
      _setLoading(false);
      return true;
    } catch (e) {
      _setError(e.toString());
      _setLoading(false);
      return false;
    }
  }
  
  /// Updates multiple grades in one atomic operation.
  /// 
  /// Efficient batch grading for bulk operations.
  /// All updates succeed or fail together.
  /// Updates local cache after successful operation.
  /// 
  /// @param grades Map of grade IDs to updated grade objects
  /// @return true if batch update successful
  Future<bool> batchUpdateGrades(Map<String, Grade> grades) async {
    _setLoading(true);
    try {
      await _gradeRepository.batchUpdateGrades(grades);
      
      // Update local grades
      grades.forEach((gradeId, grade) {
        _updateLocalGrade(gradeId, grade);
      });
      
      _setLoading(false);
      return true;
    } catch (e) {
      _setError(e.toString());
      _setLoading(false);
      return false;
    }
  }
  
  /// Creates grade records for all students in a class.
  /// 
  /// Called when publishing an assignment to pre-create
  /// grade records with 'pending' status. Ensures all
  /// students have grade entries for the assignment.
  /// 
  /// @param assignmentId Assignment requiring grades
  /// @param classId Class containing students
  /// @param teacherId Teacher creating assignment
  /// @param pointsPossible Maximum points for assignment
  /// @return true if initialization successful
  Future<bool> initializeGradesForAssignment(
    String assignmentId,
    String classId,
    String teacherId,
    double pointsPossible,
  ) async {
    _setLoading(true);
    try {
      await _gradeRepository.initializeGradesForAssignment(
        assignmentId,
        classId,
        teacherId,
        pointsPossible,
      );
      _setLoading(false);
      return true;
    } catch (e) {
      _setError(e.toString());
      _setLoading(false);
      return false;
    }
  }
  
  /// Loads statistical analysis for an assignment.
  /// 
  /// Calculates average, median, distribution, etc.
  /// Fails silently to not interrupt grade display.
  /// 
  /// @param assignmentId Assignment to analyze
  Future<void> _loadAssignmentStatistics(String assignmentId) async {
    try {
      _assignmentStatistics = await _gradeRepository.getAssignmentStatistics(assignmentId);
      notifyListeners();
    } catch (e) {
      // Silently fail for statistics
    }
  }
  
  /// Loads statistical analysis for student in a class.
  /// 
  /// Calculates student's performance metrics within
  /// the class context. Fails silently.
  /// 
  /// @param studentId Student to analyze
  /// @param classId Class context
  Future<void> _loadStudentClassStatistics(String studentId, String classId) async {
    try {
      _studentStatistics = await _gradeRepository.getStudentClassStatistics(studentId, classId);
      notifyListeners();
    } catch (e) {
      // Silently fail for statistics
    }
  }
  
  /// Loads statistical analysis for entire class.
  /// 
  /// Calculates class-wide performance metrics.
  /// Fails silently to not interrupt display.
  /// 
  /// @param classId Class to analyze
  Future<void> _loadClassStatistics(String classId) async {
    try {
      _classStatistics = await _gradeRepository.getClassStatistics(classId);
      notifyListeners();
    } catch (e) {
      // Silently fail for statistics
    }
  }
  
  /// Sets the currently selected grade.
  /// 
  /// Used for detail views and context-aware operations.
  /// 
  /// @param grade Grade to select or null to clear
  void setSelectedGrade(Grade? grade) {
    _selectedGrade = grade;
    notifyListeners();
  }
  
  // Helper methods
  
  /// Searches for a grade across all loaded lists.
  /// 
  /// @param gradeId Grade identifier to find
  /// @return Grade instance or null if not found
  Grade? _findGradeById(String gradeId) {
    // Search in all grade lists
    final allGrades = [..._assignmentGrades, ..._studentGrades, ..._classGrades];
    try {
      return allGrades.firstWhere((g) => g.id == gradeId);
    } catch (e) {
      return null;
    }
  }
  
  /// Updates a grade in all local caches.
  /// 
  /// Searches through assignment, student, and class grade
  /// lists to update the grade instance. Also updates
  /// selected grade if it matches.
  /// 
  /// @param gradeId Grade identifier to update
  /// @param grade New grade data
  void _updateLocalGrade(String gradeId, Grade grade) {
    // Update in assignment grades
    final assignmentIndex = _assignmentGrades.indexWhere((g) => g.id == gradeId);
    if (assignmentIndex != -1) {
      _assignmentGrades[assignmentIndex] = grade;
    }
    
    // Update in student grades
    final studentIndex = _studentGrades.indexWhere((g) => g.id == gradeId);
    if (studentIndex != -1) {
      _studentGrades[studentIndex] = grade;
    }
    
    // Update in class grades
    final classIndex = _classGrades.indexWhere((g) => g.id == gradeId);
    if (classIndex != -1) {
      _classGrades[classIndex] = grade;
    }
    
    // Update selected grade
    if (_selectedGrade?.id == gradeId) {
      _selectedGrade = grade;
    }
    
    notifyListeners();
  }
  
  /// Sets loading state and notifies listeners.
  /// 
  /// @param loading New loading state
  void _setLoading(bool loading) {
    _isLoading = loading;
    notifyListeners();
  }
  
  /// Sets error message and notifies listeners.
  /// 
  /// @param error Error description or null
  void _setError(String? error) {
    _error = error;
    notifyListeners();
  }
  
  /// Clears error message and notifies UI.
  /// 
  /// Called after user acknowledges error.
  void clearError() {
    _error = null;
    notifyListeners();
  }
  
  /// Clears all cached grade data.
  /// 
  /// Resets provider to initial state.
  /// Useful for user logout or role switch.
  void clearData() {
    _assignmentGrades = [];
    _studentGrades = [];
    _classGrades = [];
    _assignmentStatistics = null;
    _studentStatistics = null;
    _classStatistics = null;
    _selectedGrade = null;
    _isLoading = false;
    _error = null;
    notifyListeners();
  }
  
  /// Cleans up resources when provider is disposed.
  /// 
  /// Cancels all stream subscriptions and disposes
  /// repositories to prevent memory leaks.
  @override
  void dispose() {
    // Cancel subscriptions
    _assignmentGradesSubscription?.cancel();
    _studentGradesSubscription?.cancel();
    _classGradesSubscription?.cancel();
    
    // Dispose repositories
    _gradeRepository.dispose();
    _assignmentRepository.dispose();
    
    super.dispose();
  }
}
````

## File: lib/features/notifications/data/services/notification_service.dart
````dart
import 'dart:io';
import 'package:flutter/foundation.dart';
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:flutter_local_notifications/flutter_local_notifications.dart';
import 'package:flutter_callkit_incoming/flutter_callkit_incoming.dart';
import 'package:flutter_callkit_incoming/entities/entities.dart';
import 'package:timezone/data/latest.dart' as tz;
import '../../../calendar/domain/models/calendar_event.dart';
import '../../../assignments/domain/models/assignment.dart';
import '../../../chat/domain/models/call.dart';
import '../../domain/models/notification.dart' as app_notification;
import '../../../../shared/services/logger_service.dart';
// Conditional import for web notification permissions
import 'notification_service_stub.dart'
    if (dart.library.html) 'notification_service_web.dart' as platform;

/// Service for managing local notifications and reminders
/// Now with full WebRTC call notification support for all platforms
class NotificationService {
  static final NotificationService _instance = NotificationService._internal();
  factory NotificationService() => _instance;
  NotificationService._internal();

  final FirebaseFirestore _firestore = FirebaseFirestore.instance;
  final FlutterLocalNotificationsPlugin _localNotifications = FlutterLocalNotificationsPlugin();
  // FlutterCallkitIncoming is a singleton, no instantiation needed
  
  bool _isInitialized = false;
  bool _isCallKitSupported = false;
  bool _notificationPermissionDenied = false;
  
  // Callbacks for call actions
  Function(String callId)? onCallAccepted;
  Function(String callId)? onCallDeclined;
  
  // Notification channel IDs
  static const String _channelId = 'teacher_dashboard_calls';
  static const String _channelName = 'Incoming Calls';
  static const String _channelDescription = 'Notifications for incoming calls';
  
  /// Initialize notification service with full platform support
  Future<void> initialize() async {
    if (_isInitialized) return;
    
    try {
      // Initialize timezone
      tz.initializeTimeZones();
      
      // Check platform support for CallKit
      _isCallKitSupported = !kIsWeb && (Platform.isIOS || Platform.isAndroid);
      
      // Initialize local notifications for all platforms
      await _initializeLocalNotifications();
      
      // Initialize CallKit for mobile platforms
      if (_isCallKitSupported) {
        await _initializeCallKit();
      }
      
      _isInitialized = true;
      LoggerService.info('Notification service initialized with full support', tag: 'NotificationService');
    } catch (e) {
      LoggerService.error('Failed to initialize NotificationService', error: e, tag: 'NotificationService');
      // Fallback to basic functionality
      _isInitialized = true;
    }
  }
  
  /// Request notification permissions
  Future<bool> requestPermissions() async {
    try {
      if (kIsWeb) {
        // Request browser notification permissions for web
        return await _requestWebNotificationPermissions();
      } else if (Platform.isAndroid) {
        final androidPlugin = _localNotifications
            .resolvePlatformSpecificImplementation<AndroidFlutterLocalNotificationsPlugin>();
        final granted = await androidPlugin?.requestNotificationsPermission();
        return granted ?? false;
      } else if (Platform.isIOS || Platform.isMacOS) {
        final iosPlugin = _localNotifications
            .resolvePlatformSpecificImplementation<IOSFlutterLocalNotificationsPlugin>();
        final granted = await iosPlugin?.requestPermissions(
          alert: true,
          badge: true,
          sound: true,
        );
        return granted ?? false;
      }
      return true; // Assume granted on other platforms
    } catch (e) {
      LoggerService.error('Failed to request permissions', error: e, tag: 'NotificationService');
      return true; // Fallback for compatibility
    }
  }
  
  /// Request web browser notification permissions
  Future<bool> _requestWebNotificationPermissions() async {
    try {
      if (kIsWeb) {
        // Use the Notification API to request permission
        final permission = await _checkWebNotificationPermission();
        if (permission == 'granted') {
          LoggerService.info('Web notification permission already granted', tag: 'NotificationService');
          return true;
        } else if (permission == 'denied') {
          LoggerService.warning('Web notification permission denied by user', tag: 'NotificationService');
          // Store denied state for UI feedback
          _notificationPermissionDenied = true;
          _showPermissionDeniedGuidance();
          return false;
        } else {
          // Permission is 'default', we can request it
          final requestResult = await _requestWebNotificationPermissionFromBrowser();
          final granted = requestResult == 'granted';
          
          if (!granted && requestResult == 'denied') {
            _notificationPermissionDenied = true;
            _showPermissionDeniedGuidance();
          }
          
          LoggerService.info('Web notification permission request result: $requestResult', tag: 'NotificationService');
          return granted;
        }
      }
      return true;
    } catch (e) {
      LoggerService.error('Failed to request web notification permissions', error: e, tag: 'NotificationService');
      return false;
    }
  }
  
  /// Check current web notification permission status
  Future<String> _checkWebNotificationPermission() async {
    if (kIsWeb) {
      try {
        // Use platform abstraction to check Notification.permission
        if (platform.WebNotification.supported) {
          final permission = platform.WebNotification.permission ?? 'denied';
          LoggerService.info('Web notification permission status: $permission', tag: 'NotificationService');
          return permission;
        } else {
          LoggerService.warning('Web notifications not supported', tag: 'NotificationService');
          return 'denied';
        }
      } catch (e) {
        LoggerService.error('Error checking web notification permission', error: e, tag: 'NotificationService');
        return 'denied';
      }
    }
    return 'granted';
  }
  
  /// Request notification permission from browser
  Future<String> _requestWebNotificationPermissionFromBrowser() async {
    if (kIsWeb) {
      try {
        if (platform.WebNotification.supported) {
          // Use platform abstraction to request notification permission
          final permission = await platform.WebNotification.requestPermission();
          LoggerService.info('Browser notification permission requested: $permission', tag: 'NotificationService');
          
          // If permission is still 'default', provide guidance
          if (permission == 'default') {
            _showPermissionPendingGuidance();
          }
          
          return permission;
        } else {
          LoggerService.warning('Browser notifications not supported', tag: 'NotificationService');
          _showBrowserNotSupportedGuidance();
          return 'denied';
        }
      } catch (e) {
        LoggerService.error('Failed to request browser notification permission', error: e, tag: 'NotificationService');
        return 'denied';
      }
    }
    return 'granted';
  }
  
  /// Schedule reminder for calendar event (stub)
  Future<void> scheduleEventReminder(CalendarEvent event) async {
    LoggerService.info('Event reminder scheduled: ${event.title}', tag: 'NotificationService');
    // Store notification record only
    await _storeNotificationRecord(
      type: 'eventReminder',
      title: 'Event Reminder',
      message: '${event.title} reminder',
      relatedId: event.id,
      scheduledFor: event.startTime,
    );
  }
  
  /// Schedule reminder for assignment (stub)
  Future<void> scheduleAssignmentReminder(Assignment assignment) async {
    LoggerService.info('Assignment reminder scheduled: ${assignment.title}', tag: 'NotificationService');
    // Store notification record only
    await _storeNotificationRecord(
      type: 'assignmentReminder',
      title: 'Assignment Reminder',
      message: '${assignment.title} is due soon',
      relatedId: assignment.id,
      scheduledFor: assignment.dueDate,
    );
  }
  
  /// Send immediate notification (stub)
  Future<void> sendImmediateNotification({
    required String title,
    required String body,
    String? payload,
  }) async {
    LoggerService.info('Immediate notification: $title - $body', tag: 'NotificationService');
    // Store notification record only
    await _storeNotificationRecord(
      type: 'immediate',
      title: title,
      message: body,
      relatedId: payload,
      scheduledFor: DateTime.now(),
    );
  }
  
  /// Cancel scheduled notification (stub)
  Future<void> cancelNotification(int id) async {
    LoggerService.info('Notification cancelled: $id', tag: 'NotificationService');
  }
  
  /// Cancel all notifications (stub)
  Future<void> cancelAllNotifications() async {
    LoggerService.info('All notifications cancelled', tag: 'NotificationService');
  }
  
  /// Get pending notifications (stub)
  Future<List<app_notification.Notification>> getPendingNotifications() async {
    LoggerService.info('Getting pending notifications', tag: 'NotificationService');
    return []; // Return empty list for Windows compatibility
  }
  
  /// Store notification record in Firestore
  Future<void> _storeNotificationRecord({
    required String type,
    required String title,
    required String message,
    String? relatedId,
    required DateTime scheduledFor,
  }) async {
    try {
      await _firestore.collection('notifications').add({
        'type': type,
        'title': title,
        'message': message,
        'relatedId': relatedId,
        'scheduledFor': Timestamp.fromDate(scheduledFor),
        'createdAt': Timestamp.now(),
        'status': 'scheduled',
      });
    } catch (e) {
      LoggerService.error('Failed to store notification record', error: e, tag: 'NotificationService');
    }
  }
  
  // WebRTC Call Notification Methods
  
  Future<void> _initializeLocalNotifications() async {
    // Android settings
    const androidSettings = AndroidInitializationSettings('@mipmap/ic_launcher');
    
    // iOS settings
    const iosSettings = DarwinInitializationSettings(
      requestAlertPermission: true,
      requestBadgePermission: true,
      requestSoundPermission: true,
    );
    
    // macOS settings (for desktop)
    const macOSSettings = DarwinInitializationSettings(
      requestAlertPermission: true,
      requestBadgePermission: true,
      requestSoundPermission: true,
    );
    
    // Linux settings
    final linuxSettings = LinuxInitializationSettings(
      defaultActionName: 'Open notification',
      defaultIcon: AssetsLinuxIcon('icons/app_icon.png'),
    );
    
    // Windows settings - basic support through flutter_local_notifications
    // Note: Windows notification support is limited compared to other platforms
    // Full action support requires additional platform-specific implementation
    
    // Combined settings
    final initSettings = InitializationSettings(
      android: androidSettings,
      iOS: iosSettings,
      macOS: macOSSettings,
      linux: linuxSettings,
      // Windows uses default initialization
    );
    
    await _localNotifications.initialize(
      initSettings,
      onDidReceiveNotificationResponse: _onNotificationResponse,
    );
    
    // Create notification channel for Android
    if (!kIsWeb && Platform.isAndroid) {
      const androidChannel = AndroidNotificationChannel(
        _channelId,
        _channelName,
        description: _channelDescription,
        importance: Importance.max,
        playSound: true,
        enableVibration: true,
        enableLights: true,
      );
      
      await _localNotifications
          .resolvePlatformSpecificImplementation<AndroidFlutterLocalNotificationsPlugin>()
          ?.createNotificationChannel(androidChannel);
    }
  }
  
  Future<void> _initializeCallKit() async {
    // Set up event listeners
    FlutterCallkitIncoming.onEvent.listen((CallEvent? event) {
      if (event == null) return;
      
      switch (event.event) {
        case Event.actionCallAccept:
          _handleAcceptCall(event);
          break;
        case Event.actionCallDecline:
          _handleDeclineCall(event);
          break;
        case Event.actionCallEnded:
          _handleEndCall(event);
          break;
        case Event.actionCallTimeout:
          _handleCallTimeout(event);
          break;
        default:
          break;
      }
    });
  }
  
  // Show incoming call notification
  Future<void> showIncomingCall(Call call) async {
    if (_isCallKitSupported && !kIsWeb) {
      // Use native call UI on mobile
      await _showNativeCallUI(call);
    } else {
      // Use local notifications on desktop/web
      await _showCallNotification(call);
    }
  }
  
  Future<void> _showNativeCallUI(Call call) async {
    final params = CallKitParams(
      id: call.id,
      nameCaller: call.callerName,
      appName: 'Teacher Dashboard',
      avatar: call.callerPhotoUrl,
      handle: call.callerId,
      type: call.isVideo ? 1 : 0, // 0 for audio, 1 for video
      duration: 30000, // 30 seconds
      textAccept: 'Accept',
      textDecline: 'Decline',
      android: const AndroidParams(
        isCustomNotification: true,
        isShowLogo: false,
        ringtonePath: 'system_ringtone_default',
        backgroundColor: '#0955fa',
        actionColor: '#4CAF50',
      ),
      ios: const IOSParams(
        iconName: 'CallKitLogo',
        handleType: 'generic',
        supportsVideo: true,
        maximumCallGroups: 1,
        maximumCallsPerCallGroup: 1,
        audioSessionMode: 'default',
        audioSessionActive: true,
        audioSessionPreferredSampleRate: 44100.0,
        audioSessionPreferredIOBufferDuration: 0.005,
        supportsDTMF: true,
        supportsHolding: true,
        supportsGrouping: false,
        supportsUngrouping: false,
        ringtonePath: 'system_ringtone_default',
      ),
    );
    
    await FlutterCallkitIncoming.showCallkitIncoming(params);
  }
  
  Future<void> _showCallNotification(Call call, {bool isBackup = false}) async {
    final title = isBackup ? 'Call from ${call.callerName}' : 'Incoming ${call.isVideo ? "Video" : "Voice"} Call';
    final body = '${call.callerName} is calling you';
    
    if (!kIsWeb && Platform.isAndroid) {
      final androidDetails = AndroidNotificationDetails(
        _channelId,
        _channelName,
        channelDescription: _channelDescription,
        importance: Importance.max,
        priority: Priority.max,
        showWhen: true,
        ongoing: true,
        autoCancel: false,
        fullScreenIntent: true,
        category: AndroidNotificationCategory.call,
        actions: [
          const AndroidNotificationAction(
            'accept_call',
            'Accept',
            showsUserInterface: true,
          ),
          const AndroidNotificationAction(
            'decline_call',
            'Decline',
            cancelNotification: true,
          ),
        ],
      );
      
      await _localNotifications.show(
        call.id.hashCode,
        title,
        body,
        NotificationDetails(android: androidDetails),
        payload: call.id,
      );
    } else if (!kIsWeb && (Platform.isIOS || Platform.isMacOS)) {
      // iOS/macOS notification
      const iosDetails = DarwinNotificationDetails(
        presentAlert: true,
        presentBadge: true,
        presentSound: true,
        sound: 'default',
        categoryIdentifier: 'INCOMING_CALL',
      );
      
      const macOSDetails = DarwinNotificationDetails(
        presentAlert: true,
        presentBadge: true,
        presentSound: true,
        sound: 'default',
      );
      
      await _localNotifications.show(
        call.id.hashCode,
        title,
        body,
        const NotificationDetails(
          iOS: iosDetails,
          macOS: macOSDetails,
        ),
        payload: call.id,
      );
    } else if (!kIsWeb && Platform.isLinux) {
      // Linux notification
      const linuxDetails = LinuxNotificationDetails(
        urgency: LinuxNotificationUrgency.critical,
        actions: [
          LinuxNotificationAction(
            key: 'accept_call',
            label: 'Accept',
          ),
          LinuxNotificationAction(
            key: 'decline_call',
            label: 'Decline',
          ),
        ],
      );
      
      await _localNotifications.show(
        call.id.hashCode,
        title,
        body,
        const NotificationDetails(linux: linuxDetails),
        payload: call.id,
      );
    } else if (!kIsWeb && Platform.isWindows) {
      // Windows notification - basic support
      // Note: Windows notifications through flutter_local_notifications
      // have limited functionality compared to other platforms
      await _localNotifications.show(
        call.id.hashCode,
        title,
        body,
        null, // Windows uses default notification settings
        payload: call.id,
      );
      
      LoggerService.info(
        'Windows notification shown. Note: Action buttons not supported on Windows yet.',
        tag: 'NotificationService',
      );
    } else if (kIsWeb) {
      // Web notification fallback
      LoggerService.info(
        'Web platform detected. Call notifications require browser permission.',
        tag: 'NotificationService',
      );
    }
  }
  
  // End call notification
  Future<void> endCall(String callId) async {
    if (_isCallKitSupported) {
      await FlutterCallkitIncoming.endCall(callId);
    }
    await _localNotifications.cancel(callId.hashCode);
  }
  
  // CallKit event handlers
  void _handleAcceptCall(CallEvent event) {
    final callUUID = event.body['id'] as String?;
    if (callUUID != null) {
      LoggerService.info('Call accepted: $callUUID', tag: 'NotificationService');
      // Invoke callback if provided
      onCallAccepted?.call(callUUID);
    }
  }
  
  void _handleDeclineCall(CallEvent event) {
    final callUUID = event.body['id'] as String?;
    if (callUUID != null) {
      LoggerService.info('Call declined: $callUUID', tag: 'NotificationService');
      onCallDeclined?.call(callUUID);
      endCall(callUUID);
    }
  }
  
  void _handleEndCall(CallEvent event) {
    final callUUID = event.body['id'] as String?;
    if (callUUID != null) {
      LoggerService.info('Call ended: $callUUID', tag: 'NotificationService');
      endCall(callUUID);
    }
  }
  
  void _handleCallTimeout(CallEvent event) {
    final callUUID = event.body['id'] as String?;
    if (callUUID != null) {
      LoggerService.info('Call timeout: $callUUID', tag: 'NotificationService');
      endCall(callUUID);
    }
  }
  
  void _onNotificationResponse(NotificationResponse response) {
    final callId = response.payload;
    
    if (response.actionId == 'accept_call') {
      LoggerService.info('Call accepted via notification: $callId', tag: 'NotificationService');
      if (callId != null) {
        onCallAccepted?.call(callId);
      }
    } else if (response.actionId == 'decline_call') {
      LoggerService.info('Call declined via notification: $callId', tag: 'NotificationService');
      if (callId != null) {
        onCallDeclined?.call(callId);
        endCall(callId);
      }
    } else if (response.notificationResponseType == NotificationResponseType.selectedNotification) {
      LoggerService.info('Notification tapped: $callId', tag: 'NotificationService');
      // Tapping notification should accept the call
      if (callId != null) {
        onCallAccepted?.call(callId);
      }
    }
  }
  
  /// Show guidance when notification permission is denied
  void _showPermissionDeniedGuidance() {
    LoggerService.info(
      'Notification permissions denied. User guidance: '
      'To enable notifications, please go to your browser settings and allow notifications for this site.',
      tag: 'NotificationService'
    );
    // In a real implementation, this would trigger UI feedback
    // For now, we log the guidance for the UI layer to handle
  }
  
  /// Show guidance when permission is pending (default state)
  void _showPermissionPendingGuidance() {
    LoggerService.info(
      'Notification permission pending. User guidance: '
      'Please click "Allow" in the browser permission dialog to enable notifications.',
      tag: 'NotificationService'
    );
    // In a real implementation, this would trigger UI feedback
  }
  
  /// Show guidance when browser doesn't support notifications
  void _showBrowserNotSupportedGuidance() {
    LoggerService.warning(
      'Browser does not support notifications. User guidance: '
      'Your browser does not support web notifications. Please use a modern browser like Chrome, Firefox, or Safari.',
      tag: 'NotificationService'
    );
    // In a real implementation, this would trigger UI feedback
  }
  
  /// Get current notification permission status for UI
  bool get isPermissionDenied => _notificationPermissionDenied;
  
  /// Retry notification permission request
  Future<bool> retryPermissionRequest() async {
    if (_notificationPermissionDenied) {
      LoggerService.info('Retrying notification permission request', tag: 'NotificationService');
      _notificationPermissionDenied = false; // Reset the flag
      return await requestPermissions();
    }
    return false;
  }
}
````

## File: lib/features/notifications/presentation/providers/notification_provider.dart
````dart
import 'dart:async';
import 'package:flutter/material.dart';
import '../../domain/models/notification_model.dart';
import '../../data/services/firebase_notification_service.dart';

class NotificationProvider extends ChangeNotifier {
  final FirebaseNotificationService _notificationService = FirebaseNotificationService();
  
  List<NotificationModel> _notifications = [];
  List<NotificationModel> _filteredNotifications = [];
  bool _isLoading = false;
  String _error = '';
  String _searchQuery = '';
  String _selectedFilter = 'All';
  StreamSubscription<List<NotificationModel>>? _notificationSubscription;
  
  // Getters
  List<NotificationModel> get notifications => _notifications;
  List<NotificationModel> get filteredNotifications => _filteredNotifications;
  bool get isLoading => _isLoading;
  String get error => _error;
  String get searchQuery => _searchQuery;
  String get selectedFilter => _selectedFilter;
  int get unreadCount => _notifications.where((n) => !n.isRead).length;
  
  // Initialize and start listening to notifications
  void initialize() {
    _loadNotifications();
  }
  
  // Load notifications from Firebase
  void _loadNotifications() {
    _isLoading = true;
    _error = '';
    notifyListeners();
    
    _notificationSubscription?.cancel();
    _notificationSubscription = _notificationService.getUserNotifications().listen(
      (notifications) {
        _notifications = notifications;
        _applyFilters();
        _isLoading = false;
        notifyListeners();
      },
      onError: (error) {
        _error = error.toString();
        _isLoading = false;
        notifyListeners();
      },
    );
  }
  
  // Apply search and filter
  void _applyFilters() {
    _filteredNotifications = _notifications.where((notification) {
      // Apply search filter
      if (_searchQuery.isNotEmpty) {
        final query = _searchQuery.toLowerCase();
        if (!notification.title.toLowerCase().contains(query) &&
            !notification.message.toLowerCase().contains(query)) {
          return false;
        }
      }
      
      // Apply type filter
      if (_selectedFilter != 'All') {
        switch (_selectedFilter) {
          case 'Grades':
            if (notification.type != NotificationType.grade) return false;
            break;
          case 'Assignments':
            if (notification.type != NotificationType.assignment) return false;
            break;
          case 'Messages':
            if (notification.type != NotificationType.message) return false;
            break;
          case 'System':
            if (notification.type != NotificationType.system) return false;
            break;
        }
      }
      
      return true;
    }).toList();
  }
  
  // Update search query
  void updateSearchQuery(String query) {
    _searchQuery = query;
    _applyFilters();
    notifyListeners();
  }
  
  // Update filter
  void updateFilter(String filter) {
    _selectedFilter = filter;
    _applyFilters();
    notifyListeners();
  }
  
  // Get notifications by tab
  List<NotificationModel> getNotificationsByTab(String tab) {
    switch (tab) {
      case 'all':
        return filteredNotifications;
      case 'unread':
        return filteredNotifications.where((n) => !n.isRead).toList();
      case 'academic':
        return filteredNotifications.where((n) => 
          n.type == NotificationType.grade ||
          n.type == NotificationType.assignment ||
          n.type == NotificationType.submission
        ).toList();
      default:
        return filteredNotifications;
    }
  }
  
  // Mark notification as read
  Future<void> markAsRead(String notificationId) async {
    try {
      await _notificationService.markAsRead(notificationId);
      // Update local state immediately for better UX
      final index = _notifications.indexWhere((n) => n.id == notificationId);
      if (index != -1) {
        _notifications[index] = _notifications[index].copyWith(isRead: true);
        _applyFilters();
        notifyListeners();
      }
    } catch (e) {
      _error = 'Failed to mark as read: $e';
      notifyListeners();
    }
  }
  
  // Mark notification as unread
  Future<void> markAsUnread(String notificationId) async {
    try {
      await _notificationService.markAsUnread(notificationId);
      // Update local state immediately for better UX
      final index = _notifications.indexWhere((n) => n.id == notificationId);
      if (index != -1) {
        _notifications[index] = _notifications[index].copyWith(isRead: false);
        _applyFilters();
        notifyListeners();
      }
    } catch (e) {
      _error = 'Failed to mark as unread: $e';
      notifyListeners();
    }
  }
  
  // Mark all as read
  Future<void> markAllAsRead() async {
    try {
      await _notificationService.markAllAsRead();
      // Update local state
      _notifications = _notifications.map((n) => 
        n.copyWith(isRead: true)
      ).toList();
      _applyFilters();
      notifyListeners();
    } catch (e) {
      _error = 'Failed to mark all as read: $e';
      notifyListeners();
    }
  }
  
  // Delete notification
  Future<void> deleteNotification(String notificationId) async {
    try {
      await _notificationService.deleteNotification(notificationId);
      // Remove from local state
      _notifications.removeWhere((n) => n.id == notificationId);
      _applyFilters();
      notifyListeners();
    } catch (e) {
      _error = 'Failed to delete notification: $e';
      notifyListeners();
    }
  }
  
  // Delete all read notifications
  Future<void> deleteAllRead() async {
    try {
      await _notificationService.deleteAllRead();
      // Remove from local state
      _notifications.removeWhere((n) => n.isRead);
      _applyFilters();
      notifyListeners();
    } catch (e) {
      _error = 'Failed to delete read notifications: $e';
      notifyListeners();
    }
  }
  
  // Get notification settings
  Future<Map<String, bool>> getNotificationSettings() async {
    try {
      return await _notificationService.getNotificationSettings();
    } catch (e) {
      _error = 'Failed to get settings: $e';
      notifyListeners();
      return {};
    }
  }
  
  // Update notification settings
  Future<void> updateNotificationSettings(Map<String, bool> settings) async {
    try {
      await _notificationService.updateNotificationSettings(settings);
    } catch (e) {
      _error = 'Failed to update settings: $e';
      notifyListeners();
    }
  }
  
  @override
  void dispose() {
    _notificationSubscription?.cancel();
    super.dispose();
  }
}
````

## File: lib/features/notifications/presentation/screens/notifications_screen.dart
````dart
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import '../../../../shared/models/user_model.dart';
import '../../../auth/presentation/providers/auth_provider.dart';
import 'package:go_router/go_router.dart';
import '../../../../shared/widgets/common/adaptive_layout.dart';
import '../../../../shared/widgets/common/responsive_layout.dart';
import '../providers/notification_provider.dart';
import '../../domain/models/notification_model.dart';

class NotificationsScreen extends StatefulWidget {
  const NotificationsScreen({super.key});

  @override
  State<NotificationsScreen> createState() => _NotificationsScreenState();
}

class _NotificationsScreenState extends State<NotificationsScreen> with SingleTickerProviderStateMixin {
  late TabController _tabController;
  final _searchController = TextEditingController();
  String _selectedFilter = 'All';

  @override
  void initState() {
    super.initState();
    _tabController = TabController(length: 3, vsync: this, initialIndex: 0);
    // Initialize notifications provider
    WidgetsBinding.instance.addPostFrameCallback((_) {
      context.read<NotificationProvider>().initialize();
    });
  }

  @override
  void dispose() {
    _tabController.dispose();
    _searchController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);

    return AdaptiveLayout(
      title: 'Notifications',
      showBackButton: true,
      actions: [
        IconButton(
          icon: const Icon(Icons.settings),
          onPressed: () => _showNotificationSettings(context),
          tooltip: 'Notification Settings',
        ),
      ],
      bottom: TabBar(
        controller: _tabController,
        tabs: const [
          Tab(text: 'All'),
          Tab(text: 'Unread'),
          Tab(text: 'Academic'),
        ],
      ),
      body: Column(
        children: [
          // Search and Filter Bar
          Container(
            padding: const EdgeInsets.all(16),
            child: Row(
              children: [
                // Search Field
                Expanded(
                  child: TextField(
                    controller: _searchController,
                    decoration: InputDecoration(
                      hintText: 'Search notifications...',
                      prefixIcon: const Icon(Icons.search),
                      suffixIcon: _searchController.text.isNotEmpty
                          ? IconButton(
                              icon: const Icon(Icons.clear),
                              onPressed: () {
                                setState(() {
                                  _searchController.clear();
                                });
                              },
                            )
                          : null,
                      border: const OutlineInputBorder(),
                      contentPadding: const EdgeInsets.symmetric(
                        horizontal: 16,
                        vertical: 12,
                      ),
                    ),
                    onChanged: (value) {
                      context.read<NotificationProvider>().updateSearchQuery(value);
                    },
                  ),
                ),
                const SizedBox(width: 12),
                // Filter Button
                Container(
                  decoration: BoxDecoration(
                    border: Border.all(color: theme.colorScheme.outline),
                    borderRadius: BorderRadius.circular(8),
                  ),
                  child: PopupMenuButton<String>(
                    initialValue: _selectedFilter,
                    onSelected: (value) {
                      setState(() {
                        _selectedFilter = value;
                        context.read<NotificationProvider>().updateFilter(value);
                      });
                    },
                    itemBuilder: (context) => [
                      const PopupMenuItem(value: 'All', child: Text('All Types')),
                      const PopupMenuItem(value: 'Grades', child: Text('Grades')),
                      const PopupMenuItem(value: 'Assignments', child: Text('Assignments')),
                      const PopupMenuItem(value: 'Messages', child: Text('Messages')),
                      const PopupMenuItem(value: 'System', child: Text('System')),
                    ],
                    child: Padding(
                      padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 8),
                      child: Row(
                        children: [
                          const Icon(Icons.filter_list, size: 20),
                          const SizedBox(width: 8),
                          Text(_selectedFilter),
                          const Icon(Icons.arrow_drop_down),
                        ],
                      ),
                    ),
                  ),
                ),
              ],
            ),
          ),
          // Notifications List
          Expanded(
            child: TabBarView(
              controller: _tabController,
              children: [
                _buildAllNotifications(),
                _buildUnreadNotifications(),
                _buildAcademicNotifications(),
              ],
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildAllNotifications() {
    return Consumer<NotificationProvider>(
      builder: (context, provider, child) {
        if (provider.isLoading) {
          return const Center(child: CircularProgressIndicator());
        }
        
        if (provider.error.isNotEmpty) {
          return Center(
            child: Column(
              mainAxisAlignment: MainAxisAlignment.center,
              children: [
                const Icon(Icons.error_outline, size: 48, color: Colors.red),
                const SizedBox(height: 16),
                Text(provider.error),
                const SizedBox(height: 16),
                FilledButton(
                  onPressed: () => provider.initialize(),
                  child: const Text('Retry'),
                ),
              ],
            ),
          );
        }
        
        final notifications = provider.getNotificationsByTab('all');
        if (notifications.isEmpty) {
          return Center(
            child: Column(
              mainAxisAlignment: MainAxisAlignment.center,
              children: [
                Icon(
                  Icons.notifications_none,
                  size: 64,
                  color: Theme.of(context).colorScheme.onSurfaceVariant.withValues(alpha: 0.5),
                ),
                const SizedBox(height: 16),
                Text(
                  'No notifications',
                  style: Theme.of(context).textTheme.titleMedium?.copyWith(
                    color: Theme.of(context).colorScheme.onSurfaceVariant,
                  ),
                ),
              ],
            ),
          );
        }
        
        return _buildNotificationsList(notifications);
      },
    );
  }

  Widget _buildUnreadNotifications() {
    return Consumer<NotificationProvider>(
      builder: (context, provider, child) {
        if (provider.isLoading) {
          return const Center(child: CircularProgressIndicator());
        }
        
        final notifications = provider.getNotificationsByTab('unread');
        if (notifications.isEmpty) {
          return Center(
            child: Column(
              mainAxisAlignment: MainAxisAlignment.center,
              children: [
                Icon(
                  Icons.mark_email_read,
                  size: 64,
                  color: Theme.of(context).colorScheme.onSurfaceVariant.withValues(alpha: 0.5),
                ),
                const SizedBox(height: 16),
                Text(
                  'All caught up!',
                  style: Theme.of(context).textTheme.titleMedium?.copyWith(
                    color: Theme.of(context).colorScheme.onSurfaceVariant,
                  ),
                ),
                const SizedBox(height: 8),
                Text(
                  'No unread notifications',
                  style: Theme.of(context).textTheme.bodyMedium?.copyWith(
                    color: Theme.of(context).colorScheme.onSurfaceVariant,
                  ),
                ),
              ],
            ),
          );
        }
        
        return _buildNotificationsList(notifications);
      },
    );
  }

  Widget _buildAcademicNotifications() {
    return Consumer<NotificationProvider>(
      builder: (context, provider, child) {
        if (provider.isLoading) {
          return const Center(child: CircularProgressIndicator());
        }
        
        final notifications = provider.getNotificationsByTab('academic');
        if (notifications.isEmpty) {
          return Center(
            child: Column(
              mainAxisAlignment: MainAxisAlignment.center,
              children: [
                Icon(
                  Icons.school_outlined,
                  size: 64,
                  color: Theme.of(context).colorScheme.onSurfaceVariant.withValues(alpha: 0.5),
                ),
                const SizedBox(height: 16),
                Text(
                  'No academic notifications',
                  style: Theme.of(context).textTheme.titleMedium?.copyWith(
                    color: Theme.of(context).colorScheme.onSurfaceVariant,
                  ),
                ),
              ],
            ),
          );
        }
        
        return _buildNotificationsList(notifications);
      },
    );
  }

  Widget _buildNotificationsList(List<NotificationModel> notifications) {
    return ResponsiveContainer(
      child: ListView.builder(
        itemCount: notifications.length,
        itemBuilder: (context, index) {
          final notification = notifications[index];
          return _buildNotificationCard(notification);
        },
      ),
    );
  }

  Widget _buildNotificationCard(NotificationModel notification) {
    final theme = Theme.of(context);
    final isUnread = !notification.isRead;
    
    Color typeColor;
    IconData typeIcon;
    switch (notification.type) {
      case NotificationType.grade:
        typeColor = Colors.green;
        typeIcon = Icons.grade;
        break;
      case NotificationType.assignment:
        typeColor = Colors.blue;
        typeIcon = Icons.assignment;
        break;
      case NotificationType.message:
        typeColor = Colors.orange;
        typeIcon = Icons.message;
        break;
      case NotificationType.system:
        typeColor = Colors.purple;
        typeIcon = Icons.info;
        break;
      case NotificationType.calendar:
        typeColor = Colors.indigo;
        typeIcon = Icons.calendar_month;
        break;
      case NotificationType.announcement:
        typeColor = Colors.red;
        typeIcon = Icons.campaign;
        break;
      case NotificationType.discussion:
        typeColor = Colors.teal;
        typeIcon = Icons.forum;
        break;
      case NotificationType.submission:
        typeColor = Colors.deepOrange;
        typeIcon = Icons.upload_file;
        break;
    }

    Color priorityColor;
    switch (notification.priority) {
      case NotificationPriority.urgent:
        priorityColor = Colors.red[700]!;
        break;
      case NotificationPriority.high:
        priorityColor = Colors.red;
        break;
      case NotificationPriority.medium:
        priorityColor = Colors.orange;
        break;
      case NotificationPriority.low:
        priorityColor = Colors.green;
        break;
      case NotificationPriority.normal:
        priorityColor = Colors.grey;
        break;
    }

    return Card(
      margin: const EdgeInsets.symmetric(horizontal: 16, vertical: 4),
      elevation: isUnread ? 2 : 1,
      child: InkWell(
        onTap: () => _handleNotificationTap(notification),
        borderRadius: BorderRadius.circular(12),
        child: Container(
          padding: const EdgeInsets.all(16),
          decoration: BoxDecoration(
            borderRadius: BorderRadius.circular(12),
            border: isUnread 
                ? Border.all(color: theme.colorScheme.primary.withValues(alpha: 0.3), width: 1)
                : null,
          ),
          child: Row(
            children: [
              // Type Icon with priority indicator
              Stack(
                children: [
                  Container(
                    padding: const EdgeInsets.all(12),
                    decoration: BoxDecoration(
                      color: isUnread 
                          ? typeColor.withValues(alpha: 0.2)
                          : Colors.grey.withValues(alpha: 0.1),
                      shape: BoxShape.circle,
                    ),
                    child: Icon(
                      typeIcon,
                      color: isUnread ? typeColor : Colors.grey,
                      size: 20,
                    ),
                  ),
                  if (notification.priority == NotificationPriority.high || 
                      notification.priority == NotificationPriority.urgent)
                    Positioned(
                      top: 0,
                      right: 0,
                      child: Container(
                        width: 12,
                        height: 12,
                        decoration: const BoxDecoration(
                          color: Colors.red,
                          shape: BoxShape.circle,
                        ),
                        child: const Icon(
                          Icons.priority_high,
                          color: Colors.white,
                          size: 8,
                        ),
                      ),
                    ),
                ],
              ),
              const SizedBox(width: 16),
              // Notification Content
              Expanded(
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    // Header Row
                    Row(
                      children: [
                        Expanded(
                          child: Text(
                            notification.title,
                            style: theme.textTheme.titleMedium?.copyWith(
                              fontWeight: isUnread ? FontWeight.bold : FontWeight.w600,
                            ),
                            overflow: TextOverflow.ellipsis,
                          ),
                        ),
                        Text(
                          _formatNotificationTime(notification.createdAt),
                          style: theme.textTheme.bodySmall?.copyWith(
                            color: theme.colorScheme.onSurfaceVariant,
                            fontWeight: isUnread ? FontWeight.w600 : FontWeight.normal,
                          ),
                        ),
                      ],
                    ),
                    const SizedBox(height: 4),
                    // Message
                    Text(
                      notification.message,
                      style: theme.textTheme.bodyMedium?.copyWith(
                        color: theme.colorScheme.onSurfaceVariant,
                        fontWeight: isUnread ? FontWeight.w500 : FontWeight.normal,
                      ),
                      maxLines: 2,
                      overflow: TextOverflow.ellipsis,
                    ),
                    const SizedBox(height: 8),
                    // Type and Priority Tags
                    Row(
                      children: [
                        _buildNotificationTag(
                          notification.type.name.toUpperCase(),
                          typeColor,
                        ),
                        if (notification.priority != NotificationPriority.normal) ...[ 
                          const SizedBox(width: 8),
                          _buildNotificationTag(
                            notification.priority.name.toUpperCase(),
                            priorityColor,
                          ),
                        ],
                      ],
                    ),
                  ],
                ),
              ),
              const SizedBox(width: 8),
              // Actions
              PopupMenuButton<String>(
                icon: Icon(
                  Icons.more_vert,
                  color: theme.colorScheme.onSurfaceVariant,
                ),
                itemBuilder: (context) => [
                  PopupMenuItem(
                    value: 'mark_read',
                    child: Row(
                      children: [
                        Icon(
                          isUnread ? Icons.mark_email_read : Icons.mark_email_unread,
                          size: 18,
                        ),
                        const SizedBox(width: 8),
                        Text(isUnread ? 'Mark as Read' : 'Mark as Unread'),
                      ],
                    ),
                  ),
                  const PopupMenuItem(
                    value: 'delete',
                    child: Row(
                      children: [
                        Icon(Icons.delete, size: 18),
                        SizedBox(width: 8),
                        Text('Delete'),
                      ],
                    ),
                  ),
                ],
                onSelected: (value) => _handleNotificationAction(value, notification),
              ),
            ],
          ),
        ),
      ),
    );
  }

  Widget _buildNotificationTag(String label, Color color) {
    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 6, vertical: 2),
      decoration: BoxDecoration(
        color: color.withValues(alpha: 0.1),
        borderRadius: BorderRadius.circular(8),
      ),
      child: Text(
        label,
        style: TextStyle(
          color: color,
          fontWeight: FontWeight.w600,
          fontSize: 10,
        ),
      ),
    );
  }

  String _formatNotificationTime(DateTime time) {
    final now = DateTime.now();
    final difference = now.difference(time);
    
    if (difference.inMinutes < 60) {
      return '${difference.inMinutes}m';
    } else if (difference.inHours < 24) {
      return '${difference.inHours}h';
    } else if (difference.inDays < 7) {
      return '${difference.inDays}d';
    } else {
      return '${time.day}/${time.month}';
    }
  }

  void _handleNotificationTap(NotificationModel notification) {
    final provider = context.read<NotificationProvider>();
    
    // Mark as read if unread
    if (!notification.isRead) {
      provider.markAsRead(notification.id);
    }

    // Handle different notification types
    switch (notification.type) {
      case NotificationType.grade:
        _navigateToGrades(notification.actionData);
        break;
      case NotificationType.assignment:
        _navigateToAssignments(notification.actionData);
        break;
      case NotificationType.message:
        _navigateToMessages(notification.actionData);
        break;
      case NotificationType.system:
        _showSystemNotificationDetails(notification);
        break;
      case NotificationType.calendar:
        context.go('/calendar');
        break;
      case NotificationType.announcement:
        // Navigate to discussions board where announcements are typically posted
        if (notification.actionData != null && notification.actionData!['boardId'] != null) {
          context.go('/discussions/${notification.actionData!['boardId']}');
        } else {
          context.go('/discussions');
        }
        break;
      case NotificationType.discussion:
        context.go('/discussions');
        break;
      case NotificationType.submission:
        _navigateToAssignments(notification.actionData);
        break;
    }
  }

  void _navigateToGrades(Map<String, dynamic>? actionData) {
    // Check if user is a teacher or student and navigate accordingly
    final authProvider = Provider.of<AuthProvider>(context, listen: false);
    final isTeacher = authProvider.userModel?.role == UserRole.teacher;
    
    if (actionData != null && actionData['assignmentId'] != null) {
      // Navigate to specific assignment's grades
      if (isTeacher) {
        context.go('/teacher/gradebook?assignmentId=${actionData['assignmentId']}');
      } else {
        // For students, just go to their grades page
        context.go('/student/grades');
      }
    } else if (actionData != null && actionData['classId'] != null) {
      // Navigate to specific class grades
      if (isTeacher) {
        context.go('/teacher/gradebook?classId=${actionData['classId']}');
      } else {
        context.go('/student/grades');
      }
    } else {
      // Navigate to general grades page
      context.go(isTeacher ? '/teacher/gradebook' : '/student/grades');
    }
  }

  void _navigateToAssignments(Map<String, dynamic>? actionData) {
    // Check if user is a teacher or student and navigate accordingly
    final authProvider = Provider.of<AuthProvider>(context, listen: false);
    final isTeacher = authProvider.userModel?.role == UserRole.teacher;
    
    if (actionData != null && actionData['assignmentId'] != null) {
      // Navigate to specific assignment
      if (isTeacher) {
        context.go('/teacher/assignments/${actionData['assignmentId']}');
      } else {
        // For students, go to submission page
        context.go('/student/assignments/${actionData['assignmentId']}/submit');
      }
    } else {
      // Navigate to general assignments page
      context.go(isTeacher ? '/teacher/assignments' : '/student/assignments');
    }
  }

  void _navigateToMessages(Map<String, dynamic>? actionData) {
    if (actionData != null && actionData['chatRoomId'] != null) {
      // Navigate to specific chat room
      context.go('/messages/${actionData['chatRoomId']}');
    } else if (actionData != null && actionData['userId'] != null) {
      // Navigate to create new chat with specific user
      context.go('/messages', extra: {'userId': actionData['userId']});
    } else {
      // Navigate to general messages page
      context.go('/messages');
    }
  }

  void _showSystemNotificationDetails(NotificationModel notification) {
    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        title: Text(notification.title),
        content: Text(notification.message),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(context),
            child: const Text('OK'),
          ),
        ],
      ),
    );
  }

  void _handleNotificationAction(String action, NotificationModel notification) {
    final provider = context.read<NotificationProvider>();
    
    switch (action) {
      case 'mark_read':
        if (notification.isRead) {
          provider.markAsUnread(notification.id);
        } else {
          provider.markAsRead(notification.id);
        }
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text(
              notification.isRead 
                  ? 'Marked as unread' 
                  : 'Marked as read',
            ),
          ),
        );
        break;
      case 'delete':
        _showDeleteConfirmation(notification);
        break;
    }
  }

  void _showDeleteConfirmation(NotificationModel notification) {
    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        title: const Text('Delete Notification'),
        content: const Text('Are you sure you want to delete this notification?'),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(context),
            child: const Text('Cancel'),
          ),
          FilledButton(
            onPressed: () {
              Navigator.pop(context);
              context.read<NotificationProvider>().deleteNotification(notification.id);
              ScaffoldMessenger.of(context).showSnackBar(
                const SnackBar(
                  content: Text('Notification deleted'),
                ),
              );
            },
            child: const Text('Delete'),
          ),
        ],
      ),
    );
  }

  void _showNotificationSettings(BuildContext context) {
    showModalBottomSheet(
      context: context,
      isScrollControlled: true,
      backgroundColor: Colors.transparent,
      builder: (context) => const NotificationSettingsSheet(),
    );
  }
}

// Notification Settings Sheet
class NotificationSettingsSheet extends StatefulWidget {
  const NotificationSettingsSheet({super.key});

  @override
  State<NotificationSettingsSheet> createState() => _NotificationSettingsSheetState();
}

class _NotificationSettingsSheetState extends State<NotificationSettingsSheet> {
  bool _pushNotifications = true;
  bool _emailNotifications = true;
  bool _gradeNotifications = true;
  bool _assignmentNotifications = true;
  bool _messageNotifications = true;
  bool _systemNotifications = true;
  String _quietHoursStart = '22:00';
  String _quietHoursEnd = '08:00';

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);

    return Container(
      height: MediaQuery.of(context).size.height * 0.8,
      decoration: BoxDecoration(
        color: theme.colorScheme.surface,
        borderRadius: const BorderRadius.vertical(top: Radius.circular(20)),
      ),
      child: Column(
        children: [
          // Handle Bar
          Center(
            child: Container(
              margin: const EdgeInsets.only(top: 12, bottom: 8),
              width: 40,
              height: 4,
              decoration: BoxDecoration(
                color: theme.colorScheme.onSurfaceVariant.withValues(alpha: 0.3),
                borderRadius: BorderRadius.circular(2),
              ),
            ),
          ),
          // Header
          Padding(
            padding: const EdgeInsets.symmetric(horizontal: 24, vertical: 16),
            child: Row(
              mainAxisAlignment: MainAxisAlignment.spaceBetween,
              children: [
                Text(
                  'Notification Settings',
                  style: theme.textTheme.headlineSmall?.copyWith(
                    fontWeight: FontWeight.bold,
                  ),
                ),
                IconButton(
                  onPressed: () => Navigator.pop(context),
                  icon: const Icon(Icons.close),
                ),
              ],
            ),
          ),
          // Settings Content
          Expanded(
            child: SingleChildScrollView(
              padding: const EdgeInsets.symmetric(horizontal: 24),
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  // General Settings
                  Text(
                    'General',
                    style: theme.textTheme.titleMedium?.copyWith(
                      fontWeight: FontWeight.bold,
                    ),
                  ),
                  const SizedBox(height: 12),
                  SwitchListTile(
                    title: const Text('Push Notifications'),
                    subtitle: const Text('Receive notifications on this device'),
                    value: _pushNotifications,
                    onChanged: (value) {
                      setState(() {
                        _pushNotifications = value;
                      });
                    },
                  ),
                  SwitchListTile(
                    title: const Text('Email Notifications'),
                    subtitle: const Text('Receive notifications via email'),
                    value: _emailNotifications,
                    onChanged: (value) {
                      setState(() {
                        _emailNotifications = value;
                      });
                    },
                  ),
                  
                  const SizedBox(height: 24),
                  
                  // Notification Types
                  Text(
                    'Notification Types',
                    style: theme.textTheme.titleMedium?.copyWith(
                      fontWeight: FontWeight.bold,
                    ),
                  ),
                  const SizedBox(height: 12),
                  SwitchListTile(
                    title: const Text('Grade Notifications'),
                    subtitle: const Text('New grades and grade updates'),
                    value: _gradeNotifications,
                    onChanged: (value) {
                      setState(() {
                        _gradeNotifications = value;
                      });
                    },
                  ),
                  SwitchListTile(
                    title: const Text('Assignment Notifications'),
                    subtitle: const Text('Assignment reminders and updates'),
                    value: _assignmentNotifications,
                    onChanged: (value) {
                      setState(() {
                        _assignmentNotifications = value;
                      });
                    },
                  ),
                  SwitchListTile(
                    title: const Text('Message Notifications'),
                    subtitle: const Text('New messages from teachers and staff'),
                    value: _messageNotifications,
                    onChanged: (value) {
                      setState(() {
                        _messageNotifications = value;
                      });
                    },
                  ),
                  SwitchListTile(
                    title: const Text('System Notifications'),
                    subtitle: const Text('System updates and announcements'),
                    value: _systemNotifications,
                    onChanged: (value) {
                      setState(() {
                        _systemNotifications = value;
                      });
                    },
                  ),
                  
                  const SizedBox(height: 24),
                  
                  // Quiet Hours
                  Text(
                    'Quiet Hours',
                    style: theme.textTheme.titleMedium?.copyWith(
                      fontWeight: FontWeight.bold,
                    ),
                  ),
                  const SizedBox(height: 12),
                  Text(
                    'No notifications will be sent during quiet hours',
                    style: theme.textTheme.bodyMedium?.copyWith(
                      color: theme.colorScheme.onSurfaceVariant,
                    ),
                  ),
                  const SizedBox(height: 16),
                  Row(
                    children: [
                      Expanded(
                        child: ListTile(
                          title: const Text('Start Time'),
                          subtitle: Text(_quietHoursStart),
                          trailing: const Icon(Icons.access_time),
                          onTap: () => _selectTime(context, true),
                        ),
                      ),
                      Expanded(
                        child: ListTile(
                          title: const Text('End Time'),
                          subtitle: Text(_quietHoursEnd),
                          trailing: const Icon(Icons.access_time),
                          onTap: () => _selectTime(context, false),
                        ),
                      ),
                    ],
                  ),
                  
                  const SizedBox(height: 32),
                ],
              ),
            ),
          ),
          // Save Button
          Container(
            padding: const EdgeInsets.all(24),
            decoration: BoxDecoration(
              color: theme.colorScheme.surface,
              boxShadow: [
                BoxShadow(
                  color: Colors.black.withValues(alpha: 0.1),
                  blurRadius: 10,
                  offset: const Offset(0, -5),
                ),
              ],
            ),
            child: SizedBox(
              width: double.infinity,
              child: FilledButton(
                onPressed: () {
                  Navigator.pop(context);
                  ScaffoldMessenger.of(context).showSnackBar(
                    const SnackBar(
                      content: Text('Notification settings saved'),
                    ),
                  );
                },
                style: FilledButton.styleFrom(
                  padding: const EdgeInsets.symmetric(vertical: 16),
                ),
                child: const Text('Save Settings'),
              ),
            ),
          ),
        ],
      ),
    );
  }

  Future<void> _selectTime(BuildContext context, bool isStart) async {
    final currentTime = isStart ? _quietHoursStart : _quietHoursEnd;
    final parts = currentTime.split(':');
    final initialTime = TimeOfDay(
      hour: int.parse(parts[0]),
      minute: int.parse(parts[1]),
    );

    final TimeOfDay? picked = await showTimePicker(
      context: context,
      initialTime: initialTime,
    );

    if (picked != null) {
      final formattedTime = '${picked.hour.toString().padLeft(2, '0')}:${picked.minute.toString().padLeft(2, '0')}';
      setState(() {
        if (isStart) {
          _quietHoursStart = formattedTime;
        } else {
          _quietHoursEnd = formattedTime;
        }
      });
    }
  }
}
````

## File: lib/features/notifications/presentation/screens/student_notifications_screen.dart
````dart
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'package:go_router/go_router.dart';
import '../../../../shared/widgets/common/adaptive_layout.dart';
import '../../../../shared/widgets/common/responsive_layout.dart';
import '../providers/notification_provider.dart';
import '../../domain/models/notification_model.dart';

class StudentNotificationsScreen extends StatefulWidget {
  const StudentNotificationsScreen({super.key});

  @override
  State<StudentNotificationsScreen> createState() => _StudentNotificationsScreenState();
}

class _StudentNotificationsScreenState extends State<StudentNotificationsScreen> 
    with SingleTickerProviderStateMixin {
  late TabController _tabController;
  final _searchController = TextEditingController();
  String _selectedFilter = 'All';
  
  @override
  void initState() {
    super.initState();
    _tabController = TabController(length: 4, vsync: this, initialIndex: 0);
    // Initialize notifications provider for student context
    WidgetsBinding.instance.addPostFrameCallback((_) {
      context.read<NotificationProvider>().initialize();
    });
  }

  @override
  void dispose() {
    _tabController.dispose();
    _searchController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);

    return AdaptiveLayout(
      title: 'Notifications',
      showBackButton: true,
      actions: [
        IconButton(
          icon: const Icon(Icons.mark_email_read),
          onPressed: _markAllAsRead,
          tooltip: 'Mark All as Read',
        ),
        IconButton(
          icon: const Icon(Icons.settings),
          onPressed: () => _showNotificationSettings(context),
          tooltip: 'Notification Settings',
        ),
      ],
      bottom: TabBar(
        controller: _tabController,
        tabs: const [
          Tab(text: 'All'),
          Tab(text: 'Unread'),
          Tab(text: 'Classes'),
          Tab(text: 'Grades'),
        ],
      ),
      body: Column(
        children: [
          // Search and Filter Bar
          Container(
            padding: const EdgeInsets.all(16),
            child: Row(
              children: [
                // Search Field
                Expanded(
                  child: TextField(
                    controller: _searchController,
                    decoration: InputDecoration(
                      hintText: 'Search notifications...',
                      prefixIcon: const Icon(Icons.search),
                      suffixIcon: _searchController.text.isNotEmpty
                          ? IconButton(
                              icon: const Icon(Icons.clear),
                              onPressed: () {
                                setState(() {
                                  _searchController.clear();
                                });
                              },
                            )
                          : null,
                      border: const OutlineInputBorder(),
                      contentPadding: const EdgeInsets.symmetric(
                        horizontal: 16,
                        vertical: 12,
                      ),
                    ),
                    onChanged: (value) {
                      context.read<NotificationProvider>().updateSearchQuery(value);
                    },
                  ),
                ),
                const SizedBox(width: 12),
                // Filter Button
                Container(
                  decoration: BoxDecoration(
                    border: Border.all(color: theme.colorScheme.outline),
                    borderRadius: BorderRadius.circular(8),
                  ),
                  child: PopupMenuButton<String>(
                    initialValue: _selectedFilter,
                    onSelected: (value) {
                      setState(() {
                        _selectedFilter = value;
                        context.read<NotificationProvider>().updateFilter(value);
                      });
                    },
                    itemBuilder: (context) => [
                      const PopupMenuItem(value: 'All', child: Text('All Types')),
                      const PopupMenuItem(value: 'Grades', child: Text('Grades')),
                      const PopupMenuItem(value: 'Assignments', child: Text('Assignments')),
                      const PopupMenuItem(value: 'Announcements', child: Text('Announcements')),
                      const PopupMenuItem(value: 'Messages', child: Text('Messages from Teachers')),
                    ],
                    child: Padding(
                      padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 8),
                      child: Row(
                        children: [
                          const Icon(Icons.filter_list, size: 20),
                          const SizedBox(width: 8),
                          Text(_selectedFilter),
                          const Icon(Icons.arrow_drop_down),
                        ],
                      ),
                    ),
                  ),
                ),
              ],
            ),
          ),
          // Notifications List
          Expanded(
            child: TabBarView(
              controller: _tabController,
              children: [
                _buildAllNotifications(),
                _buildUnreadNotifications(),
                _buildClassNotifications(),
                _buildGradeNotifications(),
              ],
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildAllNotifications() {
    return Consumer<NotificationProvider>(
      builder: (context, provider, child) {
        if (provider.isLoading) {
          return const Center(child: CircularProgressIndicator());
        }
        
        if (provider.error.isNotEmpty) {
          return Center(
            child: Column(
              mainAxisAlignment: MainAxisAlignment.center,
              children: [
                const Icon(Icons.error_outline, size: 48, color: Colors.red),
                const SizedBox(height: 16),
                Text(provider.error),
                const SizedBox(height: 16),
                FilledButton(
                  onPressed: () => provider.initialize(),
                  child: const Text('Retry'),
                ),
              ],
            ),
          );
        }
        
        final notifications = provider.getNotificationsByTab('all');
        if (notifications.isEmpty) {
          return _buildEmptyState(
            icon: Icons.notifications_none,
            title: 'No notifications',
            subtitle: 'You\'ll see updates from your classes here',
          );
        }
        
        return _buildNotificationsList(notifications);
      },
    );
  }

  Widget _buildUnreadNotifications() {
    return Consumer<NotificationProvider>(
      builder: (context, provider, child) {
        if (provider.isLoading) {
          return const Center(child: CircularProgressIndicator());
        }
        
        final notifications = provider.getNotificationsByTab('unread');
        if (notifications.isEmpty) {
          return _buildEmptyState(
            icon: Icons.mark_email_read,
            title: 'All caught up!',
            subtitle: 'No unread notifications',
          );
        }
        
        return _buildNotificationsList(notifications);
      },
    );
  }

  Widget _buildClassNotifications() {
    return Consumer<NotificationProvider>(
      builder: (context, provider, child) {
        if (provider.isLoading) {
          return const Center(child: CircularProgressIndicator());
        }
        
        // Filter for class-related notifications
        final notifications = provider.getNotificationsByTab('all').where((notif) {
          return notif.type == NotificationType.announcement ||
                 notif.type == NotificationType.calendar ||
                 notif.type == NotificationType.discussion;
        }).toList();
        
        if (notifications.isEmpty) {
          return _buildEmptyState(
            icon: Icons.class_outlined,
            title: 'No class updates',
            subtitle: 'Class announcements will appear here',
          );
        }
        
        return _buildNotificationsList(notifications);
      },
    );
  }

  Widget _buildGradeNotifications() {
    return Consumer<NotificationProvider>(
      builder: (context, provider, child) {
        if (provider.isLoading) {
          return const Center(child: CircularProgressIndicator());
        }
        
        // Filter for grade-related notifications
        final notifications = provider.getNotificationsByTab('all').where((notif) {
          return notif.type == NotificationType.grade ||
                 notif.type == NotificationType.submission;
        }).toList();
        
        if (notifications.isEmpty) {
          return _buildEmptyState(
            icon: Icons.grade_outlined,
            title: 'No grade updates',
            subtitle: 'New grades will appear here',
          );
        }
        
        return _buildNotificationsList(notifications);
      },
    );
  }

  Widget _buildEmptyState({
    required IconData icon,
    required String title,
    String? subtitle,
  }) {
    final theme = Theme.of(context);
    return Center(
      child: Column(
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          Icon(
            icon,
            size: 64,
            color: theme.colorScheme.onSurfaceVariant.withValues(alpha: 0.5),
          ),
          const SizedBox(height: 16),
          Text(
            title,
            style: theme.textTheme.titleMedium?.copyWith(
              color: theme.colorScheme.onSurfaceVariant,
            ),
          ),
          if (subtitle != null) ...[
            const SizedBox(height: 8),
            Text(
              subtitle,
              style: theme.textTheme.bodyMedium?.copyWith(
                color: theme.colorScheme.onSurfaceVariant,
              ),
            ),
          ],
        ],
      ),
    );
  }

  Widget _buildNotificationsList(List<NotificationModel> notifications) {
    return ResponsiveContainer(
      child: ListView.builder(
        itemCount: notifications.length,
        itemBuilder: (context, index) {
          final notification = notifications[index];
          return _buildNotificationCard(notification);
        },
      ),
    );
  }

  Widget _buildNotificationCard(NotificationModel notification) {
    final theme = Theme.of(context);
    final isUnread = !notification.isRead;
    
    Color typeColor;
    IconData typeIcon;
    switch (notification.type) {
      case NotificationType.grade:
        typeColor = Colors.green;
        typeIcon = Icons.grade;
        break;
      case NotificationType.assignment:
        typeColor = Colors.blue;
        typeIcon = Icons.assignment;
        break;
      case NotificationType.message:
        typeColor = Colors.orange;
        typeIcon = Icons.message;
        break;
      case NotificationType.announcement:
        typeColor = Colors.red;
        typeIcon = Icons.campaign;
        break;
      case NotificationType.submission:
        typeColor = Colors.deepOrange;
        typeIcon = Icons.upload_file;
        break;
      case NotificationType.calendar:
        typeColor = Colors.indigo;
        typeIcon = Icons.calendar_month;
        break;
      case NotificationType.discussion:
        typeColor = Colors.teal;
        typeIcon = Icons.forum;
        break;
      case NotificationType.system:
        typeColor = Colors.purple;
        typeIcon = Icons.info;
        break;
    }

    return Card(
      margin: const EdgeInsets.symmetric(horizontal: 16, vertical: 4),
      elevation: isUnread ? 2 : 1,
      child: InkWell(
        onTap: () => _handleNotificationTap(notification),
        borderRadius: BorderRadius.circular(12),
        child: Container(
          padding: const EdgeInsets.all(16),
          decoration: BoxDecoration(
            borderRadius: BorderRadius.circular(12),
            border: isUnread 
                ? Border.all(color: theme.colorScheme.primary.withValues(alpha: 0.3), width: 1)
                : null,
          ),
          child: Row(
            children: [
              // Type Icon with unread indicator
              Stack(
                children: [
                  Container(
                    padding: const EdgeInsets.all(12),
                    decoration: BoxDecoration(
                      color: isUnread 
                          ? typeColor.withValues(alpha: 0.2)
                          : Colors.grey.withValues(alpha: 0.1),
                      shape: BoxShape.circle,
                    ),
                    child: Icon(
                      typeIcon,
                      color: isUnread ? typeColor : Colors.grey,
                      size: 20,
                    ),
                  ),
                  if (isUnread)
                    Positioned(
                      top: 0,
                      right: 0,
                      child: Container(
                        width: 8,
                        height: 8,
                        decoration: BoxDecoration(
                          color: theme.colorScheme.primary,
                          shape: BoxShape.circle,
                        ),
                      ),
                    ),
                ],
              ),
              const SizedBox(width: 16),
              // Notification Content
              Expanded(
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    // Header Row
                    Row(
                      children: [
                        Expanded(
                          child: Text(
                            notification.title,
                            style: theme.textTheme.titleMedium?.copyWith(
                              fontWeight: isUnread ? FontWeight.bold : FontWeight.w600,
                            ),
                            overflow: TextOverflow.ellipsis,
                          ),
                        ),
                        Text(
                          _formatNotificationTime(notification.createdAt),
                          style: theme.textTheme.bodySmall?.copyWith(
                            color: theme.colorScheme.onSurfaceVariant,
                            fontWeight: isUnread ? FontWeight.w600 : FontWeight.normal,
                          ),
                        ),
                      ],
                    ),
                    const SizedBox(height: 4),
                    // Message
                    Text(
                      notification.message,
                      style: theme.textTheme.bodyMedium?.copyWith(
                        color: theme.colorScheme.onSurfaceVariant,
                        fontWeight: isUnread ? FontWeight.w500 : FontWeight.normal,
                      ),
                      maxLines: 2,
                      overflow: TextOverflow.ellipsis,
                    ),
                    const SizedBox(height: 8),
                    // Course Tag if available
                    if (notification.actionData?['courseName'] != null)
                      Container(
                        padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 2),
                        decoration: BoxDecoration(
                          color: theme.colorScheme.primaryContainer,
                          borderRadius: BorderRadius.circular(8),
                        ),
                        child: Text(
                          notification.actionData!['courseName'],
                          style: TextStyle(
                            color: theme.colorScheme.onPrimaryContainer,
                            fontWeight: FontWeight.w600,
                            fontSize: 11,
                          ),
                        ),
                      ),
                  ],
                ),
              ),
              const SizedBox(width: 8),
              // Actions
              PopupMenuButton<String>(
                icon: Icon(
                  Icons.more_vert,
                  color: theme.colorScheme.onSurfaceVariant,
                ),
                itemBuilder: (context) => [
                  PopupMenuItem(
                    value: 'mark_read',
                    child: Row(
                      children: [
                        Icon(
                          isUnread ? Icons.mark_email_read : Icons.mark_email_unread,
                          size: 18,
                        ),
                        const SizedBox(width: 8),
                        Text(isUnread ? 'Mark as Read' : 'Mark as Unread'),
                      ],
                    ),
                  ),
                  const PopupMenuItem(
                    value: 'delete',
                    child: Row(
                      children: [
                        Icon(Icons.delete, size: 18),
                        SizedBox(width: 8),
                        Text('Delete'),
                      ],
                    ),
                  ),
                ],
                onSelected: (value) => _handleNotificationAction(value, notification),
              ),
            ],
          ),
        ),
      ),
    );
  }

  String _formatNotificationTime(DateTime time) {
    final now = DateTime.now();
    final difference = now.difference(time);
    
    if (difference.inMinutes < 60) {
      return '${difference.inMinutes}m';
    } else if (difference.inHours < 24) {
      return '${difference.inHours}h';
    } else if (difference.inDays < 7) {
      return '${difference.inDays}d';
    } else {
      return '${time.day}/${time.month}';
    }
  }

  void _handleNotificationTap(NotificationModel notification) {
    final provider = context.read<NotificationProvider>();
    
    // Mark as read if unread
    if (!notification.isRead) {
      provider.markAsRead(notification.id);
    }

    // Handle different notification types for students
    switch (notification.type) {
      case NotificationType.grade:
        // Navigate to grades/progress screen
        context.go('/student/grades');
        break;
      case NotificationType.assignment:
        // Navigate to assignments screen with specific assignment
        if (notification.actionData?['assignmentId'] != null) {
          context.go('/student/assignments/${notification.actionData!['assignmentId']}');
        } else {
          context.go('/student/assignments');
        }
        break;
      case NotificationType.message:
        // Navigate to messages/chat
        if (notification.actionData?['conversationId'] != null) {
          context.go('/student/messages/${notification.actionData!['conversationId']}');
        } else {
          context.go('/student/messages');
        }
        break;
      case NotificationType.announcement:
        // Show announcement details
        _showAnnouncementDetails(notification);
        break;
      case NotificationType.submission:
        // Navigate to specific submission
        if (notification.actionData?['assignmentId'] != null) {
          context.go('/student/assignments/${notification.actionData!['assignmentId']}');
        }
        break;
      case NotificationType.calendar:
        // Navigate to calendar/schedule
        context.go('/student/schedule');
        break;
      case NotificationType.discussion:
        // Navigate to class discussions
        if (notification.actionData?['discussionId'] != null) {
          context.go('/student/discussions/${notification.actionData!['discussionId']}');
        } else {
          context.go('/student/discussions');
        }
        break;
      case NotificationType.system:
        _showSystemNotificationDetails(notification);
        break;
    }
  }

  void _showAnnouncementDetails(NotificationModel notification) {
    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        title: Text(notification.title),
        content: SingleChildScrollView(
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            mainAxisSize: MainAxisSize.min,
            children: [
              if (notification.actionData?['courseName'] != null) ...[
                Text(
                  notification.actionData!['courseName'],
                  style: Theme.of(context).textTheme.bodySmall?.copyWith(
                    color: Theme.of(context).colorScheme.primary,
                    fontWeight: FontWeight.bold,
                  ),
                ),
                const SizedBox(height: 8),
              ],
              Text(notification.message),
              if (notification.actionData?['details'] != null) ...[
                const SizedBox(height: 16),
                Text(notification.actionData!['details']),
              ],
            ],
          ),
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(context),
            child: const Text('Close'),
          ),
          if (notification.actionData?['classId'] != null)
            FilledButton(
              onPressed: () {
                Navigator.pop(context);
                context.go('/student/classes/${notification.actionData!['classId']}');
              },
              child: const Text('View Class'),
            ),
        ],
      ),
    );
  }

  void _showSystemNotificationDetails(NotificationModel notification) {
    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        title: Text(notification.title),
        content: Text(notification.message),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(context),
            child: const Text('OK'),
          ),
        ],
      ),
    );
  }

  void _handleNotificationAction(String action, NotificationModel notification) {
    final provider = context.read<NotificationProvider>();
    
    switch (action) {
      case 'mark_read':
        if (notification.isRead) {
          provider.markAsUnread(notification.id);
        } else {
          provider.markAsRead(notification.id);
        }
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text(
              notification.isRead 
                  ? 'Marked as unread' 
                  : 'Marked as read',
            ),
          ),
        );
        break;
      case 'delete':
        _showDeleteConfirmation(notification);
        break;
    }
  }

  void _showDeleteConfirmation(NotificationModel notification) {
    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        title: const Text('Delete Notification'),
        content: const Text('Are you sure you want to delete this notification?'),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(context),
            child: const Text('Cancel'),
          ),
          FilledButton(
            onPressed: () {
              Navigator.pop(context);
              context.read<NotificationProvider>().deleteNotification(notification.id);
              ScaffoldMessenger.of(context).showSnackBar(
                const SnackBar(
                  content: Text('Notification deleted'),
                ),
              );
            },
            child: const Text('Delete'),
          ),
        ],
      ),
    );
  }

  void _markAllAsRead() {
    final provider = context.read<NotificationProvider>();
    provider.markAllAsRead();
    
    ScaffoldMessenger.of(context).showSnackBar(
      const SnackBar(
        content: Text('All notifications marked as read'),
      ),
    );
  }

  void _showNotificationSettings(BuildContext context) {
    showModalBottomSheet(
      context: context,
      isScrollControlled: true,
      backgroundColor: Colors.transparent,
      builder: (context) => const StudentNotificationSettingsSheet(),
    );
  }
}

// Student-specific Notification Settings Sheet
class StudentNotificationSettingsSheet extends StatefulWidget {
  const StudentNotificationSettingsSheet({super.key});

  @override
  State<StudentNotificationSettingsSheet> createState() => 
      _StudentNotificationSettingsSheetState();
}

class _StudentNotificationSettingsSheetState 
    extends State<StudentNotificationSettingsSheet> {
  bool _pushNotifications = true;
  bool _emailNotifications = true;
  bool _gradeNotifications = true;
  bool _assignmentNotifications = true;
  bool _announcementNotifications = true;
  bool _messageNotifications = true;
  bool _discussionNotifications = true;
  String _assignmentReminder = '24 hours';

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);

    return Container(
      height: MediaQuery.of(context).size.height * 0.85,
      decoration: BoxDecoration(
        color: theme.colorScheme.surface,
        borderRadius: const BorderRadius.vertical(top: Radius.circular(20)),
      ),
      child: Column(
        children: [
          // Handle Bar
          Center(
            child: Container(
              margin: const EdgeInsets.only(top: 12, bottom: 8),
              width: 40,
              height: 4,
              decoration: BoxDecoration(
                color: theme.colorScheme.onSurfaceVariant.withValues(alpha: 0.3),
                borderRadius: BorderRadius.circular(2),
              ),
            ),
          ),
          // Header
          Padding(
            padding: const EdgeInsets.symmetric(horizontal: 24, vertical: 16),
            child: Row(
              mainAxisAlignment: MainAxisAlignment.spaceBetween,
              children: [
                Text(
                  'Notification Settings',
                  style: theme.textTheme.headlineSmall?.copyWith(
                    fontWeight: FontWeight.bold,
                  ),
                ),
                IconButton(
                  onPressed: () => Navigator.pop(context),
                  icon: const Icon(Icons.close),
                ),
              ],
            ),
          ),
          // Settings Content
          Expanded(
            child: SingleChildScrollView(
              padding: const EdgeInsets.symmetric(horizontal: 24),
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  // General Settings
                  Text(
                    'General',
                    style: theme.textTheme.titleMedium?.copyWith(
                      fontWeight: FontWeight.bold,
                    ),
                  ),
                  const SizedBox(height: 12),
                  SwitchListTile(
                    title: const Text('Push Notifications'),
                    subtitle: const Text('Get instant updates on your device'),
                    value: _pushNotifications,
                    onChanged: (value) {
                      setState(() {
                        _pushNotifications = value;
                      });
                    },
                  ),
                  SwitchListTile(
                    title: const Text('Email Notifications'),
                    subtitle: const Text('Receive important updates via email'),
                    value: _emailNotifications,
                    onChanged: (value) {
                      setState(() {
                        _emailNotifications = value;
                      });
                    },
                  ),
                  
                  const SizedBox(height: 24),
                  
                  // Academic Notifications
                  Text(
                    'Academic Updates',
                    style: theme.textTheme.titleMedium?.copyWith(
                      fontWeight: FontWeight.bold,
                    ),
                  ),
                  const SizedBox(height: 12),
                  SwitchListTile(
                    title: const Text('New Grades'),
                    subtitle: const Text('When teachers post new grades'),
                    value: _gradeNotifications,
                    onChanged: (value) {
                      setState(() {
                        _gradeNotifications = value;
                      });
                    },
                  ),
                  SwitchListTile(
                    title: const Text('Assignment Updates'),
                    subtitle: const Text('New assignments and due date reminders'),
                    value: _assignmentNotifications,
                    onChanged: (value) {
                      setState(() {
                        _assignmentNotifications = value;
                      });
                    },
                  ),
                  
                  // Assignment Reminder Timing
                  ListTile(
                    title: const Text('Assignment Reminders'),
                    subtitle: Text('Remind me $_assignmentReminder before due'),
                    trailing: const Icon(Icons.arrow_forward_ios, size: 16),
                    onTap: () => _showReminderOptions(),
                  ),
                  
                  const SizedBox(height: 24),
                  
                  // Communication Notifications
                  Text(
                    'Communications',
                    style: theme.textTheme.titleMedium?.copyWith(
                      fontWeight: FontWeight.bold,
                    ),
                  ),
                  const SizedBox(height: 12),
                  SwitchListTile(
                    title: const Text('Class Announcements'),
                    subtitle: const Text('Important updates from teachers'),
                    value: _announcementNotifications,
                    onChanged: (value) {
                      setState(() {
                        _announcementNotifications = value;
                      });
                    },
                  ),
                  SwitchListTile(
                    title: const Text('Direct Messages'),
                    subtitle: const Text('Messages from teachers'),
                    value: _messageNotifications,
                    onChanged: (value) {
                      setState(() {
                        _messageNotifications = value;
                      });
                    },
                  ),
                  SwitchListTile(
                    title: const Text('Discussion Updates'),
                    subtitle: const Text('New posts in class discussions'),
                    value: _discussionNotifications,
                    onChanged: (value) {
                      setState(() {
                        _discussionNotifications = value;
                      });
                    },
                  ),
                  
                  const SizedBox(height: 32),
                ],
              ),
            ),
          ),
          // Save Button
          Container(
            padding: const EdgeInsets.all(24),
            decoration: BoxDecoration(
              color: theme.colorScheme.surface,
              boxShadow: [
                BoxShadow(
                  color: Colors.black.withValues(alpha: 0.1),
                  blurRadius: 10,
                  offset: const Offset(0, -5),
                ),
              ],
            ),
            child: SizedBox(
              width: double.infinity,
              child: FilledButton(
                onPressed: () {
                  Navigator.pop(context);
                  ScaffoldMessenger.of(context).showSnackBar(
                    const SnackBar(
                      content: Text('Notification settings saved'),
                    ),
                  );
                },
                style: FilledButton.styleFrom(
                  padding: const EdgeInsets.symmetric(vertical: 16),
                ),
                child: const Text('Save Settings'),
              ),
            ),
          ),
        ],
      ),
    );
  }

  void _showReminderOptions() {
    showModalBottomSheet(
      context: context,
      builder: (context) => Container(
        padding: const EdgeInsets.symmetric(vertical: 16),
        child: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            ListTile(
              title: const Text('1 hour before'),
              onTap: () {
                setState(() {
                  _assignmentReminder = '1 hour';
                });
                Navigator.pop(context);
              },
              trailing: _assignmentReminder == '1 hour' 
                  ? const Icon(Icons.check, color: Colors.green)
                  : null,
            ),
            ListTile(
              title: const Text('6 hours before'),
              onTap: () {
                setState(() {
                  _assignmentReminder = '6 hours';
                });
                Navigator.pop(context);
              },
              trailing: _assignmentReminder == '6 hours' 
                  ? const Icon(Icons.check, color: Colors.green)
                  : null,
            ),
            ListTile(
              title: const Text('24 hours before'),
              onTap: () {
                setState(() {
                  _assignmentReminder = '24 hours';
                });
                Navigator.pop(context);
              },
              trailing: _assignmentReminder == '24 hours' 
                  ? const Icon(Icons.check, color: Colors.green)
                  : null,
            ),
            ListTile(
              title: const Text('2 days before'),
              onTap: () {
                setState(() {
                  _assignmentReminder = '2 days';
                });
                Navigator.pop(context);
              },
              trailing: _assignmentReminder == '2 days' 
                  ? const Icon(Icons.check, color: Colors.green)
                  : null,
            ),
            ListTile(
              title: const Text('1 week before'),
              onTap: () {
                setState(() {
                  _assignmentReminder = '1 week';
                });
                Navigator.pop(context);
              },
              trailing: _assignmentReminder == '1 week' 
                  ? const Icon(Icons.check, color: Colors.green)
                  : null,
            ),
          ],
        ),
      ),
    );
  }
}
````

## File: lib/features/student/presentation/screens/student_dashboard_screen.dart
````dart
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'package:go_router/go_router.dart';
import '../../../auth/presentation/providers/auth_provider.dart';
import '../../../classes/presentation/providers/class_provider.dart';
import '../../../chat/presentation/providers/call_provider.dart';
import '../../../../shared/models/user_model.dart';
import '../../../classes/domain/models/class_model.dart';
import '../../../../shared/widgets/common/adaptive_layout.dart';
import '../../../../shared/widgets/common/responsive_layout.dart';
import '../../../../shared/widgets/common/common_widgets.dart';
import '../../../../shared/theme/app_spacing.dart';
import '../../../../shared/theme/app_theme.dart';

class StudentDashboardScreen extends StatefulWidget {
  const StudentDashboardScreen({super.key});

  @override
  State<StudentDashboardScreen> createState() => _StudentDashboardScreenState();
}

class _StudentDashboardScreenState extends State<StudentDashboardScreen> {
  @override
  void initState() {
    super.initState();
    WidgetsBinding.instance.addPostFrameCallback((_) {
      _loadStudentClasses();
    });
  }

  void _loadStudentClasses() {
    final authProvider = context.read<AuthProvider>();
    final classProvider = context.read<ClassProvider>();
    final studentId = authProvider.userModel?.uid;
    
    if (studentId != null) {
      classProvider.loadStudentClasses(studentId);
    }
  }

  @override
  Widget build(BuildContext context) {
    final authProvider = context.watch<AuthProvider>();
    final callProvider = context.watch<CallProvider>();
    final user = authProvider.userModel;
    final theme = Theme.of(context);

    // Handle incoming calls
    if (callProvider.hasIncomingCall && 
        callProvider.incomingCall != null &&
        !callProvider.isNavigationInProgress) {
      WidgetsBinding.instance.addPostFrameCallback((_) {
        callProvider.setNavigationInProgress(true);
        context.push('/incoming-call', extra: callProvider.incomingCall).then((_) {
          // Reset navigation state after call screen is popped
          callProvider.setNavigationInProgress(false);
          // Optional: Add any post-call logic here
        });
      });
    }

    return AdaptiveLayout(
      title: 'Student Dashboard',
      actions: [
        IconButton(
          icon: const Icon(Icons.notifications_outlined),
          onPressed: () {
            context.go('/student/notifications');
          },
        ),
        IconButton(
          icon: const Icon(Icons.settings_outlined),
          onPressed: () {
            context.go('/settings');
          },
        ),
      ],
      body: ResponsiveContainer(
        child: SingleChildScrollView(
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              // Welcome Header
              Card(
                child: Padding(
                    padding: const EdgeInsets.all(24),
                    child: Row(
                      children: [
                        CircleAvatar(
                          radius: 32,
                          backgroundColor: theme.colorScheme.primary,
                          child: Text(
                            user?.displayName.isNotEmpty == true
                                ? user!.displayName[0].toUpperCase()
                                : 'S',
                            style: theme.textTheme.headlineMedium?.copyWith(
                              color: theme.colorScheme.onPrimary,
                              fontWeight: FontWeight.bold,
                            ),
                          ),
                        ),
                        const SizedBox(width: 16),
                        Expanded(
                          child: Column(
                            crossAxisAlignment: CrossAxisAlignment.start,
                            children: [
                              Text(
                                'Welcome Back',
                                style: theme.textTheme.headlineSmall?.copyWith(
                                  fontWeight: FontWeight.bold,
                                ),
                              ),
                              Text(
                                _getUserFirstName(user, authProvider),
                                style: theme.textTheme.headlineSmall?.copyWith(
                                  fontWeight: FontWeight.bold,
                                ),
                              ),
                            ],
                          ),
                        ),
                      ],
                    ),
                  ),
                ),
              const SizedBox(height: 16),

              // Quick Stats - Smaller section
              _buildQuickStats(context),
              const SizedBox(height: 24),

              // My Classes
              Text(
                  'My Classes',
                  style: theme.textTheme.titleLarge?.copyWith(
                    fontWeight: FontWeight.bold,
                  ),
                ),
              const SizedBox(height: AppSpacing.md),
              _buildClassesSection(context),
              const SizedBox(height: AppSpacing.lg),

              // Upcoming Assignments
              Text(
                  'Upcoming Assignments',
                  style: theme.textTheme.titleLarge?.copyWith(
                    fontWeight: FontWeight.bold,
                  ),
                ),
              const SizedBox(height: AppSpacing.md),
              _buildUpcomingAssignmentsCard(context),
              const SizedBox(height: AppSpacing.lg),

              // Recent Grades
              Text(
                  'Recent Grades',
                  style: theme.textTheme.titleLarge?.copyWith(
                    fontWeight: FontWeight.bold,
                  ),
                ),
              const SizedBox(height: AppSpacing.md),
              _buildRecentGradesCard(context),
            ],
          ),
        ),
      ),
    );
  }

  Widget _buildQuickStats(BuildContext context) {
    final classProvider = context.watch<ClassProvider>();
    final enrolledClasses = classProvider.studentClasses;
    
    return SizedBox(
      height: 80,
      child: ListView(
        scrollDirection: Axis.horizontal,
        children: [
          _buildCompactStatCard(
            context,
            icon: Icons.book,
            title: 'Courses',
            value: '${enrolledClasses.length}',
            color: Colors.blue,
            onTap: () => context.go('/student/courses'),
          ),
          const SizedBox(width: 12),
          _buildCompactStatCard(
            context,
            icon: Icons.assignment,
            title: 'Assignments',
            value: '12',
            color: Colors.orange,
            onTap: () => context.go('/student/assignments'),
          ),
          const SizedBox(width: 12),
          _buildCompactStatCard(
            context,
            icon: Icons.schedule,
            title: 'Due Soon',
            value: '3',
            color: Colors.red,
          ),
          const SizedBox(width: 12),
          _buildCompactStatCard(
            context,
            icon: Icons.trending_up,
            title: 'GPA',
            value: '3.8',
            color: Colors.green,
            onTap: () => context.go('/student/grades'),
          ),
        ],
      ),
    );
  }

  Widget _buildClassesSection(BuildContext context) {
    final classProvider = context.watch<ClassProvider>();
    
    if (classProvider.isLoading) {
      return const Center(
        child: CircularProgressIndicator(),
      );
    }
    
    final enrolledClasses = classProvider.studentClasses;
    
    if (enrolledClasses.isEmpty) {
      return Card(
        child: Padding(
          padding: const EdgeInsets.all(32),
          child: Center(
            child: Column(
              children: [
                Icon(
                  Icons.school_outlined,
                  size: 48,
                  color: Theme.of(context).colorScheme.onSurfaceVariant,
                ),
                const SizedBox(height: 16),
                Text(
                  'No Classes Yet',
                  style: Theme.of(context).textTheme.titleLarge,
                ),
                const SizedBox(height: 8),
                Text(
                  'Join a class to get started',
                  style: Theme.of(context).textTheme.bodyMedium?.copyWith(
                    color: Theme.of(context).colorScheme.onSurfaceVariant,
                  ),
                ),
                const SizedBox(height: 16),
                FilledButton(
                  onPressed: () => context.go('/student/enroll'),
                  child: const Text('Join a Class'),
                ),
              ],
            ),
          ),
        ),
      );
    }
    
    // Show max 4 classes on dashboard
    final displayClasses = enrolledClasses.take(4).toList();
    
    return Column(
      children: [
        ...displayClasses.map((course) => Padding(
          padding: const EdgeInsets.only(bottom: 12),
          child: _buildClassCard(context, course),
        )),
        if (enrolledClasses.length > 4) ...[
          const SizedBox(height: 4),
          SizedBox(
            width: double.infinity,
            child: OutlinedButton(
              onPressed: () => context.go('/student/courses'),
              child: Text('View All ${enrolledClasses.length} Classes'),
            ),
          ),
        ],
      ],
    );
  }

  Widget _buildClassCard(BuildContext context, ClassModel course) {
    final theme = Theme.of(context);
    final colorIndex = course.subject.hashCode % AppTheme.subjectColors.length;
    final color = AppTheme.subjectColors[colorIndex];
    
    return AppCard(
      onTap: () => _navigateToClass(context, course),
      child: Row(
        children: [
          // Color indicator
          Container(
            width: 4,
            height: 60,
            decoration: BoxDecoration(
              color: color,
              borderRadius: BorderRadius.circular(2),
            ),
          ),
          const SizedBox(width: 12),
          
          // Class info
          Expanded(
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Text(
                  course.name,
                  style: theme.textTheme.titleMedium?.copyWith(
                    fontWeight: FontWeight.bold,
                  ),
                  maxLines: 1,
                  overflow: TextOverflow.ellipsis,
                ),
                const SizedBox(height: 4),
                Text(
                  course.subject,
                  style: theme.textTheme.bodyMedium?.copyWith(
                    color: theme.colorScheme.onSurfaceVariant,
                  ),
                ),
                const SizedBox(height: 8),
                Wrap(
                  spacing: 8.0,
                  children: [
                    if (course.room != null)
                      _buildInfoChip(Icons.room, course.room!),
                    if (course.schedule != null)
                      _buildInfoChip(Icons.schedule, course.schedule!),
                    _buildInfoChip(Icons.school, course.gradeLevel),
                  ],
                ),
              ],
            ),
          ),
          
          // Arrow icon
          Icon(
            Icons.arrow_forward_ios,
            size: 16,
            color: theme.colorScheme.onSurfaceVariant,
          ),
        ],
      ),
    );
  }

  void _navigateToClass(BuildContext context, ClassModel course) {
    // Set the selected class in the provider
    context.read<ClassProvider>().setSelectedClass(course);
    // Navigate to class detail or assignments
    context.go('/student/courses'); // You can change this to a specific class detail route
  }

  Widget _buildCompactStatCard(
    BuildContext context, {
    required IconData icon,
    required String title,
    required String value,
    required Color color,
    VoidCallback? onTap,
  }) {
    final theme = Theme.of(context);
    
    return SizedBox(
      width: 120,
      child: Card(
        child: InkWell(
          onTap: onTap,
          borderRadius: BorderRadius.circular(12),
          child: Padding(
            padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 8),
            child: Column(
              mainAxisAlignment: MainAxisAlignment.center,
              children: [
                Row(
                  mainAxisAlignment: MainAxisAlignment.center,
                  children: [
                    Icon(
                      icon,
                      size: 20,
                      color: color,
                    ),
                    const SizedBox(width: 8),
                    Text(
                      value,
                      style: theme.textTheme.titleMedium?.copyWith(
                        fontWeight: FontWeight.bold,
                        color: color,
                      ),
                    ),
                  ],
                ),
                const SizedBox(height: 4),
                Text(
                  title,
                  style: theme.textTheme.bodySmall?.copyWith(
                    color: theme.colorScheme.onSurfaceVariant,
                  ),
                  maxLines: 1,
                  overflow: TextOverflow.ellipsis,
                ),
              ],
            ),
          ),
        ),
      ),
    );
  }

  Widget _buildInfoChip(IconData icon, String text) {
    final theme = Theme.of(context);
    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
      decoration: BoxDecoration(
        color: theme.colorScheme.surfaceContainerHighest,
        borderRadius: BorderRadius.circular(12),
      ),
      child: Row(
        mainAxisSize: MainAxisSize.min,
        children: [
          Icon(
            icon,
            size: 14,
            color: theme.colorScheme.onSurfaceVariant,
          ),
          const SizedBox(width: 4),
          Text(
            text,
            style: theme.textTheme.bodySmall?.copyWith(
              color: theme.colorScheme.onSurfaceVariant,
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildUpcomingAssignmentsCard(BuildContext context) {
    return Card(
      child: Padding(
        padding: const EdgeInsets.all(16),
        child: Column(
          children: [
            _buildAssignmentItem(
              context,
              subject: 'Mathematics',
              title: 'Algebra Problem Set 5',
              dueDate: 'Due Tomorrow',
              priority: 'High',
              color: Colors.red,
            ),
            const Divider(),
            _buildAssignmentItem(
              context,
              subject: 'Science',
              title: 'Lab Report: Chemical Reactions',
              dueDate: 'Due in 3 days',
              priority: 'Medium',
              color: Colors.orange,
            ),
            const Divider(),
            _buildAssignmentItem(
              context,
              subject: 'English',
              title: 'Book Report: To Kill a Mockingbird',
              dueDate: 'Due in 1 week',
              priority: 'Low',
              color: Colors.green,
            ),
            const SizedBox(height: 16),
            SizedBox(
              width: double.infinity,
              child: OutlinedButton(
                onPressed: () => context.go('/student/assignments'),
                child: const Text('View All Assignments'),
              ),
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildAssignmentItem(
    BuildContext context, {
    required String subject,
    required String title,
    required String dueDate,
    required String priority,
    required Color color,
  }) {
    final theme = Theme.of(context);
    
    return ListTile(
      leading: CircleAvatar(
        backgroundColor: color.withValues(alpha: 0.1),
        child: Icon(
          Icons.assignment,
          color: color,
          size: 20,
        ),
      ),
      title: Text(
        title,
        style: theme.textTheme.titleMedium?.copyWith(
          fontWeight: FontWeight.w600,
        ),
      ),
      subtitle: Text('$subject • $dueDate'),
      trailing: Container(
        padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
        decoration: BoxDecoration(
          color: color.withValues(alpha: 0.1),
          borderRadius: BorderRadius.circular(12),
        ),
        child: Text(
          priority,
          style: TextStyle(
            color: color,
            fontWeight: FontWeight.w600,
            fontSize: 12,
          ),
        ),
      ),
      contentPadding: EdgeInsets.zero,
    );
  }

  Widget _buildRecentGradesCard(BuildContext context) {
    return Card(
      child: Padding(
        padding: const EdgeInsets.all(16),
        child: Column(
          children: [
            _buildGradeItem(
              context,
              subject: 'Mathematics',
              assignment: 'Quiz 4: Quadratic Equations',
              grade: 'A-',
              points: '87/100',
              color: Colors.green,
            ),
            const Divider(),
            _buildGradeItem(
              context,
              subject: 'Science',
              assignment: 'Midterm Exam',
              grade: 'B+',
              points: '92/100',
              color: Colors.blue,
            ),
            const Divider(),
            _buildGradeItem(
              context,
              subject: 'English',
              assignment: 'Essay: Character Analysis',
              grade: 'A',
              points: '95/100',
              color: Colors.green,
            ),
            const SizedBox(height: 16),
            SizedBox(
              width: double.infinity,
              child: OutlinedButton(
                onPressed: () => context.go('/student/grades'),
                child: const Text('View All Grades'),
              ),
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildGradeItem(
    BuildContext context, {
    required String subject,
    required String assignment,
    required String grade,
    required String points,
    required Color color,
  }) {
    final theme = Theme.of(context);
    
    return ListTile(
      leading: CircleAvatar(
        backgroundColor: color.withValues(alpha: 0.1),
        child: Text(
          grade,
          style: TextStyle(
            color: color,
            fontWeight: FontWeight.bold,
            fontSize: 16,
          ),
        ),
      ),
      title: Text(
        assignment,
        style: theme.textTheme.titleMedium?.copyWith(
          fontWeight: FontWeight.w600,
        ),
      ),
      subtitle: Text('$subject • $points'),
      contentPadding: EdgeInsets.zero,
    );
  }
  
  String _getUserFirstName(UserModel? user, AuthProvider authProvider) {
    // Try firstName field first
    if (user?.firstName.isNotEmpty == true) {
      return '${user!.firstName}!';
    }
    
    // Try displayName from user model
    if (user?.displayName.isNotEmpty == true) {
      final nameParts = user!.displayName.split(' ');
      if (nameParts.isNotEmpty) {
        return '${nameParts.first}!';
      }
    }
    
    // Try Firebase Auth displayName
    final firebaseUser = authProvider.firebaseUser;
    if (firebaseUser?.displayName?.isNotEmpty == true) {
      final nameParts = firebaseUser!.displayName!.split(' ');
      if (nameParts.isNotEmpty) {
        return '${nameParts.first}!';
      }
    }
    
    // Default fallback
    return 'Student!';
  }
}
````

## File: lib/features/teacher/presentation/screens/teacher_dashboard_screen.dart
````dart
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'package:go_router/go_router.dart';
import '../../../auth/presentation/providers/auth_provider.dart';
import '../../../classes/presentation/providers/class_provider.dart';
import '../../../chat/presentation/providers/call_provider.dart';
import '../../../../shared/models/user_model.dart';
import '../../../classes/domain/models/class_model.dart';
import '../../../../shared/widgets/common/adaptive_layout.dart';
import '../../../../shared/widgets/common/responsive_layout.dart';
import '../../../../shared/widgets/common/common_widgets.dart';
import '../../../student/presentation/widgets/online_users_card.dart';
import '../../../../shared/theme/app_spacing.dart';
import '../../../../shared/theme/app_theme.dart';

class TeacherDashboardScreen extends StatefulWidget {
  const TeacherDashboardScreen({super.key});

  @override
  State<TeacherDashboardScreen> createState() => _TeacherDashboardScreenState();
}

class _TeacherDashboardScreenState extends State<TeacherDashboardScreen> {
  @override
  void initState() {
    super.initState();
    WidgetsBinding.instance.addPostFrameCallback((_) {
      _loadTeacherClasses();
    });
  }

  void _loadTeacherClasses() {
    final authProvider = context.read<AuthProvider>();
    final classProvider = context.read<ClassProvider>();
    final teacherId = authProvider.userModel?.uid;
    
    if (teacherId != null) {
      classProvider.loadTeacherClasses(teacherId);
    }
  }

  @override
  Widget build(BuildContext context) {
    final authProvider = context.watch<AuthProvider>();
    final callProvider = context.watch<CallProvider>();
    final user = authProvider.userModel;
    final theme = Theme.of(context);

    // Handle incoming calls
    if (callProvider.hasIncomingCall && 
        callProvider.incomingCall != null &&
        !callProvider.isNavigationInProgress) {
      WidgetsBinding.instance.addPostFrameCallback((_) {
        callProvider.setNavigationInProgress(true);
        context.push('/incoming-call', extra: callProvider.incomingCall).then((_) {
          // Reset navigation state after call screen is popped
          callProvider.setNavigationInProgress(false);
          // Optional: Add any post-call logic here
        });
      });
    }

    return AdaptiveLayout(
      title: 'Teacher Dashboard',
      actions: [
        IconButton(
          icon: const Icon(Icons.notifications_outlined),
          onPressed: () {
            context.go('/notifications');
          },
        ),
        IconButton(
          icon: const Icon(Icons.settings_outlined),
          onPressed: () {
            context.go('/settings');
          },
        ),
      ],
      body: ResponsiveContainer(
        child: SingleChildScrollView(
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              // Welcome Header
              Card(
                child: Padding(
                    padding: const EdgeInsets.all(24),
                    child: Row(
                      children: [
                        CircleAvatar(
                          radius: 32,
                          backgroundColor: theme.colorScheme.primary,
                          child: Text(
                            user?.displayName.isNotEmpty == true
                                ? user!.displayName[0].toUpperCase()
                                : 'T',
                            style: theme.textTheme.headlineMedium?.copyWith(
                              color: theme.colorScheme.onPrimary,
                              fontWeight: FontWeight.bold,
                            ),
                          ),
                        ),
                        const SizedBox(width: 16),
                        Expanded(
                          child: Column(
                            crossAxisAlignment: CrossAxisAlignment.start,
                            children: [
                              Text(
                                'Welcome Back',
                                style: theme.textTheme.headlineSmall?.copyWith(
                                  fontWeight: FontWeight.bold,
                                ),
                              ),
                              Text(
                                _getUserFirstName(user, authProvider),
                                style: theme.textTheme.headlineSmall?.copyWith(
                                  fontWeight: FontWeight.bold,
                                ),
                              ),
                            ],
                          ),
                        ),
                      ],
                    ),
                  ),
                ),
              const SizedBox(height: 16),

              // Quick Stats - Smaller section
              _buildQuickStats(context),
              const SizedBox(height: 24),

              // My Classes
              Text(
                  'My Classes',
                  style: theme.textTheme.titleLarge?.copyWith(
                    fontWeight: FontWeight.bold,
                  ),
                ),
              const SizedBox(height: AppSpacing.md),
              _buildClassesSection(context),
              const SizedBox(height: AppSpacing.lg),

              // Recent Activity
              Text(
                  'Recent Activity',
                  style: theme.textTheme.titleLarge?.copyWith(
                    fontWeight: FontWeight.bold,
                  ),
                ),
              const SizedBox(height: AppSpacing.md),
              _buildRecentActivityCard(context),
              const SizedBox(height: AppSpacing.lg),
              
              // Online Users
              Text(
                  'Online Users',
                  style: theme.textTheme.titleLarge?.copyWith(
                    fontWeight: FontWeight.bold,
                  ),
                ),
              const SizedBox(height: AppSpacing.md),
              SizedBox(
                height: 300,
                child: OnlineUsersCard(),
              ),
              const SizedBox(height: AppSpacing.lg),

              // Quick Actions
              Text(
                  'Quick Actions',
                  style: theme.textTheme.titleLarge?.copyWith(
                    fontWeight: FontWeight.bold,
                  ),
                ),
              const SizedBox(height: AppSpacing.md),
              _buildQuickActionsGrid(context),
            ],
          ),
        ),
      ),
    );
  }

  Widget _buildQuickStats(BuildContext context) {
    final classProvider = context.watch<ClassProvider>();
    final teacherClasses = classProvider.teacherClasses;
    final totalStudents = teacherClasses.fold<int>(0, (sum, classModel) => sum + classModel.studentCount);
    
    return SizedBox(
      height: 80,
      child: ListView(
        scrollDirection: Axis.horizontal,
        children: [
          _buildCompactStatCard(
            context,
            icon: Icons.class_,
            title: 'Classes',
            value: '${teacherClasses.length}',
            color: Colors.blue,
            onTap: () => context.go('/teacher/classes'),
          ),
          const SizedBox(width: 12),
          _buildCompactStatCard(
            context,
            icon: Icons.people,
            title: 'Students',
            value: '$totalStudents',
            color: Colors.green,
            onTap: () => context.go('/teacher/students'),
          ),
          const SizedBox(width: 12),
          _buildCompactStatCard(
            context,
            icon: Icons.assignment,
            title: 'Assignments',
            value: '23',
            color: Colors.orange,
            onTap: () => context.go('/teacher/assignments'),
          ),
          const SizedBox(width: 12),
          _buildCompactStatCard(
            context,
            icon: Icons.grade,
            title: 'To Grade',
            value: '8',
            color: Colors.red,
            onTap: () => context.go('/teacher/gradebook'),
          ),
        ],
      ),
    );
  }

  Widget _buildClassesSection(BuildContext context) {
    final classProvider = context.watch<ClassProvider>();
    
    if (classProvider.isLoading) {
      return const Center(
        child: CircularProgressIndicator(),
      );
    }
    
    final teacherClasses = classProvider.teacherClasses;
    
    if (teacherClasses.isEmpty) {
      return Card(
        child: Padding(
          padding: const EdgeInsets.all(32),
          child: Center(
            child: Column(
              children: [
                Icon(
                  Icons.class_outlined,
                  size: 48,
                  color: Theme.of(context).colorScheme.onSurfaceVariant,
                ),
                const SizedBox(height: 16),
                Text(
                  'No Classes Yet',
                  style: Theme.of(context).textTheme.titleLarge,
                ),
                const SizedBox(height: 8),
                Text(
                  'Create your first class to get started',
                  style: Theme.of(context).textTheme.bodyMedium?.copyWith(
                    color: Theme.of(context).colorScheme.onSurfaceVariant,
                  ),
                ),
                const SizedBox(height: 16),
                FilledButton(
                  onPressed: () => context.go('/teacher/classes'),
                  child: const Text('Create a Class'),
                ),
              ],
            ),
          ),
        ),
      );
    }
    
    // Show max 4 classes on dashboard
    final displayClasses = teacherClasses.take(4).toList();
    
    return Column(
      children: [
        ...displayClasses.map((course) => Padding(
          padding: const EdgeInsets.only(bottom: 12),
          child: _buildClassCard(context, course),
        )),
        if (teacherClasses.length > 4) ...[
          const SizedBox(height: 4),
          SizedBox(
            width: double.infinity,
            child: OutlinedButton(
              onPressed: () => context.go('/teacher/classes'),
              child: Text('View All ${teacherClasses.length} Classes'),
            ),
          ),
        ],
      ],
    );
  }

  Widget _buildClassCard(BuildContext context, ClassModel course) {
    final theme = Theme.of(context);
    final colorIndex = course.subject.hashCode % AppTheme.subjectColors.length;
    final color = AppTheme.subjectColors[colorIndex];
    
    return AppCard(
      onTap: () => _navigateToClass(context, course),
      child: Row(
        children: [
          // Color indicator
          Container(
            width: 4,
            height: 60,
            decoration: BoxDecoration(
              color: color,
              borderRadius: BorderRadius.circular(2),
            ),
          ),
          const SizedBox(width: 12),
          
          // Class info
          Expanded(
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Text(
                  course.name,
                  style: theme.textTheme.titleMedium?.copyWith(
                    fontWeight: FontWeight.bold,
                  ),
                  maxLines: 1,
                  overflow: TextOverflow.ellipsis,
                ),
                const SizedBox(height: 4),
                Text(
                  course.subject,
                  style: theme.textTheme.bodyMedium?.copyWith(
                    color: theme.colorScheme.onSurfaceVariant,
                  ),
                ),
                const SizedBox(height: 8),
                Wrap(
                  spacing: 8.0,
                  children: [
                    if (course.room != null)
                      _buildInfoChip(Icons.room, course.room!),
                    if (course.schedule != null)
                      _buildInfoChip(Icons.schedule, course.schedule!),
                    _buildInfoChip(Icons.people, '${course.studentCount} students'),
                  ],
                ),
              ],
            ),
          ),
          
          // Arrow icon
          Icon(
            Icons.arrow_forward_ios,
            size: 16,
            color: theme.colorScheme.onSurfaceVariant,
          ),
        ],
      ),
    );
  }

  void _navigateToClass(BuildContext context, ClassModel course) {
    // Set the selected class in the provider
    context.read<ClassProvider>().setSelectedClass(course);
    // Navigate to classes screen with selected class
    context.go('/teacher/classes');
  }

  Widget _buildCompactStatCard(
    BuildContext context, {
    required IconData icon,
    required String title,
    required String value,
    required Color color,
    VoidCallback? onTap,
  }) {
    final theme = Theme.of(context);
    
    return SizedBox(
      width: 120,
      child: Card(
        child: InkWell(
          onTap: onTap,
          borderRadius: BorderRadius.circular(12),
          child: Padding(
            padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 8),
            child: Column(
              mainAxisAlignment: MainAxisAlignment.center,
              children: [
                Row(
                  mainAxisAlignment: MainAxisAlignment.center,
                  children: [
                    Icon(
                      icon,
                      size: 20,
                      color: color,
                    ),
                    const SizedBox(width: 8),
                    Text(
                      value,
                      style: theme.textTheme.titleMedium?.copyWith(
                        fontWeight: FontWeight.bold,
                        color: color,
                      ),
                    ),
                  ],
                ),
                const SizedBox(height: 4),
                Text(
                  title,
                  style: theme.textTheme.bodySmall?.copyWith(
                    color: theme.colorScheme.onSurfaceVariant,
                  ),
                  maxLines: 1,
                  overflow: TextOverflow.ellipsis,
                ),
              ],
            ),
          ),
        ),
      ),
    );
  }

  Widget _buildInfoChip(IconData icon, String text) {
    final theme = Theme.of(context);
    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
      decoration: BoxDecoration(
        color: theme.colorScheme.surfaceContainerHighest,
        borderRadius: BorderRadius.circular(12),
      ),
      child: Row(
        mainAxisSize: MainAxisSize.min,
        children: [
          Icon(
            icon,
            size: 14,
            color: theme.colorScheme.onSurfaceVariant,
          ),
          const SizedBox(width: 4),
          Text(
            text,
            style: theme.textTheme.bodySmall?.copyWith(
              color: theme.colorScheme.onSurfaceVariant,
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildRecentActivityCard(BuildContext context) {
    return Card(
      child: Padding(
        padding: const EdgeInsets.all(16),
        child: Column(
          children: [
            _buildActivityItem(
              context,
              icon: Icons.assignment_turned_in,
              title: 'New assignment submitted',
              subtitle: 'John Doe submitted Math Homework #5',
              time: '2 hours ago',
              color: Colors.green,
            ),
            const Divider(),
            _buildActivityItem(
              context,
              icon: Icons.message,
              title: 'New message',
              subtitle: 'Parent inquiry about Sarah\'s progress',
              time: '4 hours ago',
              color: Colors.blue,
            ),
            const Divider(),
            _buildActivityItem(
              context,
              icon: Icons.schedule,
              title: 'Upcoming deadline',
              subtitle: 'Science Project due tomorrow',
              time: '1 day left',
              color: Colors.orange,
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildActivityItem(
    BuildContext context, {
    required IconData icon,
    required String title,
    required String subtitle,
    required String time,
    required Color color,
  }) {
    final theme = Theme.of(context);
    
    return ListTile(
      leading: CircleAvatar(
        backgroundColor: color.withValues(alpha: 0.1),
        child: Icon(icon, color: color),
      ),
      title: Text(
        title,
        style: theme.textTheme.titleMedium?.copyWith(
          fontWeight: FontWeight.w600,
        ),
      ),
      subtitle: Text(subtitle),
      trailing: Text(
        time,
        style: theme.textTheme.bodySmall?.copyWith(
          color: theme.colorScheme.onSurfaceVariant,
        ),
      ),
      contentPadding: EdgeInsets.zero,
    );
  }

  Widget _buildQuickActionsGrid(BuildContext context) {
    return ResponsiveGrid(
      shrinkWrap: true,
      physics: const NeverScrollableScrollPhysics(),
      mobileColumns: 2,
      tabletColumns: 3,
      desktopColumns: 3,
      spacing: AppSpacing.md,
      runSpacing: AppSpacing.md,
      childAspectRatio: 1.0, // Reduced to give more height for action cards
      children: [
        _buildActionCard(
          context,
          icon: Icons.add_circle_outline,
          title: 'Create Assignment',
          subtitle: 'Add new homework or project',
          onTap: () {
            context.go('/teacher/assignments/create');
          },
        ),
        _buildActionCard(
          context,
          icon: Icons.grade,
          title: 'Grade Work',
          subtitle: 'Review student submissions',
          onTap: () {
            context.go('/teacher/gradebook');
          },
        ),
        _buildActionCard(
          context,
          icon: Icons.chat,
          title: 'Message Parents',
          subtitle: 'Send updates and announcements',
          onTap: () {
            context.go('/messages');
          },
        ),
        _buildActionCard(
          context,
          icon: Icons.analytics,
          title: 'View Reports',
          subtitle: 'Class performance analytics',
          onTap: () {
            context.go('/teacher/analytics');
          },
        ),
        _buildActionCard(
          context,
          icon: Icons.schedule,
          title: 'Schedule Event',
          subtitle: 'Add to class calendar',
          onTap: () {
            context.go('/calendar');
          },
        ),
        _buildActionCard(
          context,
          icon: Icons.backup,
          title: 'Export Data',
          subtitle: 'Download gradebook backup',
          onTap: () {
            _showExportDialog(context);
          },
        ),
        _buildActionCard(
          context,
          icon: Icons.grid_view_rounded,
          title: 'Jeopardy Games',
          subtitle: 'Create and play quiz games',
          onTap: () {
            context.go('/teacher/games/jeopardy');
          },
        ),
      ],
    );
  }

  Widget _buildActionCard(
    BuildContext context, {
    required IconData icon,
    required String title,
    required String subtitle,
    required VoidCallback onTap,
  }) {
    final theme = Theme.of(context);
    
    return Card(
      child: InkWell(
        onTap: onTap,
        borderRadius: BorderRadius.circular(12),
        child: Padding(
          padding: const EdgeInsets.all(16),
          child: Column(
            mainAxisAlignment: MainAxisAlignment.center,
            children: [
              Icon(
                icon,
                size: 32,
                color: theme.colorScheme.primary,
              ),
              const SizedBox(height: 8),
              Text(
                title,
                style: theme.textTheme.titleMedium?.copyWith(
                  fontWeight: FontWeight.w600,
                ),
                textAlign: TextAlign.center,
              ),
              const SizedBox(height: 4),
              Text(
                subtitle,
                style: theme.textTheme.bodySmall?.copyWith(
                  color: theme.colorScheme.onSurfaceVariant,
                ),
                textAlign: TextAlign.center,
              ),
            ],
          ),
        ),
      ),
    );
  }
  
  String _getUserFirstName(UserModel? user, AuthProvider authProvider) {
    // Try firstName field first
    if (user?.firstName.isNotEmpty == true) {
      return '${user!.firstName}!';
    }
    
    // Try displayName from user model
    if (user?.displayName.isNotEmpty == true) {
      final nameParts = user!.displayName.split(' ');
      if (nameParts.isNotEmpty) {
        return '${nameParts.first}!';
      }
    }
    
    // Try Firebase Auth displayName
    final firebaseUser = authProvider.firebaseUser;
    if (firebaseUser?.displayName?.isNotEmpty == true) {
      final nameParts = firebaseUser!.displayName!.split(' ');
      if (nameParts.isNotEmpty) {
        return '${nameParts.first}!';
      }
    }
    
    // Default fallback
    return 'Teacher!';
  }

  void _showExportDialog(BuildContext context) {
    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        title: const Text('Export Data'),
        content: Column(
          mainAxisSize: MainAxisSize.min,
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            const Text('Select data to export:'),
            const SizedBox(height: 16),
            ListTile(
              leading: const Icon(Icons.grade),
              title: const Text('Gradebook Data'),
              subtitle: const Text('Export all grades as CSV'),
              onTap: () {
                Navigator.pop(context);
                ScaffoldMessenger.of(context).showSnackBar(
                  const SnackBar(
                    content: Text('Gradebook export will be available soon'),
                  ),
                );
              },
            ),
            ListTile(
              leading: const Icon(Icons.people),
              title: const Text('Student List'),
              subtitle: const Text('Export student roster as CSV'),
              onTap: () {
                Navigator.pop(context);
                ScaffoldMessenger.of(context).showSnackBar(
                  const SnackBar(
                    content: Text('Student list export will be available soon'),
                  ),
                );
              },
            ),
            ListTile(
              leading: const Icon(Icons.assignment),
              title: const Text('Assignments'),
              subtitle: const Text('Export assignment details as CSV'),
              onTap: () {
                Navigator.pop(context);
                ScaffoldMessenger.of(context).showSnackBar(
                  const SnackBar(
                    content: Text('Assignment export will be available soon'),
                  ),
                );
              },
            ),
          ],
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(context),
            child: const Text('Cancel'),
          ),
        ],
      ),
    );
  }
}
````

## File: lib/shared/screens/common/common/dashboard_screen.dart
````dart
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import '../../../../features/auth/presentation/providers/auth_provider.dart';

/// Temporary fallback dashboard screen for admin users or unspecified roles.
/// 
/// This screen is displayed when:
/// - User role is neither teacher nor student (e.g., admin users)
/// - User role cannot be determined
/// 
/// Features:
/// - Displays user welcome message with name
/// - Shows current user role
/// - Provides logout functionality
/// 
/// This is a temporary implementation that should be replaced with
/// proper admin dashboard functionality in future iterations.
class DashboardScreen extends StatelessWidget {
  const DashboardScreen({super.key});

  @override
  Widget build(BuildContext context) {
    final authProvider = context.watch<AuthProvider>();
    final user = authProvider.userModel;

    return Scaffold(
      appBar: AppBar(
        title: const Text('Dashboard'),
        actions: [
          IconButton(
            icon: const Icon(Icons.logout),
            onPressed: () => authProvider.signOut(),
          ),
        ],
      ),
      body: Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Icon(
              Icons.dashboard,
              size: 80,
              color: Theme.of(context).colorScheme.primary,
            ),
            const SizedBox(height: 24),
            Text(
              'Welcome, ${user?.displayName ?? 'User'}!',
              style: Theme.of(context).textTheme.headlineMedium,
            ),
            const SizedBox(height: 8),
            Text(
              'Role: ${user?.role.toString().split('.').last ?? 'Unknown'}',
              style: Theme.of(context).textTheme.titleLarge,
            ),
            const SizedBox(height: 8),
            Text(
              user?.email ?? '',
              style: Theme.of(context).textTheme.bodyLarge,
            ),
          ],
        ),
      ),
    );
  }
}
````

## File: lib/shared/screens/contact_support_screen.dart
````dart
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'package:cloud_firestore/cloud_firestore.dart';
import '../../features/auth/presentation/providers/auth_provider.dart';
import '../widgets/common/adaptive_layout.dart';
import '../theme/app_spacing.dart';

class ContactSupportScreen extends StatefulWidget {
  const ContactSupportScreen({super.key});

  @override
  State<ContactSupportScreen> createState() => _ContactSupportScreenState();
}

class _ContactSupportScreenState extends State<ContactSupportScreen> {
  final _formKey = GlobalKey<FormState>();
  final _subjectController = TextEditingController();
  final _descriptionController = TextEditingController();
  
  String _selectedCategory = 'bug_report';
  String _selectedPriority = 'medium';
  bool _isSubmitting = false;

  @override
  void dispose() {
    _subjectController.dispose();
    _descriptionController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    
    return AdaptiveLayout(
      title: 'Contact Support',
      showBackButton: true,
      body: Center(
        child: ConstrainedBox(
          constraints: const BoxConstraints(maxWidth: 600),
          child: SingleChildScrollView(
            padding: const EdgeInsets.all(AppSpacing.lg),
            child: Form(
              key: _formKey,
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  // Header
                  Text(
                    'Submit Support Request',
                    style: theme.textTheme.headlineSmall?.copyWith(
                      fontWeight: FontWeight.bold,
                    ),
                  ),
                  const SizedBox(height: AppSpacing.sm),
                  Text(
                    'Choose a category below to submit your request',
                    style: theme.textTheme.bodyMedium?.copyWith(
                      color: theme.colorScheme.onSurfaceVariant,
                    ),
                  ),
                  const SizedBox(height: AppSpacing.xl),
                  
                  // Category Selection
                  Text(
                    'Issue Type',
                    style: theme.textTheme.titleMedium?.copyWith(
                      fontWeight: FontWeight.w600,
                    ),
                  ),
                  const SizedBox(height: AppSpacing.sm),
                  DropdownButtonFormField<String>(
                    value: _selectedCategory,
                    decoration: const InputDecoration(
                      border: OutlineInputBorder(),
                      contentPadding: EdgeInsets.symmetric(
                        horizontal: AppSpacing.md,
                        vertical: AppSpacing.md,
                      ),
                    ),
                    items: const [
                      DropdownMenuItem(
                        value: 'bug_report',
                        child: Text('Bug Report'),
                      ),
                      DropdownMenuItem(
                        value: 'feature_request',
                        child: Text('Feature Request'),
                      ),
                      DropdownMenuItem(
                        value: 'performance_issue',
                        child: Text('Performance Issue'),
                      ),
                      DropdownMenuItem(
                        value: 'ui_ux',
                        child: Text('UI/UX Problem'),
                      ),
                      DropdownMenuItem(
                        value: 'other',
                        child: Text('Other'),
                      ),
                    ],
                    onChanged: (value) {
                      setState(() {
                        _selectedCategory = value!;
                      });
                    },
                  ),
                  const SizedBox(height: AppSpacing.lg),
                  
                  // Priority Selection
                  Text(
                    'Priority',
                    style: theme.textTheme.titleMedium?.copyWith(
                      fontWeight: FontWeight.w600,
                    ),
                  ),
                  const SizedBox(height: AppSpacing.sm),
                  DropdownButtonFormField<String>(
                    value: _selectedPriority,
                    decoration: const InputDecoration(
                      border: OutlineInputBorder(),
                      contentPadding: EdgeInsets.symmetric(
                        horizontal: AppSpacing.md,
                        vertical: AppSpacing.md,
                      ),
                    ),
                    items: const [
                      DropdownMenuItem(
                        value: 'critical',
                        child: Text('Critical - App is unusable'),
                      ),
                      DropdownMenuItem(
                        value: 'high',
                        child: Text('High - Major functionality broken'),
                      ),
                      DropdownMenuItem(
                        value: 'medium',
                        child: Text('Medium - Minor issue'),
                      ),
                      DropdownMenuItem(
                        value: 'low',
                        child: Text('Low - Cosmetic issue'),
                      ),
                    ],
                    onChanged: (value) {
                      setState(() {
                        _selectedPriority = value!;
                      });
                    },
                  ),
                  const SizedBox(height: AppSpacing.lg),
                  
                  // Subject Field
                  Text(
                    'Subject',
                    style: theme.textTheme.titleMedium?.copyWith(
                      fontWeight: FontWeight.w600,
                    ),
                  ),
                  const SizedBox(height: AppSpacing.sm),
                  TextFormField(
                    controller: _subjectController,
                    decoration: const InputDecoration(
                      hintText: 'Brief description of the issue',
                      border: OutlineInputBorder(),
                      contentPadding: EdgeInsets.symmetric(
                        horizontal: AppSpacing.md,
                        vertical: AppSpacing.md,
                      ),
                    ),
                    validator: (value) {
                      if (value == null || value.trim().isEmpty) {
                        return 'Please enter a subject';
                      }
                      if (value.trim().length < 5) {
                        return 'Subject must be at least 5 characters';
                      }
                      return null;
                    },
                  ),
                  const SizedBox(height: AppSpacing.lg),
                  
                  // Description Field
                  Text(
                    'Description',
                    style: theme.textTheme.titleMedium?.copyWith(
                      fontWeight: FontWeight.w600,
                    ),
                  ),
                  const SizedBox(height: AppSpacing.sm),
                  TextFormField(
                    controller: _descriptionController,
                    maxLines: 8,
                    decoration: const InputDecoration(
                      hintText: 'Please provide detailed information about the issue:\n'
                          '• What were you trying to do?\n'
                          '• What happened instead?\n'
                          '• Steps to reproduce the issue\n'
                          '• Error messages (if any)',
                      border: OutlineInputBorder(),
                      contentPadding: EdgeInsets.all(AppSpacing.md),
                      alignLabelWithHint: true,
                    ),
                    validator: (value) {
                      if (value == null || value.trim().isEmpty) {
                        return 'Please provide a description';
                      }
                      if (value.trim().length < 20) {
                        return 'Description must be at least 20 characters';
                      }
                      return null;
                    },
                  ),
                  const SizedBox(height: AppSpacing.sm),
                  Text(
                    'The more details you provide, the better we can help!',
                    style: theme.textTheme.bodySmall?.copyWith(
                      color: theme.colorScheme.onSurfaceVariant,
                    ),
                  ),
                  const SizedBox(height: AppSpacing.xl),
                  
                  // Device Info (automatically collected)
                  Container(
                    padding: const EdgeInsets.all(AppSpacing.md),
                    decoration: BoxDecoration(
                      color: theme.colorScheme.surfaceContainerHighest,
                      borderRadius: BorderRadius.circular(AppSpacing.sm),
                    ),
                    child: Column(
                      crossAxisAlignment: CrossAxisAlignment.start,
                      children: [
                        Row(
                          children: [
                            Icon(
                              Icons.info_outline,
                              size: 20,
                              color: theme.colorScheme.primary,
                            ),
                            const SizedBox(width: AppSpacing.sm),
                            Text(
                              'System Information',
                              style: theme.textTheme.titleSmall?.copyWith(
                                fontWeight: FontWeight.w600,
                              ),
                            ),
                          ],
                        ),
                        const SizedBox(height: AppSpacing.sm),
                        Text(
                          'We automatically collect device information to help diagnose issues:',
                          style: theme.textTheme.bodySmall,
                        ),
                        const SizedBox(height: AppSpacing.xs),
                        Text(
                          '• App version and platform\n'
                          '• Device type and OS version\n'
                          '• Screen size and orientation',
                          style: theme.textTheme.bodySmall?.copyWith(
                            color: theme.colorScheme.onSurfaceVariant,
                          ),
                        ),
                      ],
                    ),
                  ),
                  const SizedBox(height: AppSpacing.xl),
                  
                  // Submit Button
                  SizedBox(
                    width: double.infinity,
                    child: FilledButton(
                      onPressed: _isSubmitting ? null : _submitReport,
                      child: _isSubmitting
                          ? const SizedBox(
                              height: 20,
                              width: 20,
                              child: CircularProgressIndicator(
                                strokeWidth: 2,
                                color: Colors.white,
                              ),
                            )
                          : const Text('Submit Bug Report'),
                    ),
                  ),
                ],
              ),
            ),
          ),
        ),
      ),
    );
  }
  
  Future<void> _submitReport() async {
    if (!_formKey.currentState!.validate()) {
      return;
    }
    
    setState(() {
      _isSubmitting = true;
    });
    
    try {
      final authProvider = context.read<AuthProvider>();
      final user = authProvider.userModel;
      
      // Prepare bug report data
      final reportData = {
        'category': _selectedCategory,
        'priority': _selectedPriority,
        'subject': _subjectController.text.trim(),
        'description': _descriptionController.text.trim(),
        'userId': user?.uid ?? 'anonymous',
        'userEmail': user?.email ?? 'unknown',
        'userName': user?.displayName ?? 'Unknown User',
        'userRole': user?.role.toString().split('.').last ?? 'unknown',
        'createdAt': FieldValue.serverTimestamp(),
        'status': 'new',
        'platform': Theme.of(context).platform.name,
        'appVersion': '1.0.0', // You might want to get this from package_info_plus
        'deviceInfo': {
          'platform': Theme.of(context).platform.name,
          'screenSize': '${MediaQuery.of(context).size.width}x${MediaQuery.of(context).size.height}',
          'pixelRatio': MediaQuery.of(context).devicePixelRatio,
        },
      };
      
      // Submit to Firestore
      await FirebaseFirestore.instance
          .collection('bug_reports')
          .add(reportData);
      
      if (!mounted) return;
      
      // Show success message
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(
          content: Text('Bug report submitted successfully! Thank you for your feedback.'),
          backgroundColor: Colors.green,
        ),
      );
      
      // Clear form
      _subjectController.clear();
      _descriptionController.clear();
      setState(() {
        _selectedCategory = 'bug_report';
        _selectedPriority = 'medium';
      });
      
      // Navigate back after a short delay
      Future.delayed(const Duration(seconds: 2), () {
        if (mounted) {
          Navigator.of(context).pop();
        }
      });
      
    } catch (e) {
      if (!mounted) return;
      
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(
          content: Text('Failed to submit report: $e'),
          backgroundColor: Theme.of(context).colorScheme.error,
        ),
      );
    } finally {
      if (mounted) {
        setState(() {
          _isSubmitting = false;
        });
      }
    }
  }
}
````

## File: lib/shared/screens/debug/debug/update_display_name_screen.dart
````dart
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import '../../../../features/auth/presentation/providers/auth_provider.dart';

/// Debug screen to update user display name
class UpdateDisplayNameScreen extends StatefulWidget {
  const UpdateDisplayNameScreen({super.key});

  @override
  State<UpdateDisplayNameScreen> createState() => _UpdateDisplayNameScreenState();
}

class _UpdateDisplayNameScreenState extends State<UpdateDisplayNameScreen> {
  final _formKey = GlobalKey<FormState>();
  final _displayNameController = TextEditingController();
  final _firstNameController = TextEditingController();
  final _lastNameController = TextEditingController();
  bool _isLoading = false;

  @override
  void initState() {
    super.initState();
    // Pre-fill with current values
    final authProvider = context.read<AuthProvider>();
    final user = authProvider.userModel;
    if (user != null) {
      _displayNameController.text = user.displayName;
      _firstNameController.text = user.firstName;
      _lastNameController.text = user.lastName;
    }
  }

  @override
  void dispose() {
    _displayNameController.dispose();
    _firstNameController.dispose();
    _lastNameController.dispose();
    super.dispose();
  }

  Future<void> _updateProfile() async {
    if (!_formKey.currentState!.validate()) return;

    setState(() => _isLoading = true);

    try {
      final authProvider = context.read<AuthProvider>();
      final success = await authProvider.updateProfile(
        displayName: _displayNameController.text.trim(),
        firstName: _firstNameController.text.trim(),
        lastName: _lastNameController.text.trim(),
      );

      if (mounted) {
        if (success) {
          ScaffoldMessenger.of(context).showSnackBar(
            const SnackBar(
              content: Text('Profile updated successfully!'),
              backgroundColor: Colors.green,
            ),
          );
          Navigator.of(context).pop();
        } else {
          ScaffoldMessenger.of(context).showSnackBar(
            const SnackBar(
              content: Text('Failed to update profile'),
              backgroundColor: Colors.red,
            ),
          );
        }
      }
    } catch (e) {
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('Error: $e'),
            backgroundColor: Colors.red,
          ),
        );
      }
    } finally {
      if (mounted) {
        setState(() => _isLoading = false);
      }
    }
  }

  @override
  Widget build(BuildContext context) {
    final authProvider = context.watch<AuthProvider>();
    final user = authProvider.userModel;

    return Scaffold(
      appBar: AppBar(
        title: const Text('Update Display Name'),
      ),
      body: Padding(
        padding: const EdgeInsets.all(16.0),
        child: Form(
          key: _formKey,
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              // Current info card
              Card(
                child: Padding(
                  padding: const EdgeInsets.all(16.0),
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      Text(
                        'Current Information',
                        style: Theme.of(context).textTheme.titleMedium?.copyWith(
                          fontWeight: FontWeight.bold,
                        ),
                      ),
                      const SizedBox(height: 8),
                      Text('Email: ${user?.email ?? 'N/A'}'),
                      Text('Display Name: "${user?.displayName ?? ''}"'),
                      Text('First Name: "${user?.firstName ?? ''}"'),
                      Text('Last Name: "${user?.lastName ?? ''}"'),
                      Text('Role: ${user?.role?.toString().split('.').last ?? 'N/A'}'),
                    ],
                  ),
                ),
              ),
              const SizedBox(height: 24),
              
              // Update form
              TextFormField(
                controller: _displayNameController,
                decoration: const InputDecoration(
                  labelText: 'Display Name',
                  hintText: 'How you want to appear in the app',
                  helperText: 'This is what other users will see',
                  border: OutlineInputBorder(),
                ),
                validator: (value) {
                  if (value == null || value.trim().isEmpty) {
                    return 'Please enter a display name';
                  }
                  return null;
                },
              ),
              const SizedBox(height: 16),
              
              TextFormField(
                controller: _firstNameController,
                decoration: const InputDecoration(
                  labelText: 'First Name',
                  border: OutlineInputBorder(),
                ),
                validator: (value) {
                  if (value == null || value.trim().isEmpty) {
                    return 'Please enter your first name';
                  }
                  return null;
                },
              ),
              const SizedBox(height: 16),
              
              TextFormField(
                controller: _lastNameController,
                decoration: const InputDecoration(
                  labelText: 'Last Name',
                  border: OutlineInputBorder(),
                ),
              ),
              const SizedBox(height: 24),
              
              SizedBox(
                width: double.infinity,
                height: 48,
                child: ElevatedButton(
                  onPressed: _isLoading ? null : _updateProfile,
                  child: _isLoading
                      ? const CircularProgressIndicator()
                      : const Text('Update Profile'),
                ),
              ),
            ],
          ),
        ),
      ),
    );
  }
}
````

## File: lib/shared/screens/settings_screen.dart
````dart
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'package:image_picker/image_picker.dart';
import 'package:firebase_storage/firebase_storage.dart';
import 'package:cached_network_image/cached_network_image.dart';
import 'dart:io';
import '../../features/auth/presentation/providers/auth_provider.dart';
import '../providers/theme_provider.dart';
import '../widgets/common/adaptive_layout.dart';
import '../widgets/common/responsive_layout.dart';

class SettingsScreen extends StatefulWidget {
  const SettingsScreen({super.key});

  @override
  State<SettingsScreen> createState() => _SettingsScreenState();
}

class _SettingsScreenState extends State<SettingsScreen> {
  final ImagePicker _picker = ImagePicker();
  
  // User Preferences
  bool _darkMode = false;
  bool _pushNotifications = true;
  bool _emailNotifications = true;
  String _language = 'English';
  String _timeZone = 'America/New_York';
  String _dateFormat = 'MM/dd/yyyy';
  
  // Privacy Settings
  bool _crashReporting = true;
  
  // Academic Settings
  bool _gradeNotifications = true;
  bool _assignmentReminders = true;
  bool _attendanceAlerts = true;
  String _defaultView = 'Dashboard';
  
  // Security Settings
  bool _biometricAuth = false;
  bool _autoLock = true;
  String _autoLockTime = '5 minutes';

  @override
  void initState() {
    super.initState();
    // Initialize dark mode from theme provider
    WidgetsBinding.instance.addPostFrameCallback((_) {
      final themeProvider = context.read<ThemeProvider>();
      setState(() {
        _darkMode = themeProvider.isDarkMode;
      });
    });
  }

  @override
  Widget build(BuildContext context) {
    final themeProvider = context.watch<ThemeProvider>();

    return AdaptiveLayout(
      title: 'Settings',
      showBackButton: true,
      body: ResponsiveContainer(
        child: ListView(
          padding: const EdgeInsets.all(16),
          children: [
            // User Profile Section
            _buildProfileSection(),
            
            const SizedBox(height: 24),
            
            // Appearance Settings
            _buildSettingsSection(
              title: 'Appearance',
              icon: Icons.palette,
              children: [
                _buildSwitchTile(
                  title: 'Dark Mode',
                  subtitle: 'Use dark theme throughout the app',
                  value: _darkMode,
                  onChanged: (value) {
                    setState(() {
                      _darkMode = value;
                    });
                    themeProvider.toggleTheme();
                  },
                ),
                _buildDropdownTile(
                  title: 'Language',
                  subtitle: 'Choose your preferred language',
                  value: _language,
                  items: ['English', 'Spanish', 'French', 'German', 'Chinese'],
                  onChanged: (value) {
                    setState(() {
                      _language = value!;
                    });
                    _showFeatureComingSoon();
                  },
                ),
                _buildDropdownTile(
                  title: 'Date Format',
                  subtitle: 'How dates are displayed',
                  value: _dateFormat,
                  items: ['MM/dd/yyyy', 'dd/MM/yyyy', 'yyyy-MM-dd'],
                  onChanged: (value) {
                    setState(() {
                      _dateFormat = value!;
                    });
                  },
                ),
              ],
            ),
            
            const SizedBox(height: 24),
            
            // Notification Settings
            _buildSettingsSection(
              title: 'Notifications',
              icon: Icons.notifications,
              children: [
                _buildSwitchTile(
                  title: 'Push Notifications',
                  subtitle: 'Receive notifications on this device',
                  value: _pushNotifications,
                  onChanged: (value) {
                    setState(() {
                      _pushNotifications = value;
                    });
                  },
                ),
                _buildSwitchTile(
                  title: 'Email Notifications',
                  subtitle: 'Receive notifications via email',
                  value: _emailNotifications,
                  onChanged: (value) {
                    setState(() {
                      _emailNotifications = value;
                    });
                  },
                ),
                _buildSwitchTile(
                  title: 'Grade Notifications',
                  subtitle: 'Get notified when grades are posted',
                  value: _gradeNotifications,
                  onChanged: (value) {
                    setState(() {
                      _gradeNotifications = value;
                    });
                  },
                ),
                _buildSwitchTile(
                  title: 'Assignment Reminders',
                  subtitle: 'Reminders for upcoming assignments',
                  value: _assignmentReminders,
                  onChanged: (value) {
                    setState(() {
                      _assignmentReminders = value;
                    });
                  },
                ),
                _buildSwitchTile(
                  title: 'Attendance Alerts',
                  subtitle: 'Notifications about attendance',
                  value: _attendanceAlerts,
                  onChanged: (value) {
                    setState(() {
                      _attendanceAlerts = value;
                    });
                  },
                ),
                _buildActionTile(
                  title: 'Notification Settings',
                  subtitle: 'Advanced notification preferences',
                  icon: Icons.tune,
                  onTap: _showAdvancedNotificationSettings,
                ),
              ],
            ),
            
            const SizedBox(height: 24),
            
            // Academic Settings
            _buildSettingsSection(
              title: 'Academic',
              icon: Icons.school,
              children: [
                _buildDropdownTile(
                  title: 'Default View',
                  subtitle: 'Screen to show when app opens',
                  value: _defaultView,
                  items: ['Dashboard', 'Calendar', 'Grades', 'Assignments'],
                  onChanged: (value) {
                    setState(() {
                      _defaultView = value!;
                    });
                  },
                ),
                _buildDropdownTile(
                  title: 'Time Zone',
                  subtitle: 'Your local time zone',
                  value: _timeZone,
                  items: [
                    'America/New_York',
                    'America/Chicago',
                    'America/Denver',
                    'America/Los_Angeles',
                    'Europe/London',
                    'Europe/Paris',
                    'Asia/Tokyo',
                  ],
                  onChanged: (value) {
                    setState(() {
                      _timeZone = value!;
                    });
                  },
                ),
                _buildActionTile(
                  title: 'Academic Calendar',
                  subtitle: 'Configure semester and holiday dates',
                  icon: Icons.calendar_month,
                  onTap: () => _showFeatureComingSoon(),
                ),
              ],
            ),
            
            const SizedBox(height: 24),
            
            // Security & Privacy
            _buildSettingsSection(
              title: 'Security & Privacy',
              icon: Icons.security,
              children: [
                _buildSwitchTile(
                  title: 'Biometric Authentication',
                  subtitle: 'Use fingerprint or face ID to unlock',
                  value: _biometricAuth,
                  onChanged: (value) {
                    setState(() {
                      _biometricAuth = value;
                    });
                    _showFeatureComingSoon();
                  },
                ),
                _buildSwitchTile(
                  title: 'Auto Lock',
                  subtitle: 'Automatically lock the app when inactive',
                  value: _autoLock,
                  onChanged: (value) {
                    setState(() {
                      _autoLock = value;
                    });
                  },
                ),
                _buildDropdownTile(
                  title: 'Auto Lock Time',
                  subtitle: 'Time before auto lock activates',
                  value: _autoLockTime,
                  items: ['1 minute', '5 minutes', '10 minutes', '30 minutes'],
                  onChanged: _autoLock ? (value) {
                    setState(() {
                      _autoLockTime = value!;
                    });
                  } : null,
                ),
                _buildActionTile(
                  title: 'Change Password',
                  subtitle: 'Update your account password',
                  icon: Icons.lock,
                  onTap: _showChangePasswordDialog,
                ),
                _buildActionTile(
                  title: 'Privacy Policy',
                  subtitle: 'Read our privacy policy',
                  icon: Icons.privacy_tip,
                  onTap: () => _showFeatureComingSoon(),
                ),
              ],
            ),
            
            const SizedBox(height: 24),
            
            // Data & Storage
            _buildSettingsSection(
              title: 'Data & Storage',
              icon: Icons.storage,
              children: [
                _buildSwitchTile(
                  title: 'Crash Reporting',
                  subtitle: 'Automatically report app crashes',
                  value: _crashReporting,
                  onChanged: (value) {
                    setState(() {
                      _crashReporting = value;
                    });
                  },
                ),
                _buildActionTile(
                  title: 'Clear Cache',
                  subtitle: 'Free up storage space',
                  icon: Icons.cleaning_services,
                  onTap: _showClearCacheDialog,
                ),
                _buildActionTile(
                  title: 'Export Data',
                  subtitle: 'Download your personal data',
                  icon: Icons.download,
                  onTap: () => _showFeatureComingSoon(),
                ),
              ],
            ),
            
            const SizedBox(height: 24),
            
            // Support & About
            _buildSettingsSection(
              title: 'Support & About',
              icon: Icons.help,
              children: [
                _buildActionTile(
                  title: 'Send Feedback',
                  subtitle: 'Share your thoughts and suggestions',
                  icon: Icons.feedback,
                  onTap: _showFeedbackDialog,
                ),
                _buildActionTile(
                  title: 'About',
                  subtitle: 'Version 1.0.0 • Build 100',
                  icon: Icons.info,
                  onTap: _showAboutDialog,
                ),
              ],
            ),
            
            const SizedBox(height: 24),
            
            // Account Actions
            _buildSettingsSection(
              title: 'Account',
              icon: Icons.account_circle,
              children: [
                _buildActionTile(
                  title: 'Sign Out',
                  subtitle: 'Sign out of your account',
                  icon: Icons.logout,
                  onTap: _showSignOutDialog,
                  isDestructive: true,
                ),
              ],
            ),
            
            const SizedBox(height: 32),
          ],
        ),
      ),
    );
  }

  Widget _buildProfileSection() {
    final authProvider = context.watch<AuthProvider>();
    final user = authProvider.userModel;
    
    return Container(
      padding: const EdgeInsets.all(16),
      decoration: BoxDecoration(
        color: Theme.of(context).colorScheme.surfaceContainerLow,
        borderRadius: BorderRadius.circular(12),
        border: Border.all(
          color: Theme.of(context).colorScheme.outline.withValues(alpha: 0.2),
        ),
      ),
      child: Row(
        children: [
          CircleAvatar(
            radius: 30,
            backgroundColor: Theme.of(context).colorScheme.primary,
            backgroundImage: user?.photoURL != null && user!.photoURL!.isNotEmpty
                ? CachedNetworkImageProvider(user.photoURL!)
                : null,
            child: user?.photoURL == null || user!.photoURL!.isEmpty
                ? const Icon(
                    Icons.person,
                    color: Colors.white,
                    size: 30,
                  )
                : null,
          ),
          const SizedBox(width: 16),
          Expanded(
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Text(
                  user?.displayName ?? 'User',
                  style: Theme.of(context).textTheme.titleLarge?.copyWith(
                    fontWeight: FontWeight.bold,
                  ),
                ),
                Text(
                  user?.email ?? '',
                  style: Theme.of(context).textTheme.bodyMedium?.copyWith(
                    color: Theme.of(context).colorScheme.onSurfaceVariant,
                  ),
                ),
                const SizedBox(height: 4),
                Text(
                  user?.role.toString().split('.').last.toUpperCase() ?? 'USER',
                  style: Theme.of(context).textTheme.bodySmall?.copyWith(
                    color: Theme.of(context).colorScheme.primary,
                    fontWeight: FontWeight.w500,
                  ),
                ),
              ],
            ),
          ),
          IconButton(
            onPressed: _showEditProfileDialog,
            icon: const Icon(Icons.edit),
            tooltip: 'Edit Profile',
          ),
          IconButton(
            onPressed: _showProfilePictureOptions,
            icon: const Icon(Icons.camera_alt),
            tooltip: 'Change Photo',
          ),
        ],
      ),
    );
  }

  Widget _buildSettingsSection({
    required String title,
    required IconData icon,
    required List<Widget> children,
  }) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Padding(
          padding: const EdgeInsets.only(left: 16, bottom: 12),
          child: Row(
            children: [
              Icon(
                icon,
                size: 20,
                color: Theme.of(context).colorScheme.primary,
              ),
              const SizedBox(width: 8),
              Text(
                title,
                style: Theme.of(context).textTheme.titleMedium?.copyWith(
                  fontWeight: FontWeight.bold,
                  color: Theme.of(context).colorScheme.primary,
                ),
              ),
            ],
          ),
        ),
        Container(
          decoration: BoxDecoration(
            color: Theme.of(context).colorScheme.surface,
            borderRadius: BorderRadius.circular(12),
            border: Border.all(
              color: Theme.of(context).colorScheme.outline.withValues(alpha: 0.2),
            ),
          ),
          child: Column(
            children: children,
          ),
        ),
      ],
    );
  }

  Widget _buildSwitchTile({
    required String title,
    required String subtitle,
    required bool value,
    required ValueChanged<bool> onChanged,
  }) {
    return ListTile(
      title: Text(title),
      subtitle: Text(subtitle),
      trailing: Switch(
        value: value,
        onChanged: onChanged,
      ),
    );
  }

  Widget _buildDropdownTile({
    required String title,
    required String subtitle,
    required String value,
    required List<String> items,
    required ValueChanged<String?>? onChanged,
  }) {
    return ListTile(
      title: Text(title),
      subtitle: Text(subtitle),
      trailing: DropdownButton<String>(
        value: value,
        items: items.map((item) => DropdownMenuItem(
          value: item,
          child: Text(item),
        )).toList(),
        onChanged: onChanged,
        underline: const SizedBox(),
      ),
    );
  }

  Widget _buildActionTile({
    required String title,
    required String subtitle,
    required IconData icon,
    required VoidCallback onTap,
    bool isDestructive = false,
  }) {
    return ListTile(
      leading: Icon(
        icon,
        color: isDestructive ? Colors.red : Theme.of(context).colorScheme.onSurfaceVariant,
      ),
      title: Text(
        title,
        style: TextStyle(
          color: isDestructive ? Colors.red : null,
        ),
      ),
      subtitle: Text(subtitle),
      trailing: const Icon(Icons.chevron_right),
      onTap: onTap,
    );
  }

  void _showAdvancedNotificationSettings() {
    showModalBottomSheet(
      context: context,
      isScrollControlled: true,
      backgroundColor: Colors.transparent,
      builder: (context) => const AdvancedNotificationSettingsSheet(),
    );
  }

  void _showChangePasswordDialog() {
    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        title: const Text('Change Password'),
        content: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            const TextField(
              obscureText: true,
              decoration: InputDecoration(
                labelText: 'Current Password',
                border: OutlineInputBorder(),
              ),
            ),
            const SizedBox(height: 16),
            const TextField(
              obscureText: true,
              decoration: InputDecoration(
                labelText: 'New Password',
                border: OutlineInputBorder(),
              ),
            ),
            const SizedBox(height: 16),
            const TextField(
              obscureText: true,
              decoration: InputDecoration(
                labelText: 'Confirm New Password',
                border: OutlineInputBorder(),
              ),
            ),
          ],
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(context),
            child: const Text('Cancel'),
          ),
          FilledButton(
            onPressed: () {
              Navigator.pop(context);
              ScaffoldMessenger.of(context).showSnackBar(
                const SnackBar(
                  content: Text('Password changed successfully'),
                ),
              );
            },
            child: const Text('Change'),
          ),
        ],
      ),
    );
  }

  void _showClearCacheDialog() {
    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        title: const Text('Clear Cache'),
        content: const Text(
          'This will clear all cached data and may temporarily slow down the app. Continue?',
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(context),
            child: const Text('Cancel'),
          ),
          FilledButton(
            onPressed: () {
              Navigator.pop(context);
              // Simulate clearing cache
              ScaffoldMessenger.of(context).showSnackBar(
                const SnackBar(
                  content: Text('Cache cleared successfully'),
                ),
              );
            },
            child: const Text('Clear'),
          ),
        ],
      ),
    );
  }


  void _showFeedbackDialog() {
    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        title: const Text('Send Feedback'),
        content: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            const TextField(
              decoration: InputDecoration(
                labelText: 'Subject',
                border: OutlineInputBorder(),
              ),
            ),
            const SizedBox(height: 16),
            const TextField(
              maxLines: 4,
              decoration: InputDecoration(
                labelText: 'Your feedback',
                border: OutlineInputBorder(),
                alignLabelWithHint: true,
              ),
            ),
          ],
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(context),
            child: const Text('Cancel'),
          ),
          FilledButton(
            onPressed: () {
              Navigator.pop(context);
              ScaffoldMessenger.of(context).showSnackBar(
                const SnackBar(
                  content: Text('Feedback sent successfully'),
                ),
              );
            },
            child: const Text('Send'),
          ),
        ],
      ),
    );
  }

  void _showAboutDialog() {
    showAboutDialog(
      context: context,
      applicationName: 'Teacher Dashboard',
      applicationVersion: '1.0.0',
      applicationIcon: Container(
        padding: const EdgeInsets.all(8),
        decoration: BoxDecoration(
          color: Theme.of(context).colorScheme.primary,
          borderRadius: BorderRadius.circular(8),
        ),
        child: const Icon(
          Icons.school,
          color: Colors.white,
          size: 24,
        ),
      ),
      children: const [
        Text('A comprehensive educational management platform for students and teachers.'),
        SizedBox(height: 16),
        Text('Built with Flutter and Firebase.'),
      ],
    );
  }

  void _showSignOutDialog() {
    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        title: const Text('Sign Out'),
        content: const Text('Are you sure you want to sign out?'),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(context),
            child: const Text('Cancel'),
          ),
          FilledButton(
            onPressed: () async {
              Navigator.pop(context);
              final authProvider = context.read<AuthProvider>();
              await authProvider.signOut();
            },
            style: FilledButton.styleFrom(
              backgroundColor: Colors.red,
            ),
            child: const Text('Sign Out'),
          ),
        ],
      ),
    );
  }

  void _showFeatureComingSoon() {
    ScaffoldMessenger.of(context).showSnackBar(
      const SnackBar(
        content: Text('This feature is coming soon!'),
      ),
    );
  }
  
  void _showProfilePictureOptions() {
    showModalBottomSheet(
      context: context,
      builder: (context) => Container(
        padding: const EdgeInsets.all(16),
        child: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            ListTile(
              leading: const Icon(Icons.camera_alt),
              title: const Text('Take Photo'),
              onTap: () {
                Navigator.pop(context);
                _pickImage(ImageSource.camera);
              },
            ),
            ListTile(
              leading: const Icon(Icons.photo_library),
              title: const Text('Choose from Gallery'),
              onTap: () {
                Navigator.pop(context);
                _pickImage(ImageSource.gallery);
              },
            ),
            ListTile(
              leading: const Icon(Icons.delete),
              title: const Text('Remove Photo'),
              onTap: () {
                Navigator.pop(context);
                _removeProfilePicture();
              },
            ),
          ],
        ),
      ),
    );
  }
  
  Future<void> _pickImage(ImageSource source) async {
    try {
      final XFile? image = await _picker.pickImage(source: source);
      if (image != null) {
        await _uploadProfilePicture(image);
      }
    } catch (e) {
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('Failed to pick image: $e'),
          ),
        );
      }
    }
  }
  
  Future<void> _uploadProfilePicture(XFile image) async {
    try {
      final authProvider = context.read<AuthProvider>();
      final user = authProvider.userModel;
      
      if (user == null) return;
      
      // Show loading
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(
          content: Text('Uploading profile picture...'),
          duration: Duration(seconds: 2),
        ),
      );
      
      // Create a reference to Firebase Storage
      final storageRef = FirebaseStorage.instance
          .ref()
          .child('users')
          .child(user.uid)
          .child('profile')
          .child('avatar.jpg');
      
      // Upload the file
      final file = File(image.path);
      await storageRef.putFile(file);
      
      // Get the download URL
      final downloadUrl = await storageRef.getDownloadURL();
      
      // Update user profile with new photo URL
      await authProvider.updateProfile(photoURL: downloadUrl, updatePhoto: true);
      
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(
            content: Text('Profile picture updated successfully!'),
          ),
        );
      }
    } catch (e) {
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('Failed to upload profile picture: $e'),
          ),
        );
      }
    }
  }
  
  Future<void> _removeProfilePicture() async {
    try {
      final authProvider = context.read<AuthProvider>();
      final user = authProvider.userModel;
      
      if (user == null || user.photoURL == null) return;
      
      // Show loading
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(
          content: Text('Removing profile picture...'),
          duration: Duration(seconds: 2),
        ),
      );
      
      // Delete from Firebase Storage
      final storageRef = FirebaseStorage.instance
          .ref()
          .child('users')
          .child(user.uid)
          .child('profile')
          .child('avatar.jpg');
      
      try {
        await storageRef.delete();
      } catch (e) {
        // File might not exist, continue with profile update
      }
      
      // Update user profile to remove photo URL
      await authProvider.updateProfile(photoURL: null, updatePhoto: true);
      
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(
            content: Text('Profile picture removed successfully!'),
          ),
        );
      }
    } catch (e) {
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('Failed to remove profile picture: $e'),
          ),
        );
      }
    }
  }
  
  void _showEditProfileDialog() {
    final authProvider = context.read<AuthProvider>();
    final user = authProvider.userModel;
    final firstNameController = TextEditingController(text: user?.firstName);
    final lastNameController = TextEditingController(text: user?.lastName);
    
    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        title: const Text('Edit Profile'),
        content: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            TextField(
              controller: firstNameController,
              decoration: const InputDecoration(
                labelText: 'First Name',
                border: OutlineInputBorder(),
              ),
            ),
            const SizedBox(height: 16),
            TextField(
              controller: lastNameController,
              decoration: const InputDecoration(
                labelText: 'Last Name',
                border: OutlineInputBorder(),
              ),
            ),
          ],
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(context),
            child: const Text('Cancel'),
          ),
          FilledButton(
            onPressed: () async {
              Navigator.pop(context);
              final firstName = firstNameController.text.trim();
              final lastName = lastNameController.text.trim();
              
              if (firstName.isNotEmpty || lastName.isNotEmpty) {
                final displayName = '$firstName $lastName'.trim();
                
                final authProvider = context.read<AuthProvider>();
                final scaffoldMessenger = ScaffoldMessenger.of(context);
                
                final success = await authProvider.updateProfile(
                  displayName: displayName,
                  firstName: firstName,
                  lastName: lastName,
                );
                
                if (!mounted) return;
                
                if (success) {
                  scaffoldMessenger.showSnackBar(
                    const SnackBar(
                      content: Text('Profile updated successfully!'),
                    ),
                  );
                } else {
                  scaffoldMessenger.showSnackBar(
                    const SnackBar(
                      content: Text('Failed to update profile'),
                    ),
                  );
                }
              }
            },
            child: const Text('Save'),
          ),
        ],
      ),
    );
  }
}

// Advanced Notification Settings Sheet
class AdvancedNotificationSettingsSheet extends StatefulWidget {
  const AdvancedNotificationSettingsSheet({super.key});

  @override
  State<AdvancedNotificationSettingsSheet> createState() => _AdvancedNotificationSettingsSheetState();
}

class _AdvancedNotificationSettingsSheetState extends State<AdvancedNotificationSettingsSheet> {
  bool _quietHours = true;
  String _quietStart = '22:00';
  String _quietEnd = '08:00';
  bool _weekendNotifications = false;
  String _notificationSound = 'Default';
  bool _vibration = true;
  bool _ledNotification = true;

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);

    return Container(
      height: MediaQuery.of(context).size.height * 0.8,
      decoration: BoxDecoration(
        color: theme.colorScheme.surface,
        borderRadius: const BorderRadius.vertical(top: Radius.circular(20)),
      ),
      child: Column(
        children: [
          // Handle Bar
          Center(
            child: Container(
              margin: const EdgeInsets.only(top: 12, bottom: 8),
              width: 40,
              height: 4,
              decoration: BoxDecoration(
                color: theme.colorScheme.onSurfaceVariant.withValues(alpha: 0.3),
                borderRadius: BorderRadius.circular(2),
              ),
            ),
          ),
          // Header
          Padding(
            padding: const EdgeInsets.symmetric(horizontal: 24, vertical: 16),
            child: Row(
              mainAxisAlignment: MainAxisAlignment.spaceBetween,
              children: [
                Text(
                  'Advanced Notifications',
                  style: theme.textTheme.headlineSmall?.copyWith(
                    fontWeight: FontWeight.bold,
                  ),
                ),
                IconButton(
                  onPressed: () => Navigator.pop(context),
                  icon: const Icon(Icons.close),
                ),
              ],
            ),
          ),
          // Settings Content
          Expanded(
            child: ListView(
              padding: const EdgeInsets.symmetric(horizontal: 24),
              children: [
                SwitchListTile(
                  title: const Text('Quiet Hours'),
                  subtitle: const Text('Disable notifications during specified hours'),
                  value: _quietHours,
                  onChanged: (value) {
                    setState(() {
                      _quietHours = value;
                    });
                  },
                ),
                if (_quietHours) ...[
                  ListTile(
                    title: const Text('Start Time'),
                    subtitle: Text(_quietStart),
                    trailing: const Icon(Icons.access_time),
                    onTap: () => _selectTime(true),
                  ),
                  ListTile(
                    title: const Text('End Time'),
                    subtitle: Text(_quietEnd),
                    trailing: const Icon(Icons.access_time),
                    onTap: () => _selectTime(false),
                  ),
                ],
                const Divider(),
                SwitchListTile(
                  title: const Text('Weekend Notifications'),
                  subtitle: const Text('Receive notifications on weekends'),
                  value: _weekendNotifications,
                  onChanged: (value) {
                    setState(() {
                      _weekendNotifications = value;
                    });
                  },
                ),
                ListTile(
                  title: const Text('Notification Sound'),
                  subtitle: Text(_notificationSound),
                  trailing: const Icon(Icons.music_note),
                  onTap: _selectNotificationSound,
                ),
                SwitchListTile(
                  title: const Text('Vibration'),
                  subtitle: const Text('Vibrate when receiving notifications'),
                  value: _vibration,
                  onChanged: (value) {
                    setState(() {
                      _vibration = value;
                    });
                  },
                ),
                SwitchListTile(
                  title: const Text('LED Notification'),
                  subtitle: const Text('Flash LED for notifications'),
                  value: _ledNotification,
                  onChanged: (value) {
                    setState(() {
                      _ledNotification = value;
                    });
                  },
                ),
              ],
            ),
          ),
          // Save Button
          Container(
            padding: const EdgeInsets.all(24),
            child: SizedBox(
              width: double.infinity,
              child: FilledButton(
                onPressed: () {
                  Navigator.pop(context);
                  ScaffoldMessenger.of(context).showSnackBar(
                    const SnackBar(
                      content: Text('Notification settings saved'),
                    ),
                  );
                },
                style: FilledButton.styleFrom(
                  padding: const EdgeInsets.symmetric(vertical: 16),
                ),
                child: const Text('Save Settings'),
              ),
            ),
          ),
        ],
      ),
    );
  }

  Future<void> _selectTime(bool isStart) async {
    final currentTime = isStart ? _quietStart : _quietEnd;
    final parts = currentTime.split(':');
    final initialTime = TimeOfDay(
      hour: int.parse(parts[0]),
      minute: int.parse(parts[1]),
    );

    final TimeOfDay? picked = await showTimePicker(
      context: context,
      initialTime: initialTime,
    );

    if (picked != null) {
      final formattedTime = '${picked.hour.toString().padLeft(2, '0')}:${picked.minute.toString().padLeft(2, '0')}';
      setState(() {
        if (isStart) {
          _quietStart = formattedTime;
        } else {
          _quietEnd = formattedTime;
        }
      });
    }
  }

  void _selectNotificationSound() {
    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        title: const Text('Notification Sound'),
        content: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            'Default',
            'Bell',
            'Chime',
            'Ding',
            'None',
          ].map((sound) => RadioListTile<String>(
            title: Text(sound),
            value: sound,
            groupValue: _notificationSound,
            onChanged: (value) {
              setState(() {
                _notificationSound = value!;
              });
              Navigator.pop(context);
            },
          )).toList(),
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(context),
            child: const Text('Cancel'),
          ),
        ],
      ),
    );
  }
}
````

## File: lib/shared/widgets/common/adaptive_layout.dart
````dart
/// Adaptive layout system for responsive navigation and content presentation.
///
/// This module provides platform-aware layout components that automatically
/// adapt between mobile and desktop/tablet layouts, handling navigation
/// patterns, spacing, and UI structure for optimal user experience across
/// different screen sizes and educational platform contexts.
library;

import 'package:flutter/material.dart';
import 'package:go_router/go_router.dart';
import 'package:provider/provider.dart';
import '../navigation/app_drawer.dart';
import '../navigation/favorites_nav_bar.dart';
import 'responsive_layout.dart';
import '../../theme/app_spacing.dart';
import '../../../features/auth/presentation/providers/auth_provider.dart';
import '../../providers/navigation_provider.dart';

/// Adaptive layout wrapper that switches between mobile and desktop layouts.
///
/// This widget provides automatic layout adaptation based on screen size:
/// - **Mobile Layout**: Standard Scaffold with drawer, bottom navigation, and mobile spacing
/// - **Desktop/Tablet Layout**: Permanent side navigation with expanded content area
///
/// Key Features:
/// - Automatic responsive breakpoint detection
/// - Conditional navigation drawer display (slide-out mobile, permanent desktop)
/// - Bottom navigation bar for mobile, hidden for desktop
/// - Responsive padding that scales with screen size
/// - Consistent app bar behavior across layouts
/// - Support for floating action buttons and custom app bar actions
/// - Back button handling with custom callbacks
/// - Optional navigation components for different screen contexts
///
/// Layout Behavior:
/// - Mobile (< 768px): Drawer slides from left, bottom nav visible, compact spacing
/// - Tablet/Desktop (≥ 768px): Permanent drawer sidebar, no bottom nav, generous spacing
/// - Maintains consistent theme integration and accessibility
///
/// Usage:
/// ```dart
/// AdaptiveLayout(
///   title: 'Dashboard',
///   body: DashboardContent(),
///   actions: [IconButton(icon: Icon(Icons.settings), onPressed: () {})],
///   showBackButton: true,
///   onBackPressed: () => context.go('/'),
/// )
/// ```
class AdaptiveLayout extends StatelessWidget {
  /// Main content widget to display in the layout body.
  final Widget body;

  /// Title text displayed in the app bar across all screen sizes.
  final String title;

  /// Optional action widgets for the app bar (typically IconButtons).
  ///
  /// Displayed in the trailing section of the app bar.
  /// Common actions include settings, search, or context menus.
  final List<Widget>? actions;

  /// Whether to show the navigation drawer/sidebar.
  ///
  /// When true, displays slide-out drawer on mobile and permanent
  /// sidebar on desktop/tablet. Defaults to true.
  final bool showNavigationDrawer;

  /// Whether to show bottom navigation bar on mobile layouts.
  ///
  /// Defaults to true. Bottom navigation is always hidden on
  /// desktop/tablet layouts regardless of this setting.
  final bool showBottomNavigation;

  /// Optional floating action button to display.
  ///
  /// Positioned consistently across both mobile and desktop layouts
  /// following Material Design guidelines.
  final Widget? floatingActionButton;

  /// Optional bottom widget for the app bar (typically TabBar).
  ///
  /// Extends the app bar downward and maintains consistent
  /// behavior across responsive layouts.
  final PreferredSizeWidget? bottom;

  /// Whether to show back button instead of menu/drawer toggle.
  ///
  /// When true, replaces the drawer toggle with a back arrow.
  /// Useful for detail views and nested navigation screens.
  final bool showBackButton;

  /// Custom callback for back button press handling.
  ///
  /// If not provided, defaults to Navigator.pop() behavior.
  /// Use for custom navigation logic or route management.
  final VoidCallback? onBackPressed;

  /// Creates an adaptive layout with responsive navigation.
  ///
  /// @param body Main content widget (required)
  /// @param title App bar title text (required)
  /// @param actions Optional app bar action widgets
  /// @param showNavigationDrawer Whether to show drawer/sidebar (default: true)
  /// @param showBottomNavigation Whether to show bottom nav on mobile (default: true)
  /// @param floatingActionButton Optional floating action button
  /// @param bottom Optional app bar bottom widget (e.g., TabBar)
  /// @param showBackButton Whether to show back button (default: false)
  /// @param onBackPressed Custom back button callback (optional)
  const AdaptiveLayout({
    super.key,
    required this.body,
    required this.title,
    this.actions,
    this.showNavigationDrawer = true,
    this.showBottomNavigation = true,
    this.floatingActionButton,
    this.bottom,
    this.showBackButton = false,
    this.onBackPressed,
  });

  @override
  Widget build(BuildContext context) {
    // Get providers
    final authProvider = context.watch<AuthProvider>();
    
    // Schedule role update after build completes
    if (authProvider.userModel != null) {
      final role = authProvider.userModel!.role.toString().split('.').last.toLowerCase();
      // Use a microtask to ensure this happens after the current build
      Future.microtask(() {
        if (context.mounted) {
          context.read<NavigationProvider>().setRole(role);
        }
      });
    }

    return ResponsiveLayoutBuilder(
      builder: (context, screenSize) {
        if (screenSize == ScreenSize.mobile) {
          // Mobile layout with drawer and bottom navigation
          return Scaffold(
            appBar: AppBar(
              // Show back button or default drawer toggle
              leading: showBackButton
                  ? IconButton(
                      icon: const Icon(Icons.arrow_back),
                      onPressed: onBackPressed ??
                          () {
                            // Use GoRouter instead of Navigator for better navigation control
                            if (context.canPop()) {
                              context.pop();
                            } else {
                              // If we can't pop, go to the dashboard
                              context.go('/dashboard');
                            }
                          },
                    )
                  : null,
              title: Text(title),
              actions: actions,
              bottom: bottom,
            ),
            // Conditional drawer display (hidden when showing back button)
            drawer: showNavigationDrawer && !showBackButton
                ? const AppDrawer()
                : null,
            // Content area with mobile-optimized padding
            body: ResponsivePadding(
              mobile: const EdgeInsets.all(AppSpacing.md),
              child: body,
            ),
            // Bottom navigation for mobile-first navigation pattern
            bottomNavigationBar:
                showBottomNavigation ? const FavoritesNavBar() : null,
            floatingActionButton: floatingActionButton,
          );
        } else {
          // Desktop/Tablet layout with permanent navigation drawer
          return Scaffold(
            body: Row(
              children: [
                // Permanent navigation sidebar for larger screens
                if (showNavigationDrawer)
                  const SizedBox(
                    width: AppSpacing.drawerWidth,
                    child: AppDrawer(),
                  ),
                // Main content area with app bar and content
                Expanded(
                  child: Scaffold(
                    appBar: AppBar(
                      // Back button handling for desktop layout
                      leading: showBackButton
                          ? IconButton(
                              icon: const Icon(Icons.arrow_back),
                              onPressed: onBackPressed ??
                                  () {
                                    if (context.canPop()) {
                                      context.pop();
                                    } else {
                                      context.go('/dashboard');
                                    }
                                  },
                            )
                          : null,
                      title: Text(title),
                      actions: actions,
                      automaticallyImplyLeading:
                          false, // Disable default drawer toggle
                      bottom: bottom,
                    ),
                    body: ResponsivePadding(
                      tablet: const EdgeInsets.all(AppSpacing.lg),
                      desktop: const EdgeInsets.all(AppSpacing.xl),
                      child: body,
                    ),
                  ),
                ),
              ],
            ),
            floatingActionButton: floatingActionButton,
          );
        }
      },
    );
  }
}
````

## File: lib/shared/widgets/navigation/app_drawer.dart
````dart
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'package:go_router/go_router.dart';
import '../../../features/auth/presentation/providers/auth_provider.dart';
import '../../providers/navigation_provider.dart';
import '../../models/user_model.dart';
import 'favorites_nav_bar.dart';

class AppDrawer extends StatelessWidget {
  const AppDrawer({super.key});

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final authProvider = context.watch<AuthProvider>();
    final user = authProvider.userModel;

    return Drawer(
      child: SafeArea(
        child: Column(
          children: [
            // User Header
            Container(
              width: double.infinity,
              padding: const EdgeInsets.all(24),
              decoration: BoxDecoration(
                color: theme.colorScheme.primaryContainer,
              ),
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  CircleAvatar(
                    radius: 30,
                    backgroundColor: theme.colorScheme.primary,
                    child: Text(
                      user?.displayName.isNotEmpty == true
                          ? user!.displayName[0].toUpperCase()
                          : 'U',
                      style: theme.textTheme.headlineSmall?.copyWith(
                        color: theme.colorScheme.onPrimary,
                        fontWeight: FontWeight.bold,
                      ),
                    ),
                  ),
                  const SizedBox(height: 12),
                  Text(
                    (user?.displayName.isNotEmpty == true)
                        ? user!.displayName
                        : 'User',
                    style: theme.textTheme.titleMedium?.copyWith(
                      fontWeight: FontWeight.bold,
                    ),
                  ),
                  Text(
                    user?.email ?? '',
                    style: theme.textTheme.bodyMedium?.copyWith(
                      color: theme.colorScheme.onSurfaceVariant,
                    ),
                  ),
                  const SizedBox(height: 8),
                  Container(
                    padding: const EdgeInsets.symmetric(
                      horizontal: 8,
                      vertical: 4,
                    ),
                    decoration: BoxDecoration(
                      color: theme.colorScheme.primary,
                      borderRadius: BorderRadius.circular(12),
                    ),
                    child: Text(
                      user?.role.toString().split('.').last.toUpperCase() ??
                          'USER',
                      style: theme.textTheme.labelSmall?.copyWith(
                        color: theme.colorScheme.onPrimary,
                        fontWeight: FontWeight.bold,
                      ),
                    ),
                  ),
                ],
              ),
            ),

            // Navigation Items
            Expanded(
              child: ListView(
                padding: const EdgeInsets.symmetric(vertical: 8),
                children: [
                  // Quick Access Favorites Section
                  _buildFavoritesSection(context),
                  
                  const Divider(height: 32),
                  
                  // All Navigation Items
                  Padding(
                    padding: const EdgeInsets.fromLTRB(16, 0, 16, 8),
                    child: Text(
                      'All Navigation',
                      style: theme.textTheme.labelMedium?.copyWith(
                        color: theme.colorScheme.onSurfaceVariant,
                        fontWeight: FontWeight.w600,
                      ),
                    ),
                  ),
                  
                  _buildNavItem(
                    context,
                    icon: Icons.dashboard_outlined,
                    selectedIcon: Icons.dashboard,
                    title: 'Dashboard',
                    route: '/dashboard',
                  ),

                  // Teacher-specific navigation
                  if (user?.role == UserRole.teacher) ...[
                    _buildNavItem(
                      context,
                      icon: Icons.class_outlined,
                      selectedIcon: Icons.class_,
                      title: 'My Classes',
                      route: '/teacher/classes',
                    ),
                    _buildNavItem(
                      context,
                      icon: Icons.grade_outlined,
                      selectedIcon: Icons.grade,
                      title: 'Gradebook',
                      route: '/teacher/gradebook',
                    ),
                    _buildNavItem(
                      context,
                      icon: Icons.assignment_outlined,
                      selectedIcon: Icons.assignment,
                      title: 'Assignments',
                      route: '/teacher/assignments',
                    ),
                    _buildNavItem(
                      context,
                      icon: Icons.people_outline,
                      selectedIcon: Icons.people,
                      title: 'Students',
                      route: '/teacher/students',
                    ),
                  ],

                  // Student-specific navigation
                  if (user?.role == UserRole.student) ...[
                    _buildNavItem(
                      context,
                      icon: Icons.book_outlined,
                      selectedIcon: Icons.book,
                      title: 'My Courses',
                      route: '/student/courses',
                    ),
                    _buildNavItem(
                      context,
                      icon: Icons.assignment_outlined,
                      selectedIcon: Icons.assignment,
                      title: 'Assignments',
                      route: '/student/assignments',
                    ),
                    _buildNavItem(
                      context,
                      icon: Icons.grade_outlined,
                      selectedIcon: Icons.grade,
                      title: 'Grades',
                      route: '/student/grades',
                    ),
                  ],

                  // Common navigation
                  _buildNavItem(
                    context,
                    icon: Icons.chat_outlined,
                    selectedIcon: Icons.chat,
                    title: 'Messages',
                    route: '/messages',
                  ),
                  _buildNavItem(
                    context,
                    icon: Icons.forum_outlined,
                    selectedIcon: Icons.forum,
                    title: 'Discussion Boards',
                    route: '/discussions',
                  ),
                  _buildNavItem(
                    context,
                    icon: Icons.calendar_month_outlined,
                    selectedIcon: Icons.calendar_month,
                    title: 'Calendar',
                    route: '/calendar',
                  ),
                  _buildNavItem(
                    context,
                    icon: Icons.notifications_outlined,
                    selectedIcon: Icons.notifications,
                    title: 'Notifications',
                    route: '/notifications',
                  ),

                  const Divider(height: 32),

                  // Customize Navigation
                  ListTile(
                    leading: const Icon(Icons.tune),
                    title: const Text('Customize Navigation'),
                    subtitle: const Text('Choose your favorite shortcuts'),
                    contentPadding:
                        const EdgeInsets.symmetric(horizontal: 16, vertical: 4),
                    shape: RoundedRectangleBorder(
                      borderRadius: BorderRadius.circular(8),
                    ),
                    onTap: () {
                      Scaffold.of(context).closeDrawer(); // Close drawer
                      showModalBottomSheet(
                        context: context,
                        isScrollControlled: true,
                        backgroundColor: Colors.transparent,
                        builder: (context) =>
                            const NavigationCustomizationSheet(),
                      );
                    },
                  ),

                  _buildNavItem(
                    context,
                    icon: Icons.settings_outlined,
                    selectedIcon: Icons.settings,
                    title: 'Settings',
                    route: '/settings',
                  ),
                  _buildNavItem(
                    context,
                    icon: Icons.contact_support_outlined,
                    selectedIcon: Icons.contact_support,
                    title: 'Contact Support',
                    route: '/contact-support',
                  ),

                  // Temporary debug option
                  _buildNavItem(
                    context,
                    icon: Icons.bug_report_outlined,
                    selectedIcon: Icons.bug_report,
                    title: 'Update Display Name',
                    route: '/debug/update-name',
                  ),
                ],
              ),
            ),

            // Sign Out
            Padding(
              padding: const EdgeInsets.all(16),
              child: ListTile(
                leading: Icon(
                  Icons.logout,
                  color: theme.colorScheme.error,
                ),
                title: Text(
                  'Sign Out',
                  style: TextStyle(
                    color: theme.colorScheme.error,
                    fontWeight: FontWeight.w500,
                  ),
                ),
                onTap: () {
                  Scaffold.of(context).closeDrawer();
                  authProvider.signOut();
                },
              ),
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildNavItem(
    BuildContext context, {
    required IconData icon,
    required IconData selectedIcon,
    required String title,
    required String route,
  }) {
    final theme = Theme.of(context);
    final router = GoRouter.of(context);
    final currentRoute = router.routeInformationProvider.value.uri.path;
    final isSelected = currentRoute == route;

    return ListTile(
      leading: Icon(
        isSelected ? selectedIcon : icon,
        color: isSelected
            ? theme.colorScheme.primary
            : theme.colorScheme.onSurfaceVariant,
      ),
      title: Text(
        title,
        style: TextStyle(
          color: isSelected
              ? theme.colorScheme.primary
              : theme.colorScheme.onSurface,
          fontWeight: isSelected ? FontWeight.w600 : FontWeight.normal,
        ),
      ),
      selected: isSelected,
      selectedTileColor:
          theme.colorScheme.primaryContainer.withValues(alpha: 0.3),
      shape: RoundedRectangleBorder(
        borderRadius: BorderRadius.circular(8),
      ),
      contentPadding: const EdgeInsets.symmetric(horizontal: 16, vertical: 4),
      onTap: () {
        // Close drawer using Scaffold
        Scaffold.of(context).closeDrawer();
        
        // Navigate to the route after drawer closes
        Future.delayed(const Duration(milliseconds: 200), () {
          if (context.mounted) {
            context.go(route);
          }
        });
      },
    );
  }
  
  Widget _buildFavoritesSection(BuildContext context) {
    final theme = Theme.of(context);
    final navigationProvider = context.watch<NavigationProvider>();
    final favoriteItems = navigationProvider.favoriteItems;
    
    if (favoriteItems.isEmpty) {
      return const SizedBox.shrink();
    }
    
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Padding(
          padding: const EdgeInsets.fromLTRB(16, 8, 16, 12),
          child: Row(
            children: [
              Text(
                'Quick Access',
                style: theme.textTheme.labelMedium?.copyWith(
                  color: theme.colorScheme.onSurfaceVariant,
                  fontWeight: FontWeight.w600,
                ),
              ),
              const SizedBox(width: 8),
              Icon(
                Icons.star,
                size: 16,
                color: theme.colorScheme.primary,
              ),
            ],
          ),
        ),
        
        // Favorites Grid
        Container(
          padding: const EdgeInsets.symmetric(horizontal: 12),
          child: GridView.builder(
            shrinkWrap: true,
            physics: const NeverScrollableScrollPhysics(),
            gridDelegate: const SliverGridDelegateWithFixedCrossAxisCount(
              crossAxisCount: 2,
              childAspectRatio: 2.5,
              crossAxisSpacing: 8,
              mainAxisSpacing: 8,
            ),
            itemCount: favoriteItems.length,
            itemBuilder: (context, index) {
              final item = favoriteItems[index];
              final router = GoRouter.of(context);
              final currentRoute = router.routeInformationProvider.value.uri.path;
              final isSelected = currentRoute == item.route;
              
              return Material(
                color: isSelected 
                    ? theme.colorScheme.primaryContainer
                    : theme.colorScheme.surfaceContainerHighest,
                borderRadius: BorderRadius.circular(12),
                child: InkWell(
                  onTap: () {
                    Scaffold.of(context).closeDrawer();
                    Future.delayed(const Duration(milliseconds: 200), () {
                      if (context.mounted) {
                        context.go(item.route);
                      }
                    });
                  },
                  borderRadius: BorderRadius.circular(12),
                  child: Container(
                    padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 8),
                    child: Row(
                      children: [
                        Icon(
                          isSelected ? item.activeIcon : item.icon,
                          size: 20,
                          color: isSelected
                              ? theme.colorScheme.primary
                              : theme.colorScheme.onSurfaceVariant,
                        ),
                        const SizedBox(width: 8),
                        Expanded(
                          child: Text(
                            item.title,
                            style: theme.textTheme.labelMedium?.copyWith(
                              color: isSelected
                                  ? theme.colorScheme.primary
                                  : theme.colorScheme.onSurface,
                              fontWeight: isSelected ? FontWeight.w600 : FontWeight.normal,
                            ),
                            overflow: TextOverflow.ellipsis,
                          ),
                        ),
                      ],
                    ),
                  ),
                ),
              );
            },
          ),
        ),
      ],
    );
  }
}
````

## File: lib/shared/widgets/navigation/bottom_nav_bar.dart
````dart
/// Role-based bottom navigation bar for the education platform.
/// 
/// This module provides adaptive navigation that changes based on user role,
/// supporting different navigation structures for teachers, students, and admins
/// with role-specific icons, labels, and routes.
library;

import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'package:go_router/go_router.dart';
import '../../../features/auth/presentation/providers/auth_provider.dart';
import '../../models/user_model.dart';

/// Adaptive bottom navigation bar that adjusts based on user role.
/// 
/// This widget provides role-specific navigation with:
/// - Teacher navigation: Dashboard, Classes, Gradebook, Messages
/// - Student navigation: Dashboard, Courses, Assignments, Grades
/// - Admin/default navigation: Dashboard, Settings
/// 
/// Features:
/// - Automatic route detection and highlighting
/// - Role-based icon and label customization
/// - Go Router integration for navigation
/// - Fallback handling for unknown routes
/// - Authentication state awareness
/// 
/// The navigation adapts in real-time when user role changes
/// and maintains proper route synchronization.
class BottomNavBar extends StatelessWidget {
  /// Creates an adaptive bottom navigation bar.
  /// 
  /// The navigation items and routes are determined automatically
  /// based on the current user's role from the auth provider.
  const BottomNavBar({super.key});

  @override
  Widget build(BuildContext context) {
    // Watch authentication state for real-time role updates
    final authProvider = context.watch<AuthProvider>();
    final user = authProvider.userModel;
    
    // Get current route for highlighting active navigation item
    final currentRoute = GoRouterState.of(context).matchedLocation;

    // Initialize navigation configuration based on user role
    List<BottomNavigationBarItem> items = [];
    List<String> routes = [];

    // Configure teacher navigation with academic management features
    if (user?.role == UserRole.teacher) {
      items = [
        const BottomNavigationBarItem(
          icon: Icon(Icons.dashboard_outlined),
          activeIcon: Icon(Icons.dashboard),
          label: 'Dashboard',
        ),
        const BottomNavigationBarItem(
          icon: Icon(Icons.class_outlined),
          activeIcon: Icon(Icons.class_),
          label: 'Classes',
        ),
        const BottomNavigationBarItem(
          icon: Icon(Icons.grade_outlined),
          activeIcon: Icon(Icons.grade),
          label: 'Gradebook',
        ),
        const BottomNavigationBarItem(
          icon: Icon(Icons.chat_outlined),
          activeIcon: Icon(Icons.chat),
          label: 'Messages',
        ),
      ];
      routes = [
        '/dashboard',        // Overview and quick actions
        '/teacher/classes',  // Class management and roster
        '/teacher/gradebook', // Grade entry and analytics
        '/messages',         // Communication hub
      ];
    // Configure student navigation with learning-focused features
    } else if (user?.role == UserRole.student) {
      items = [
        const BottomNavigationBarItem(
          icon: Icon(Icons.dashboard_outlined),
          activeIcon: Icon(Icons.dashboard),
          label: 'Dashboard',
        ),
        const BottomNavigationBarItem(
          icon: Icon(Icons.book_outlined),
          activeIcon: Icon(Icons.book),
          label: 'Courses',
        ),
        const BottomNavigationBarItem(
          icon: Icon(Icons.assignment_outlined),
          activeIcon: Icon(Icons.assignment),
          label: 'Assignments',
        ),
        const BottomNavigationBarItem(
          icon: Icon(Icons.grade_outlined),
          activeIcon: Icon(Icons.grade),
          label: 'Grades',
        ),
      ];
      routes = [
        '/dashboard',           // Student overview and schedule
        '/student/courses',     // Enrolled courses and materials
        '/student/assignments', // Assignment submissions
        '/student/grades',      // Grade tracking and reports
      ];
    // Configure default navigation for admin or unknown roles
    } else {
      // Fallback navigation for admin users or undefined roles
      items = [
        const BottomNavigationBarItem(
          icon: Icon(Icons.dashboard_outlined),
          activeIcon: Icon(Icons.dashboard),
          label: 'Dashboard',
        ),
        const BottomNavigationBarItem(
          icon: Icon(Icons.settings_outlined),
          activeIcon: Icon(Icons.settings),
          label: 'Settings',
        ),
      ];
      routes = [
        '/dashboard', // System overview
        '/settings',  // Administrative settings
      ];
    }

    // Determine active tab index from current route
    int currentIndex = routes.indexOf(currentRoute);
    if (currentIndex == -1) currentIndex = 0; // Default to first tab if route not found

    return BottomNavigationBar(
      items: items,
      currentIndex: currentIndex,
      type: BottomNavigationBarType.fixed, // Ensure all tabs are always visible
      onTap: (index) {
        // Navigate to selected route with bounds checking
        if (index < routes.length) {
          context.go(routes[index]);
        }
      },
    );
  }
}
````

## File: test/widget_test.dart
````dart
// This is a basic Flutter widget test.
//
// To perform an interaction with a widget in your test, use the WidgetTester
// utility in the flutter_test package. For example, you can send tap and scroll
// gestures. You can also use WidgetTester to find child widgets in the widget
// tree, read text, and verify that the values of widget properties are correct.

import 'package:flutter/material.dart';
import 'package:flutter_test/flutter_test.dart';

import 'package:teacher_dashboard_flutter/main.dart';

void main() {
  testWidgets('Counter increments smoke test', (WidgetTester tester) async {
    // Build our app and trigger a frame.
    await tester.pumpWidget(const TeacherDashboardApp());

    // Verify that our counter starts at 0.
    expect(find.text('0'), findsOneWidget);
    expect(find.text('1'), findsNothing);

    // Tap the '+' icon and trigger a frame.
    await tester.tap(find.byIcon(Icons.add));
    await tester.pump();

    // Verify that our counter has incremented.
    expect(find.text('0'), findsNothing);
    expect(find.text('1'), findsOneWidget);
  });
}
````

## File: windows/CMakeLists.txt
````
# Project-level configuration.
cmake_minimum_required(VERSION 3.14)
project(teacher_dashboard_flutter LANGUAGES CXX)

# The name of the executable created for the application. Change this to change
# the on-disk name of your application.
set(BINARY_NAME "teacher_dashboard_flutter")

# Explicitly opt in to modern CMake behaviors to avoid warnings with recent
# versions of CMake.
cmake_policy(VERSION 3.14...3.25)

# Define build configuration option.
get_property(IS_MULTICONFIG GLOBAL PROPERTY GENERATOR_IS_MULTI_CONFIG)
if(IS_MULTICONFIG)
  set(CMAKE_CONFIGURATION_TYPES "Debug;Profile;Release"
    CACHE STRING "" FORCE)
else()
  if(NOT CMAKE_BUILD_TYPE AND NOT CMAKE_CONFIGURATION_TYPES)
    set(CMAKE_BUILD_TYPE "Debug" CACHE
      STRING "Flutter build mode" FORCE)
    set_property(CACHE CMAKE_BUILD_TYPE PROPERTY STRINGS
      "Debug" "Profile" "Release")
  endif()
endif()
# Define settings for the Profile build mode.
set(CMAKE_EXE_LINKER_FLAGS_PROFILE "${CMAKE_EXE_LINKER_FLAGS_RELEASE}")
set(CMAKE_SHARED_LINKER_FLAGS_PROFILE "${CMAKE_SHARED_LINKER_FLAGS_RELEASE}")
set(CMAKE_C_FLAGS_PROFILE "${CMAKE_C_FLAGS_RELEASE}")
set(CMAKE_CXX_FLAGS_PROFILE "${CMAKE_CXX_FLAGS_RELEASE}")

# Use Unicode for all projects.
add_definitions(-DUNICODE -D_UNICODE)

# Compilation settings that should be applied to most targets.
#
# Be cautious about adding new options here, as plugins use this function by
# default. In most cases, you should add new options to specific targets instead
# of modifying this function.
function(APPLY_STANDARD_SETTINGS TARGET)
  target_compile_features(${TARGET} PUBLIC cxx_std_17)
  target_compile_options(${TARGET} PRIVATE /W4 /WX /wd"4100" /wd"4996" /wd"4005")
  target_compile_options(${TARGET} PRIVATE /EHsc)
  target_compile_definitions(${TARGET} PRIVATE "_HAS_EXCEPTIONS=0")
  target_compile_definitions(${TARGET} PRIVATE "$<$<CONFIG:Debug>:_DEBUG>")
endfunction()

# Flutter library and tool build rules.
set(FLUTTER_MANAGED_DIR "${CMAKE_CURRENT_SOURCE_DIR}/flutter")
add_subdirectory(${FLUTTER_MANAGED_DIR})

# Application build; see runner/CMakeLists.txt.
add_subdirectory("runner")


# Generated plugin build rules, which manage building the plugins and adding
# them to the application.
include(flutter/generated_plugins.cmake)


# === Installation ===
# Support files are copied into place next to the executable, so that it can
# run in place. This is done instead of making a separate bundle (as on Linux)
# so that building and running from within Visual Studio will work.
set(BUILD_BUNDLE_DIR "$<TARGET_FILE_DIR:${BINARY_NAME}>")
# Make the "install" step default, as it's required to run.
set(CMAKE_VS_INCLUDE_INSTALL_TO_DEFAULT_BUILD 1)
if(CMAKE_INSTALL_PREFIX_INITIALIZED_TO_DEFAULT)
  set(CMAKE_INSTALL_PREFIX "${BUILD_BUNDLE_DIR}" CACHE PATH "..." FORCE)
endif()

set(INSTALL_BUNDLE_DATA_DIR "${CMAKE_INSTALL_PREFIX}/data")
set(INSTALL_BUNDLE_LIB_DIR "${CMAKE_INSTALL_PREFIX}")

install(TARGETS ${BINARY_NAME} RUNTIME DESTINATION "${CMAKE_INSTALL_PREFIX}"
  COMPONENT Runtime)

install(FILES "${FLUTTER_ICU_DATA_FILE}" DESTINATION "${INSTALL_BUNDLE_DATA_DIR}"
  COMPONENT Runtime)

install(FILES "${FLUTTER_LIBRARY}" DESTINATION "${INSTALL_BUNDLE_LIB_DIR}"
  COMPONENT Runtime)

if(PLUGIN_BUNDLED_LIBRARIES)
  install(FILES "${PLUGIN_BUNDLED_LIBRARIES}"
    DESTINATION "${INSTALL_BUNDLE_LIB_DIR}"
    COMPONENT Runtime)
endif()

# Copy the native assets provided by the build.dart from all packages.
set(NATIVE_ASSETS_DIR "${PROJECT_BUILD_DIR}native_assets/windows/")
install(DIRECTORY "${NATIVE_ASSETS_DIR}"
   DESTINATION "${INSTALL_BUNDLE_LIB_DIR}"
   COMPONENT Runtime)

# Fully re-copy the assets directory on each build to avoid having stale files
# from a previous install.
set(FLUTTER_ASSET_DIR_NAME "flutter_assets")
install(CODE "
  file(REMOVE_RECURSE \"${INSTALL_BUNDLE_DATA_DIR}/${FLUTTER_ASSET_DIR_NAME}\")
  " COMPONENT Runtime)
install(DIRECTORY "${PROJECT_BUILD_DIR}/${FLUTTER_ASSET_DIR_NAME}"
  DESTINATION "${INSTALL_BUNDLE_DATA_DIR}" COMPONENT Runtime)

# Install the AOT library on non-Debug builds only.
install(FILES "${AOT_LIBRARY}" DESTINATION "${INSTALL_BUNDLE_DATA_DIR}"
  CONFIGURATIONS Profile;Release
  COMPONENT Runtime)
````

## File: windows/flutter/generated_plugins.cmake
````
#
# Generated file, do not edit.
#

list(APPEND FLUTTER_PLUGIN_LIST
  cloud_firestore
  file_selector_windows
  firebase_auth
  firebase_core
  firebase_storage
  flutter_webrtc
  permission_handler_windows
)

list(APPEND FLUTTER_FFI_PLUGIN_LIST
)

set(PLUGIN_BUNDLED_LIBRARIES)

foreach(plugin ${FLUTTER_PLUGIN_LIST})
  add_subdirectory(flutter/ephemeral/.plugin_symlinks/${plugin}/windows plugins/${plugin})
  target_link_libraries(${BINARY_NAME} PRIVATE ${plugin}_plugin)
  list(APPEND PLUGIN_BUNDLED_LIBRARIES $<TARGET_FILE:${plugin}_plugin>)
  list(APPEND PLUGIN_BUNDLED_LIBRARIES ${${plugin}_bundled_libraries})
endforeach(plugin)

foreach(ffi_plugin ${FLUTTER_FFI_PLUGIN_LIST})
  add_subdirectory(flutter/ephemeral/.plugin_symlinks/${ffi_plugin}/windows plugins/${ffi_plugin})
  list(APPEND PLUGIN_BUNDLED_LIBRARIES ${${ffi_plugin}_bundled_libraries})
endforeach(ffi_plugin)
````

## File: android/app/build.gradle.kts
````
plugins {
    id("com.android.application")
    id("kotlin-android")
    // The Flutter Gradle Plugin must be applied after the Android and Kotlin Gradle plugins.
    id("dev.flutter.flutter-gradle-plugin")
    id("com.google.gms.google-services")
}

android {
    namespace = "com.teacherdashboard.teacher_dashboard_flutter_firebase"
    compileSdk = 35
    ndkVersion = "27.0.12077973"

    compileOptions {
        isCoreLibraryDesugaringEnabled = true
        sourceCompatibility = JavaVersion.VERSION_11
        targetCompatibility = JavaVersion.VERSION_11
    }

    kotlinOptions {
        jvmTarget = "11"
    }

    signingConfigs {
        getByName("debug") {
            storeFile = file("debug.keystore")
            storePassword = "android"
            keyAlias = "androiddebugkey"
            keyPassword = "android"
        }
    }

    defaultConfig {
        // TODO: Specify your own unique Application ID (https://developer.android.com/studio/build/application-id.html).
        applicationId = "com.teacherdashboard.teacher_dashboard_flutter_firebase"
        // You can update the following values to match your application needs.
        // For more information, see: https://flutter.dev/to/review-gradle-config.
        minSdk = 23
        targetSdk = 35
        versionCode = project.flutter.versionCode
        versionName = project.flutter.versionName
        
        // Add multiDex support for complex apps
        multiDexEnabled = true
    }

    buildTypes {
        debug {
            // Emulator-specific configurations
            signingConfig = signingConfigs.getByName("debug")
            isDebuggable = true
            isMinifyEnabled = false
            // Allow Firebase emulator connections
            manifestPlaceholders["usesCleartextTraffic"] = "true"
        }
        release {
            // TODO: Add your own signing config for the release build.
            // Signing with the debug keys for now, so `flutter run --release` works.
            signingConfig = signingConfigs.getByName("debug")
            isMinifyEnabled = true
            proguardFiles(
                getDefaultProguardFile("proguard-android-optimize.txt"),
                "proguard-rules.pro"
            )
        }
    }
    
    packaging {
        resources {
            excludes += listOf(
                "META-INF/DEPENDENCIES",
                "META-INF/LICENSE",
                "META-INF/LICENSE.txt",
                "META-INF/license.txt",
                "META-INF/NOTICE",
                "META-INF/NOTICE.txt",
                "META-INF/notice.txt",
                "META-INF/ASL2.0",
                "META-INF/*.kotlin_module"
            )
        }
    }
}

flutter {
    source = "../.."
}

dependencies {
    coreLibraryDesugaring("com.android.tools:desugar_jdk_libs:2.1.4")
}
````

## File: android/app/src/main/AndroidManifest.xml
````xml
<manifest xmlns:android="http://schemas.android.com/apk/res/android">
    <!-- WebRTC permissions -->
    <uses-permission android:name="android.permission.CAMERA" />
    <uses-permission android:name="android.permission.RECORD_AUDIO" />
    <uses-permission android:name="android.permission.INTERNET" />
    <uses-permission android:name="android.permission.ACCESS_NETWORK_STATE" />
    <uses-permission android:name="android.permission.MODIFY_AUDIO_SETTINGS" />
    <uses-permission android:name="android.permission.FOREGROUND_SERVICE" />
    
    <!-- Notifications permissions for Android 13+ -->
    <uses-permission android:name="android.permission.POST_NOTIFICATIONS" />
    
    <application
        android:label="teacher_dashboard_flutter"
        android:name="${applicationName}"
        android:icon="@mipmap/ic_launcher"
        android:enableOnBackInvokedCallback="true"
        android:networkSecurityConfig="@xml/network_security_config"
        android:usesCleartextTraffic="true">
        <activity
            android:name=".MainActivity"
            android:exported="true"
            android:launchMode="singleTop"
            android:taskAffinity=""
            android:theme="@style/LaunchTheme"
            android:configChanges="orientation|keyboardHidden|keyboard|screenSize|smallestScreenSize|locale|layoutDirection|fontScale|screenLayout|density|uiMode"
            android:hardwareAccelerated="true"
            android:windowSoftInputMode="adjustResize">
            <!-- Specifies an Android theme to apply to this Activity as soon as
                 the Android process has started. This theme is visible to the user
                 while the Flutter UI initializes. After that, this theme continues
                 to determine the Window background behind the Flutter UI. -->
            <meta-data
              android:name="io.flutter.embedding.android.NormalTheme"
              android:resource="@style/NormalTheme"
              />
            <intent-filter>
                <action android:name="android.intent.action.MAIN"/>
                <category android:name="android.intent.category.LAUNCHER"/>
            </intent-filter>
        </activity>
        
        <!-- Firebase Cloud Messaging Service -->
        <service
            android:name="com.google.firebase.messaging.FirebaseMessagingService"
            android:exported="false">
            <intent-filter>
                <action android:name="com.google.firebase.MESSAGING_EVENT" />
            </intent-filter>
        </service>
        
        <!-- Don't delete the meta-data below.
             This is used by the Flutter tool to generate GeneratedPluginRegistrant.java -->
        <meta-data
            android:name="flutterEmbedding"
            android:value="2" />
    </application>
    <!-- Required to query activities that can process text, see:
         https://developer.android.com/training/package-visibility and
         https://developer.android.com/reference/android/content/Intent#ACTION_PROCESS_TEXT.

         In particular, this is used by the Flutter engine in io.flutter.plugin.text.ProcessTextPlugin. -->
    <queries>
        <intent>
            <action android:name="android.intent.action.PROCESS_TEXT"/>
            <data android:mimeType="text/plain"/>
        </intent>
    </queries>
</manifest>
````

## File: android/build/reports/problems/problems-report.html
````html
<!DOCTYPE html>

<html lang="en">
<head>
    <!-- Required meta tags -->
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

                    <style type="text/css">
                /*! normalize.css v7.0.0 | MIT License | github.com/necolas/normalize.css */
html {
    line-height: 1.15;
    -ms-text-size-adjust: 100%;
    -webkit-text-size-adjust: 100%
}

body {
    margin: 0
}

article, aside, footer, header, nav, section {
    display: block
}

h1 {
    font-size: 2em;
    margin: .67em 0
}

figcaption, figure, main {
    display: block
}

figure {
    margin: 1em 40px
}

hr {
    box-sizing: content-box;
    height: 0;
    overflow: visible
}

pre {
    font-family: monospace, monospace;
    font-size: 1em
}

a {
    background-color: transparent;
    -webkit-text-decoration-skip: objects
}

abbr[title] {
    border-bottom: none;
    text-decoration: underline;
    text-decoration: underline dotted
}

b, strong {
    font-weight: inherit
}

b, strong {
    font-weight: bolder
}

code, kbd, samp {
    font-family: monospace, monospace;
    font-size: 1em
}

dfn {
    font-style: italic
}

mark {
    background-color: #ff0;
    color: #000
}

small {
    font-size: 80%
}

sub, sup {
    font-size: 75%;
    line-height: 0;
    position: relative;
    vertical-align: baseline
}

sub {
    bottom: -.25em
}

sup {
    top: -.5em
}

audio, video {
    display: inline-block
}

audio:not([controls]) {
    display: none;
    height: 0
}

img {
    border-style: none
}

svg:not(:root) {
    overflow: hidden
}

button, input, optgroup, select, textarea {
    font-family: sans-serif;
    font-size: 100%;
    line-height: 1.15;
    margin: 0
}

button, input {
    overflow: visible
}

button, select {
    text-transform: none
}

[type=reset], [type=submit], button, html [type=button] {
    -webkit-appearance: button
}

[type=button]::-moz-focus-inner, [type=reset]::-moz-focus-inner, [type=submit]::-moz-focus-inner, button::-moz-focus-inner {
    border-style: none;
    padding: 0
}

[type=button]:-moz-focusring, [type=reset]:-moz-focusring, [type=submit]:-moz-focusring, button:-moz-focusring {
    outline: 1px dotted ButtonText
}

fieldset {
    padding: .35em .75em .625em
}

legend {
    box-sizing: border-box;
    color: inherit;
    display: table;
    max-width: 100%;
    padding: 0;
    white-space: normal
}

progress {
    display: inline-block;
    vertical-align: baseline
}

textarea {
    overflow: auto
}

[type=checkbox], [type=radio] {
    box-sizing: border-box;
    padding: 0
}

[type=number]::-webkit-inner-spin-button, [type=number]::-webkit-outer-spin-button {
    height: auto
}

[type=search] {
    -webkit-appearance: textfield;
    outline-offset: -2px
}

[type=search]::-webkit-search-cancel-button, [type=search]::-webkit-search-decoration {
    -webkit-appearance: none
}

::-webkit-file-upload-button {
    -webkit-appearance: button;
    font: inherit
}

details, menu {
    display: block
}

summary {
    display: list-item
}

canvas {
    display: inline-block
}

template {
    display: none
}

[hidden] {
    display: none
}

/* configuration cache styles */

.report-wrapper {
    margin: 0;
    padding: 0 24px;
}

.gradle-logo {
    width: 32px;
    height: 24px;
    background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAYCAYAAACbU/80AAAAAXNSR0IArs4c6QAAAERlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAA6ABAAMAAAABAAEAAKACAAQAAAABAAAAIKADAAQAAAABAAAAGAAAAAA915G0AAAD5klEQVRIDbVWC0xTZxT+emmhVUEeA1/ROh/tFAFFGK7oJisIKsNVoOwBbJPowEWHzikRxeiMRpwwjDWRBHQLIzOmiRhe22BT40TitiyaMBQFfMEeLMIEaSmk+/+rvd7be4no6Elu7n++c/5zzv845/wyOyG4iGyDgzCdNOPLM9W41n4bnmNUiHo5DNsz0hGsmcV6lbkyAOOWXJjrz4qWp1C4o3z/LqzWL4VcJB1FIHmZHn/f78a6pDcxbeIEfNvQiPwTZbDZBpC24zOEaGfDpTsgtZby6u+QlrubFWUY3nh6AH39/ahr/Bn1jZfxW3ML2js60dtvgbtcQVblj8CZM7A0PBSrol6Ft+c4KZ8iTB1nwN0//8IEP9/hA2i924Gir0/iq8oa/NvbJzLiDKiUSqTE6pGVbEBY4BxnsYAPSnwXTa3tLCZ5BF3dPdAkGNHzoFcwcaRMnC4CeZkZiAgKFE252nITC1Pew9Dj5GNEGgS4Rbb5eZ1Te7UXG6FLX4cV6zeh5kIDaDpSunL9Boyf5nLOpwT4Sx+BxWrFK8QAnTAapPRQwofcj86uLoG59cbVEOzA0NAQNh38Atn5RSjY8rFAmc/I3dyQvOx1PsSNVy7Roa3ajHDePbBYLSLn1MaGd5KFAXy07xAOl59C6elK+I73hIHcbGd6wXs8qkyH8FZcjLOI5X/9/TrOnLsAldJDUu4As1NToFFPe3IEpm/M2HigwCFnU6t4Zw6Ck1JhGRhgcXq5juXloKyqFnlHirmz5CaNcEAv59kSE9wVikcB3O78A/MSU0Fznk/H9+yAetJEnPr+B8RFLsLcGS8ia28+qQuX+WrPNNZOV+Nc6VH4+3iz89g0pEaLzRUiQ3LGDWsM8Qidq2WL0PGKKlgf74ZIeQTAfFJ6a44WIsDXh9OW/dPdY58aawC9KK6kpOgolO7JxViVSuBGXnvxksudZ5F0O5yzGYxMJnBOGaau4fnPU2RNAtCFBKFoa7akczaAptY2iWmjB33+yQa4kZwfjpi2ex3Dyf43vuAljWQ/4Btmei1WPj+q45hF4U+1J4fEizCEvNf0EWHoIW244sfzoN1RipaT2kDfdjfv3MNpojdISjmfIheE8Fnp8WR9vJ2Zr+O+bYUmO+kJ9KnIUtf9bnvY2x9wcqrrvnCJvfL8Tw4V9v9LU7PdKzJaoNdy645AR4ph1JMncZHRKrVvYyYY5kmP8iO1v2T3dk6HDtYmrgJtOnwKnaPFrg8z+BBX7QSgEyOPJfX9Qd9DFs40GgTOHbrBs2ch4bXFuEG2mmFkeD9hpUMk+NMXEe0TNtsg/Ly94DVurEAuxfwHC1WiVbe0U7MAAAAASUVORK5CYII=");
    background-size: contain;
}

.header {
    display: flex;
    flex-wrap: wrap;
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    padding: 24px 24px 0 24px;
    background-color: white;
    z-index: 1;
}

.learn-more {
    margin-left: auto;
    align-self: center;
    font-size: 0.875rem;
    font-weight: normal;
}

.title {
    display: flex;
    align-items: center;
    padding: 18px 0 24px 0;
    flex: 1 0 100%;
}

.content {
    font-size: 0.875rem;
    padding: 240px 0 48px;
    overflow-x: auto;
    white-space: nowrap;
}

.content ol:first-of-type {
    margin: 0;
}

.tree-btn {
    cursor: pointer;
    display: inline-block;
    width: 16px;
    height: 16px;
    background-size: contain;
    background-repeat: no-repeat;
    vertical-align: middle;
    margin-top: -0.2em;
}

.tree-btn.collapsed {
    background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 192 512"><path d="M166.9 264.5l-117.8 116c-4.7 4.7-12.3 4.7-17 0l-7.1-7.1c-4.7-4.7-4.7-12.3 0-17L127.3 256 25.1 155.6c-4.7-4.7-4.7-12.3 0-17l7.1-7.1c4.7-4.7 12.3-4.7 17 0l117.8 116c4.6 4.7 4.6 12.3-.1 17z" fill="%23999999" stroke="%23999999"/></svg>');
}

.tree-btn.expanded {
    background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 256 512"><path d="M119.5 326.9L3.5 209.1c-4.7-4.7-4.7-12.3 0-17l7.1-7.1c4.7-4.7 12.3-4.7 17 0L128 287.3l100.4-102.2c4.7-4.7 12.3-4.7 17 0l7.1 7.1c4.7 4.7 4.7 12.3 0 17L136.5 327c-4.7 4.6-12.3 4.6-17-.1z" fill="%23999999" stroke="%23999999"/></svg>');
}

ul .tree-btn {
    margin-right: 3px;
}

.leaf-icon {
    display: inline-block;
    width: 16px;
    height: 16px;
    background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 256 512"><path d="M32 256 H224" stroke="%23999999" stroke-width="48" stroke-linecap="round"/></svg>');
    background-size: contain;
    background-repeat: no-repeat;
    vertical-align: middle;
    margin-top: -0.2em;
}

.invisible-text {
    user-select: all; /* Allow the text to be selectable */
    color: transparent; /* Hide the text */
    text-indent: -9999px; /* Move the text out of view */
    position: relative;
    white-space: pre; /* Preserve meaningful whitespace in the invisible text for copying */
}

.text-for-copy {
    display: inline-block;
}

.enum-icon {
    display: inline-block;
    width: 16px;
    height: 16px;
    background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1024 1024"><circle cx="512" cy="512" r="200" /></svg>');
    background-size: contain;
    background-repeat: no-repeat;
    vertical-align: middle;
    margin-inline-start: 0.5ex;
    margin-inline-end: 0.5ex;
    margin-top: -0.2em;
}

.error-icon {
    display: inline-block;
    width: 16px;
    height: 16px;
    background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><path d="M193.94 256L296.5 153.44l21.15-21.15c3.12-3.12 3.12-8.19 0-11.31l-22.63-22.63c-3.12-3.12-8.19-3.12-11.31 0L160 222.06 36.29 98.34c-3.12-3.12-8.19-3.12-11.31 0L2.34 120.97c-3.12 3.12-3.12 8.19 0 11.31L126.06 256 2.34 379.71c-3.12 3.12-3.12 8.19 0 11.31l22.63 22.63c3.12 3.12 8.19 3.12 11.31 0L160 289.94 262.56 392.5l21.15 21.15c3.12 3.12 8.19 3.12 11.31 0l22.63-22.63c3.12-3.12 3.12-8.19 0-11.31L193.94 256z" fill="%23FC461E" stroke="%23FC461E"/></svg>');
    background-size: contain;
    background-repeat: no-repeat;
    vertical-align: middle;
    margin-inline-start: 0.5ex;
    margin-inline-end: 0.5ex;
    margin-top: -0.2em;
}

.advice-icon {
    display: inline-block;
    width: 16px;
    height: 16px;
    background-image: url('data:image/svg+xml;utf8,<svg width="800px" height="800px" viewBox="-4.93 0 122.88 122.88" version="1.1" id="Layer_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"  style="enable-background:new 0 0 113.01 122.88" xml:space="preserve"><g><path d="M44.13,102.06c-1.14,0.03-2.14-0.81-2.3-1.96c-0.17-1.2,0.64-2.31,1.82-2.54c-1.3-7.37-4.85-11.43-8.6-15.72 c-2.92-3.34-5.95-6.81-8.34-11.92c-2.35-5.03-3.64-10.23-3.6-15.63c0.05-5.4,1.42-10.96,4.4-16.71c0.02-0.04,0.04-0.07,0.06-0.11 l0,0c3.91-6.62,9.38-11.04,15.47-13.52c5.11-2.09,10.66-2.8,16.1-2.3c5.42,0.5,10.73,2.2,15.37,4.94 c5.9,3.49,10.75,8.67,13.42,15.21c1.44,3.54,2.42,7.49,2.54,11.82c0.12,4.31-0.62,8.96-2.61,13.88 c-2.66,6.59-6.18,10.68-9.47,14.51c-3.03,3.53-5.85,6.81-7.42,11.84c0.89,0.21,1.59,0.94,1.73,1.9c0.17,1.24-0.7,2.39-1.94,2.56 l-0.77,0.11c-0.14,1.09-0.23,2.26-0.27,3.51l0.25-0.04c1.24-0.17,2.39,0.7,2.56,1.94c0.17,1.24-0.7,2.39-1.94,2.56l-0.78,0.11 c0.01,0.15,0.02,0.3,0.03,0.45l0,0c0.07,0.88,0.08,1.73,0.03,2.54l0.13-0.02c1.25-0.15,2.38,0.74,2.54,1.98 c0.15,1.25-0.74,2.38-1.98,2.54l-1.68,0.21c-1.2,3.11-3.34,5.48-5.87,6.94c-1.74,1.01-3.67,1.59-5.61,1.71 c-1.97,0.12-3.96-0.25-5.78-1.13c-2.08-1.02-3.94-2.71-5.29-5.14c-0.65-0.33-1.13-0.97-1.23-1.75c-0.04-0.31-0.01-0.61,0.07-0.89 c-0.39-1.16-0.68-2.43-0.87-3.83l-0.07,0.01c-1.24,0.17-2.39-0.7-2.56-1.94c-0.17-1.24,0.7-2.39,1.94-2.56l0.54-0.08 C44.19,104.32,44.18,103.16,44.13,102.06L44.13,102.06z M2.18,58.86C1.01,58.89,0.04,57.98,0,56.81c-0.04-1.17,0.88-2.14,2.05-2.18 l8.7-0.3c1.17-0.04,2.14,0.88,2.18,2.05c0.04,1.17-0.88,2.14-2.05,2.18L2.18,58.86L2.18,58.86z M110.68,50.25 c1.16-0.12,2.2,0.73,2.32,1.89c0.12,1.16-0.73,2.2-1.89,2.32l-8.66,0.91c-1.16,0.12-2.2-0.73-2.32-1.89 c-0.12-1.16,0.73-2.2,1.89-2.32L110.68,50.25L110.68,50.25z M94.91,14.78c0.65-0.97,1.96-1.23,2.93-0.58 c0.97,0.65,1.23,1.96,0.58,2.93l-4.84,7.24c-0.65,0.97-1.96,1.23-2.93,0.58c-0.97-0.65-1.23-1.96-0.58-2.93L94.91,14.78 L94.91,14.78z M57.63,2.06c0.03-1.17,1-2.09,2.16-2.06c1.17,0.03,2.09,1,2.06,2.16l-0.22,8.7c-0.03,1.17-1,2.09-2.16,2.06 c-1.17-0.03-2.09-1-2.06-2.16L57.63,2.06L57.63,2.06z M13.88,15.53c-0.86-0.8-0.9-2.14-0.11-2.99c0.8-0.86,2.14-0.9,2.99-0.11 l6.37,5.94c0.86,0.8,0.9,2.14,0.11,2.99c-0.8,0.86-2.14,0.9-2.99,0.11L13.88,15.53L13.88,15.53z M47.88,96.95l18.49-2.63 c1.59-6.7,5.05-10.73,8.8-15.08c3.08-3.58,6.36-7.4,8.76-13.34c1.76-4.35,2.41-8.43,2.31-12.19c-0.1-3.75-0.96-7.21-2.24-10.34 c-2.3-5.63-6.51-10.11-11.65-13.15c-4.11-2.43-8.8-3.94-13.59-4.37c-4.77-0.44-9.64,0.19-14.13,2.02 c-5.26,2.15-9.99,5.97-13.39,11.72c-2.64,5.12-3.86,10.02-3.9,14.73c-0.04,4.74,1.11,9.33,3.2,13.8c2.13,4.56,4.97,7.8,7.69,10.92 C42.47,83.9,46.48,88.49,47.88,96.95L47.88,96.95z M65.62,99.02l-17.27,2.45c0.05,1.1,0.07,2.25,0.05,3.47l17.05-2.42 C65.47,101.29,65.52,100.12,65.62,99.02L65.62,99.02z M48.49,109.52c0.12,0.92,0.3,1.76,0.53,2.54l16.55-2.04 c0.11-0.86,0.13-1.77,0.05-2.74l0,0l0-0.02l-0.01-0.17L48.49,109.52L48.49,109.52z M51.37,116.36c0.64,0.67,1.35,1.19,2.1,1.55 c1.15,0.56,2.42,0.79,3.67,0.72c1.29-0.08,2.57-0.47,3.74-1.15c1.1-0.64,2.09-1.53,2.88-2.65L51.37,116.36L51.37,116.36z"/></g></svg>');
    background-size: contain;
    background-repeat: no-repeat;
    vertical-align: middle;
    margin-inline-start: 0.5ex;
    margin-inline-end: 0.5ex;
    margin-top: -0.2em;
}

.warning-icon {
    display: inline-block;
    width: 13px;
    height: 13px;
    background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><path d="M270.2 160h35.5c3.4 0 6.1 2.8 6 6.2l-7.5 196c-.1 3.2-2.8 5.8-6 5.8h-20.5c-3.2 0-5.9-2.5-6-5.8l-7.5-196c-.1-3.4 2.6-6.2 6-6.2zM288 388c-15.5 0-28 12.5-28 28s12.5 28 28 28 28-12.5 28-28-12.5-28-28-28zm281.5 52L329.6 24c-18.4-32-64.7-32-83.2 0L6.5 440c-18.4 31.9 4.6 72 41.6 72H528c36.8 0 60-40 41.5-72zM528 480H48c-12.3 0-20-13.3-13.9-24l240-416c6.1-10.6 21.6-10.7 27.7 0l240 416c6.2 10.6-1.5 24-13.8 24z" fill="%23DEAD22" stroke="%23DEAD22"/></svg>');
    background-size: contain;
    background-repeat: no-repeat;
    vertical-align: middle;
    margin-inline-start: 0.3ex;
    margin-inline-end: 1.1ex;
    margin-top: -0.1em;
}

.documentation-button {
    cursor: pointer;
    display: inline-block;
    width: 13px;
    height: 13px;
    background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path d="M256 340c-15.464 0-28 12.536-28 28s12.536 28 28 28 28-12.536 28-28-12.536-28-28-28zm7.67-24h-16c-6.627 0-12-5.373-12-12v-.381c0-70.343 77.44-63.619 77.44-107.408 0-20.016-17.761-40.211-57.44-40.211-29.144 0-44.265 9.649-59.211 28.692-3.908 4.98-11.054 5.995-16.248 2.376l-13.134-9.15c-5.625-3.919-6.86-11.771-2.645-17.177C185.658 133.514 210.842 116 255.67 116c52.32 0 97.44 29.751 97.44 80.211 0 67.414-77.44 63.849-77.44 107.408V304c0 6.627-5.373 12-12 12zM256 40c118.621 0 216 96.075 216 216 0 119.291-96.61 216-216 216-119.244 0-216-96.562-216-216 0-119.203 96.602-216 216-216m0-32C119.043 8 8 119.083 8 256c0 136.997 111.043 248 248 248s248-111.003 248-248C504 119.083 392.957 8 256 8z" fill="%23999999" stroke="%23999999"/></svg>');
    background-size: contain;
    background-repeat: no-repeat;
    vertical-align: middle;
    margin-inline-start: 0.5ex;
    margin-inline-end: 0.5ex;
    margin-top: -0.2em;
}

.documentation-button::selection {
    color: transparent;
}

.documentation-button:hover {
    color: transparent;
}

.copy-button {
    cursor: pointer;
    display: inline-block;
    width: 12px;
    height: 12px;
    background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><path d="M433.941 193.941l-51.882-51.882A48 48 0 0 0 348.118 128H320V80c0-26.51-21.49-48-48-48h-66.752C198.643 13.377 180.858 0 160 0s-38.643 13.377-45.248 32H48C21.49 32 0 53.49 0 80v288c0 26.51 21.49 48 48 48h80v48c0 26.51 21.49 48 48 48h224c26.51 0 48-21.49 48-48V227.882a48 48 0 0 0-14.059-33.941zm-22.627 22.627a15.888 15.888 0 0 1 4.195 7.432H352v-63.509a15.88 15.88 0 0 1 7.431 4.195l51.883 51.882zM160 30c9.941 0 18 8.059 18 18s-8.059 18-18 18-18-8.059-18-18 8.059-18 18-18zM48 384c-8.822 0-16-7.178-16-16V80c0-8.822 7.178-16 16-16h66.752c6.605 18.623 24.389 32 45.248 32s38.643-13.377 45.248-32H272c8.822 0 16 7.178 16 16v48H176c-26.51 0-48 21.49-48 48v208H48zm352 96H176c-8.822 0-16-7.178-16-16V176c0-8.822 7.178-16 16-16h144v72c0 13.2 10.8 24 24 24h72v208c0 8.822-7.178 16-16 16z" fill="%23999999" stroke="%23999999"/></svg>');
    background-size: contain;
    background-repeat: no-repeat;
    vertical-align: middle;
    margin-inline-start: 0.5ex;
    margin-top: -0.2em;
}

.groups{
    display: flex;
    border-bottom: 1px solid #EDEEEF;
    flex: 1 0 100%;
}

.uncategorized {
    display: flex;
    border-top: 4px solid #EDEEEF;
    flex: 1 0 100%;
}

.group-selector {
    padding: 0 52px 24px 0;
    font-size: 0.9rem;
    font-weight: bold;
    color: #999999;
    cursor: pointer;
}

.group-selector__count {
    margin: 0 8px;
    border-radius: 8px;
    background-color: #999;
    color: #fff;
    padding: 1px 8px 2px;
    font-size: 0.75rem;
}

.group-selector--active {
    color: #02303A;
    cursor: auto;
}

.group-selector--active .group-selector__count {
    background-color: #686868;
}

.group-selector--disabled {
    cursor: not-allowed;
}

.accordion-header {
    cursor: pointer;
}

.container {
    padding-left: 0.5em;
    padding-right: 0.5em;
}

.stacktrace {
    border-radius: 4px;
    overflow-x: auto;
    padding: 0.5rem;
    margin-bottom: 0;
    min-width: 1000px;
}

/* Lato (bold, regular) */
@font-face {
    font-display: swap;
    font-family: Lato;
    font-weight: 500;
    font-style: normal;
    src: url("https://assets.gradle.com/lato/fonts/lato-semibold/lato-semibold.woff2") format("woff2"),
    url("https://assets.gradle.com/lato/fonts/lato-semibold/lato-semibold.woff") format("woff");
}

@font-face {
    font-display: swap;
    font-family: Lato;
    font-weight: bold;
    font-style: normal;
    src: url("https://assets.gradle.com/lato/fonts/lato-bold/lato-bold.woff2") format("woff2"),
    url("https://assets.gradle.com/lato/fonts/lato-bold/lato-bold.woff") format("woff");
}

* {
    -webkit-box-sizing: border-box;
    -moz-box-sizing: border-box;
    box-sizing: border-box;
}

html,
body {
    margin: 0;
    padding: 0;
}

html {
    font-family: "Lato", "Helvetica Neue", Arial, sans-serif;
    font-size: 16px;
    font-weight: 400;
    line-height: 1.5;
}

body {
    color: #02303A;
    background-color: #ffffff;
    -webkit-text-size-adjust: 100%;
    -ms-text-size-adjust: 100%;
    -webkit-font-smoothing: antialiased;
}


/* typography */
h1, h2, h3, h4, h5, h6 {
    color: #02303A;
    text-rendering: optimizeLegibility;
    margin: 0;
}

h1 {
    font-size: 1rem;
}

h2 {
    font-size: 0.9rem;
}

h3 {
    font-size: 1.125rem;
}

h4, h5, h6 {
    font-size: 0.875rem;
}

h1 code {
    font-weight: bold;
}

ul, ol, dl {
    list-style-position: outside;
    line-height: 1.6;
    padding: 0;
    margin: 0 0 0 20px;
    list-style-type: none;
}

li {
    line-height: 2;
}

a {
    color: #1DA2BD;
    text-decoration: none;
    transition: all 0.3s ease, visibility 0s;
}

a:hover {
    color: #35c1e4;
}

/* code */
code, pre {
    font-family: Inconsolata, Monaco, "Courier New", monospace;
    font-style: normal;
    font-variant-ligatures: normal;
    font-variant-caps: normal;
    font-variant-numeric: normal;
    font-variant-east-asian: normal;
    font-weight: normal;
    font-stretch: normal;
    color: #686868;
}

*:not(pre) > code {
    letter-spacing: 0;
    padding: 0.1em 0.5ex;
    text-rendering: optimizeSpeed;
    word-spacing: -0.15em;
    word-wrap: break-word;
}

pre {
    font-size: 0.75rem;
    line-height: 1.8;
    margin-top: 0;
    margin-bottom: 1.5em;
    padding: 1rem;
}

pre code {
    background-color: transparent;
    color: inherit;
    line-height: 1.8;
    font-size: 100%;
    padding: 0;
}

a code {
    color: #1BA8CB;
}

pre.code, pre.programlisting, pre.screen, pre.tt {
    background-color: #f7f7f8;
    border-radius: 4px;
    font-size: 1em;
    line-height: 1.45;
    margin-bottom: 1.25em;
    overflow-x: auto;
    padding: 1rem;
}

li em, p em {
    padding: 0 1px;
}

code em, tt em {
    text-decoration: none;
}

code + .copy-button {
    margin-inline-start: 0.2ex;
}

.java-exception {
    font-size: 0.75rem;
    padding-left: 24px;
}

.java-exception ul {
    margin: 0;
    line-height: inherit;
}

.java-exception code {
    white-space: pre;
}

.java-exception-part-toggle {
    user-select: none;
    cursor: pointer;
    border-radius: 2px;
    padding: 0.1em 0.2em;
    background: azure;
    color: #686868;
}

                </style>
    <!-- Inconsolata is used as a default monospace font in the report. -->
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Inconsolata:400,700" />

    <title>Gradle Configuration Cache</title>
</head>
<body>

<div id="playground"></div>

<div class="report" id="report">
    Loading...
</div>

<script type="text/javascript">
function configurationCacheProblems() { return (
// begin-report-data
{"diagnostics":[{"locations":[{"path":"build file 'C:\\Users\\frank\\AppData\\Local\\Pub\\Cache\\hosted\\pub.dev\\cloud_firestore-5.6.11\\android\\build.gradle'","line":1}],"problem":[{"text":"Properties should be assigned using the 'propName = value' syntax. Setting a property via the Gradle-generated 'propName value' or 'propName(value)' syntax in Groovy DSL has been deprecated."}],"severity":"WARNING","problemDetails":[{"text":"This is scheduled to be removed in Gradle 10.0."}],"contextualLabel":"Properties should be assigned using the 'propName = value' syntax. Setting a property via the Gradle-generated 'propName value' or 'propName(value)' syntax in Groovy DSL has been deprecated.","documentationLink":"https://docs.gradle.org/8.13/userguide/upgrading_version_8.html#groovy_space_assignment_syntax","problemId":[{"name":"deprecation","displayName":"Deprecation"},{"name":"properties-should-be-assigned-using-the-propname-value-syntax-setting-a-property-via-the-gradle-generated-propname-value-or-propname-value-syntax-in-groovy-dsl","displayName":"Properties should be assigned using the 'propName = value' syntax. Setting a property via the Gradle-generated 'propName value' or 'propName(value)' syntax in Groovy DSL has been deprecated."}],"solutions":[[{"text":"Use assignment ('group = <value>') instead."}]]},{"locations":[{"path":"build file 'C:\\Users\\frank\\AppData\\Local\\Pub\\Cache\\hosted\\pub.dev\\cloud_firestore-5.6.11\\android\\build.gradle'","line":2}],"problem":[{"text":"Properties should be assigned using the 'propName = value' syntax. Setting a property via the Gradle-generated 'propName value' or 'propName(value)' syntax in Groovy DSL has been deprecated."}],"severity":"WARNING","problemDetails":[{"text":"This is scheduled to be removed in Gradle 10.0."}],"contextualLabel":"Properties should be assigned using the 'propName = value' syntax. Setting a property via the Gradle-generated 'propName value' or 'propName(value)' syntax in Groovy DSL has been deprecated.","documentationLink":"https://docs.gradle.org/8.13/userguide/upgrading_version_8.html#groovy_space_assignment_syntax","problemId":[{"name":"deprecation","displayName":"Deprecation"},{"name":"properties-should-be-assigned-using-the-propname-value-syntax-setting-a-property-via-the-gradle-generated-propname-value-or-propname-value-syntax-in-groovy-dsl","displayName":"Properties should be assigned using the 'propName = value' syntax. Setting a property via the Gradle-generated 'propName value' or 'propName(value)' syntax in Groovy DSL has been deprecated."}],"solutions":[[{"text":"Use assignment ('version = <value>') instead."}]]},{"locations":[{"path":"build file 'C:\\Users\\frank\\AppData\\Local\\Pub\\Cache\\hosted\\pub.dev\\cloud_firestore-5.6.11\\android\\build.gradle'","line":41}],"problem":[{"text":"Properties should be assigned using the 'propName = value' syntax. Setting a property via the Gradle-generated 'propName value' or 'propName(value)' syntax in Groovy DSL has been deprecated."}],"severity":"WARNING","problemDetails":[{"text":"This is scheduled to be removed in Gradle 10.0."}],"contextualLabel":"Properties should be assigned using the 'propName = value' syntax. Setting a property via the Gradle-generated 'propName value' or 'propName(value)' syntax in Groovy DSL has been deprecated.","documentationLink":"https://docs.gradle.org/8.13/userguide/upgrading_version_8.html#groovy_space_assignment_syntax","problemId":[{"name":"deprecation","displayName":"Deprecation"},{"name":"properties-should-be-assigned-using-the-propname-value-syntax-setting-a-property-via-the-gradle-generated-propname-value-or-propname-value-syntax-in-groovy-dsl","displayName":"Properties should be assigned using the 'propName = value' syntax. Setting a property via the Gradle-generated 'propName value' or 'propName(value)' syntax in Groovy DSL has been deprecated."}],"solutions":[[{"text":"Use assignment ('namespace = <value>') instead."}]]},{"locations":[{"path":"build file 'C:\\Users\\frank\\AppData\\Local\\Pub\\Cache\\hosted\\pub.dev\\cloud_firestore-5.6.11\\android\\build.gradle'","line":57}],"problem":[{"text":"Properties should be assigned using the 'propName = value' syntax. Setting a property via the Gradle-generated 'propName value' or 'propName(value)' syntax in Groovy DSL has been deprecated."}],"severity":"WARNING","problemDetails":[{"text":"This is scheduled to be removed in Gradle 10.0."}],"contextualLabel":"Properties should be assigned using the 'propName = value' syntax. Setting a property via the Gradle-generated 'propName value' or 'propName(value)' syntax in Groovy DSL has been deprecated.","documentationLink":"https://docs.gradle.org/8.13/userguide/upgrading_version_8.html#groovy_space_assignment_syntax","problemId":[{"name":"deprecation","displayName":"Deprecation"},{"name":"properties-should-be-assigned-using-the-propname-value-syntax-setting-a-property-via-the-gradle-generated-propname-value-or-propname-value-syntax-in-groovy-dsl","displayName":"Properties should be assigned using the 'propName = value' syntax. Setting a property via the Gradle-generated 'propName value' or 'propName(value)' syntax in Groovy DSL has been deprecated."}],"solutions":[[{"text":"Use assignment ('buildConfig = <value>') instead."}]]},{"locations":[{"path":"build file 'C:\\Users\\frank\\AppData\\Local\\Pub\\Cache\\hosted\\pub.dev\\device_calendar-4.3.3\\android\\build.gradle'","line":1}],"problem":[{"text":"Properties should be assigned using the 'propName = value' syntax. Setting a property via the Gradle-generated 'propName value' or 'propName(value)' syntax in Groovy DSL has been deprecated."}],"severity":"WARNING","problemDetails":[{"text":"This is scheduled to be removed in Gradle 10.0."}],"contextualLabel":"Properties should be assigned using the 'propName = value' syntax. Setting a property via the Gradle-generated 'propName value' or 'propName(value)' syntax in Groovy DSL has been deprecated.","documentationLink":"https://docs.gradle.org/8.13/userguide/upgrading_version_8.html#groovy_space_assignment_syntax","problemId":[{"name":"deprecation","displayName":"Deprecation"},{"name":"properties-should-be-assigned-using-the-propname-value-syntax-setting-a-property-via-the-gradle-generated-propname-value-or-propname-value-syntax-in-groovy-dsl","displayName":"Properties should be assigned using the 'propName = value' syntax. Setting a property via the Gradle-generated 'propName value' or 'propName(value)' syntax in Groovy DSL has been deprecated."}],"solutions":[[{"text":"Use assignment ('group = <value>') instead."}]]},{"locations":[{"path":"build file 'C:\\Users\\frank\\AppData\\Local\\Pub\\Cache\\hosted\\pub.dev\\device_calendar-4.3.3\\android\\build.gradle'","line":2}],"problem":[{"text":"Properties should be assigned using the 'propName = value' syntax. Setting a property via the Gradle-generated 'propName value' or 'propName(value)' syntax in Groovy DSL has been deprecated."}],"severity":"WARNING","problemDetails":[{"text":"This is scheduled to be removed in Gradle 10.0."}],"contextualLabel":"Properties should be assigned using the 'propName = value' syntax. Setting a property via the Gradle-generated 'propName value' or 'propName(value)' syntax in Groovy DSL has been deprecated.","documentationLink":"https://docs.gradle.org/8.13/userguide/upgrading_version_8.html#groovy_space_assignment_syntax","problemId":[{"name":"deprecation","displayName":"Deprecation"},{"name":"properties-should-be-assigned-using-the-propname-value-syntax-setting-a-property-via-the-gradle-generated-propname-value-or-propname-value-syntax-in-groovy-dsl","displayName":"Properties should be assigned using the 'propName = value' syntax. Setting a property via the Gradle-generated 'propName value' or 'propName(value)' syntax in Groovy DSL has been deprecated."}],"solutions":[[{"text":"Use assignment ('version = <value>') instead."}]]},{"locations":[{"path":"build file 'C:\\Users\\frank\\AppData\\Local\\Pub\\Cache\\hosted\\pub.dev\\device_calendar-4.3.3\\android\\build.gradle'","line":48}],"problem":[{"text":"Properties should be assigned using the 'propName = value' syntax. Setting a property via the Gradle-generated 'propName value' or 'propName(value)' syntax in Groovy DSL has been deprecated."}],"severity":"WARNING","problemDetails":[{"text":"This is scheduled to be removed in Gradle 10.0."}],"contextualLabel":"Properties should be assigned using the 'propName = value' syntax. Setting a property via the Gradle-generated 'propName value' or 'propName(value)' syntax in Groovy DSL has been deprecated.","documentationLink":"https://docs.gradle.org/8.13/userguide/upgrading_version_8.html#groovy_space_assignment_syntax","problemId":[{"name":"deprecation","displayName":"Deprecation"},{"name":"properties-should-be-assigned-using-the-propname-value-syntax-setting-a-property-via-the-gradle-generated-propname-value-or-propname-value-syntax-in-groovy-dsl","displayName":"Properties should be assigned using the 'propName = value' syntax. Setting a property via the Gradle-generated 'propName value' or 'propName(value)' syntax in Groovy DSL has been deprecated."}],"solutions":[[{"text":"Use assignment ('namespace = <value>') instead."}]]},{"locations":[{"path":"build file 'C:\\Users\\frank\\AppData\\Local\\Pub\\Cache\\hosted\\pub.dev\\file_picker-10.2.0\\android\\build.gradle'","line":1}],"problem":[{"text":"Properties should be assigned using the 'propName = value' syntax. Setting a property via the Gradle-generated 'propName value' or 'propName(value)' syntax in Groovy DSL has been deprecated."}],"severity":"WARNING","problemDetails":[{"text":"This is scheduled to be removed in Gradle 10.0."}],"contextualLabel":"Properties should be assigned using the 'propName = value' syntax. Setting a property via the Gradle-generated 'propName value' or 'propName(value)' syntax in Groovy DSL has been deprecated.","documentationLink":"https://docs.gradle.org/8.13/userguide/upgrading_version_8.html#groovy_space_assignment_syntax","problemId":[{"name":"deprecation","displayName":"Deprecation"},{"name":"properties-should-be-assigned-using-the-propname-value-syntax-setting-a-property-via-the-gradle-generated-propname-value-or-propname-value-syntax-in-groovy-dsl","displayName":"Properties should be assigned using the 'propName = value' syntax. Setting a property via the Gradle-generated 'propName value' or 'propName(value)' syntax in Groovy DSL has been deprecated."}],"solutions":[[{"text":"Use assignment ('group = <value>') instead."}]]},{"locations":[{"path":"build file 'C:\\Users\\frank\\AppData\\Local\\Pub\\Cache\\hosted\\pub.dev\\file_picker-10.2.0\\android\\build.gradle'","line":2}],"problem":[{"text":"Properties should be assigned using the 'propName = value' syntax. Setting a property via the Gradle-generated 'propName value' or 'propName(value)' syntax in Groovy DSL has been deprecated."}],"severity":"WARNING","problemDetails":[{"text":"This is scheduled to be removed in Gradle 10.0."}],"contextualLabel":"Properties should be assigned using the 'propName = value' syntax. Setting a property via the Gradle-generated 'propName value' or 'propName(value)' syntax in Groovy DSL has been deprecated.","documentationLink":"https://docs.gradle.org/8.13/userguide/upgrading_version_8.html#groovy_space_assignment_syntax","problemId":[{"name":"deprecation","displayName":"Deprecation"},{"name":"properties-should-be-assigned-using-the-propname-value-syntax-setting-a-property-via-the-gradle-generated-propname-value-or-propname-value-syntax-in-groovy-dsl","displayName":"Properties should be assigned using the 'propName = value' syntax. Setting a property via the Gradle-generated 'propName value' or 'propName(value)' syntax in Groovy DSL has been deprecated."}],"solutions":[[{"text":"Use assignment ('version = <value>') instead."}]]},{"locations":[{"path":"build file 'C:\\Users\\frank\\AppData\\Local\\Pub\\Cache\\hosted\\pub.dev\\file_picker-10.2.0\\android\\build.gradle'","line":30}],"problem":[{"text":"Properties should be assigned using the 'propName = value' syntax. Setting a property via the Gradle-generated 'propName value' or 'propName(value)' syntax in Groovy DSL has been deprecated."}],"severity":"WARNING","problemDetails":[{"text":"This is scheduled to be removed in Gradle 10.0."}],"contextualLabel":"Properties should be assigned using the 'propName = value' syntax. Setting a property via the Gradle-generated 'propName value' or 'propName(value)' syntax in Groovy DSL has been deprecated.","documentationLink":"https://docs.gradle.org/8.13/userguide/upgrading_version_8.html#groovy_space_assignment_syntax","problemId":[{"name":"deprecation","displayName":"Deprecation"},{"name":"properties-should-be-assigned-using-the-propname-value-syntax-setting-a-property-via-the-gradle-generated-propname-value-or-propname-value-syntax-in-groovy-dsl","displayName":"Properties should be assigned using the 'propName = value' syntax. Setting a property via the Gradle-generated 'propName value' or 'propName(value)' syntax in Groovy DSL has been deprecated."}],"solutions":[[{"text":"Use assignment ('compileSdk = <value>') instead."}]]},{"locations":[{"path":"build file 'C:\\Users\\frank\\AppData\\Local\\Pub\\Cache\\hosted\\pub.dev\\file_picker-10.2.0\\android\\build.gradle'","line":33}],"problem":[{"text":"Properties should be assigned using the 'propName = value' syntax. Setting a property via the Gradle-generated 'propName value' or 'propName(value)' syntax in Groovy DSL has been deprecated."}],"severity":"WARNING","problemDetails":[{"text":"This is scheduled to be removed in Gradle 10.0."}],"contextualLabel":"Properties should be assigned using the 'propName = value' syntax. Setting a property via the Gradle-generated 'propName value' or 'propName(value)' syntax in Groovy DSL has been deprecated.","documentationLink":"https://docs.gradle.org/8.13/userguide/upgrading_version_8.html#groovy_space_assignment_syntax","problemId":[{"name":"deprecation","displayName":"Deprecation"},{"name":"properties-should-be-assigned-using-the-propname-value-syntax-setting-a-property-via-the-gradle-generated-propname-value-or-propname-value-syntax-in-groovy-dsl","displayName":"Properties should be assigned using the 'propName = value' syntax. Setting a property via the Gradle-generated 'propName value' or 'propName(value)' syntax in Groovy DSL has been deprecated."}],"solutions":[[{"text":"Use assignment ('minSdk = <value>') instead."}]]},{"locations":[{"path":"build file 'C:\\Users\\frank\\AppData\\Local\\Pub\\Cache\\hosted\\pub.dev\\file_picker-10.2.0\\android\\build.gradle'","line":52}],"problem":[{"text":"Properties should be assigned using the 'propName = value' syntax. Setting a property via the Gradle-generated 'propName value' or 'propName(value)' syntax in Groovy DSL has been deprecated."}],"severity":"WARNING","problemDetails":[{"text":"This is scheduled to be removed in Gradle 10.0."}],"contextualLabel":"Properties should be assigned using the 'propName = value' syntax. Setting a property via the Gradle-generated 'propName value' or 'propName(value)' syntax in Groovy DSL has been deprecated.","documentationLink":"https://docs.gradle.org/8.13/userguide/upgrading_version_8.html#groovy_space_assignment_syntax","problemId":[{"name":"deprecation","displayName":"Deprecation"},{"name":"properties-should-be-assigned-using-the-propname-value-syntax-setting-a-property-via-the-gradle-generated-propname-value-or-propname-value-syntax-in-groovy-dsl","displayName":"Properties should be assigned using the 'propName = value' syntax. Setting a property via the Gradle-generated 'propName value' or 'propName(value)' syntax in Groovy DSL has been deprecated."}],"solutions":[[{"text":"Use assignment ('namespace = <value>') instead."}]]},{"locations":[{"path":"build file 'C:\\Users\\frank\\AppData\\Local\\Pub\\Cache\\hosted\\pub.dev\\firebase_auth-5.6.2\\android\\build.gradle'","line":1}],"problem":[{"text":"Properties should be assigned using the 'propName = value' syntax. Setting a property via the Gradle-generated 'propName value' or 'propName(value)' syntax in Groovy DSL has been deprecated."}],"severity":"WARNING","problemDetails":[{"text":"This is scheduled to be removed in Gradle 10.0."}],"contextualLabel":"Properties should be assigned using the 'propName = value' syntax. Setting a property via the Gradle-generated 'propName value' or 'propName(value)' syntax in Groovy DSL has been deprecated.","documentationLink":"https://docs.gradle.org/8.13/userguide/upgrading_version_8.html#groovy_space_assignment_syntax","problemId":[{"name":"deprecation","displayName":"Deprecation"},{"name":"properties-should-be-assigned-using-the-propname-value-syntax-setting-a-property-via-the-gradle-generated-propname-value-or-propname-value-syntax-in-groovy-dsl","displayName":"Properties should be assigned using the 'propName = value' syntax. Setting a property via the Gradle-generated 'propName value' or 'propName(value)' syntax in Groovy DSL has been deprecated."}],"solutions":[[{"text":"Use assignment ('group = <value>') instead."}]]},{"locations":[{"path":"build file 'C:\\Users\\frank\\AppData\\Local\\Pub\\Cache\\hosted\\pub.dev\\firebase_auth-5.6.2\\android\\build.gradle'","line":2}],"problem":[{"text":"Properties should be assigned using the 'propName = value' syntax. Setting a property via the Gradle-generated 'propName value' or 'propName(value)' syntax in Groovy DSL has been deprecated."}],"severity":"WARNING","problemDetails":[{"text":"This is scheduled to be removed in Gradle 10.0."}],"contextualLabel":"Properties should be assigned using the 'propName = value' syntax. Setting a property via the Gradle-generated 'propName value' or 'propName(value)' syntax in Groovy DSL has been deprecated.","documentationLink":"https://docs.gradle.org/8.13/userguide/upgrading_version_8.html#groovy_space_assignment_syntax","problemId":[{"name":"deprecation","displayName":"Deprecation"},{"name":"properties-should-be-assigned-using-the-propname-value-syntax-setting-a-property-via-the-gradle-generated-propname-value-or-propname-value-syntax-in-groovy-dsl","displayName":"Properties should be assigned using the 'propName = value' syntax. Setting a property via the Gradle-generated 'propName value' or 'propName(value)' syntax in Groovy DSL has been deprecated."}],"solutions":[[{"text":"Use assignment ('version = <value>') instead."}]]},{"locations":[{"path":"build file 'C:\\Users\\frank\\AppData\\Local\\Pub\\Cache\\hosted\\pub.dev\\firebase_auth-5.6.2\\android\\build.gradle'","line":36}],"problem":[{"text":"Properties should be assigned using the 'propName = value' syntax. Setting a property via the Gradle-generated 'propName value' or 'propName(value)' syntax in Groovy DSL has been deprecated."}],"severity":"WARNING","problemDetails":[{"text":"This is scheduled to be removed in Gradle 10.0."}],"contextualLabel":"Properties should be assigned using the 'propName = value' syntax. Setting a property via the Gradle-generated 'propName value' or 'propName(value)' syntax in Groovy DSL has been deprecated.","documentationLink":"https://docs.gradle.org/8.13/userguide/upgrading_version_8.html#groovy_space_assignment_syntax","problemId":[{"name":"deprecation","displayName":"Deprecation"},{"name":"properties-should-be-assigned-using-the-propname-value-syntax-setting-a-property-via-the-gradle-generated-propname-value-or-propname-value-syntax-in-groovy-dsl","displayName":"Properties should be assigned using the 'propName = value' syntax. Setting a property via the Gradle-generated 'propName value' or 'propName(value)' syntax in Groovy DSL has been deprecated."}],"solutions":[[{"text":"Use assignment ('namespace = <value>') instead."}]]}],"problemsReport":{"totalProblemCount":15,"buildName":"android","requestedTasks":"assembleDebug","documentationLink":"https://docs.gradle.org/8.13/userguide/reporting_problems.html","documentationLinkCaption":"Problem report","summaries":[{"problemId":[{"name":"deprecation","displayName":"Deprecation"},{"name":"properties-should-be-assigned-using-the-propname-value-syntax-setting-a-property-via-the-gradle-generated-propname-value-or-propname-value-syntax-in-groovy-dsl","displayName":"Properties should be assigned using the 'propName = value' syntax. Setting a property via the Gradle-generated 'propName value' or 'propName(value)' syntax in Groovy DSL has been deprecated."}],"count":18}]}}
// end-report-data
);}
</script>
                <script type="text/javascript">
                !function(n,t){"object"==typeof exports&&"object"==typeof module?module.exports=t():"function"==typeof define&&define.amd?define([],t):"object"==typeof exports?exports["configuration-cache-report"]=t():n["configuration-cache-report"]=t()}(this,(()=>(({70:function(){void 0===ArrayBuffer.isView&&(ArrayBuffer.isView=function(n){return null!=n&&null!=n.__proto__&&n.__proto__.__proto__===Int8Array.prototype.__proto__}),void 0===Math.imul&&(Math.imul=function(n,t){return(4294901760&n)*(65535&t)+(65535&n)*(0|t)|0}),this["configuration-cache-report"]=function(n){"use strict";var t,r,i,e,u,o,f,s,c,a,h,l,_,v,d,g,w,b,p,m,k,y,q,B,C,x,j,P,I,S,z,E,T,L,N,A,M,F,D,O,R,H,$,G,U,V,Q,Z,Y,W,K,X,J,nn,tn,rn,en,un,on,fn,sn,cn,an,hn,ln,_n,vn,dn,gn,wn,bn,pn,mn,kn,yn,qn,Bn,Cn,xn,jn,Pn,In,Sn,zn=Math.imul,En=ArrayBuffer.isView;function Tn(n,t){if(!(t>=0))throw fu(ie("Requested element count "+t+" is less than zero."));return function(n,t){if(!(t>=0))throw fu(ie("Requested element count "+t+" is less than zero."));if(0===t)return pt();if(t>=n.length)return function(n){switch(n.length){case 0:return pt();case 1:return gr(n[0]);default:return function(n){return Ar(function(n){return new qt(n,!1)}(n))}(n)}}(n);if(1===t)return gr(n[0]);var r=0,i=Nr(),e=0,u=n.length;n:for(;e<u;){var o=n[e];if(e=e+1|0,i.d(o),(r=r+1|0)===t)break n}return i}(n,Wn(n.length-t|0,0))}function Ln(n,t,r,i,e,u,o){return t=t===A?", ":t,r=r===A?"":r,i=i===A?"":i,e=e===A?-1:e,u=u===A?"...":u,o=o===A?null:o,function(n,t,r,i,e,u,o,f){r=r===A?", ":r,i=i===A?"":i,e=e===A?"":e,u=u===A?-1:u,o=o===A?"...":o,f=f===A?null:f,t.e(i);var s=0,c=0,a=n.length;n:for(;c<a;){var h=n[c];if(c=c+1|0,(s=s+1|0)>1&&t.e(r),!(u<0||s<=u))break n;Qt(t,h,f)}return u>=0&&s>u&&t.e(o),t.e(e),t}(n,bi(),t,r,i,e,u,o).toString()}function Nn(n){return n.length-1|0}function An(n,t){if(null==t){var r=0,i=n.length-1|0;if(r<=i)do{var e=r;if(r=r+1|0,null==n[e])return e}while(r<=i)}else{var u=0,o=n.length-1|0;if(u<=o)do{var f=u;if(u=u+1|0,oe(t,n[f]))return f}while(u<=o)}return-1}function Mn(n,t,r,i,e,u,o){return t=t===A?", ":t,r=r===A?"":r,i=i===A?"":i,e=e===A?-1:e,u=u===A?"...":u,o=o===A?null:o,Fn(n,bi(),t,r,i,e,u,o).toString()}function Fn(n,t,r,i,e,u,o,f){r=r===A?", ":r,i=i===A?"":i,e=e===A?"":e,u=u===A?-1:u,o=o===A?"...":o,f=f===A?null:f,t.e(i);var s=0,c=n.f();n:for(;c.g();){var a=c.h();if((s=s+1|0)>1&&t.e(r),!(u<0||s<=u))break n;Qt(t,a,f)}return u>=0&&s>u&&t.e(o),t.e(e),t}function Dn(n){if(n.i())throw mu("List is empty.");return n.j(0)}function On(n){return new Yn(n)}function Rn(n){if(Ue(n,Ti)){var t;switch(n.k()){case 0:t=pt();break;case 1:t=gr(Ue(n,Ei)?n.j(0):n.f().h());break;default:t=Hn(n)}return t}return mt(Vn(n))}function Hn(n){return Ar(n)}function $n(n){if(Ue(n,Ti)&&n.k()<=1)return Rn(n);var t=Vn(n);return function(n){var t=(n.k()/2|0)-1|0;if(t<0)return lr();var r=kt(n),i=0;if(i<=t)do{var e=i;i=i+1|0;var u=n.j(e);n.f4(e,n.j(r)),n.f4(r,u),r=r-1|0}while(e!==t)}(t),t}function Gn(n,t){if(!(t>=0))throw fu(ie("Requested element count "+t+" is less than zero."));return function(n,t){if(!(t>=0))throw fu(ie("Requested element count "+t+" is less than zero."));if(0===t)return pt();if(Ue(n,Ti)){if(t>=n.k())return Rn(n);if(1===t)return gr(function(n){if(Ue(n,Ei))return Dn(n);var t=n.f();if(!t.g())throw mu("Collection is empty.");return t.h()}(n))}var r=0,i=Nr(),e=n.f();n:for(;e.g();){var u=e.h();if(i.d(u),(r=r+1|0)===t)break n}return mt(i)}(n,Wn(n.k()-t|0,0))}function Un(n,t){if(!(t>=0))throw fu(ie("Requested element count "+t+" is less than zero."));if(0===t)return pt();var r=n.k();if(t>=r)return Rn(n);if(1===t)return gr(Qn(n));var i=Nr();if(Ue(n,li)){var e=r-t|0;if(e<r)do{var u=e;e=e+1|0,i.d(n.j(u))}while(e<r)}else for(var o=n.l(r-t|0);o.g();){var f=o.h();i.d(f)}return i}function Vn(n){return Ue(n,Ti)?Hn(n):Zn(n,Lr())}function Qn(n){if(n.i())throw mu("List is empty.");return n.j(kt(n))}function Zn(n,t){for(var r=n.f();r.g();){var i=r.h();t.d(i)}return t}function Yn(n){this.n_1=n}function Wn(n,t){return n<t?t:n}function Kn(n,t){return n>t?t:n}function Xn(n,t){return Ut().q(n,t,-1)}function Jn(n,t){return new Et(n,t)}function nt(n){var t=n.f();if(!t.g())return pt();var r=t.h();if(!t.g())return gr(r);var i=Lr();for(i.d(r);t.g();)i.d(t.h());return i}function tt(n){this.r_1=n}function rt(n,t){this.s_1=n,this.t_1=t}function it(){}function et(n){this.x_1=n,this.w_1=0}function ut(n,t){this.a1_1=n,et.call(this,n),ft().b1(t,this.a1_1.k()),this.w_1=t}function ot(){t=this}function ft(){return null==t&&new ot,t}function st(){ft(),it.call(this)}function ct(n){this.h1_1=n}function at(n,t){return t===n?"(this Map)":Oi(t)}function ht(n,t){var r;n:{for(var i=n.o().f();i.g();){var e=i.h();if(oe(e.j1(),t)){r=e;break n}}r=null}return r}function lt(){r=this}function _t(){return null==r&&new lt,r}function vt(n){this.q1_1=n,it.call(this)}function dt(){_t(),this.n1_1=null,this.o1_1=null}function gt(){i=this}function wt(){return null==i&&new gt,i}function bt(n){return n.length>0?nu(n):pt()}function pt(){return null==e&&new yt,e}function mt(n){switch(n.k()){case 0:return pt();case 1:return gr(n.j(0));default:return n}}function kt(n){return n.k()-1|0}function yt(){e=this,this.z1_1=new de(-1478467534,-1720727600)}function qt(n,t){this.b2_1=n,this.c2_1=t}function Bt(){u=this}function Ct(){return null==u&&new Bt,u}function xt(n,t){return Ue(n,Ti)?n.k():t}function jt(n,t){if(Ue(t,Ti))return n.m(t);for(var r=!1,i=t.f();i.g();){var e=i.h();n.d(e)&&(r=!0)}return r}function Pt(){}function It(n,t){this.h2_1=n,this.g2_1=n.i2_1.l(function(n,t){if(!(0<=t&&t<=n.k()))throw cu("Position index "+t+" must be in range ["+Oe(0,n.k())+"].");return n.k()-t|0}(n,t))}function St(n){st.call(this),this.i2_1=n}function zt(n){this.k2_1=n,this.j2_1=n.l2_1.f()}function Et(n,t){this.l2_1=n,this.m2_1=t}function Tt(n){for(;n.n2_1.g();){var t=n.n2_1.h();if(n.q2_1.t2_1(t)===n.q2_1.s2_1)return n.p2_1=t,n.o2_1=1,lr()}n.o2_1=0}function Lt(n){this.q2_1=n,this.n2_1=n.r2_1.f(),this.o2_1=-1,this.p2_1=null}function Nt(n,t,r){t=t===A||t,this.r2_1=n,this.s2_1=t,this.t2_1=r}function At(){return null==o&&new Mt,o}function Mt(){o=this,this.u2_1=new de(1993859828,793161749)}function Ft(n,t,r){return Dt(Dt(n,r)-Dt(t,r)|0,r)}function Dt(n,t){var r=n%t|0;return r>=0?r:r+t|0}function Ot(){f=this,this.p_1=new Ht(1,0)}function Rt(){return null==f&&new Ot,f}function Ht(n,t){Rt(),Vt.call(this,n,t,1)}function $t(n,t,r){Pt.call(this),this.d3_1=r,this.e3_1=t,this.f3_1=this.d3_1>0?n<=t:n>=t,this.g3_1=this.f3_1?n:this.e3_1}function Gt(){s=this}function Ut(){return null==s&&new Gt,s}function Vt(n,t,r){if(Ut(),0===r)throw fu("Step must be non-zero.");if(r===vr().MIN_VALUE)throw fu("Step must be greater than Int.MIN_VALUE to avoid overflow on negation.");this.z2_1=n,this.a3_1=function(n,t,r){var i;if(r>0)i=n>=t?t:t-Ft(t,n,r)|0;else{if(!(r<0))throw fu("Step is zero.");i=n<=t?t:t+Ft(n,t,0|-r)|0}return i}(n,t,r),this.b3_1=r}function Qt(n,t,r){null!=r?n.e(r(t)):null==t||Ze(t)?n.e(t):t instanceof zi?n.i3(t.h3_1):n.e(Oi(t))}function Zt(n,t,r){if(n===t)return!0;if(!(r=r!==A&&r))return!1;var i=mi(n),e=mi(t);return i===e||oe(new zi(Zi(Pi(i).toLowerCase(),0)),new zi(Zi(Pi(e).toLowerCase(),0)))}function Yt(n){return Wi(n)-1|0}function Wt(n,t,r,i){return r=r===A?0:r,(i=i!==A&&i)||"string"!=typeof n?Kt(n,t,r,Wi(n),i):n.indexOf(t,r)}function Kt(n,t,r,i,e,u){var o=(u=u!==A&&u)?Xn(Kn(r,Yt(n)),Wn(i,0)):Oe(Wn(r,0),Kn(i,Wi(n)));if("string"==typeof n&&"string"==typeof t){var f=o.z2_1,s=o.a3_1,c=o.b3_1;if(c>0&&f<=s||c<0&&s<=f)do{var a=f;if(f=f+c|0,xi(t,0,n,a,Wi(t),e))return a}while(a!==s)}else{var h=o.z2_1,l=o.a3_1,_=o.b3_1;if(_>0&&h<=l||_<0&&l<=h)do{var v=h;if(h=h+_|0,tr(t,0,n,v,Wi(t),e))return v}while(v!==l)}return-1}function Xt(n){var t=0,r=Wi(n)-1|0,i=!1;n:for(;t<=r;){var e=ki(Zi(n,i?r:t));if(i){if(!e)break n;r=r-1|0}else e?t=t+1|0:i=!0}return Ki(n,t,r+1|0)}function Jt(n,t){return ie(Ki(n,t.y2(),t.c3()+1|0))}function nr(n,t,r,i,e){r=r===A?0:r,i=i!==A&&i,rr(e=e===A?0:e);var u,o,f=nu(t);return new ur(n,r,e,(u=f,o=i,function(n,t){var r=function(n,t,r,i){if(!i&&1===t.k()){var e=function(n){if(Ue(n,Ei))return function(n){var t;switch(n.k()){case 0:throw mu("List is empty.");case 1:t=n.j(0);break;default:throw fu("List has more than one element.")}return t}(n);var t=n.f();if(!t.g())throw mu("Collection is empty.");var r=t.h();if(t.g())throw fu("Collection has more than one element.");return r}(t),u=Wt(n,e,r);return u<0?null:fr(u,e)}var o=Oe(Wn(r,0),Wi(n));if("string"==typeof n){var f=o.z2_1,s=o.a3_1,c=o.b3_1;if(c>0&&f<=s||c<0&&s<=f)do{var a,h=f;f=f+c|0;n:{for(var l=t.f();l.g();){var _=l.h();if(xi(_,0,n,h,_.length,i)){a=_;break n}}a=null}if(null!=a)return fr(h,a)}while(h!==s)}else{var v=o.z2_1,d=o.a3_1,g=o.b3_1;if(g>0&&v<=d||g<0&&d<=v)do{var w,b=v;v=v+g|0;n:{for(var p=t.f();p.g();){var m=p.h();if(tr(m,0,n,b,m.length,i)){w=m;break n}}w=null}if(null!=w)return fr(b,w)}while(b!==d)}return null}(n,u,t,o);return null==r?null:fr(r.t3_1,r.u3_1.length)}))}function tr(n,t,r,i,e,u){if(i<0||t<0||t>(Wi(n)-e|0)||i>(Wi(r)-e|0))return!1;var o=0;if(o<e)do{var f=o;if(o=o+1|0,!Zt(Zi(n,t+f|0),Zi(r,i+f|0),u))return!1}while(o<e);return!0}function rr(n){if(!(n>=0))throw fu(ie("Limit must be non-negative, but was "+n))}function ir(n){if(n.l3_1<0)n.j3_1=0,n.m3_1=null;else{var t;if(n.o3_1.r3_1>0?(n.n3_1=n.n3_1+1|0,t=n.n3_1>=n.o3_1.r3_1):t=!1,t||n.l3_1>Wi(n.o3_1.p3_1))n.m3_1=Oe(n.k3_1,Yt(n.o3_1.p3_1)),n.l3_1=-1;else{var r=n.o3_1.s3_1(n.o3_1.p3_1,n.l3_1);if(null==r)n.m3_1=Oe(n.k3_1,Yt(n.o3_1.p3_1)),n.l3_1=-1;else{var i=r.v3(),e=r.w3();n.m3_1=function(n,t){return t<=vr().MIN_VALUE?Rt().p_1:Oe(n,t-1|0)}(n.k3_1,i),n.k3_1=i+e|0,n.l3_1=n.k3_1+(0===e?1:0)|0}}n.j3_1=1}}function er(n){this.o3_1=n,this.j3_1=-1,this.k3_1=function(n,t,r){if(0>r)throw fu("Cannot coerce value to an empty range: maximum "+r+" is less than minimum 0.");return n<0?0:n>r?r:n}(n.q3_1,0,Wi(n.p3_1)),this.l3_1=this.k3_1,this.m3_1=null,this.n3_1=0}function ur(n,t,r,i){this.p3_1=n,this.q3_1=t,this.r3_1=r,this.s3_1=i}function or(n,t){this.t3_1=n,this.u3_1=t}function fr(n,t){return new or(n,t)}function sr(){}function cr(){}function ar(){}function hr(){c=this}function lr(){return null==c&&new hr,c}function _r(){a=this,this.MIN_VALUE=-2147483648,this.MAX_VALUE=2147483647,this.SIZE_BYTES=4,this.SIZE_BITS=32}function vr(){return null==a&&new _r,a}function dr(n){for(var t=[],r=n.f();r.g();)t.push(r.h());return t}function gr(n){return 0===(t=[n]).length?Lr():Ar(new qt(t,!0));var t}function wr(n){return n<0&&function(){throw yu("Index overflow has happened.")}(),n}function br(n){return void 0!==n.toArray?n.toArray():dr(n)}function pr(n){return function(n,t){for(var r=0,i=n.length;r<i;){var e=n[r];r=r+1|0,t.d(e)}return t}(t=[n],(r=t.length,i=ce(se(Zr)),function(n,t,r){zr.call(r),Zr.call(r),r.y5_1=function(n){return Ur(n,0,ce(se(Vr)))}(n)}(r,0,i),i));var t,r,i}function mr(){it.call(this)}function kr(n){this.j4_1=n,this.h4_1=0,this.i4_1=-1}function yr(n,t){this.n4_1=n,kr.call(this,n),ft().b1(t,this.n4_1.k()),this.h4_1=t}function qr(){mr.call(this),this.o4_1=0}function Br(n){this.r4_1=n}function Cr(n){this.s4_1=n}function xr(n,t){this.t4_1=n,this.u4_1=t}function jr(){zr.call(this)}function Pr(n){this.x4_1=n,zr.call(this)}function Ir(n){this.e5_1=n,mr.call(this)}function Sr(){dt.call(this),this.c5_1=null,this.d5_1=null}function zr(){mr.call(this)}function Er(){h=this;var n=Nr();n.c_1=!0,this.i5_1=n}function Tr(){return null==h&&new Er,h}function Lr(){return n=ce(se(Fr)),t=[],Fr.call(n,t),n;var n,t}function Nr(n){return t=ce(se(Fr)),r=[],Fr.call(t,r),t;var t,r}function Ar(n){return function(n,t){var r;return r=br(n),Fr.call(t,r),t}(n,ce(se(Fr)))}function Mr(n,t){return ft().e1(t,n.k()),t}function Fr(n){Tr(),qr.call(this),this.b_1=n,this.c_1=!1}function Dr(n,t,r,i,e){if(r===i)return n;var u=(r+i|0)/2|0,o=Dr(n,t,r,u,e),f=Dr(n,t,u+1|0,i,e),s=o===t?n:t,c=r,a=u+1|0,h=r;if(h<=i)do{var l=h;if(h=h+1|0,c<=u&&a<=i){var _=o[c],v=f[a];e.compare(_,v)<=0?(s[l]=_,c=c+1|0):(s[l]=v,a=a+1|0)}else c<=u?(s[l]=o[c],c=c+1|0):(s[l]=f[a],a=a+1|0)}while(l!==i);return s}function Or(n,t){return(3&n)-(3&t)|0}function Rr(){_=this}function Hr(n){this.n5_1=n,jr.call(this)}function $r(n){return function(n,t){Sr.call(t),Vr.call(t),t.t5_1=n,t.u5_1=n.w5()}(new Jr((null==_&&new Rr,_)),n),n}function Gr(){return $r(ce(se(Vr)))}function Ur(n,t,r){if($r(r),!(n>=0))throw fu(ie("Negative initial capacity: "+n));if(!(t>=0))throw fu(ie("Non-positive load factor: "+t));return r}function Vr(){this.v5_1=null}function Qr(n,t){return zr.call(t),Zr.call(t),t.y5_1=n,t}function Zr(){}function Yr(n,t){var r=Kr(n,n.h6_1.m5(t));if(null==r)return null;var i=r;if(null!=i&&Ve(i))return Wr(i,n,t);var e=i;return n.h6_1.l5(e.j1(),t)?e:null}function Wr(n,t,r){var i;n:{for(var e=0,u=n.length;e<u;){var o=n[e];if(e=e+1|0,t.h6_1.l5(o.j1(),r)){i=o;break n}}i=null}return i}function Kr(n,t){var r=n.i6_1[t];return void 0===r?null:r}function Xr(n){this.g6_1=n,this.z5_1=-1,this.a6_1=Object.keys(n.i6_1),this.b6_1=-1,this.c6_1=null,this.d6_1=!1,this.e6_1=-1,this.f6_1=null}function Jr(n){this.h6_1=n,this.i6_1=this.k6(),this.j6_1=0}function ni(){}function ti(n){this.n6_1=n,this.l6_1=null,this.m6_1=null,this.m6_1=this.n6_1.y6_1.v6_1}function ri(){v=this;var n,t=(fi(0,0,n=ce(se(si))),n);t.x6_1=!0,this.e7_1=t}function ii(){return null==v&&new ri,v}function ei(n,t,r){this.d7_1=n,xr.call(this,t,r),this.b7_1=null,this.c7_1=null}function ui(n){this.y6_1=n,jr.call(this)}function oi(){return $r(n=ce(se(si))),si.call(n),n.w6_1=Gr(),n;var n}function fi(n,t,r){return Ur(n,t,r),si.call(r),r.w6_1=Gr(),r}function si(){ii(),this.v6_1=null,this.x6_1=!1}function ci(){d=this;var n=ai(0),t=n.y5_1;(t instanceof si?t:_e()).j5(),this.f7_1=n}function ai(n){return function(n,t){return function(n,t,r){Qr(function(n,t){return fi(n,t,ce(se(si)))}(n,t),r),hi.call(r)}(n,0,t),t}(n,ce(se(hi)))}function hi(){null==d&&new ci}function li(){}function _i(){}function vi(n){_i.call(this),this.k7_1=n}function di(){gi.call(this)}function gi(){_i.call(this),this.m7_1=""}function wi(){if(!w){w=!0;var n="undefined"!=typeof process&&process.versions&&!!process.versions.node;g=n?new vi(process.stdout):new di}}function bi(){return n=ce(se(pi)),pi.call(n,""),n;var n}function pi(n){this.o7_1=void 0!==n?n:""}function mi(n){var t=Pi(n).toUpperCase();return t.length>1?n:Zi(t,0)}function ki(n){return function(n){return 9<=n&&n<=13||28<=n&&n<=32||160===n||n>4096&&(5760===n||8192<=n&&n<=8202||8232===n||8233===n||8239===n||8287===n||12288===n)}(n)}function yi(){b=this,this.q7_1=new RegExp("[\\\\^$*+?.()|[\\]{}]","g"),this.r7_1=new RegExp("[\\\\$]","g"),this.s7_1=new RegExp("\\$","g")}function qi(){return null==b&&new yi,b}function Bi(n,t){qi(),this.v7_1=n,this.w7_1=function(n){if(Ue(n,Ti)){var t;switch(n.k()){case 0:t=At();break;case 1:t=pr(Ue(n,Ei)?n.j(0):n.f().h());break;default:t=Zn(n,ai(n.k()))}return t}return function(n){switch(n.k()){case 0:return At();case 1:return pr(n.f().h());default:return n}}(Zn(n,(r=ce(se(hi)),Qr(oi(),r),hi.call(r),r)));var r}(t),this.x7_1=new RegExp(n,Mn(t,"","gu",A,A,A,Ci)),this.y7_1=null,this.z7_1=null}function Ci(n){return n.d8_1}function xi(n,t,r,i,e,u){return tr(n,t,r,i,e,u=u!==A&&u)}function ji(n,t){return n-t|0}function Pi(n){return String.fromCharCode(n)}function Ii(){p=this,this.e8_1=0,this.f8_1=65535,this.g8_1=55296,this.h8_1=56319,this.i8_1=56320,this.j8_1=57343,this.k8_1=55296,this.l8_1=57343,this.m8_1=2,this.n8_1=16}function Si(){return null==p&&new Ii,p}function zi(n){Si(),this.h3_1=n}function Ei(){}function Ti(){}function Li(){}function Ni(){}function Ai(){}function Mi(){}function Fi(){m=this}function Di(n,t){null==m&&new Fi,this.p8_1=n,this.q8_1=t}function Oi(n){var t=null==n?null:ie(n);return null==t?"null":t}function Ri(n){return new Hi(n)}function Hi(n){this.t8_1=n,this.s8_1=0}function $i(){return Qi(),k}function Gi(){return Qi(),y}function Ui(){return Qi(),q}function Vi(){return Qi(),B}function Qi(){x||(x=!0,k=new ArrayBuffer(8),y=new Float64Array($i()),new Float32Array($i()),q=new Int32Array($i()),Gi()[0]=-1,B=0!==Ui()[0]?1:0,C=1-Vi()|0)}function Zi(n,t){var r;if(Yi(n)){var i,e=n.charCodeAt(t);if(Si(),e<0?i=!0:(Si(),i=e>65535),i)throw fu("Invalid Char code: "+e);r=De(e)}else r=n.y3(t);return r}function Yi(n){return"string"==typeof n}function Wi(n){return Yi(n)?n.length:n.x3()}function Ki(n,t,r){return Yi(n)?n.substring(t,r):n.z3(t,r)}function Xi(n){return ie(n)}function Ji(n,t){var r;switch(typeof n){case"number":r="number"==typeof t?ne(n,t):t instanceof de?ne(n,t.w8()):te(n,t);break;case"string":case"boolean":r=te(n,t);break;default:r=function(n,t){return n.a4(t)}(n,t)}return r}function ne(n,t){var r;if(n<t)r=-1;else if(n>t)r=1;else if(n===t){var i;if(0!==n)i=0;else{var e=1/n;i=e===1/t?0:e<0?-1:1}r=i}else r=n!=n?t!=t?0:1:-1;return r}function te(n,t){return n<t?-1:n>t?1:0}function re(n){if(!("kotlinHashCodeValue$"in n)){var t=4294967296*Math.random()|0,r=new Object;r.value=t,r.enumerable=!1,Object.defineProperty(n,"kotlinHashCodeValue$",r)}return n.kotlinHashCodeValue$}function ie(n){return null==n?"null":function(n){return!!$e(n)||En(n)}(n)?"[...]":n.toString()}function ee(n){if(null==n)return 0;var t;switch(typeof n){case"object":t="function"==typeof n.hashCode?n.hashCode():re(n);break;case"function":t=re(n);break;case"number":t=function(n){return Qi(),(0|n)===n?Fe(n):(Gi()[0]=n,zn(Ui()[(Qi(),C)],31)+Ui()[Vi()]|0)}(n);break;case"boolean":t=n?1:0;break;default:t=ue(String(n))}return t}function ue(n){var t=0,r=0,i=n.length-1|0;if(r<=i)do{var e=r;r=r+1|0;var u=n.charCodeAt(e);t=zn(t,31)+u|0}while(e!==i);return t}function oe(n,t){return null==n?null==t:null!=t&&("object"==typeof n&&"function"==typeof n.equals?n.equals(t):n!=n?t!=t:"number"==typeof n&&"number"==typeof t?n===t&&(0!==n||1/n==1/t):n===t)}function fe(n,t){null!=Error.captureStackTrace?Error.captureStackTrace(n,t):n.stack=(new Error).stack}function se(n){return n.prototype}function ce(n){return Object.create(n)}function ae(n,t,r){Error.call(n),function(n,t,r){var i=Xe(Object.getPrototypeOf(n));if(!(1&i)){var e;if(null==t){var u;if(null!==t){var o=null==r?null:r.toString();u=null==o?A:o}else u=A;e=u}else e=t;n.message=e}2&i||(n.cause=r),n.name=Object.getPrototypeOf(n).constructor.name}(n,t,r)}function he(n){var t;return null==n?function(){throw ju()}():t=n,t}function le(){throw Iu()}function _e(){throw zu()}function ve(){j=this,this.x8_1=new de(0,-2147483648),this.y8_1=new de(-1,2147483647),this.z8_1=8,this.a9_1=64}function de(n,t){null==j&&new ve,ar.call(this),this.u8_1=n,this.v8_1=t}function ge(){return Me(),P}function we(){return Me(),I}function be(){return Me(),S}function pe(){return Me(),E}function me(){return Me(),T}function ke(n,t){if(Me(),xe(n,t))return 0;var r=Ie(n),i=Ie(t);return r&&!i?-1:!r&&i?1:Ie(qe(n,t))?-1:1}function ye(n,t){Me();var r=n.v8_1>>>16|0,i=65535&n.v8_1,e=n.u8_1>>>16|0,u=65535&n.u8_1,o=t.v8_1>>>16|0,f=65535&t.v8_1,s=t.u8_1>>>16|0,c=0,a=0,h=0,l=0;return c=(c=c+((a=(a=a+((h=(h=h+((l=l+(u+(65535&t.u8_1)|0)|0)>>>16|0)|0)+(e+s|0)|0)>>>16|0)|0)+(i+f|0)|0)>>>16|0)|0)+(r+o|0)|0,new de((h&=65535)<<16|(l&=65535),(c&=65535)<<16|(a&=65535))}function qe(n,t){return Me(),ye(n,t.e9())}function Be(n,t){if(Me(),Se(n))return ge();if(Se(t))return ge();if(xe(n,pe()))return ze(t)?pe():ge();if(xe(t,pe()))return ze(n)?pe():ge();if(Ie(n))return Ie(t)?Be(Ee(n),Ee(t)):Ee(Be(Ee(n),t));if(Ie(t))return Ee(Be(n,Ee(t)));if(Te(n,me())&&Te(t,me()))return Le(Ce(n)*Ce(t));var r=n.v8_1>>>16|0,i=65535&n.v8_1,e=n.u8_1>>>16|0,u=65535&n.u8_1,o=t.v8_1>>>16|0,f=65535&t.v8_1,s=t.u8_1>>>16|0,c=65535&t.u8_1,a=0,h=0,l=0,_=0;return l=l+((_=_+zn(u,c)|0)>>>16|0)|0,_&=65535,h=(h=h+((l=l+zn(e,c)|0)>>>16|0)|0)+((l=(l&=65535)+zn(u,s)|0)>>>16|0)|0,l&=65535,a=(a=(a=a+((h=h+zn(i,c)|0)>>>16|0)|0)+((h=(h&=65535)+zn(e,s)|0)>>>16|0)|0)+((h=(h&=65535)+zn(u,f)|0)>>>16|0)|0,h&=65535,a=a+(((zn(r,c)+zn(i,s)|0)+zn(e,f)|0)+zn(u,o)|0)|0,new de(l<<16|_,(a&=65535)<<16|h)}function Ce(n){return Me(),4294967296*n.v8_1+function(n){return Me(),n.u8_1>=0?n.u8_1:4294967296+n.u8_1}(n)}function xe(n,t){return Me(),n.v8_1===t.v8_1&&n.u8_1===t.u8_1}function je(n,t){if(Me(),t<2||36<t)throw vu("radix out of range: "+t);if(Se(n))return"0";if(Ie(n)){if(xe(n,pe())){var r=Pe(t),i=n.d9(r),e=qe(Be(i,r),n).g9();return je(i,t)+e.toString(t)}return"-"+je(Ee(n),t)}for(var u=2===t?31:t<=10?9:t<=21?7:t<=35?6:5,o=Le(Math.pow(t,u)),f=n,s="";;){var c=f.d9(o),a=qe(f,Be(c,o)).g9().toString(t);if(Se(f=c))return a+s;for(;a.length<u;)a="0"+a;s=a+s}}function Pe(n){return Me(),new de(n,n<0?-1:0)}function Ie(n){return Me(),n.v8_1<0}function Se(n){return Me(),0===n.v8_1&&0===n.u8_1}function ze(n){return Me(),!(1&~n.u8_1)}function Ee(n){return Me(),n.e9()}function Te(n,t){return Me(),ke(n,t)<0}function Le(n){if(Me(),(t=n)!=t)return ge();if(n<=-0x8000000000000000)return pe();if(n+1>=0x8000000000000000)return Me(),z;if(n<0)return Ee(Le(-n));var t,r=4294967296;return new de(n%r|0,n/r|0)}function Ne(n,t){return Me(),ke(n,t)>0}function Ae(n,t){return Me(),ke(n,t)>=0}function Me(){L||(L=!0,P=Pe(0),I=Pe(1),S=Pe(-1),z=new de(-1,2147483647),E=new de(0,-2147483648),T=Pe(16777216))}function Fe(n){return n instanceof de?n.g9():function(n){return n>2147483647?2147483647:n<-2147483648?-2147483648:0|n}(n)}function De(n){var t;return t=function(n){return n<<16>>16}(Fe(n)),function(n){return 65535&n}(t)}function Oe(n,t){return new Ht(n,t)}function Re(n,t,r,i){return He("class",n,t,r,i,null)}function He(n,t,r,i,e,u){return{kind:n,simpleName:t,associatedObjectKey:r,associatedObjects:i,suspendArity:e,$kClass$:A,iid:u}}function $e(n){return Array.isArray(n)}function Ge(n,t,r,i,e,u,o,f){null!=i&&(n.prototype=Object.create(i.prototype),n.prototype.constructor=n);var s=r(t,u,o,null==f?[]:f);n.$metadata$=s,null!=e&&((null!=s.iid?n:n.prototype).$imask$=function(n){for(var t=1,r=[],i=0,e=n.length;i<e;){var u=n[i];i=i+1|0;var o=t,f=u.prototype.$imask$,s=null==f?u.$imask$:f;null!=s&&(r.push(s),o=s.length);var c=u.$metadata$.iid,a=null==c?null:(l=void 0,v=1<<(31&(h=c)),(l=new Int32Array(1+(h>>5)|0))[_=h>>5]=l[_]|v,l);null!=a&&(r.push(a),o=Math.max(o,a.length)),o>t&&(t=o)}var h,l,_,v;return function(n,t){for(var r=0,i=new Int32Array(n);r<n;){for(var e=r,u=0,o=0,f=t.length;o<f;){var s=t[o];o=o+1|0,e<s.length&&(u|=s[e])}i[e]=u,r=r+1|0}return i}(t,r)}(e))}function Ue(n,t){return function(n,t){var r=n.$imask$;return null!=r&&function(n,t){var r=t>>5;if(r>n.length)return!1;var i=1<<(31&t);return!!(n[r]&i)}(r,t)}(n,t.$metadata$.iid)}function Ve(n){return!!$e(n)&&!n.$type$}function Qe(n){var t;switch(typeof n){case"string":case"number":case"boolean":case"function":t=!0;break;default:t=n instanceof Object}return t}function Ze(n){return"string"==typeof n||Ue(n,sr)}function Ye(n,t,r,i){return He("interface",n,t,r,i,(null==N&&(N=0),N=We()+1|0,We()))}function We(){if(null!=N)return N;!function(){throw Tu("lateinit property iid has not been initialized")}()}function Ke(n,t,r,i){return He("object",n,t,r,i,null)}function Xe(n){var t=n.constructor,r=null==t?null:t.$metadata$,i=null==r?null:r.errorInfo;if(null!=i)return i;var e,u=0;if(Je(n,"message")&&(u|=1),Je(n,"cause")&&(u|=2),3!==u){var o=(e=n,Object.getPrototypeOf(e));o!=Error.prototype&&(u|=Xe(o))}return null!=r&&(r.errorInfo=u),u}function Je(n,t){return n.hasOwnProperty(t)}function nu(n){return new Fr(n)}function tu(n,t,r){for(var i=new Int32Array(r),e=0,u=0,o=0,f=0,s=n.length;f<s;){var c=Zi(n,f);f=f+1|0;var a=t[c];if(u|=(31&a)<<o,a<32){var h=e;e=h+1|0,i[h]=u,u=0,o=0}else o=o+5|0}return i}function ru(n,t){for(var r=0,i=n.length-1|0,e=-1,u=0;r<=i;)if(t>(u=n[e=(r+i|0)/2|0]))r=e+1|0;else{if(t===u)return e;i=e-1|0}return e-(t<u?1:0)|0}function iu(){M=this;var n="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",t=new Int32Array(128),r=0,i=Wi(n)-1|0;if(r<=i)do{var e=r;r=r+1|0,t[Zi(n,e)]=e}while(r<=i);var u=tu("hCgBpCQGYHZH5BRpBPPPPPPRMP5BPPlCPP6BkEPPPPcPXPzBvBrB3BOiDoBHwD+E3DauCnFmBmB2D6E1BlBTiBmBlBP5BhBiBrBvBjBqBnBPRtBiCmCtBlB0BmB5BiB7BmBgEmChBZgCoEoGVpBSfRhBPqKQ2BwBYoFgB4CJuTiEvBuCuDrF5DgEgFlJ1DgFmBQtBsBRGsB+BPiBlD1EIjDPRPPPQPPPPPGQSQS/DxENVNU+B9zCwBwBPPCkDPNnBPqDYY1R8B7FkFgTgwGgwUwmBgKwBuBScmEP/BPPPPPPrBP8B7F1B/ErBqC6B7BiBmBfQsBUwCw/KwqIwLwETPcPjQgJxFgBlBsD",t,222),o=new Int32Array(u.length),f=0,s=u.length-1|0;if(f<=s)do{var c=f;f=f+1|0,o[c]=0===c?u[c]:o[c-1|0]+u[c]|0}while(f<=s);this.h9_1=o,this.i9_1=tu("aaMBXHYH5BRpBPPPPPPRMP5BPPlCPPzBDOOPPcPXPzBvBjB3BOhDmBBpB7DoDYxB+EiBP1DoExBkBQhBekBPmBgBhBctBiBMWOOXhCsBpBkBUV3Ba4BkB0DlCgBXgBtD4FSdBfPhBPpKP0BvBXjEQ2CGsT8DhBtCqDpFvD1D3E0IrD2EkBJrBDOBsB+BPiBlB1EIjDPPPPPPPPPPPGPPMNLsBNPNPKCvBvBPPCkDPBmBPhDXXgD4B6FzEgDguG9vUtkB9JcuBSckEP/BPPPPPPBPf4FrBjEhBpC3B5BKaWPrBOwCk/KsCuLqDHPbPxPsFtEaaqDL",t,222),this.j9_1=tu("GFjgggUHGGFFZZZmzpz5qB6s6020B60ptltB6smt2sB60mz22B1+vv+8BZZ5s2850BW5q1ymtB506smzBF3q1q1qB1q1q1+Bgii4wDTm74g3KiggxqM60q1q1Bq1o1q1BF1qlrqrBZ2q5wprBGFZWWZGHFsjiooLowgmOowjkwCkgoiIk7ligGogiioBkwkiYkzj2oNoi+sbkwj04DghhkQ8wgiYkgoioDsgnkwC4gikQ//v+85BkwvoIsgoyI4yguI0whiwEowri4CoghsJowgqYowgm4DkwgsY/nwnzPowhmYkg6wI8yggZswikwHgxgmIoxgqYkwgk4DkxgmIkgoioBsgssoBgzgyI8g9gL8g9kI0wgwJoxgkoC0wgioFkw/wI0w53iF4gioYowjmgBHGq1qkgwBF1q1q8qBHwghuIwghyKk0goQkwgoQk3goQHGFHkyg0pBgxj6IoinkxDswno7Ikwhz9Bo0gioB8z48Rwli0xN0mpjoX8w78pDwltoqKHFGGwwgsIHFH3q1q16BFHWFZ1q10q1B2qlwq1B1q10q1B2q1yq1B6q1gq1Biq1qhxBir1qp1Bqt1q1qB1g1q1+B//3q16B///q1qBH/qlqq9Bholqq9B1i00a1q10qD1op1HkwmigEigiy6Cptogq1Bixo1kDq7/j00B2qgoBWGFm1lz50B6s5q1+BGWhggzhwBFFhgk4//Bo2jigE8wguI8wguI8wgugUog1qoB4qjmIwwi2KgkYHHH4lBgiFWkgIWoghssMmz5smrBZ3q1y50B5sm7gzBtz1smzB5smz50BqzqtmzB5sgzqzBF2/9//5BowgoIwmnkzPkwgk4C8ys65BkgoqI0wgy6FghquZo2giY0ghiIsgh24B4ghsQ8QF/v1q1OFs0O8iCHHF1qggz/B8wg6Iznv+//B08QgohsjK0QGFk7hsQ4gB",t,222)}function eu(){return null==M&&new iu,M}function uu(){F=this,this.k9_1=new Int32Array([170,186,688,704,736,837,890,7468,7544,7579,8305,8319,8336,8560,9424,11388,42652,42864,43e3,43868]),this.l9_1=new Int32Array([1,1,9,2,5,1,1,63,1,37,1,1,13,16,26,2,2,1,2,4])}function ou(){return null==F&&new uu,F}function fu(n){var t=function(n,t){return wu(n,t),su.call(t),t}(n,ce(se(su)));return fe(t,fu),t}function su(){fe(this,su)}function cu(n){var t=function(n,t){return wu(n,t),au.call(t),t}(n,ce(se(au)));return fe(t,cu),t}function au(){fe(this,au)}function hu(n){var t=function(n,t){return wu(n,t),lu.call(t),t}(n,ce(se(lu)));return fe(t,hu),t}function lu(){fe(this,lu)}function _u(n,t){return ae(t,n),du.call(t),t}function vu(n){var t=_u(n,ce(se(du)));return fe(t,vu),t}function du(){fe(this,du)}function gu(n){return function(n){ae(n),du.call(n)}(n),bu.call(n),n}function wu(n,t){return _u(n,t),bu.call(t),t}function bu(){fe(this,bu)}function pu(){var n,t=(gu(n=ce(se(ku))),ku.call(n),n);return fe(t,pu),t}function mu(n){var t=function(n,t){return wu(n,t),ku.call(t),t}(n,ce(se(ku)));return fe(t,mu),t}function ku(){fe(this,ku)}function yu(n){var t=function(n,t){return wu(n,t),qu.call(t),t}(n,ce(se(qu)));return fe(t,yu),t}function qu(){fe(this,qu)}function Bu(){var n,t=(gu(n=ce(se(xu))),xu.call(n),n);return fe(t,Bu),t}function Cu(n){var t=function(n,t){return wu(n,t),xu.call(t),t}(n,ce(se(xu)));return fe(t,Cu),t}function xu(){fe(this,xu)}function ju(){var n,t=(gu(n=ce(se(Pu))),Pu.call(n),n);return fe(t,ju),t}function Pu(){fe(this,Pu)}function Iu(){var n,t=(gu(n=ce(se(Su))),Su.call(n),n);return fe(t,Iu),t}function Su(){fe(this,Su)}function zu(){var n,t=(gu(n=ce(se(Eu))),Eu.call(n),n);return fe(t,zu),t}function Eu(){fe(this,Eu)}function Tu(n){var t=function(n,t){return wu(n,t),Lu.call(t),t}(n,ce(se(Lu)));return fe(t,Tu),t}function Lu(){fe(this,Lu)}function Nu(n,t){var r,i=n.className;return(r="(^|.*\\s+)"+t+"($|\\s+.*)",function(n,t){return Bi.call(t,n,At()),t}(r,ce(se(Bi)))).a8(i)}function Au(n,t){this.o9_1=n,this.p9_1=t}function Mu(n){this.q9_1=n}function Fu(n,t,r){var i,e=Ff(),u=Wu(),o=Mf().ga(t),f=Wu();if(0===Wi(r))i=Lf();else{var s=n.ia_1,c=null==s?null:new Mu(s).v9(r,"Copy reference to the clipboard");i=null==c?Lf():c}return e.ja([u,o,f,i])}function Du(n){n=n===A?null:n,this.ia_1=n}function Ou(n,t,r){Yu.call(this),this.ma_1=n,this.na_1=t,this.oa_1=r}function Ru(n,t){this.ra_1=n,this.sa_1=t}function Hu(n,t){Yu.call(this),this.va_1=n,this.wa_1=t}function $u(n,t){Yu.call(this),this.xa_1=n,this.ya_1=t}function Gu(n){Yu.call(this),this.za_1=n}function Uu(n){Yu.call(this),this.ab_1=n}function Vu(n){Yu.call(this),this.bb_1=n}function Qu(n,t){Yu.call(this),this.cb_1=n,this.db_1=t}function Zu(n){Yu.call(this),this.eb_1=n}function Yu(){}function Wu(){return ro(),D}function Ku(){return ro(),O}function Xu(){return ro(),R}function Ju(){return ro(),H}function no(n){return ro(),Ff().fb(Jf(to),n)}function to(n){return ro(),n.gb(["invisible-text","text-for-copy"]),lr()}function ro(){$||($=!0,D=no("`"),O=no(" "),R=no("("),H=no(")"))}function io(n,t){Yu.call(this),this.hb_1=n,this.ib_1=t}function eo(n){Yu.call(this),this.jb_1=n}function uo(n,t){Yu.call(this),this.kb_1=n,this.lb_1=t}function oo(n){Yu.call(this),this.mb_1=n}function fo(n){Yu.call(this),this.nb_1=n}function so(n){Yu.call(this),this.ob_1=n}function co(n,t,r){Yu.call(this),this.pb_1=n,this.qb_1=t,this.rb_1=r}function ao(n){Yu.call(this),this.sb_1=n}function ho(n){Yu.call(this),this.tb_1=n}function lo(n){return n.xb_1.vb_1.k()}function _o(){if(Z)return lr();Z=!0,G=new ko("Inputs",0,"Build configuration inputs"),U=new ko("ByMessage",1,"Problems grouped by message"),V=new ko("ByLocation",2,"Problems grouped by location"),Q=new ko("IncompatibleTasks",3,"Incompatible tasks")}function vo(n){yc.call(this),this.yb_1=n}function go(n){yc.call(this),this.ac_1=n}function wo(n){yc.call(this),this.bc_1=n}function bo(n){yc.call(this),this.cc_1=n}function po(n){yo.call(this),this.dc_1=n}function mo(n,t,r,i,e,u,o,f){this.ec_1=n,this.fc_1=t,this.gc_1=r,this.hc_1=i,this.ic_1=e,this.jc_1=u,this.kc_1=o,this.lc_1=f}function ko(n,t,r){Di.call(this,n,t),this.qc_1=r}function yo(){Bc.call(this)}function qo(n,t){var r=Af(),i=Jf(Lo),e=Af().y9(Jf(No),[]),u=function(n,t){var r,i=Af(),e=Jf(Oo),u=Ff().ga("Learn more about the "),o=$f();return i.y9(e,[u,o.fb(Jf((r=t,function(n){return n.bd(r.tc_1),lr()})),t.sc_1),Ff().ga(".")])}(0,t.gc_1),o=Af().y9(Jf(Ao),[Co(0,t)]),f=Af();return r.y9(i,[e,u,o,f.y9(Jf(Mo),[Io(0,Ro(),t.lc_1,lo(t.jc_1)),Io(0,Ho(),t.lc_1,lo(t.hc_1)),Io(0,$o(),t.lc_1,lo(t.ic_1)),Io(0,Go(),t.lc_1,lo(t.kc_1))])])}function Bo(n,t){var r,i,e=Af(),u=Jf(Fo);switch(t.lc_1.q8_1){case 0:r=zo(0,t.jc_1,((i=function(n){return new wo(n)}).callableName="<init>",i));break;case 3:r=zo(0,t.kc_1,function(){var n=function(n){return new bo(n)};return n.callableName="<init>",n}());break;case 1:r=zo(0,t.hc_1,function(){var n=function(n){return new go(n)};return n.callableName="<init>",n}());break;case 2:r=zo(0,t.ic_1,function(){var n=function(n){return new vo(n)};return n.callableName="<init>",n}());break;default:le()}return e.y9(u,[r])}function Co(n,t){return Af().ja([Po(0,t),xo(0,t)])}function xo(n,t){for(var r=Af(),i=t.fc_1,e=Lr(),u=0,o=i.f();o.g();){var f=o.h(),s=u;u=s+1|0,jt(e,0===wr(s)?gr(jo(Vo(),f)):bt([Gf().ja([]),jo(Vo(),f)]))}return r.ha(e)}function jo(n,t){return Df().ja([Ic(t)])}function Po(n,t){return Nf().ja([jc().ka(t.ec_1)])}function Io(n,t,r,i){var e,u,o;return Af().y9(Jf((e=i,u=t,o=r,function(n){return n.t9("group-selector"),0===e?(n.t9("group-selector--disabled"),lr()):u.equals(o)?(n.t9("group-selector--active"),lr()):(n.u9(function(n){return function(t){return new po(n)}}(u)),lr()),lr()})),[Ff().rc(t.qc_1,[So(0,i)])])}function So(n,t){return Ff().y9(Jf(Do),[Ku(),Xu(),Ff().ga(""+t),Ju()])}function zo(n,t,r){return function(n,t,r){var i,e=Af(),u=Of();return e.ja([u.ha(ys(t,(i=r,function(n){var t,r=n.cd().ub_1;return r instanceof Hu?Nc(i,(Vo(),(t=function(n){return Eo(0,n)}).callableName="viewNode",t),n,r.va_1,r.wa_1,Cc()):r instanceof $u?Nc(i,function(){var n=function(n){return Eo(0,n)};return n.callableName="viewNode",n}(Vo()),n,r.xa_1,r.ya_1,xc()):r instanceof io?Nc(i,function(){var n=function(n){return Eo(0,n)};return n.callableName="viewNode",n}(Vo()),n,r.hb_1,r.ib_1,A,So(Vo(),n.cd().vb_1.k())):r instanceof Ou?Lc(i,n,r):Nc(i,function(){var n=function(n){return Eo(0,n)};return n.callableName="viewNode",n}(Vo()),n,r)})))])}(0,t.xb_1.uc().vc(),r)}function Eo(n,t){var r;return t instanceof eo?Sc((r=t,function(n){return n.ed("project "),n.fd(r.jb_1),lr()})):t instanceof co?Sc(function(n){return function(t){return t.ed(n.pb_1+" "),t.fd(n.qb_1),t.ed(" of "),t.fd(n.rb_1),lr()}}(t)):t instanceof so?Sc(function(n){return function(t){return t.ed("system property "),t.fd(n.ob_1),lr()}}(t)):t instanceof uo?Sc(function(n){return function(t){return t.ed("task "),t.fd(n.kb_1),t.ed(" of type "),t.fd(n.lb_1),lr()}}(t)):t instanceof fo?Sc(function(n){return function(t){return t.ed("bean of type "),t.fd(n.nb_1),lr()}}(t)):t instanceof ao?Sc(function(n){return function(t){return t.ed(n.sb_1),lr()}}(t)):t instanceof ho?Sc(function(n){return function(t){return t.ed("class "),t.fd(n.tb_1),lr()}}(t)):t instanceof Zu?Sc(function(n){return function(t){return t.ed(n.eb_1),lr()}}(t)):t instanceof Gu?Ic(t.za_1):t instanceof Qu?Qo(t):Ff().ga(ie(t))}function To(n){return n.t9("report-wrapper"),lr()}function Lo(n){return n.t9("header"),lr()}function No(n){return n.t9("gradle-logo"),lr()}function Ao(n){return n.t9("title"),lr()}function Mo(n){return n.t9("groups"),lr()}function Fo(n){return n.t9("content"),lr()}function Do(n){return n.t9("group-selector__count"),lr()}function Oo(n){return n.t9("learn-more"),lr()}function Ro(){return _o(),G}function Ho(){return _o(),U}function $o(){return _o(),V}function Go(){return _o(),Q}function Uo(){Y=this}function Vo(){return null==Y&&new Uo,Y}function Qo(n){var t;return $f().fb(Jf((t=n,function(n){return n.t9("documentation-button"),n.bd(t.cb_1),lr()})),n.db_1)}function Zo(n,t,r){this.kd_1=n,this.ld_1=t,this.md_1=r}function Yo(n,t,r){this.nd_1=n,this.od_1=t,this.pd_1=r}function Wo(n,t){for(var r=vf(n),i=t.trace,e=Nr(i.length),u=0,o=i.length;u<o;){var f,s=i[u];u=u+1|0,f=Jo(s),e.d(f)}return new Zo(t,r,e)}function Ko(n,t){var r,i=null==(r=t.kd_1.error)?null:nf(r);null==i||n.d(i)}function Xo(n){return function(n,t,r){var i=null==n.error?null:new Hu(t,r);return null==i?new $u(t,r):i}(n.kd_1,new Gu(n.ld_1),ef(n.kd_1))}function Jo(n){var t;switch(n.kind){case"Project":t=new eo(n.path);break;case"Task":t=new uo(n.path,n.type);break;case"TaskPath":t=new oo(n.path);break;case"Bean":t=new fo(n.type);break;case"Field":t=new co("field",n.name,n.declaringType);break;case"InputProperty":t=new co("input property",n.name,n.task);break;case"OutputProperty":t=new co("output property",n.name,n.task);break;case"SystemProperty":t=new so(n.name);break;case"PropertyUsage":t=new co("property",n.name,n.from);break;case"BuildLogic":t=new ao(n.location);break;case"BuildLogicClass":t=new ho(n.type);break;default:t=new Zu("Gradle runtime")}return t}function nf(n){var t=n.parts;if(null==t){var r=n.summary;return null==r?null:new Gu(vf(r))}for(var i=n.summary,e=null==i?null:vf(i),u=Lr(),o=Ri(t);o.g();){var f=rf(o.h());null==f||u.d(f)}for(var s=Mn(u,"\n"),c=Lr(),a=Ri(t);a.g();){var h=tf(a.h());null==h||c.d(h)}return new Ou(e,s,c)}function tf(n){var t=rf(n);if(null==t)return null;var r,i,e=nt(new Nt(function(n,t,r,i){var e;return Jn(nr(n,["\r\n","\n","\r"],A,r=r!==A&&r,i=i===A?0:i),(e=n,function(n){return Jt(e,n)}))}(t),!0,lf));return new Ru(e,(r=!(null==n.internalText),i=e.k(),r&&i>1?ps():null))}function rf(n){var t=n.text;return null==t?n.internalText:t}function ef(n){var t=n.documentationLink;return null==t?null:new Qu(t,"")}function uf(n,t){return new cs(of(n,jf().sd(t),ps()))}function of(n,t,r){return new ks(n,function(n,t){var r,i=Jn(On(n.o()),If);return nt(Jn(new rt(i,new ff(_f)),(r=t,function(n){return of(n.v3(),n.w3().wd_1,r)})))}(t,1===Pf(t)?ms():ps()),0===Pf(t)?ps():r)}function ff(n){this.td_1=n}function sf(n){var t=Lr(),r=n.ld_1,i=Dn(r.ca_1).fa_1,e=ie(Xt(Ze(i)?i:_e())),u=r.vd(function(n,t){var r;if(!(t>=0))throw fu(ie("Requested element count "+t+" is less than zero."));if(0===t)return Rn(n);if(Ue(n,Ti)){var i=n.k()-t|0;if(i<=0)return pt();if(1===i)return gr(function(n){if(Ue(n,Ei))return Qn(n);var t=n.f();if(!t.g())throw mu("Collection is empty.");for(var r=t.h();t.g();)r=t.h();return r}(n));if(r=Nr(),Ue(n,Ei)){if(Ue(n,li)){var e=t,u=n.k();if(e<u)do{var o=e;e=e+1|0,r.d(n.j(o))}while(e<u)}else for(var f=n.l(t);f.g();){var s=f.h();r.d(s)}return r}}else r=Lr();for(var c=0,a=n.f();a.g();){var h=a.h();c>=t?r.d(h):c=c+1|0}return mt(r)}(r.ca_1,1));return t.d(new io(new Zu(e),ef(n.kd_1))),t.d(new Gu(u)),t.m(n.md_1),t.j5()}function cf(n){var t=Lr(),r=n.ld_1,i=r.vd(r.ca_1);return t.d(new $u(new Gu(i),ef(n.kd_1))),t.j5()}function af(n){var t=Lr();return t.d(Xo(n)),t.m(n.md_1),Ko(t,n),t.j5()}function hf(n){var t=Lr();return t.m(new St(n.md_1)),t.d(Xo(n)),Ko(t,n),t.j5()}function lf(n){return Wi(n)>0}function _f(n,t){return function(n,t){return n===t?0:null==n?-1:null==t?1:Ji(null!=n&&("string"==(i=typeof(r=n))||"boolean"===i||function(n){return"number"==typeof n||n instanceof de}(r)||Ue(r,cr))?n:_e(),t);var r,i}(Oi(n.v3()),Oi(t.v3()))}function vf(n){var t;return Bf().qd((t=n,function(n){for(var r=t,i=0,e=r.length;i<e;){var u=r[i];i=i+1|0;var o=u.text;null==o||n.ed(o);var f=u.name;null==f||(n.fd(f),lr())}return lr()}))}function df(n,t){return(0!==(r=n)?r.toString():"No")+" "+gf(t,n)+" "+wf(n)+" found";var r}function gf(n,t){return t<2?n:n+"s"}function wf(n){return n<=1?"was":"were"}function bf(n,t){this.sc_1=n,this.tc_1=t}function pf(n){kf.call(this),this.fa_1=n}function mf(n,t){kf.call(this),this.da_1=n,this.ea_1=t}function kf(){}function yf(){this.dd_1=Lr()}function qf(){W=this}function Bf(){return null==W&&new qf,W}function Cf(n){Bf(),this.ca_1=n}function xf(){K=this}function jf(){return null==K&&new xf,K}function Pf(n){return n.k()}function If(n){var t=n.j1(),r=n.i1();return fr(t,new Sf(Ue(r,Ni)?r:_e()))}function Sf(n){jf(),this.wd_1=n}function zf(n,t,r){var i;Tf(t,n,r),i="Component mounted at #"+n.id+".",wi(),(wi(),g).j7(i)}function Ef(n){var t=document.getElementById(n);if(null==t)throw hu("'"+n+"' element missing");return t}function Tf(n,t,r){var i,e,u;i=n.z9(r),e=t,u=function(n,t,r){return function(i){return Tf(n,r,n.ba(i,t)),lr()}}(n,r,t),fs(),e.innerHTML="",us(e,i,u)}function Lf(){return fs(),X}function Nf(){return fs(),J}function Af(){return fs(),nn}function Mf(){return fs(),tn}function Ff(){return fs(),rn}function Df(){return fs(),en}function Of(){return fs(),un}function Rf(){return fs(),on}function Hf(){return fs(),fn}function $f(){return fs(),sn}function Gf(){return fs(),cn}function Uf(n){this.x9_1=n}function Vf(){an=this}function Qf(){return null==an&&new Vf,an}function Zf(){hn=this,Xf.call(this)}function Yf(){return null==hn&&new Zf,hn}function Wf(n,t,r,i){t=t===A?pt():t,r=r===A?null:r,i=i===A?pt():i,Xf.call(this),this.be_1=n,this.ce_1=t,this.de_1=r,this.ee_1=i}function Kf(){}function Xf(){Qf()}function Jf(n){fs();var t,r=Lr();return n(new ns((t=r,function(n){return t.d(n),lr()}))),r}function ns(n){this.r9_1=n}function ts(n,t){es.call(this),this.fe_1=n,this.ge_1=t}function rs(n){es.call(this),this.he_1=n}function is(n,t){es.call(this),this.ie_1=n,this.je_1=t}function es(){}function us(n,t,r){if(fs(),t instanceof Wf)!function(n,t,r){var i=function(n,t,r){var i=n.createElement(t);return r(i),i}(he(n.ownerDocument),t,r);n.appendChild(i)}(n,t.be_1,(e=t,u=r,function(n){for(var t=e.ce_1.f();t.g();)os(n,t.h(),u);var r=e.de_1;null==r||function(n,t){n.appendChild(he(n.ownerDocument).createTextNode(t))}(n,r);for(var i=e.ee_1.f();i.g();)us(n,i.h(),u);return lr()}));else if(t instanceof Kf){var i=t instanceof Kf?t:_e();us(n,i.ke_1,function(n,t){return function(r){return n(t.le_1(r)),lr()}}(r,i))}else if(oe(t,Yf()))return lr();var e,u}function os(n,t,r){var i,e;fs(),t instanceof is?n.setAttribute(t.ie_1,t.je_1):t instanceof rs?function(n,t){for(var r=Lr(),i=0,e=t.length;i<e;){var u=t[i];i=i+1|0,Nu(n,u)||r.d(u)}var o=r;if(!o.i()){var f=n.className,s=ie(Xt(Ze(f)?f:_e())),c=bi();c.p7(s),0!==Wi(s)&&c.p7(" "),Fn(o,c," "),n.className=c.toString()}}(n,[t.he_1]):t instanceof ts&&n.addEventListener(t.fe_1,(i=r,e=t,function(n){return n.stopPropagation(),i(e.ge_1(n)),lr()}))}function fs(){ln||(ln=!0,X=Yf(),new Uf("hr"),J=new Uf("h1"),new Uf("h2"),nn=new Uf("div"),new Uf("pre"),tn=new Uf("code"),rn=new Uf("span"),en=new Uf("small"),un=new Uf("ol"),on=new Uf("ul"),fn=new Uf("li"),sn=new Uf("a"),cn=new Uf("br"),new Uf("p"))}function ss(n){as.call(this),this.ne_1=n}function cs(n){this.xb_1=n}function as(){}function hs(n){return n.me(A,A,n.wb_1.ad())}function ls(){_n=this}function _s(){return null==_n&&new ls,_n}function vs(){if(gn)return lr();gn=!0,vn=new ws("Collapsed",0),dn=new ws("Expanded",1)}function ds(n){bs.call(this),this.ve_1=n}function gs(n,t,r){bs.call(this),this.se_1=n,this.te_1=t,this.ue_1=r}function ws(n,t){Di.call(this,n,t)}function bs(){}function ps(){return vs(),vn}function ms(){return vs(),dn}function ks(n,t,r){t=t===A?pt():t,r=r===A?ps():r,this.ub_1=n,this.vb_1=t,this.wb_1=r}function ys(n,t){return nt(Jn(n,(r=t,function(n){return function(n,t){var r,i=n.cd(),e=Hf(),u=t(n),o=i.vb_1;r=null==(i.wb_1.equals(ms())&&!o.i()?o:null)?null:function(n,t){return Rf().ha(function(n,t){return ys(n.vc(),t)}(n,t))}(n,t);var f=r;return e.ja([u,null==f?Lf():f])}(n,r)})));var r}function qs(){if(kn)return lr();kn=!0,bn=new Bs("ByMessage",0,"Messages"),pn=new Bs("ByGroup",1,"Group"),mn=new Bs("ByFileLocation",2,"Locations")}function Bs(n,t,r){Di.call(this,n,t),this.cf_1=r}function Cs(n,t){this.df_1=n,this.ef_1=t}function xs(n,t){this.ff_1=n,this.gf_1=t}function js(n){return new ks(new Gu(Bf().rd(n+" more problem"+(n>1?"s have":" has")+" been skipped")))}function Ps(n,t,r,i){var e,u,o=n.v1(t);if(null==o){var f=Lr(),s=fr(new ks(new Vs(Bf().qd((u=t,function(n){return n.fd(u),lr()}))),f,ms()),f);n.h5(t,s),e=s}else e=o;e.u3_1.d(Es(r,i))}function Is(n,t,r,i){var e;if(t=t===A?Lr():t,r=r===A?oi():r,i===A){var u=wn;wn=u+1|0,e=u}else e=i;i=e,this.hf_1=n,this.if_1=t,this.jf_1=r,this.kf_1=i}function Ss(n,t){if(t.i())return null;for(var r,i=n,e=null,u=t.f();u.g();){var o=u.h();r=e;var f,s=i,c=o.ef_1+" ("+o.df_1+")",a=s.v1(c);if(null==a){var h=Lr(),l=new Is(new ks(new Vs(Bf().qd(Fs(o))),h,ms()),h);s.h5(c,l),f=l}else f=a;e=f,null==r||he(r).if_1.u(he(e).hf_1)||he(r).if_1.d(he(e).hf_1),i=he(e).jf_1}return e}function zs(n,t){if(n.k()===t.length){var r;n:{var i=function(n,t){var r=t.length,i=xt(n,10),e=Nr(Math.min(i,r)),u=0,o=n.f();t:for(;o.g();){var f,s=o.h();if(u>=r)break t;var c=u;u=c+1|0,f=fr(s,t[c]),e.d(f)}return e}(n,t);if(Ue(i,Ti)&&i.i())r=!0;else{for(var e=i.f();e.g();){var u=e.h();if(u.t3_1.df_1!==u.u3_1.name||u.t3_1.ef_1!==u.u3_1.displayName){r=!1;break n}}r=!0}}return r}return!1}function Es(n,t,r){var i=function(n,t,r){t=t===A?null:t;var i=Ns(function(n,t){return n&&null!=t.contextualLabel?he(t.contextualLabel):Ts(t)}(r=r!==A&&r,n),t).j5();return Ls(n,new Gu(i))}(n,t=t===A?null:t,r=r!==A&&r),e=function(n,t,r){r=r!==A&&r;var i,e=n.problemDetails;if(null==e)i=null;else{var u,o=e[0].text,f=null==o?null:function(n,t,r,i){if(r=r!==A&&r,i=i===A?0:i,1===t.length){var e=t[0];if(0!==Wi(e))return function(n,t,r,i){rr(i);var e=0,u=Wt(n,t,e,r);if(-1===u||1===i)return gr(ie(n));var o,f=i>0,s=Nr(f&&Kn(i,10));n:do{var c;if(c=ie(Ki(n,e,u)),s.d(c),e=u+t.length|0,f&&s.k()===(i-1|0))break n;u=Wt(n,t,e,r)}while(-1!==u);return o=ie(Ki(n,e,Wi(n))),s.d(o),s}(n,e,r,i)}for(var u=function(n){return new tt(n)}(nr(n,t,A,r,i)),o=Nr(xt(u,10)),f=u.f();f.g();){var s;s=Jt(n,f.h()),o.d(s)}return o}(o,["\n"]);if(null==f)u=null;else{for(var s=Nr(xt(f,10)),c=f.f();c.g();){var a,h=c.h();a=Ms(n)?Bf().qd(Os(h)):Bf().rd(h),s.d(a)}u=s}var l,_=u;if(null==_)l=null;else{for(var v=Nr(xt(_,10)),d=_.f();d.g();){var g;g=new ks(new Gu(d.h())),v.d(g)}l=v}var w=null==l?null:Hn(l);i=null==w?Lr():w}var b=i,p=null==b?Lr():b;r||null==n.contextualLabel||p.d(new ks(new Gu(Bf().rd(he(n.contextualLabel)))));var m=function(n){var t=n.solutions;if(null==t||0===t.length)return null;for(var r=new Vu(Bf().rd("Solutions")),i=he(n.solutions),e=Nr(i.length),u=0,o=i.length;u<o;){var f,s=i[u];u=u+1|0,f=new ks(new Uu(vf(s))),e.d(f)}return new ks(r,e)}(n);null==m||p.d(m);var k,y=n.error,q=null==y?null:nf(y);if(null==q||p.d(new ks(q)),t){var B=n.locations;k=!(null==B||0===B.length)}else k=!1;return k&&p.d(function(n){var t,r=n.locations;if(null==r)t=null;else{for(var i=Nr(r.length),e=Ri(r);e.g();){var u,o=e.h();u=new ks(new Gu(Bf().qd(Rs(o)))),i.d(u)}t=i}var f=t;return new ks(new Zu("Locations"),null==f?pt():f)}(n)),p}(n,null==t,r);return new ks(i,e)}function Ts(n){return function(n){if(0===n.length)throw mu("Array is empty.");return n[Nn(n)]}(n.problemId).displayName}function Ls(n,t){var r;switch(n.severity){case"WARNING":var i=n.documentationLink;r=new $u(t,null==i?null:new Qu(i,""));break;case"ERROR":var e=n.documentationLink;r=new Hu(t,null==e?null:new Qu(e,""));break;case"ADVICE":var u=n.documentationLink;r=new Qs(t,null==u?null:new Qu(u,""));break;default:console.error("no severity "+n.severity),r=t}return r}function Ns(n,t){t=t===A?null:t;var r,i=new yf;if(i.ed(n),null==t);else{if(null!=t.line){var e=As(t);i.xd(e+(null==(r=t).line||null==r.length?"":"-"+r.length),""+t.path+e)}var u=t.taskPath;null==u||i.fd(u);var o=t.pluginId;null!=o&&i.fd(o)}return i}function As(n){var t;if(null==n.line)t=null;else{var r,i=":"+n.line,e=n.column;t=i+(null==(r=null==e?null:":"+e)?"":r)}return null==t?"":t}function Ms(n){var t,r,i=n.problemId;n:{for(var e=0,u=i.length;e<u;){var o=i[e];if(e=e+1|0,"compilation"===o.name){r=o;break n}}r=null}if(null!=r){var f,s=n.problemId;n:{for(var c=0,a=s.length;c<a;){var h=s[c];if(c=c+1|0,"java"===h.name){f=h;break n}}f=null}t=!(null==f)}else t=!1;return t}function Fs(n){return function(t){return t.ed(n.ef_1),t.fd(n.df_1),lr()}}function Ds(n){return n.name}function Os(n){return function(t){return t.xd(function(n,t,r,i){i=i!==A&&i;var e=new RegExp(qi().t7(" "),i?"gui":"gu"),u=qi().u7(" ");return n.replace(e,u)}(n),""),lr()}}function Rs(n){return function(t){return t.ed("- "),t.fd(""+n.path+As(n)),lr()}}function Hs(){return qs(),bn}function $s(){return qs(),pn}function Gs(){return qs(),mn}function Us(n){Zs.call(this),this.lf_1=n}function Vs(n,t){t=t!==A&&t,Zs.call(this),this.mf_1=n,this.nf_1=t}function Qs(n,t){t=t===A?null:t,Yu.call(this),this.of_1=n,this.pf_1=t}function Zs(){Yu.call(this)}function Ys(n){yc.call(this),this.qf_1=n}function Ws(n){yc.call(this),this.rf_1=n}function Ks(n){yc.call(this),this.sf_1=n}function Xs(n){nc.call(this),this.tf_1=n}function Js(n,t,r,i,e,u,o,f){this.uf_1=n,this.vf_1=t,this.wf_1=r,this.xf_1=i,this.yf_1=e,this.zf_1=u,this.ag_1=o,this.bg_1=f}function nc(){Bc.call(this)}function tc(n,t){var r=Lr();lo(t.xf_1)>0&&r.d(fc(0,Hs(),t.bg_1,t.ag_1)),lo(t.yf_1)>0&&r.d(fc(0,$s(),t.bg_1,t.ag_1)),lo(t.zf_1)>0&&r.d(fc(0,Gs(),t.bg_1,t.ag_1));var i=Af(),e=Jf(hc),u=Af().y9(Jf(lc),[]),o=function(n,t){var r,i=Af(),e=Jf(wc),u=Ff().ga("Learn more about "),o=$f();return i.y9(e,[u,o.fb(Jf((r=t,function(n){return n.bd(r.tc_1),lr()})),t.sc_1),Ff().ga(".")])}(0,t.wf_1),f=Af().y9(Jf(_c),[ic(0,t)]),s=Af();return i.y9(e,[u,o,f,s.zd(Jf(vc),r)])}function rc(n,t){var r,i,e=Af(),u=Jf(dc);switch(t.bg_1.q8_1){case 0:r=sc(0,t.xf_1,((i=function(n){return new Ys(n)}).callableName="<init>",i));break;case 1:r=sc(0,t.yf_1,function(){var n=function(n){return new Ws(n)};return n.callableName="<init>",n}());break;case 2:r=sc(0,t.zf_1,function(){var n=function(n){return new Ks(n)};return n.callableName="<init>",n}());break;default:le()}return e.y9(u,[r])}function ic(n,t){return Af().ja([oc(0,t),ec(0,t)])}function ec(n,t){for(var r=Af(),i=t.vf_1,e=Lr(),u=0,o=i.f();o.g();){var f=o.h(),s=u;u=s+1|0,jt(e,0===wr(s)?gr(uc(pc(),f)):bt([Gf().ja([]),uc(pc(),f)]))}return r.ha(e)}function uc(n,t){return Df().ja([Ic(t)])}function oc(n,t){return Nf().ja([jc().ka(t.uf_1)])}function fc(n,t,r,i){var e,u,o,f;return Af().y9(Jf((e=i,u=t,o=r,function(n){return n.t9("group-selector"),0===e?(n.t9("group-selector--disabled"),lr()):u.equals(o)?(n.t9("group-selector--active"),lr()):(n.u9(function(n){return function(t){return new Xs(n)}}(u)),lr()),lr()})),[Ff().rc(t.cf_1,[(f=i,Ff().y9(Jf(gc),[Ku(),Xu(),Ff().ga(""+f),Ju()]))])])}function sc(n,t,r){return function(n,t,r){var i,e=Af(),u=Of();return e.ja([u.ha(ys(t,(i=r,function(n){return function(n,t,r,i){var e,u;return t instanceof Us?Ic(Bf().rd(t.lf_1)):t instanceof Vs?Af().y9(Jf((u=t,function(n){return u.nf_1&&(n.t9("uncategorized"),lr()),lr()})),[Af().ja([zc(r,i),Ic(t.mf_1)])]):t instanceof Ou?Lc(i,r,t):t instanceof Gu?Ic(t.za_1):t instanceof Uu?Af().ja([(Vc(),xn),Ic(t.ab_1)]):t instanceof Vu?Af().ja([zc(r,i),Ic(t.bb_1)]):t instanceof Hu?Nc(i,((e=function(n){return cc(0,n)}).callableName="viewIt",e),r,t.va_1,t.wa_1,Cc()):t instanceof Qs?Nc(i,function(){var n=function(n){return cc(0,n)};return n.callableName="viewIt",n}(),r,t.of_1,t.pf_1,(Vc(),Bn)):t instanceof $u?Nc(i,function(){var n=function(n){return cc(0,n)};return n.callableName="viewIt",n}(),r,t.xa_1,t.ya_1,xc()):t instanceof Zu?Af().ja([zc(r,i),Ic(Bf().rd(t.eb_1))]):Ff().ga("Unknown node type viewNode: "+t)}(pc(),n.cd().ub_1,n,i)})))])}(0,t.xb_1.uc().vc(),r)}function cc(n,t){var r;if(t instanceof Qu)r=Qo(t);else if(t instanceof Zu)r=Ic(Bf().rd(t.eb_1));else if(t instanceof Gu)r=Ic(t.za_1);else{var i="Unknown node type viewIt: "+t;console.error(i),r=Ff().ga(i)}return r}function ac(n){return n.t9("report-wrapper"),lr()}function hc(n){return n.t9("header"),lr()}function lc(n){return n.t9("gradle-logo"),lr()}function _c(n){return n.t9("title"),lr()}function vc(n){return n.t9("groups"),lr()}function dc(n){return n.t9("content"),lr()}function gc(n){return n.t9("group-selector__count"),lr()}function wc(n){return n.t9("learn-more"),lr()}function bc(){yn=this,document.title="Gradle - Problems Report"}function pc(){return null==yn&&new bc,yn}function mc(n,t,r){return n.pe(t.zb().oe(),r)}function kc(n){Bc.call(this),this.hd_1=n}function yc(){Bc.call(this)}function qc(n,t){Bc.call(this),this.wc_1=n,this.xc_1=t}function Bc(){}function Cc(){return Vc(),qn}function xc(){return Vc(),Cn}function jc(){return Vc(),jn}function Pc(){return Vc(),Pn}function Ic(n){return Vc(),Pc().ka(n)}function Sc(n){return Vc(),Pc().ka(Bf().qd(n))}function zc(n,t){return Vc(),n.cd().ye()?Ac(n,t):function(n){return Vc(),Ff().fb(Jf(Gc),Mc(n))}(n)}function Ec(n,t,r,i){var e,u,o;return Vc(),Ff().fb(Jf((e=r,u=t,o=i,function(n){return n.t9("java-exception-part-toggle"),n.u9(function(n,t){return function(r){return new qc(n,t())}}(u,o)),n.s9("Click to "+function(n){var t;switch(Vc(),n.q8_1){case 0:t="show";break;case 1:t="hide";break;default:le()}return t}(e)),lr()})),"("+n+" internal "+gf("line",n)+" "+function(n){var t;switch(Vc(),n.q8_1){case 0:t="hidden";break;case 1:t="shown";break;default:le()}return t}(r)+")")}function Tc(n,t){t=t===A?Lf():t,Vc();for(var r=Rf(),i=Nr(xt(n,10)),e=0,u=n.f();u.g();){var o,f=e;e=f+1|0,s=u.h(),c=(c=0===wr(f)?t:Lf())===A?Lf():c,Vc(),o=Hf().ja([Mf().ga(s),c]),i.d(o)}var s,c;return r.ha(i)}function Lc(n,t,r){Vc();var i,e,u,o=Af(),f=Ac(t,n),s=Ff().ga("Exception"),c=Ff().ja([(Vc(),In).v9(r.na_1,"Copy exception to the clipboard")]),a=null==r.ma_1?null:Ff().ga(" "),h=null==a?Lf():a,l=r.ma_1,_=null==l?null:Ic(l),v=null==_?Lf():_;switch(t.cd().wb_1.q8_1){case 0:i=Lf();break;case 1:i=function(n,t){Vc();for(var r=Af(),i=Jf(Uc),e=n.oa_1,u=Nr(xt(e,10)),o=0,f=e.f();f.g();){var s,c=f.h(),a=o;o=a+1|0;var h,l=wr(a);if(null!=c.sa_1){var _,v=Ec(c.ra_1.k(),l,c.sa_1,t),d=c.sa_1;switch(null==d?-1:d.q8_1){case 0:_=Tc(Un(c.ra_1,1),v);break;case 1:_=Tc(c.ra_1,v);break;default:le()}h=_}else h=Tc(c.ra_1);s=h,u.d(s)}return r.zd(i,u)}(r,(e=n,u=t,function(){return e(new ss(u))}));break;default:le()}return o.ja([f,s,c,h,v,i])}function Nc(n,t,r,i,e,u,o){e=e===A?null:e,u=u===A?Lf():u,o=o===A?Lf():o,Vc();var f=Af(),s=zc(r,n),c=t(i),a=null==e?null:t(e);return f.ja([s,u,c,null==a?Lf():a,o])}function Ac(n,t){var r,i;return Vc(),Ff().fb(Jf((r=n,i=t,function(n){return n.gb(["invisible-text","tree-btn"]),r.cd().wb_1===ps()&&(n.t9("collapsed"),lr()),r.cd().wb_1===ms()&&(n.t9("expanded"),lr()),n.s9("Click to "+function(n){var t;switch(Vc(),n.q8_1){case 0:t="expand";break;case 1:t="collapse";break;default:le()}return t}(r.cd().wb_1)),n.u9(function(n,t){return function(r){return n(new ss(t))}}(i,r)),lr()})),Mc(n))}function Mc(n){return Vc(),function(n,t){var r;if(!(t>=0))throw fu(ie("Count 'n' must be non-negative, but was "+t+"."));switch(t){case 0:r="";break;case 1:r=ie(n);break;default:var i="";if(0!==Wi(n))for(var e=ie(n),u=t;1&~u||(i+=e),0!=(u=u>>>1|0);)e+=e;return i}return r}("    ",n.we()-1|0)+"- "}function Fc(n){return Vc(),n.gb(["invisible-text","error-icon"]),lr()}function Dc(n){return Vc(),n.gb(["invisible-text","advice-icon"]),lr()}function Oc(n){return Vc(),n.gb(["invisible-text","warning-icon"]),lr()}function Rc(n){return Vc(),n.gb(["invisible-text","enum-icon"]),lr()}function Hc(n){return Vc(),new kc(n)}function $c(n){return Vc(),new kc(n)}function Gc(n){return Vc(),n.gb(["invisible-text","leaf-icon"]),lr()}function Uc(n){return Vc(),n.t9("java-exception"),lr()}function Vc(){if(!Sn){Sn=!0;var n=Ff();qn=n.fb(Jf(Fc),"[error] ");var t=Ff();Bn=t.fb(Jf(Dc),"[advice] ");var r=Ff();Cn=r.fb(Jf(Oc),"[warn]  ");var i=Ff();xn=i.fb(Jf(Rc),"[enum]  "),jn=new Du,Pn=new Du(Hc),In=new Mu($c)}}return Ge(Yn,A,Re),Ge(tt,A,Re),Ge(rt,A,Re),Ge(Ti,"Collection",Ye),Ge(it,"AbstractCollection",Re,A,[Ti]),Ge(et,"IteratorImpl",Re),Ge(ut,"ListIteratorImpl",Re,et),Ge(ot,"Companion",Ke),Ge(Ei,"List",Ye,A,[Ti]),Ge(st,"AbstractList",Re,it,[it,Ei]),Ge(ct,A,Re),Ge(lt,"Companion",Ke),Ge(vt,A,Re,it),Ge(Ni,"Map",Ye),Ge(dt,"AbstractMap",Re,A,[Ni]),Ge(gt,"Companion",Ke),Ge(li,"RandomAccess",Ye),Ge(yt,"EmptyList",Ke,A,[Ei,li]),Ge(qt,"ArrayAsCollection",Re,A,[Ti]),Ge(Bt,"EmptyIterator",Ke),Ge(Pt,"IntIterator",Re),Ge(It,A,Re),Ge(St,"ReversedListReadOnly",Re,st),Ge(zt,A,Re),Ge(Et,"TransformingSequence",Re),Ge(Lt,A,Re),Ge(Nt,"FilteringSequence",Re),Ge(Mi,"Set",Ye,A,[Ti]),Ge(Mt,"EmptySet",Ke,A,[Mi]),Ge(Ot,"Companion",Ke),Ge(Vt,"IntProgression",Re),Ge(Ht,"IntRange",Re,Vt),Ge($t,"IntProgressionIterator",Re,Pt),Ge(Gt,"Companion",Ke),Ge(er,A,Re),Ge(ur,"DelimitedRangesSequence",Re),Ge(or,"Pair",Re),Ge(sr,"CharSequence",Ye),Ge(cr,"Comparable",Ye),Ge(ar,"Number",Re),Ge(hr,"Unit",Ke),Ge(_r,"IntCompanionObject",Ke),Ge(mr,"AbstractMutableCollection",Re,it,[it,Ti]),Ge(kr,"IteratorImpl",Re),Ge(yr,"ListIteratorImpl",Re,kr),Ge(qr,"AbstractMutableList",Re,mr,[mr,Ti,Ei]),Ge(Br,A,Re),Ge(Cr,A,Re),Ge(Li,"Entry",Ye),Ge(Ai,"MutableEntry",Ye,A,[Li]),Ge(xr,"SimpleEntry",Re,A,[Ai]),Ge(zr,"AbstractMutableSet",Re,mr,[mr,Mi,Ti]),Ge(jr,"AbstractEntrySet",Re,zr),Ge(Pr,A,Re,zr),Ge(Ir,A,Re,mr),Ge(Sr,"AbstractMutableMap",Re,dt,[dt,Ni]),Ge(Er,"Companion",Ke),Ge(Fr,"ArrayList",Re,qr,[qr,Ti,Ei,li]),Ge(Rr,"HashCode",Ke),Ge(Hr,"EntrySet",Re,jr),Ge(Vr,"HashMap",Re,Sr,[Sr,Ni]),Ge(Zr,"HashSet",Re,zr,[zr,Mi,Ti]),Ge(Xr,A,Re),Ge(ni,"InternalMap",Ye),Ge(Jr,"InternalHashCodeMap",Re,A,[ni]),Ge(ti,"EntryIterator",Re),Ge(ri,"Companion",Ke),Ge(ei,"ChainEntry",Re,xr),Ge(ui,"EntrySet",Re,jr),Ge(si,"LinkedHashMap",Re,Vr,[Vr,Ni]),Ge(ci,"Companion",Ke),Ge(hi,"LinkedHashSet",Re,Zr,[Zr,Mi,Ti]),Ge(_i,"BaseOutput",Re),Ge(vi,"NodeJsOutput",Re,_i),Ge(gi,"BufferedOutput",Re,_i),Ge(di,"BufferedOutputToConsoleLog",Re,gi),Ge(pi,"StringBuilder",Re,A,[sr]),Ge(yi,"Companion",Ke),Ge(Bi,"Regex",Re),Ge(Ii,"Companion",Ke),Ge(zi,"Char",Re,A,[cr]),Ge(Fi,"Companion",Ke),Ge(Di,"Enum",Re,A,[cr]),Ge(Hi,A,Re),Ge(ve,"Companion",Ke),Ge(de,"Long",Re,ar,[ar,cr]),Ge(iu,"Letter",Ke),Ge(uu,"OtherLowercase",Ke),Ge(du,"Exception",Re,Error),Ge(bu,"RuntimeException",Re,du),Ge(su,"IllegalArgumentException",Re,bu),Ge(au,"IndexOutOfBoundsException",Re,bu),Ge(lu,"IllegalStateException",Re,bu),Ge(ku,"NoSuchElementException",Re,bu),Ge(qu,"ArithmeticException",Re,bu),Ge(xu,"UnsupportedOperationException",Re,bu),Ge(Pu,"NullPointerException",Re,bu),Ge(Su,"NoWhenBranchMatchedException",Re,bu),Ge(Eu,"ClassCastException",Re,bu),Ge(Lu,"UninitializedPropertyAccessException",Re,bu),Ge(Au,"Model",Re),Ge(Mu,"CopyButtonComponent",Re),Ge(Du,"PrettyTextComponent",Re),Ge(Yu,"ProblemNode",Re),Ge(Ou,"Exception",Re,Yu),Ge(Ru,"StackTracePart",Re),Ge(Hu,"Error",Re,Yu),Ge($u,"Warning",Re,Yu),Ge(Gu,"Message",Re,Yu),Ge(Uu,"ListElement",Re,Yu),Ge(Vu,"TreeNode",Re,Yu),Ge(Qu,"Link",Re,Yu),Ge(Zu,"Label",Re,Yu),Ge(io,"Info",Re,Yu),Ge(eo,"Project",Re,Yu),Ge(uo,"Task",Re,Yu),Ge(oo,"TaskPath",Re,Yu),Ge(fo,"Bean",Re,Yu),Ge(so,"SystemProperty",Re,Yu),Ge(co,"Property",Re,Yu),Ge(ao,"BuildLogic",Re,Yu),Ge(ho,"BuildLogicClass",Re,Yu),Ge(Bc,"BaseIntent",Re),Ge(yc,"TreeIntent",Re,Bc),Ge(vo,"TaskTreeIntent",Re,yc),Ge(go,"MessageTreeIntent",Re,yc),Ge(wo,"InputTreeIntent",Re,yc),Ge(bo,"IncompatibleTaskTreeIntent",Re,yc),Ge(yo,"Intent",Re,Bc),Ge(po,"SetTab",Re,yo),Ge(mo,"Model",Re),Ge(ko,"Tab",Re,Di),Ge(Uo,"ConfigurationCacheReportPage",Ke),Ge(Zo,"ImportedProblem",Re),Ge(Yo,"ImportedDiagnostics",Re),Ge(ff,"sam$kotlin_Comparator$0",Re),Ge(bf,"LearnMore",Re),Ge(kf,"Fragment",Re),Ge(pf,"Text",Re,kf),Ge(mf,"Reference",Re,kf),Ge(yf,"Builder",Re),Ge(qf,"Companion",Ke),Ge(Cf,"PrettyText",Re),Ge(xf,"Companion",Ke),Ge(Sf,"Trie",Re),Ge(Uf,"ViewFactory",Re),Ge(Vf,"Companion",Ke),Ge(Xf,"View",Re),Ge(Zf,"Empty",Ke,Xf),Ge(Wf,"Element",Re,Xf),Ge(Kf,"MappedView",Re,Xf),Ge(ns,"Attributes",Re),Ge(es,"Attribute",Re),Ge(ts,"OnEvent",Re,es),Ge(rs,"ClassName",Re,es),Ge(is,"Named",Re,es),Ge(as,"Intent",Re),Ge(ss,"Toggle",Re,as),Ge(cs,"Model",Re),Ge(ls,"TreeView",Ke),Ge(bs,"Focus",Re),Ge(ds,"Original",Re,bs),Ge(gs,"Child",Re,bs),Ge(ws,"ViewState",Re,Di),Ge(ks,"Tree",Re),Ge(Bs,"Tab",Re,Di),Ge(Cs,"ProblemIdElement",Re),Ge(xs,"ProblemSummary",Re),Ge(Is,"ProblemNodeGroup",Re),Ge(Zs,"ProblemApiNode",Re,Yu),Ge(Us,"Text",Re,Zs),Ge(Vs,"ProblemIdNode",Re,Zs),Ge(Qs,"Advice",Re,Yu),Ge(Ys,"MessageTreeIntent",Re,yc),Ge(Ws,"ProblemIdTreeIntent",Re,yc),Ge(Ks,"FileLocationTreeIntent",Re,yc),Ge(nc,"Intent",Re,Bc),Ge(Xs,"SetTab",Re,nc),Ge(Js,"Model",Re),Ge(bc,"ProblemsReportPage",Ke),Ge(kc,"Copy",Re,Bc),Ge(qc,"ToggleStackTracePart",Re,Bc),se(Yn).f=function(){return this.n_1.f()},se(tt).f=function(){return this.r_1.f()},se(rt).f=function(){var n,t,r=function(n,t){for(var r=n.f();r.g();){var i=r.h();t.d(i)}return t}(this.s_1,Lr());return n=r,t=this.t_1,function(n,t){if(n.k()<=1)return lr();var r=br(n);!function(n,t){if(function(){if(null!=l)return l;l=!1;var n=[],t=0;if(t<600)do{var r=t;t=t+1|0,n.push(r)}while(t<600);var i=Or;n.sort(i);var e=1,u=n.length;if(e<u)do{var o=e;e=e+1|0;var f=n[o-1|0],s=n[o];if((3&f)==(3&s)&&f>=s)return!1}while(e<u);return l=!0,!0}()){var r=(i=t,function(n,t){return i.compare(n,t)});n.sort(r)}else!function(n,t,r,i){var e=n.length,u=function(n){var t=0,r=n.length-1|0;if(t<=r)do{var i=t;t=t+1|0,n[i]=null}while(i!==r);return n}(Array(e)),o=Dr(n,u,0,r,i);if(o!==n){var f=0;if(f<=r)do{var s=f;f=f+1|0,n[s]=o[s]}while(s!==r)}}(n,0,Nn(n),t);var i}(r,t);var i=0,e=r.length;if(i<e)do{var u=i;i=i+1|0,n.f4(u,r[u])}while(i<e)}(n,t),r.f()},se(it).u=function(n){var t;n:if(Ue(this,Ti)&&this.i())t=!1;else{for(var r=this.f();r.g();)if(oe(r.h(),n)){t=!0;break n}t=!1}return t},se(it).v=function(n){var t;n:if(Ue(n,Ti)&&n.i())t=!0;else{for(var r=n.f();r.g();){var i=r.h();if(!this.u(i)){t=!1;break n}}t=!0}return t},se(it).i=function(){return 0===this.k()},se(it).toString=function(){return Mn(this,", ","[","]",A,A,(n=this,function(t){return t===n?"(this Collection)":Oi(t)}));var n},se(it).toArray=function(){return dr(this)},se(et).g=function(){return this.w_1<this.x_1.k()},se(et).h=function(){if(!this.g())throw pu();var n=this.w_1;return this.w_1=n+1|0,this.x_1.j(n)},se(ut).c1=function(){return this.w_1>0},se(ut).d1=function(){if(!this.c1())throw pu();return this.w_1=this.w_1-1|0,this.a1_1.j(this.w_1)},se(ot).e1=function(n,t){if(n<0||n>=t)throw cu("index: "+n+", size: "+t)},se(ot).b1=function(n,t){if(n<0||n>t)throw cu("index: "+n+", size: "+t)},se(ot).f1=function(n){for(var t=1,r=n.f();r.g();){var i=r.h(),e=zn(31,t),u=null==i?null:ee(i);t=e+(null==u?0:u)|0}return t},se(ot).g1=function(n,t){if(n.k()!==t.k())return!1;for(var r=t.f(),i=n.f();i.g();)if(!oe(i.h(),r.h()))return!1;return!0},se(st).f=function(){return new et(this)},se(st).l=function(n){return new ut(this,n)},se(st).equals=function(n){return n===this||!(null==n||!Ue(n,Ei))&&ft().g1(this,n)},se(st).hashCode=function(){return ft().f1(this)},se(ct).g=function(){return this.h1_1.g()},se(ct).h=function(){return this.h1_1.h().i1()},se(lt).k1=function(n){var t=n.j1(),r=null==t?null:ee(t),i=null==r?0:r,e=n.i1(),u=null==e?null:ee(e);return i^(null==u?0:u)},se(lt).l1=function(n){return Oi(n.j1())+"="+Oi(n.i1())},se(lt).m1=function(n,t){return!(null==t||!Ue(t,Li))&&!!oe(n.j1(),t.j1())&&oe(n.i1(),t.i1())},se(vt).r1=function(n){return this.q1_1.s1(n)},se(vt).u=function(n){return!(null!=n&&!Qe(n))&&this.r1(null==n||Qe(n)?n:_e())},se(vt).f=function(){return new ct(this.q1_1.o().f())},se(vt).k=function(){return this.q1_1.k()},se(dt).t1=function(n){return!(null==ht(this,n))},se(dt).s1=function(n){var t;n:{var r=this.o();if(Ue(r,Ti)&&r.i())t=!1;else{for(var i=r.f();i.g();)if(oe(i.h().i1(),n)){t=!0;break n}t=!1}}return t},se(dt).u1=function(n){if(null==n||!Ue(n,Li))return!1;var t=n.j1(),r=n.i1(),i=(Ue(this,Ni)?this:_e()).v1(t);return!(!oe(r,i)||null==i&&!(Ue(this,Ni)?this:_e()).t1(t))},se(dt).equals=function(n){if(n===this)return!0;if(null==n||!Ue(n,Ni))return!1;if(this.k()!==n.k())return!1;var t;n:{var r=n.o();if(Ue(r,Ti)&&r.i())t=!0;else{for(var i=r.f();i.g();){var e=i.h();if(!this.u1(e)){t=!1;break n}}t=!0}}return t},se(dt).v1=function(n){var t=ht(this,n);return null==t?null:t.i1()},se(dt).hashCode=function(){return ee(this.o())},se(dt).i=function(){return 0===this.k()},se(dt).k=function(){return this.o().k()},se(dt).toString=function(){var n;return Mn(this.o(),", ","{","}",A,A,(n=this,function(t){return n.p1(t)}))},se(dt).p1=function(n){return at(this,n.j1())+"="+at(this,n.i1())},se(dt).w1=function(){return null==this.o1_1&&(this.o1_1=new vt(this)),he(this.o1_1)},se(gt).x1=function(n){for(var t=0,r=n.f();r.g();){var i=r.h(),e=t,u=null==i?null:ee(i);t=e+(null==u?0:u)|0}return t},se(gt).y1=function(n,t){return n.k()===t.k()&&n.v(t)},se(yt).equals=function(n){return!(null==n||!Ue(n,Ei))&&n.i()},se(yt).hashCode=function(){return 1},se(yt).toString=function(){return"[]"},se(yt).k=function(){return 0},se(yt).i=function(){return!0},se(yt).a2=function(n){return n.i()},se(yt).v=function(n){return this.a2(n)},se(yt).j=function(n){throw cu("Empty list doesn't contain element at index "+n+".")},se(yt).f=function(){return Ct()},se(yt).l=function(n){if(0!==n)throw cu("Index: "+n);return Ct()},se(qt).k=function(){return this.b2_1.length},se(qt).i=function(){return 0===this.b2_1.length},se(qt).d2=function(n){return function(n,t){return An(n,t)>=0}(this.b2_1,n)},se(qt).e2=function(n){var t;n:if(Ue(n,Ti)&&n.i())t=!0;else{for(var r=n.f();r.g();){var i=r.h();if(!this.d2(i)){t=!1;break n}}t=!0}return t},se(qt).v=function(n){return this.e2(n)},se(qt).f=function(){return Ri(this.b2_1)},se(Bt).g=function(){return!1},se(Bt).c1=function(){return!1},se(Bt).h=function(){throw pu()},se(Bt).d1=function(){throw pu()},se(Pt).h=function(){return this.f2()},se(It).g=function(){return this.g2_1.c1()},se(It).c1=function(){return this.g2_1.g()},se(It).h=function(){return this.g2_1.d1()},se(It).d1=function(){return this.g2_1.h()},se(St).k=function(){return this.i2_1.k()},se(St).j=function(n){return this.i2_1.j(function(n,t){if(!(0<=t&&t<=kt(n)))throw cu("Element index "+t+" must be in range ["+Oe(0,kt(n))+"].");return kt(n)-t|0}(this,n))},se(St).f=function(){return this.l(0)},se(St).l=function(n){return new It(this,n)},se(zt).h=function(){return this.k2_1.m2_1(this.j2_1.h())},se(zt).g=function(){return this.j2_1.g()},se(Et).f=function(){return new zt(this)},se(Lt).h=function(){if(-1===this.o2_1&&Tt(this),0===this.o2_1)throw pu();var n=this.p2_1;return this.p2_1=null,this.o2_1=-1,null==n||Qe(n)?n:_e()},se(Lt).g=function(){return-1===this.o2_1&&Tt(this),1===this.o2_1},se(Nt).f=function(){return new Lt(this)},se(Mt).equals=function(n){return!(null==n||!Ue(n,Mi))&&n.i()},se(Mt).hashCode=function(){return 0},se(Mt).toString=function(){return"[]"},se(Mt).k=function(){return 0},se(Mt).i=function(){return!0},se(Mt).a2=function(n){return n.i()},se(Mt).v=function(n){return this.a2(n)},se(Mt).f=function(){return Ct()},se(Ht).y2=function(){return this.z2_1},se(Ht).c3=function(){return this.a3_1},se(Ht).i=function(){return this.z2_1>this.a3_1},se(Ht).equals=function(n){return n instanceof Ht&&(!(!this.i()||!n.i())||this.z2_1===n.z2_1&&this.a3_1===n.a3_1)},se(Ht).hashCode=function(){return this.i()?-1:zn(31,this.z2_1)+this.a3_1|0},se(Ht).toString=function(){return this.z2_1+".."+this.a3_1},se($t).g=function(){return this.f3_1},se($t).f2=function(){var n=this.g3_1;if(n===this.e3_1){if(!this.f3_1)throw pu();this.f3_1=!1}else this.g3_1=this.g3_1+this.d3_1|0;return n},se(Gt).q=function(n,t,r){return new Vt(n,t,r)},se(Vt).f=function(){return new $t(this.z2_1,this.a3_1,this.b3_1)},se(Vt).i=function(){return this.b3_1>0?this.z2_1>this.a3_1:this.z2_1<this.a3_1},se(Vt).equals=function(n){return n instanceof Vt&&(!(!this.i()||!n.i())||this.z2_1===n.z2_1&&this.a3_1===n.a3_1&&this.b3_1===n.b3_1)},se(Vt).hashCode=function(){return this.i()?-1:zn(31,zn(31,this.z2_1)+this.a3_1|0)+this.b3_1|0},se(Vt).toString=function(){return this.b3_1>0?this.z2_1+".."+this.a3_1+" step "+this.b3_1:this.z2_1+" downTo "+this.a3_1+" step "+(0|-this.b3_1)},se(er).h=function(){if(-1===this.j3_1&&ir(this),0===this.j3_1)throw pu();var n=this.m3_1,t=n instanceof Ht?n:_e();return this.m3_1=null,this.j3_1=-1,t},se(er).g=function(){return-1===this.j3_1&&ir(this),1===this.j3_1},se(ur).f=function(){return new er(this)},se(or).toString=function(){return"("+this.t3_1+", "+this.u3_1+")"},se(or).v3=function(){return this.t3_1},se(or).w3=function(){return this.u3_1},se(or).hashCode=function(){var n=null==this.t3_1?0:ee(this.t3_1);return zn(n,31)+(null==this.u3_1?0:ee(this.u3_1))|0},se(or).equals=function(n){if(this===n)return!0;if(!(n instanceof or))return!1;var t=n instanceof or?n:_e();return!!oe(this.t3_1,t.t3_1)&&!!oe(this.u3_1,t.u3_1)},se(hr).toString=function(){return"kotlin.Unit"},se(_r).b4=function(){return this.MIN_VALUE},se(_r).c4=function(){return this.MAX_VALUE},se(_r).d4=function(){return this.SIZE_BYTES},se(_r).e4=function(){return this.SIZE_BITS},se(mr).m=function(n){this.g4();for(var t=!1,r=n.f();r.g();){var i=r.h();this.d(i)&&(t=!0)}return t},se(mr).toJSON=function(){return this.toArray()},se(mr).g4=function(){},se(kr).g=function(){return this.h4_1<this.j4_1.k()},se(kr).h=function(){if(!this.g())throw pu();var n=this.h4_1;return this.h4_1=n+1|0,this.i4_1=n,this.j4_1.j(this.i4_1)},se(yr).c1=function(){return this.h4_1>0},se(yr).d1=function(){if(!this.c1())throw pu();return this.h4_1=this.h4_1-1|0,this.i4_1=this.h4_1,this.n4_1.j(this.i4_1)},se(qr).d=function(n){return this.g4(),this.p4(this.k(),n),!0},se(qr).f=function(){return new kr(this)},se(qr).u=function(n){return this.q4(n)>=0},se(qr).q4=function(n){var t=0,r=kt(this);if(t<=r)do{var i=t;if(t=t+1|0,oe(this.j(i),n))return i}while(i!==r);return-1},se(qr).l=function(n){return new yr(this,n)},se(qr).equals=function(n){return n===this||!(null==n||!Ue(n,Ei))&&ft().g1(this,n)},se(qr).hashCode=function(){return ft().f1(this)},se(Br).g=function(){return this.r4_1.g()},se(Br).h=function(){return this.r4_1.h().j1()},se(Cr).g=function(){return this.s4_1.g()},se(Cr).h=function(){return this.s4_1.h().i1()},se(xr).j1=function(){return this.t4_1},se(xr).i1=function(){return this.u4_1},se(xr).v4=function(n){var t=this.u4_1;return this.u4_1=n,t},se(xr).hashCode=function(){return _t().k1(this)},se(xr).toString=function(){return _t().l1(this)},se(xr).equals=function(n){return _t().m1(this,n)},se(jr).u=function(n){return this.w4(n)},se(Pr).y4=function(n){throw Cu("Add is not supported on keys")},se(Pr).d=function(n){return this.y4(null==n||Qe(n)?n:_e())},se(Pr).z4=function(n){return this.x4_1.t1(n)},se(Pr).u=function(n){return!(null!=n&&!Qe(n))&&this.z4(null==n||Qe(n)?n:_e())},se(Pr).f=function(){return new Br(this.x4_1.o().f())},se(Pr).k=function(){return this.x4_1.k()},se(Pr).g4=function(){return this.x4_1.g4()},se(Ir).f5=function(n){throw Cu("Add is not supported on values")},se(Ir).d=function(n){return this.f5(null==n||Qe(n)?n:_e())},se(Ir).r1=function(n){return this.e5_1.s1(n)},se(Ir).u=function(n){return!(null!=n&&!Qe(n))&&this.r1(null==n||Qe(n)?n:_e())},se(Ir).f=function(){return new Cr(this.e5_1.o().f())},se(Ir).k=function(){return this.e5_1.k()},se(Ir).g4=function(){return this.e5_1.g4()},se(Sr).g5=function(){return null==this.c5_1&&(this.c5_1=new Pr(this)),he(this.c5_1)},se(Sr).w1=function(){return null==this.d5_1&&(this.d5_1=new Ir(this)),he(this.d5_1)},se(Sr).g4=function(){},se(zr).equals=function(n){return n===this||!(null==n||!Ue(n,Mi))&&wt().y1(this,n)},se(zr).hashCode=function(){return wt().x1(this)},se(Fr).j5=function(){return this.g4(),this.c_1=!0,this.k()>0?this:Tr().i5_1},se(Fr).k=function(){return this.b_1.length},se(Fr).j=function(n){var t=this.b_1[Mr(this,n)];return null==t||Qe(t)?t:_e()},se(Fr).f4=function(n,t){this.g4(),Mr(this,n);var r=this.b_1[n];this.b_1[n]=t;var i=r;return null==i||Qe(i)?i:_e()},se(Fr).d=function(n){return this.g4(),this.b_1.push(n),this.o4_1=this.o4_1+1|0,!0},se(Fr).p4=function(n,t){this.g4(),this.b_1.splice(function(n,t){return ft().b1(t,n.k()),t}(this,n),0,t),this.o4_1=this.o4_1+1|0},se(Fr).m=function(n){if(this.g4(),n.i())return!1;for(var t,r,i,e=(t=this,r=n.k(),i=t.k(),t.b_1.length=t.k()+r|0,i),u=0,o=n.f();o.g();){var f=o.h(),s=u;u=s+1|0;var c=wr(s);this.b_1[e+c|0]=f}return this.o4_1=this.o4_1+1|0,!0},se(Fr).q4=function(n){return An(this.b_1,n)},se(Fr).toString=function(){return Ln(this.b_1,", ","[","]",A,A,Xi)},se(Fr).k5=function(){return[].slice.call(this.b_1)},se(Fr).toArray=function(){return this.k5()},se(Fr).g4=function(){if(this.c_1)throw Bu()},se(Rr).l5=function(n,t){return oe(n,t)},se(Rr).m5=function(n){var t=null==n?null:ee(n);return null==t?0:t},se(Hr).o5=function(n){throw Cu("Add is not supported on entries")},se(Hr).d=function(n){return this.o5(null!=n&&Ue(n,Ai)?n:_e())},se(Hr).w4=function(n){return this.n5_1.u1(n)},se(Hr).f=function(){return this.n5_1.t5_1.f()},se(Hr).k=function(){return this.n5_1.k()},se(Vr).t1=function(n){return this.t5_1.z4(n)},se(Vr).s1=function(n){var t;n:{var r=this.t5_1;if(Ue(r,Ti)&&r.i())t=!1;else{for(var i=r.f();i.g();){var e=i.h();if(this.u5_1.l5(e.i1(),n)){t=!0;break n}}t=!1}}return t},se(Vr).o=function(){return null==this.v5_1&&(this.v5_1=this.x5()),he(this.v5_1)},se(Vr).x5=function(){return new Hr(this)},se(Vr).v1=function(n){return this.t5_1.v1(n)},se(Vr).h5=function(n,t){return this.t5_1.h5(n,t)},se(Vr).k=function(){return this.t5_1.k()},se(Zr).d=function(n){return null==this.y5_1.h5(n,this)},se(Zr).u=function(n){return this.y5_1.t1(n)},se(Zr).i=function(){return this.y5_1.i()},se(Zr).f=function(){return this.y5_1.g5().f()},se(Zr).k=function(){return this.y5_1.k()},se(Xr).g=function(){return-1===this.z5_1&&(this.z5_1=function(n){if(null!=n.c6_1&&n.d6_1){var t=n.c6_1.length;if(n.e6_1=n.e6_1+1|0,n.e6_1<t)return 0}if(n.b6_1=n.b6_1+1|0,n.b6_1<n.a6_1.length){n.c6_1=n.g6_1.i6_1[n.a6_1[n.b6_1]];var r=n,i=n.c6_1;return r.d6_1=null!=i&&Ve(i),n.e6_1=0,0}return n.c6_1=null,1}(this)),0===this.z5_1},se(Xr).h=function(){if(!this.g())throw pu();var n=this.d6_1?this.c6_1[this.e6_1]:this.c6_1;return this.f6_1=n,this.z5_1=-1,n},se(Jr).w5=function(){return this.h6_1},se(Jr).k=function(){return this.j6_1},se(Jr).h5=function(n,t){var r=this.h6_1.m5(n),i=Kr(this,r);if(null==i)this.i6_1[r]=new xr(n,t);else{if(null==i||!Ve(i)){var e,u=i;return this.h6_1.l5(u.j1(),n)?u.v4(t):(e=[u,new xr(n,t)],this.i6_1[r]=e,this.j6_1=this.j6_1+1|0,null)}var o=i,f=Wr(o,this,n);if(null!=f)return f.v4(t);o.push(new xr(n,t))}return this.j6_1=this.j6_1+1|0,null},se(Jr).z4=function(n){return!(null==Yr(this,n))},se(Jr).v1=function(n){var t=Yr(this,n);return null==t?null:t.i1()},se(Jr).f=function(){return new Xr(this)},se(ti).g=function(){return!(null===this.m6_1)},se(ti).h=function(){if(!this.g())throw pu();var n=he(this.m6_1);this.l6_1=n;var t,r=n.b7_1;return t=r!==this.n6_1.y6_1.v6_1?r:null,this.m6_1=t,n},se(ei).v4=function(n){return this.d7_1.g4(),se(xr).v4.call(this,n)},se(ui).o5=function(n){throw Cu("Add is not supported on entries")},se(ui).d=function(n){return this.o5(null!=n&&Ue(n,Ai)?n:_e())},se(ui).w4=function(n){return this.y6_1.u1(n)},se(ui).f=function(){return new ti(this)},se(ui).k=function(){return this.y6_1.k()},se(ui).g4=function(){return this.y6_1.g4()},se(si).j5=function(){var n;if(this.g4(),this.x6_1=!0,this.k()>0)n=this;else{var t=ii().e7_1;n=Ue(t,Ni)?t:_e()}return n},se(si).t1=function(n){return this.w6_1.t1(n)},se(si).s1=function(n){var t=this.v6_1;if(null==t)return!1;var r=t;do{if(oe(r.i1(),n))return!0;r=he(r.b7_1)}while(r!==this.v6_1);return!1},se(si).x5=function(){return new ui(this)},se(si).v1=function(n){var t=this.w6_1.v1(n);return null==t?null:t.i1()},se(si).h5=function(n,t){this.g4();var r=this.w6_1.v1(n);if(null==r){var i=new ei(this,n,t);return this.w6_1.h5(n,i),function(n,t){if(null!=n.b7_1||null!=n.c7_1)throw hu(ie("Check failed."));var r=t.v6_1;if(null==r)t.v6_1=n,n.b7_1=n,n.c7_1=n;else{var i=r.c7_1;if(null==i)throw hu(ie("Required value was null."));var e=i;n.c7_1=e,n.b7_1=r,r.c7_1=n,e.b7_1=n}}(i,this),null}return r.v4(t)},se(si).k=function(){return this.w6_1.k()},se(si).g4=function(){if(this.x6_1)throw Bu()},se(hi).g4=function(){return this.y5_1.g4()},se(_i).h7=function(){this.i7("\n")},se(_i).j7=function(n){this.i7(n),this.h7()},se(vi).i7=function(n){var t=String(n);this.k7_1.write(t)},se(di).i7=function(n){var t=String(n),r=t.lastIndexOf("\n",0);if(r>=0){var i=this.m7_1;this.m7_1=i+t.substring(0,r),this.n7();var e=r+1|0;t=t.substring(e)}this.m7_1=this.m7_1+t},se(di).n7=function(){console.log(this.m7_1),this.m7_1=""},se(gi).i7=function(n){var t=this.m7_1;this.m7_1=t+String(n)},se(pi).x3=function(){return this.o7_1.length},se(pi).y3=function(n){var t=this.o7_1;if(!(n>=0&&n<=Yt(t)))throw cu("index: "+n+", length: "+this.x3()+"}");return Zi(t,n)},se(pi).z3=function(n,t){return this.o7_1.substring(n,t)},se(pi).i3=function(n){return this.o7_1=this.o7_1+new zi(n),this},se(pi).e=function(n){return this.o7_1=this.o7_1+Oi(n),this},se(pi).p7=function(n){var t=this.o7_1;return this.o7_1=t+(null==n?"null":n),this},se(pi).toString=function(){return this.o7_1},se(yi).t7=function(n){var t=this.q7_1;return n.replace(t,"\\$&")},se(yi).u7=function(n){var t=this.s7_1;return n.replace(t,"$$$$")},se(Bi).a8=function(n){this.x7_1.lastIndex=0;var t=this.x7_1.exec(ie(n));return null!=t&&0===t.index&&this.x7_1.lastIndex===Wi(n)},se(Bi).toString=function(){return this.x7_1.toString()},se(zi).o8=function(n){return ji(this.h3_1,n)},se(zi).a4=function(n){return function(n,t){return ji(n.h3_1,t instanceof zi?t.h3_1:_e())}(this,n)},se(zi).equals=function(n){return function(n,t){return t instanceof zi&&n===t.h3_1}(this.h3_1,n)},se(zi).hashCode=function(){return this.h3_1},se(zi).toString=function(){return Pi(this.h3_1)},se(Di).r8=function(n){return Ji(this.q8_1,n.q8_1)},se(Di).a4=function(n){return this.r8(n instanceof Di?n:_e())},se(Di).equals=function(n){return this===n},se(Di).hashCode=function(){return re(this)},se(Di).toString=function(){return this.p8_1},se(Hi).g=function(){return!(this.s8_1===this.t8_1.length)},se(Hi).h=function(){if(this.s8_1===this.t8_1.length)throw mu(""+this.s8_1);var n=this.s8_1;return this.s8_1=n+1|0,this.t8_1[n]},se(de).b9=function(n){return ke(this,n)},se(de).a4=function(n){return this.b9(n instanceof de?n:_e())},se(de).c9=function(n){return ye(this,n)},se(de).d9=function(n){return function(n,t){if(Me(),Se(t))throw vu("division by zero");if(Se(n))return ge();if(xe(n,pe())){if(xe(t,we())||xe(t,be()))return pe();if(xe(t,pe()))return we();var r=function(n){Me();return new de(n.u8_1>>>1|n.v8_1<<31,n.v8_1>>1)}(n),i=function(n){Me();return new de(n.u8_1<<1,n.v8_1<<1|n.u8_1>>>31)}(r.d9(t));return xe(i,ge())?Ie(t)?we():be():ye(i,qe(n,Be(t,i)).d9(t))}if(xe(t,pe()))return ge();if(Ie(n))return Ie(t)?Ee(n).d9(Ee(t)):Ee(Ee(n).d9(t));if(Ie(t))return Ee(n.d9(Ee(t)));for(var e=ge(),u=n;Ae(u,t);){for(var o=Ce(u)/Ce(t),f=Math.max(1,Math.floor(o)),s=Math.ceil(Math.log(f)/Math.LN2),c=s<=48?1:Math.pow(2,s-48),a=Le(f),h=Be(a,t);Ie(h)||Ne(h,u);)h=Be(a=Le(f-=c),t);Se(a)&&(a=we()),e=ye(e,a),u=qe(u,h)}return e}(this,n)},se(de).e9=function(){return this.f9().c9(new de(1,0))},se(de).f9=function(){return new de(~this.u8_1,~this.v8_1)},se(de).g9=function(){return this.u8_1},se(de).w8=function(){return Ce(this)},se(de).valueOf=function(){return this.w8()},se(de).equals=function(n){return n instanceof de&&xe(this,n)},se(de).hashCode=function(){return Me(),this.u8_1^this.v8_1},se(de).toString=function(){return je(this,10)},se(Au).toString=function(){return"Model(text="+this.o9_1+", tooltip="+this.p9_1+")"},se(Au).hashCode=function(){var n=ue(this.o9_1);return zn(n,31)+ue(this.p9_1)|0},se(Au).equals=function(n){if(this===n)return!0;if(!(n instanceof Au))return!1;var t=n instanceof Au?n:_e();return this.o9_1===t.o9_1&&this.p9_1===t.p9_1},se(Mu).v9=function(n,t){return this.w9(new Au(n,t))},se(Mu).w9=function(n){var t,r;return Df().y9(Jf((t=n,r=this,function(n){return n.s9(t.p9_1),n.t9("copy-button"),n.u9(function(n,t){return function(r){return n.q9_1(t.o9_1)}}(r,t)),lr()})),[])},se(Mu).z9=function(n){return this.w9(n instanceof Au?n:_e())},se(Mu).aa=function(n,t){return t},se(Mu).ba=function(n,t){var r=null==n||Qe(n)?n:_e();return this.aa(r,t instanceof Au?t:_e())},se(Du).ka=function(n){return function(n,t){for(var r=Ff(),i=t.ca_1,e=Nr(xt(i,10)),u=i.f();u.g();){var o,f,s=u.h();s instanceof pf?f=Ff().ga(s.fa_1):s instanceof mf?f=Fu(n,s.da_1,s.ea_1):le(),o=f,e.d(o)}return r.ha(e)}(this,n)},se(Du).z9=function(n){return this.ka(n instanceof Cf?n:_e())},se(Du).la=function(n,t){return t},se(Du).ba=function(n,t){var r=null==n||Qe(n)?n:_e();return this.la(r,t instanceof Cf?t:_e())},se(Ou).pa=function(n,t,r){return new Ou(n,t,r)},se(Ou).qa=function(n,t,r,i){return n=n===A?this.ma_1:n,t=t===A?this.na_1:t,r=r===A?this.oa_1:r,i===A?this.pa(n,t,r):i.pa.call(this,n,t,r)},se(Ou).toString=function(){return"Exception(summary="+this.ma_1+", fullText="+this.na_1+", parts="+this.oa_1+")"},se(Ou).hashCode=function(){var n=null==this.ma_1?0:this.ma_1.hashCode();return n=zn(n,31)+ue(this.na_1)|0,zn(n,31)+ee(this.oa_1)|0},se(Ou).equals=function(n){if(this===n)return!0;if(!(n instanceof Ou))return!1;var t=n instanceof Ou?n:_e();return!!oe(this.ma_1,t.ma_1)&&this.na_1===t.na_1&&!!oe(this.oa_1,t.oa_1)},se(Ru).ta=function(n,t){return new Ru(n,t)},se(Ru).ua=function(n,t,r){return n=n===A?this.ra_1:n,t=t===A?this.sa_1:t,r===A?this.ta(n,t):r.ta.call(this,n,t)},se(Ru).toString=function(){return"StackTracePart(lines="+this.ra_1+", state="+this.sa_1+")"},se(Ru).hashCode=function(){var n=ee(this.ra_1);return zn(n,31)+(null==this.sa_1?0:this.sa_1.hashCode())|0},se(Ru).equals=function(n){if(this===n)return!0;if(!(n instanceof Ru))return!1;var t=n instanceof Ru?n:_e();return!!oe(this.ra_1,t.ra_1)&&!!oe(this.sa_1,t.sa_1)},se(Hu).toString=function(){return"Error(label="+this.va_1+", docLink="+this.wa_1+")"},se(Hu).hashCode=function(){var n=ee(this.va_1);return zn(n,31)+(null==this.wa_1?0:ee(this.wa_1))|0},se(Hu).equals=function(n){if(this===n)return!0;if(!(n instanceof Hu))return!1;var t=n instanceof Hu?n:_e();return!!oe(this.va_1,t.va_1)&&!!oe(this.wa_1,t.wa_1)},se($u).toString=function(){return"Warning(label="+this.xa_1+", docLink="+this.ya_1+")"},se($u).hashCode=function(){var n=ee(this.xa_1);return zn(n,31)+(null==this.ya_1?0:ee(this.ya_1))|0},se($u).equals=function(n){if(this===n)return!0;if(!(n instanceof $u))return!1;var t=n instanceof $u?n:_e();return!!oe(this.xa_1,t.xa_1)&&!!oe(this.ya_1,t.ya_1)},se(Gu).toString=function(){return"Message(prettyText="+this.za_1+")"},se(Gu).hashCode=function(){return this.za_1.hashCode()},se(Gu).equals=function(n){if(this===n)return!0;if(!(n instanceof Gu))return!1;var t=n instanceof Gu?n:_e();return!!this.za_1.equals(t.za_1)},se(Uu).toString=function(){return"ListElement(prettyText="+this.ab_1+")"},se(Uu).hashCode=function(){return this.ab_1.hashCode()},se(Uu).equals=function(n){if(this===n)return!0;if(!(n instanceof Uu))return!1;var t=n instanceof Uu?n:_e();return!!this.ab_1.equals(t.ab_1)},se(Vu).toString=function(){return"TreeNode(prettyText="+this.bb_1+")"},se(Vu).hashCode=function(){return this.bb_1.hashCode()},se(Vu).equals=function(n){if(this===n)return!0;if(!(n instanceof Vu))return!1;var t=n instanceof Vu?n:_e();return!!this.bb_1.equals(t.bb_1)},se(Qu).toString=function(){return"Link(href="+this.cb_1+", label="+this.db_1+")"},se(Qu).hashCode=function(){var n=ue(this.cb_1);return zn(n,31)+ue(this.db_1)|0},se(Qu).equals=function(n){if(this===n)return!0;if(!(n instanceof Qu))return!1;var t=n instanceof Qu?n:_e();return this.cb_1===t.cb_1&&this.db_1===t.db_1},se(Zu).toString=function(){return"Label(text="+this.eb_1+")"},se(Zu).hashCode=function(){return ue(this.eb_1)},se(Zu).equals=function(n){if(this===n)return!0;if(!(n instanceof Zu))return!1;var t=n instanceof Zu?n:_e();return this.eb_1===t.eb_1},se(io).toString=function(){return"Info(label="+this.hb_1+", docLink="+this.ib_1+")"},se(io).hashCode=function(){var n=ee(this.hb_1);return zn(n,31)+(null==this.ib_1?0:ee(this.ib_1))|0},se(io).equals=function(n){if(this===n)return!0;if(!(n instanceof io))return!1;var t=n instanceof io?n:_e();return!!oe(this.hb_1,t.hb_1)&&!!oe(this.ib_1,t.ib_1)},se(eo).toString=function(){return"Project(path="+this.jb_1+")"},se(eo).hashCode=function(){return ue(this.jb_1)},se(eo).equals=function(n){if(this===n)return!0;if(!(n instanceof eo))return!1;var t=n instanceof eo?n:_e();return this.jb_1===t.jb_1},se(uo).toString=function(){return"Task(path="+this.kb_1+", type="+this.lb_1+")"},se(uo).hashCode=function(){var n=ue(this.kb_1);return zn(n,31)+ue(this.lb_1)|0},se(uo).equals=function(n){if(this===n)return!0;if(!(n instanceof uo))return!1;var t=n instanceof uo?n:_e();return this.kb_1===t.kb_1&&this.lb_1===t.lb_1},se(oo).toString=function(){return"TaskPath(path="+this.mb_1+")"},se(oo).hashCode=function(){return ue(this.mb_1)},se(oo).equals=function(n){if(this===n)return!0;if(!(n instanceof oo))return!1;var t=n instanceof oo?n:_e();return this.mb_1===t.mb_1},se(fo).toString=function(){return"Bean(type="+this.nb_1+")"},se(fo).hashCode=function(){return ue(this.nb_1)},se(fo).equals=function(n){if(this===n)return!0;if(!(n instanceof fo))return!1;var t=n instanceof fo?n:_e();return this.nb_1===t.nb_1},se(so).toString=function(){return"SystemProperty(name="+this.ob_1+")"},se(so).hashCode=function(){return ue(this.ob_1)},se(so).equals=function(n){if(this===n)return!0;if(!(n instanceof so))return!1;var t=n instanceof so?n:_e();return this.ob_1===t.ob_1},se(co).toString=function(){return"Property(kind="+this.pb_1+", name="+this.qb_1+", owner="+this.rb_1+")"},se(co).hashCode=function(){var n=ue(this.pb_1);return n=zn(n,31)+ue(this.qb_1)|0,zn(n,31)+ue(this.rb_1)|0},se(co).equals=function(n){if(this===n)return!0;if(!(n instanceof co))return!1;var t=n instanceof co?n:_e();return this.pb_1===t.pb_1&&this.qb_1===t.qb_1&&this.rb_1===t.rb_1},se(ao).toString=function(){return"BuildLogic(location="+this.sb_1+")"},se(ao).hashCode=function(){return ue(this.sb_1)},se(ao).equals=function(n){if(this===n)return!0;if(!(n instanceof ao))return!1;var t=n instanceof ao?n:_e();return this.sb_1===t.sb_1},se(ho).toString=function(){return"BuildLogicClass(type="+this.tb_1+")"},se(ho).hashCode=function(){return ue(this.tb_1)},se(ho).equals=function(n){if(this===n)return!0;if(!(n instanceof ho))return!1;var t=n instanceof ho?n:_e();return this.tb_1===t.tb_1},se(vo).zb=function(){return this.yb_1},se(vo).toString=function(){return"TaskTreeIntent(delegate="+this.yb_1+")"},se(vo).hashCode=function(){return ee(this.yb_1)},se(vo).equals=function(n){if(this===n)return!0;if(!(n instanceof vo))return!1;var t=n instanceof vo?n:_e();return!!oe(this.yb_1,t.yb_1)},se(go).zb=function(){return this.ac_1},se(go).toString=function(){return"MessageTreeIntent(delegate="+this.ac_1+")"},se(go).hashCode=function(){return ee(this.ac_1)},se(go).equals=function(n){if(this===n)return!0;if(!(n instanceof go))return!1;var t=n instanceof go?n:_e();return!!oe(this.ac_1,t.ac_1)},se(wo).zb=function(){return this.bc_1},se(wo).toString=function(){return"InputTreeIntent(delegate="+this.bc_1+")"},se(wo).hashCode=function(){return ee(this.bc_1)},se(wo).equals=function(n){if(this===n)return!0;if(!(n instanceof wo))return!1;var t=n instanceof wo?n:_e();return!!oe(this.bc_1,t.bc_1)},se(bo).zb=function(){return this.cc_1},se(bo).toString=function(){return"IncompatibleTaskTreeIntent(delegate="+this.cc_1+")"},se(bo).hashCode=function(){return ee(this.cc_1)},se(bo).equals=function(n){if(this===n)return!0;if(!(n instanceof bo))return!1;var t=n instanceof bo?n:_e();return!!oe(this.cc_1,t.cc_1)},se(po).toString=function(){return"SetTab(tab="+this.dc_1+")"},se(po).hashCode=function(){return this.dc_1.hashCode()},se(po).equals=function(n){if(this===n)return!0;if(!(n instanceof po))return!1;var t=n instanceof po?n:_e();return!!this.dc_1.equals(t.dc_1)},se(mo).mc=function(n,t,r,i,e,u,o,f){return new mo(n,t,r,i,e,u,o,f)},se(mo).nc=function(n,t,r,i,e,u,o,f,s){return n=n===A?this.ec_1:n,t=t===A?this.fc_1:t,r=r===A?this.gc_1:r,i=i===A?this.hc_1:i,e=e===A?this.ic_1:e,u=u===A?this.jc_1:u,o=o===A?this.kc_1:o,f=f===A?this.lc_1:f,s===A?this.mc(n,t,r,i,e,u,o,f):s.mc.call(this,n,t,r,i,e,u,o,f)},se(mo).toString=function(){return"Model(heading="+this.ec_1+", summary="+this.fc_1+", learnMore="+this.gc_1+", messageTree="+this.hc_1+", locationTree="+this.ic_1+", inputTree="+this.jc_1+", incompatibleTaskTree="+this.kc_1+", tab="+this.lc_1+")"},se(mo).hashCode=function(){var n=this.ec_1.hashCode();return n=zn(n,31)+ee(this.fc_1)|0,n=zn(n,31)+this.gc_1.hashCode()|0,n=zn(n,31)+this.hc_1.hashCode()|0,n=zn(n,31)+this.ic_1.hashCode()|0,n=zn(n,31)+this.jc_1.hashCode()|0,n=zn(n,31)+this.kc_1.hashCode()|0,zn(n,31)+this.lc_1.hashCode()|0},se(mo).equals=function(n){if(this===n)return!0;if(!(n instanceof mo))return!1;var t=n instanceof mo?n:_e();return!!(this.ec_1.equals(t.ec_1)&&oe(this.fc_1,t.fc_1)&&this.gc_1.equals(t.gc_1)&&this.hc_1.equals(t.hc_1)&&this.ic_1.equals(t.ic_1)&&this.jc_1.equals(t.jc_1)&&this.kc_1.equals(t.kc_1)&&this.lc_1.equals(t.lc_1))},se(Uo).gd=function(n,t){var r,i;return n instanceof vo?r=t.nc(A,A,A,A,_s().id(n.yb_1,t.ic_1)):n instanceof go?r=t.nc(A,A,A,_s().id(n.ac_1,t.hc_1)):n instanceof wo?r=t.nc(A,A,A,A,A,_s().id(n.bc_1,t.jc_1)):n instanceof bo?r=t.nc(A,A,A,A,A,A,_s().id(n.cc_1,t.kc_1)):n instanceof qc?r=function(n,t,r,i){var e;return r instanceof go?e=n.nc(A,A,A,mc(n.hc_1,r,i)):r instanceof vo?e=n.nc(A,A,A,A,mc(n.ic_1,r,i)):r instanceof wo?e=n.nc(A,A,A,A,A,mc(n.jc_1,r,i)):r instanceof bo?e=n.nc(A,A,A,A,A,A,mc(n.kc_1,r,i)):(console.error("Unhandled tree intent: "+r),e=n),e}(t,0,n.xc_1,(i=n,function(n){var t;if(!(n instanceof Ou))throw fu(ie("Failed requirement."));for(var r=n.oa_1,e=i.wc_1,u=Nr(xt(r,10)),o=0,f=r.f();f.g();){var s,c,a=f.h(),h=o;if(o=h+1|0,e===wr(h)){var l=a.sa_1;c=a.ua(A,null==l?null:l.ad())}else c=a;s=c,u.d(s)}return t=u,n.qa(A,A,t)})):n instanceof kc?(window.navigator.clipboard.writeText(n.hd_1),r=t):n instanceof po?r=t.nc(A,A,A,A,A,A,A,n.dc_1):(console.error("Unhandled intent: "+n),r=t),r},se(Uo).ba=function(n,t){var r=n instanceof Bc?n:_e();return this.gd(r,t instanceof mo?t:_e())},se(Uo).jd=function(n){return Af().y9(Jf(To),[qo(0,n),Bo(0,n)])},se(Uo).z9=function(n){return this.jd(n instanceof mo?n:_e())},se(Zo).toString=function(){return"ImportedProblem(problem="+this.kd_1+", message="+this.ld_1+", trace="+this.md_1+")"},se(Zo).hashCode=function(){var n=ee(this.kd_1);return n=zn(n,31)+this.ld_1.hashCode()|0,zn(n,31)+ee(this.md_1)|0},se(Zo).equals=function(n){if(this===n)return!0;if(!(n instanceof Zo))return!1;var t=n instanceof Zo?n:_e();return!!oe(this.kd_1,t.kd_1)&&!!this.ld_1.equals(t.ld_1)&&!!oe(this.md_1,t.md_1)},se(ff).ud=function(n,t){return this.td_1(n,t)},se(ff).compare=function(n,t){return this.ud(n,t)},se(bf).toString=function(){return"LearnMore(text="+this.sc_1+", documentationLink="+this.tc_1+")"},se(bf).hashCode=function(){var n=ue(this.sc_1);return zn(n,31)+ue(this.tc_1)|0},se(bf).equals=function(n){if(this===n)return!0;if(!(n instanceof bf))return!1;var t=n instanceof bf?n:_e();return this.sc_1===t.sc_1&&this.tc_1===t.tc_1},se(pf).toString=function(){return"Text(text="+this.fa_1+")"},se(pf).hashCode=function(){return ue(this.fa_1)},se(pf).equals=function(n){if(this===n)return!0;if(!(n instanceof pf))return!1;var t=n instanceof pf?n:_e();return this.fa_1===t.fa_1},se(mf).toString=function(){return"Reference(name="+this.da_1+", clipboardString="+this.ea_1+")"},se(mf).hashCode=function(){var n=ue(this.da_1);return zn(n,31)+ue(this.ea_1)|0},se(mf).equals=function(n){if(this===n)return!0;if(!(n instanceof mf))return!1;var t=n instanceof mf?n:_e();return this.da_1===t.da_1&&this.ea_1===t.ea_1},se(yf).ed=function(n){return this.dd_1.d(new pf(n)),this},se(yf).xd=function(n,t){return this.dd_1.d(new mf(n,t)),this},se(yf).fd=function(n,t,r){return t=t===A?n:t,r===A?this.xd(n,t):r.xd.call(this,n,t)},se(yf).j5=function(){return new Cf(Rn(this.dd_1))},se(qf).rd=function(n){return new Cf(gr(new pf(n)))},se(qf).qd=function(n){var t=new yf;return n(t),t.j5()},se(Cf).vd=function(n){return new Cf(n)},se(Cf).toString=function(){return"PrettyText(fragments="+this.ca_1+")"},se(Cf).hashCode=function(){return ee(this.ca_1)},se(Cf).equals=function(n){if(this===n)return!0;if(!(n instanceof Cf))return!1;var t=n instanceof Cf?n:_e();return!!oe(this.ca_1,t.ca_1)},se(xf).sd=function(n){return function(n){for(var t=Gr(),r=n.f();r.g();)for(var i=t,e=r.h().f();e.g();){var u,o=e.h(),f=i,s=f.v1(o);if(null==s){var c=Gr();f.h5(o,c),u=c}else u=s;i=u instanceof Vr?u:_e()}return t}(n)},se(Sf).toString=function(){return"Trie(nestedMaps="+this.wd_1+")"},se(Sf).hashCode=function(){return ee(this.wd_1)},se(Sf).equals=function(n){return function(n,t){return t instanceof Sf&&!!oe(n,t instanceof Sf?t.wd_1:_e())}(this.wd_1,n)},se(Uf).ga=function(n){return Qf().yd(this.x9_1,A,n)},se(Uf).ha=function(n){return Qf().yd(this.x9_1,A,A,n)},se(Uf).ja=function(n){return Qf().yd(this.x9_1,A,A,nu(n))},se(Uf).y9=function(n,t){return Qf().yd(this.x9_1,n,A,nu(t))},se(Uf).zd=function(n,t){return Qf().yd(this.x9_1,n,A,t)},se(Uf).fb=function(n,t){return Qf().yd(this.x9_1,n,t)},se(Uf).rc=function(n,t){return Qf().yd(this.x9_1,A,n,nu(t))},se(Uf).toString=function(){return"ViewFactory(elementName="+this.x9_1+")"},se(Uf).hashCode=function(){return ue(this.x9_1)},se(Uf).equals=function(n){if(this===n)return!0;if(!(n instanceof Uf))return!1;var t=n instanceof Uf?n:_e();return this.x9_1===t.x9_1},se(Vf).ae=function(n,t,r,i){return new Wf(n,t,r,i)},se(Vf).yd=function(n,t,r,i,e){return t=t===A?pt():t,r=r===A?null:r,i=i===A?pt():i,e===A?this.ae(n,t,r,i):e.ae.call(this,n,t,r,i)},se(Wf).toString=function(){return"Element(elementName="+this.be_1+", attributes="+this.ce_1+", innerText="+this.de_1+", children="+this.ee_1+")"},se(Wf).hashCode=function(){var n=ue(this.be_1);return n=zn(n,31)+ee(this.ce_1)|0,n=zn(n,31)+(null==this.de_1?0:ue(this.de_1))|0,zn(n,31)+ee(this.ee_1)|0},se(Wf).equals=function(n){if(this===n)return!0;if(!(n instanceof Wf))return!1;var t=n instanceof Wf?n:_e();return this.be_1===t.be_1&&!!oe(this.ce_1,t.ce_1)&&this.de_1==t.de_1&&!!oe(this.ee_1,t.ee_1)},se(ns).u9=function(n){return this.r9_1(new ts("click",n))},se(ns).t9=function(n){return this.r9_1(new rs(n))},se(ns).gb=function(n){for(var t=0,r=n.length;t<r;){var i=n[t];t=t+1|0,this.r9_1(new rs(i))}return lr()},se(ns).s9=function(n){return this.r9_1(new is("title",n))},se(ns).bd=function(n){return this.r9_1(new is("href",n))},se(ss).oe=function(){return this.ne_1},se(ss).toString=function(){return"Toggle(focus="+this.ne_1+")"},se(ss).hashCode=function(){return ee(this.ne_1)},se(ss).equals=function(n){if(this===n)return!0;if(!(n instanceof ss))return!1;var t=n instanceof ss?n:_e();return!!oe(this.ne_1,t.ne_1)},se(cs).pe=function(n,t){return this.re(n.qe((r=t,function(n){return n.me(r(n.ub_1))})));var r},se(cs).re=function(n){return new cs(n)},se(cs).toString=function(){return"Model(tree="+this.xb_1+")"},se(cs).hashCode=function(){return this.xb_1.hashCode()},se(cs).equals=function(n){if(this===n)return!0;if(!(n instanceof cs))return!1;var t=n instanceof cs?n:_e();return!!this.xb_1.equals(t.xb_1)},se(ls).id=function(n,t){var r;if(n instanceof ss){var i=n.oe();r=t.re(i.qe(hs))}else le();return r},se(ds).cd=function(){return this.ve_1},se(ds).we=function(){return 0},se(ds).qe=function(n){return n(this.ve_1)},se(ds).toString=function(){return"Original(tree="+this.ve_1+")"},se(ds).hashCode=function(){return this.ve_1.hashCode()},se(ds).equals=function(n){if(this===n)return!0;if(!(n instanceof ds))return!1;var t=n instanceof ds?n:_e();return!!this.ve_1.equals(t.ve_1)},se(gs).cd=function(){return this.ue_1},se(gs).we=function(){return this.se_1.we()+1|0},se(gs).qe=function(n){return this.se_1.qe((t=this,r=n,function(n){for(var i,e=n.vb_1,u=t.te_1,o=Nr(xt(e,10)),f=0,s=e.f();s.g();){var c,a=s.h(),h=f;f=h+1|0,c=u===wr(h)?r(a):a,o.d(c)}return i=o,n.me(A,i)}));var t,r},se(gs).toString=function(){return"Child(parent="+this.se_1+", index="+this.te_1+", tree="+this.ue_1+")"},se(gs).hashCode=function(){var n=ee(this.se_1);return n=zn(n,31)+this.te_1|0,zn(n,31)+this.ue_1.hashCode()|0},se(gs).equals=function(n){if(this===n)return!0;if(!(n instanceof gs))return!1;var t=n instanceof gs?n:_e();return!!oe(this.se_1,t.se_1)&&this.te_1===t.te_1&&!!this.ue_1.equals(t.ue_1)},se(ws).ad=function(){var n;switch(this.q8_1){case 0:n=ms();break;case 1:n=ps();break;default:le()}return n},se(bs).vc=function(){var n,t;return Jn(On(Oe(0,this.cd().vb_1.k()-1|0)),(n=this,(t=function(t){return n.xe(t)}).callableName="child",t))},se(bs).xe=function(n){return new gs(this,n,this.cd().vb_1.j(n))},se(ks).uc=function(){return new ds(this)},se(ks).ye=function(){return!this.vb_1.i()},se(ks).ze=function(n,t,r){return new ks(n,t,r)},se(ks).me=function(n,t,r,i){return n=n===A?this.ub_1:n,t=t===A?this.vb_1:t,r=r===A?this.wb_1:r,i===A?this.ze(n,t,r):i.ze.call(this,n,t,r)},se(ks).toString=function(){return"Tree(label="+this.ub_1+", children="+this.vb_1+", state="+this.wb_1+")"},se(ks).hashCode=function(){var n=null==this.ub_1?0:ee(this.ub_1);return n=zn(n,31)+ee(this.vb_1)|0,zn(n,31)+this.wb_1.hashCode()|0},se(ks).equals=function(n){if(this===n)return!0;if(!(n instanceof ks))return!1;var t=n instanceof ks?n:_e();return!!oe(this.ub_1,t.ub_1)&&!!oe(this.vb_1,t.vb_1)&&!!this.wb_1.equals(t.wb_1)},se(Cs).toString=function(){return"ProblemIdElement(name="+this.df_1+", displayName="+this.ef_1+")"},se(Cs).hashCode=function(){var n=ue(this.df_1);return zn(n,31)+ue(this.ef_1)|0},se(Cs).equals=function(n){if(this===n)return!0;if(!(n instanceof Cs))return!1;var t=n instanceof Cs?n:_e();return this.df_1===t.df_1&&this.ef_1===t.ef_1},se(xs).toString=function(){return"ProblemSummary(problemId="+this.ff_1+", count="+this.gf_1+")"},se(xs).hashCode=function(){var n=ee(this.ff_1);return zn(n,31)+this.gf_1|0},se(xs).equals=function(n){if(this===n)return!0;if(!(n instanceof xs))return!1;var t=n instanceof xs?n:_e();return!!oe(this.ff_1,t.ff_1)&&this.gf_1===t.gf_1},se(Is).toString=function(){return"ProblemNodeGroup(tree="+this.hf_1+", children="+this.if_1+", childGroups="+this.jf_1+", id="+this.kf_1+")"},se(Is).hashCode=function(){var n=this.hf_1.hashCode();return n=zn(n,31)+ee(this.if_1)|0,n=zn(n,31)+ee(this.jf_1)|0,zn(n,31)+this.kf_1|0},se(Is).equals=function(n){if(this===n)return!0;if(!(n instanceof Is))return!1;var t=n instanceof Is?n:_e();return!!this.hf_1.equals(t.hf_1)&&!!oe(this.if_1,t.if_1)&&!!oe(this.jf_1,t.jf_1)&&this.kf_1===t.kf_1},se(Us).toString=function(){return"Text(text="+this.lf_1+")"},se(Us).hashCode=function(){return ue(this.lf_1)},se(Us).equals=function(n){if(this===n)return!0;if(!(n instanceof Us))return!1;var t=n instanceof Us?n:_e();return this.lf_1===t.lf_1},se(Vs).toString=function(){return"ProblemIdNode(prettyText="+this.mf_1+", separator="+this.nf_1+")"},se(Vs).hashCode=function(){var n=this.mf_1.hashCode();return zn(n,31)+(0|this.nf_1)|0},se(Vs).equals=function(n){if(this===n)return!0;if(!(n instanceof Vs))return!1;var t=n instanceof Vs?n:_e();return!!this.mf_1.equals(t.mf_1)&&this.nf_1===t.nf_1},se(Qs).toString=function(){return"Advice(label="+this.of_1+", docLink="+this.pf_1+")"},se(Qs).hashCode=function(){var n=ee(this.of_1);return zn(n,31)+(null==this.pf_1?0:ee(this.pf_1))|0},se(Qs).equals=function(n){if(this===n)return!0;if(!(n instanceof Qs))return!1;var t=n instanceof Qs?n:_e();return!!oe(this.of_1,t.of_1)&&!!oe(this.pf_1,t.pf_1)},se(Ys).zb=function(){return this.qf_1},se(Ys).toString=function(){return"MessageTreeIntent(delegate="+this.qf_1+")"},se(Ys).hashCode=function(){return ee(this.qf_1)},se(Ys).equals=function(n){if(this===n)return!0;if(!(n instanceof Ys))return!1;var t=n instanceof Ys?n:_e();return!!oe(this.qf_1,t.qf_1)},se(Ws).zb=function(){return this.rf_1},se(Ws).toString=function(){return"ProblemIdTreeIntent(delegate="+this.rf_1+")"},se(Ws).hashCode=function(){return ee(this.rf_1)},se(Ws).equals=function(n){if(this===n)return!0;if(!(n instanceof Ws))return!1;var t=n instanceof Ws?n:_e();return!!oe(this.rf_1,t.rf_1)},se(Ks).zb=function(){return this.sf_1},se(Ks).toString=function(){return"FileLocationTreeIntent(delegate="+this.sf_1+")"},se(Ks).hashCode=function(){return ee(this.sf_1)},se(Ks).equals=function(n){if(this===n)return!0;if(!(n instanceof Ks))return!1;var t=n instanceof Ks?n:_e();return!!oe(this.sf_1,t.sf_1)},se(Xs).toString=function(){return"SetTab(tab="+this.tf_1+")"},se(Xs).hashCode=function(){return this.tf_1.hashCode()},se(Xs).equals=function(n){if(this===n)return!0;if(!(n instanceof Xs))return!1;var t=n instanceof Xs?n:_e();return!!this.tf_1.equals(t.tf_1)},se(Js).cg=function(n,t,r,i,e,u,o,f){return new Js(n,t,r,i,e,u,o,f)},se(Js).dg=function(n,t,r,i,e,u,o,f,s){return n=n===A?this.uf_1:n,t=t===A?this.vf_1:t,r=r===A?this.wf_1:r,i=i===A?this.xf_1:i,e=e===A?this.yf_1:e,u=u===A?this.zf_1:u,o=o===A?this.ag_1:o,f=f===A?this.bg_1:f,s===A?this.cg(n,t,r,i,e,u,o,f):s.cg.call(this,n,t,r,i,e,u,o,f)},se(Js).toString=function(){return"Model(heading="+this.uf_1+", summary="+this.vf_1+", learnMore="+this.wf_1+", messageTree="+this.xf_1+", problemIdTree="+this.yf_1+", fileLocationTree="+this.zf_1+", problemCount="+this.ag_1+", tab="+this.bg_1+")"},se(Js).hashCode=function(){var n=this.uf_1.hashCode();return n=zn(n,31)+ee(this.vf_1)|0,n=zn(n,31)+this.wf_1.hashCode()|0,n=zn(n,31)+this.xf_1.hashCode()|0,n=zn(n,31)+this.yf_1.hashCode()|0,n=zn(n,31)+this.zf_1.hashCode()|0,n=zn(n,31)+this.ag_1|0,zn(n,31)+this.bg_1.hashCode()|0},se(Js).equals=function(n){if(this===n)return!0;if(!(n instanceof Js))return!1;var t=n instanceof Js?n:_e();return!!(this.uf_1.equals(t.uf_1)&&oe(this.vf_1,t.vf_1)&&this.wf_1.equals(t.wf_1)&&this.xf_1.equals(t.xf_1)&&this.yf_1.equals(t.yf_1)&&this.zf_1.equals(t.zf_1)&&this.ag_1===t.ag_1&&this.bg_1.equals(t.bg_1))},se(bc).eg=function(n,t){var r,i;return n instanceof Ks?r=t.dg(A,A,A,A,A,_s().id(n.sf_1,t.zf_1)):n instanceof Ws?r=t.dg(A,A,A,A,_s().id(n.rf_1,t.yf_1)):n instanceof Ys?r=t.dg(A,A,A,_s().id(n.qf_1,t.xf_1)):n instanceof qc?r=function(n,t,r,i){var e;return r instanceof Ys?e=n.dg(A,A,A,mc(n.xf_1,r,i)):r instanceof Ws?e=n.dg(A,A,A,A,mc(n.yf_1,r,i)):r instanceof Ks?e=n.dg(A,A,A,A,A,mc(n.zf_1,r,i)):(console.error("Unhandled tree intent: "+r),e=n),e}(t,0,n.xc_1,(i=n,function(n){var t;if(!(n instanceof Ou))throw fu(ie("Failed requirement."));for(var r=n.oa_1,e=i.wc_1,u=Nr(xt(r,10)),o=0,f=r.f();f.g();){var s,c,a=f.h(),h=o;if(o=h+1|0,e===wr(h)){var l=a.sa_1;c=a.ua(A,null==l?null:l.ad())}else c=a;s=c,u.d(s)}return t=u,n.qa(A,A,t)})):n instanceof kc?(window.navigator.clipboard.writeText(n.hd_1),r=t):n instanceof Xs?r=t.dg(A,A,A,A,A,A,A,n.tf_1):(console.error("Unhandled intent: "+n),r=t),r},se(bc).ba=function(n,t){var r=n instanceof Bc?n:_e();return this.eg(r,t instanceof Js?t:_e())},se(bc).fg=function(n){return Af().y9(Jf(ac),[tc(0,n),rc(0,n)])},se(bc).z9=function(n){return this.fg(n instanceof Js?n:_e())},se(kc).toString=function(){return"Copy(text="+this.hd_1+")"},se(kc).hashCode=function(){return ue(this.hd_1)},se(kc).equals=function(n){if(this===n)return!0;if(!(n instanceof kc))return!1;var t=n instanceof kc?n:_e();return this.hd_1===t.hd_1},se(qc).toString=function(){return"ToggleStackTracePart(partIndex="+this.wc_1+", location="+this.xc_1+")"},se(qc).hashCode=function(){var n=this.wc_1;return zn(n,31)+ee(this.xc_1)|0},se(qc).equals=function(n){if(this===n)return!0;if(!(n instanceof qc))return!1;var t=n instanceof qc?n:_e();return this.wc_1===t.wc_1&&!!oe(this.xc_1,t.xc_1)},se(Jr).k6=function(){var n=Object.create(null);return n.foo=1,delete n.foo,lr(),n},l=null,wn=0,function(){var n=configurationCacheProblems();if(null==n.problemsReport)zf(Ef("report"),Vo(),function(n){var t,r,i,e,u,o,f,s,c,a,h=function(n){for(var t=Lr(),r=Lr(),i=Lr(),e=0,u=n.length;e<u;){var o=n[e];e=e+1|0;var f,s=o.input,c=null==s?null:r.d(Wo(s,o));if(null==c){var a=o.incompatibleTask;f=null==a?null:i.d(Wo(a,o))}else f=c;if(null==f){var h=he(o.problem);t.d(Wo(h,o))}}return new Yo(t,r,i)}(n.diagnostics),l=n.totalProblemCount;return new mo((f=(t=n).buildName,s=t.requestedTasks,c=null==s?null:Wt(s," ",A,r=r!==A&&r)>=0,a=null==c||c,Bf().qd((i=t,e=f,u=s,o=a,function(n){n.ed(function(n){var t;if(Wi(n)>0){var r,i=Zi(n,0);r=function(n){return 97<=n&&n<=122||!(ji(n,128)<0)&&function(n){var t;return t=1===function(n){var t=n,r=ru(eu().h9_1,t),i=eu().h9_1[r],e=(i+eu().i9_1[r]|0)-1|0,u=eu().j9_1[r];if(t>e)return 0;var o=3&u;if(0===o){var f=2,s=i,c=0;if(c<=1)do{if(c=c+1|0,(s=s+(u>>f&127)|0)>t)return 3;if((s=s+(u>>(f=f+7|0)&127)|0)>t)return 0;f=f+7|0}while(c<=1);return 3}if(u<=7)return o;var a=t-i|0;return u>>zn(2,u<=31?a%2|0:a)&3}(n)||function(n){var t=ru(ou().k9_1,n);return t>=0&&n<(ou().k9_1[t]+ou().l9_1[t]|0)}(n),t}(n)}(i)?function(n){return function(n){var t=Pi(n).toUpperCase();if(t.length>1){var r;if(329===n)r=t;else{var i=Zi(t,0),e=t.substring(1).toLowerCase();r=Pi(i)+e}return r}return Pi(function(n){return function(n){var t=n;return 452<=t&&t<=460||497<=t&&t<=499?De(zn(3,(t+1|0)/3|0)):4304<=t&&t<=4346||4349<=t&&t<=4351?n:mi(n)}(n)}(n))}(n)}(i):Pi(i),t=ie(r)+n.substring(1)}else t=n;return t}(i.cacheAction)+" the configuration cache for ");var t=e;null==t||n.fd(t),null==e||n.ed(" build and ");var r=u;return null==(null==r?null:n.fd(r))&&n.ed("default"),n.ed(o?" tasks":" task"),lr()}))),function(n,t){var r=n.cacheActionDescription,i=null==r?null:vf(r),e=Bf().rd(function(n){var t=n.od_1.k(),r=df(t,"build configuration input");return t>0?r+" and will cause the cache to be discarded when "+(t<=1?"its":"their")+" value change":r}(t)),u=Bf().rd(function(n,t){var r=n.totalProblemCount,i=t.nd_1.k(),e=df(r,"problem");return r>i?e+", only the first "+i+" "+wf(i)+" included in this report":e}(n,t));return function(n,t){for(var r=0,i=n.length;r<i;){var e=n[r];r=r+1|0,null!=e&&t.d(e)}return t}([i,e,u],Lr())}(n,h),new bf("Gradle Configuration Cache",n.documentationLink),uf(new Zu(Ho().qc_1),Jn(On(h.nd_1),af)),uf(new Zu($o().qc_1),function(n){return Jn(On(n),hf)}(h.nd_1)),uf(new Zu(Ro().qc_1),Jn(On(h.od_1),sf)),uf(new Zu(Go().qc_1),Jn(On(h.pd_1),cf)),0===l?Ro():Ho())}(n));else{var t=n.problemsReport;zf(Ef("report"),pc(),function(n,t){for(var r=n.summaries,i=Nr(r.length),e=0,u=r.length;e<u;){var o,f=r[e];e=e+1|0;for(var s=f.problemId,c=Nr(s.length),a=0,h=s.length;a<h;){var l,_=s[a];a=a+1|0,l=new Cs(_.name,_.displayName),c.d(l)}o=new xs(c,f.count),i.d(o)}for(var v=i,d=function(n,t){for(var r=oi(),i=0,e=n.length;i<e;){var u=n[i];i=i+1|0;var o,f=Ln(u.problemId,":",A,A,A,A,Ds),s=r.v1(f);if(null==s){var c=Lr();r.h5(f,c),o=c}else o=s;o.d(u)}for(var a=r.o(),h=Nr(xt(a,10)),l=a.f();l.g();){for(var _,v=l.h(),d=v.i1(),g=Nr(xt(d,10)),w=d.f();w.g();){var b;b=Es(w.h(),null,!0),g.d(b)}var p,m=Hn(g),k=Dn(v.i1()),y=Ls(k,new Gu(Ns(Ts(k)).ed(" ("+v.i1().k()+")").j5()));n:{for(var q=t.f();q.g();){var B=q.h();if(zs(B.ff_1,k.problemId)){p=B;break n}}p=null}var C=p;null==C||m.d(js(C.gf_1)),_=new ks(y,m),h.d(_)}var x=h;return new cs(new ks(new Us("message tree root"),x))}(t,v),g=function(n,t){for(var r=function(){var n=Lr();return new Is(new ks(new Vs(Bf().rd("Ungrouped"),!0),n),n,oi())}(),i=oi(),e=0,u=n.length;e<u;){var o=n[e];e=e+1|0;for(var f=$n(Tn(o.problemId,1)),s=Nr(xt(f,10)),c=f.f();c.g();){var a,h=c.h();a=new Cs(h.name,h.displayName),s.d(a)}var l=Ss(i,s),_=Es(o);null==l?r.if_1.d(_):l.if_1.d(_)}for(var v=Nr(xt(t,10)),d=t.f();d.g();){var g,w=d.h();g=new xs($n(Gn(w.ff_1,1)),w.gf_1),v.d(g)}for(var b=oi(),p=v.f();p.g();){var m,k=p.h(),y=k.ff_1,q=b.v1(y);if(null==q){var B=Lr();b.h5(y,B),m=B}else m=q;m.d(k)}for(var C=b.o(),x=Nr(xt(C,10)),j=C.f();j.g();){for(var P,I=j.h(),S=I.j1(),z=0,E=I.i1().f();E.g();)z=z+E.h().gf_1|0;P=new xs(S,z),x.d(P)}for(var T=x.f();T.g();){var L=T.h(),N=Ss(i,L.ff_1),A=null==N?null:N.if_1;null==A||A.d(js(L.gf_1))}for(var M=i.w1(),F=Nr(xt(M,10)),D=M.f();D.g();){var O;O=D.h().hf_1,F.d(O)}var R=function(n,t){var r=Nr(n.k());return r.m(n),r.d(t),r}(F,r.hf_1);return new cs(new ks(new Us("group tree root"),R))}(t,v),w=0,b=v.f();b.g();)w=w+b.h().gf_1|0;var p=function(n,t){for(var r=Lr(),i=oi(),e=0,u=n.length;e<u;){var o=n[e];e=e+1|0;var f=o.locations;if(null==f||0===f.length)r.d(Es(o));else{var s,c=o.locations;if(null==c)s=null;else{for(var a=Lr(),h=Ri(c);h.g();){var l=h.h();null!=l.path&&a.d(l)}s=a}if(null==s);else for(var _=s.f();_.g();){var v=_.h();Ps(i,he(v.path),o,v)}var d,g=o.locations;if(null==g)d=null;else{for(var w=Lr(),b=Ri(g);b.g();){var p=b.h();null!=p.pluginId&&w.d(p)}d=w}if(null==d);else for(var m=d.f();m.g();){var k=m.h();Ps(i,he(k.pluginId),o,k)}var y,q=o.locations;if(null==q)y=null;else{for(var B=Lr(),C=Ri(q);C.g();){var x=C.h();null!=x.taskPath&&B.d(x)}y=B}if(null==y);else for(var j=y.f();j.g();){var P=j.h();Ps(i,he(P.taskPath),o,P)}}}var I=function(n,t,r){for(var i=n.w1(),e=Nr(xt(i,10)),u=i.f();u.g();){var o;o=u.h().t3_1,e.d(o)}var f=Hn(e);return t.i()||f.d(new ks(new Vs(Bf().rd("no location"),!0),t)),r>0&&f.d(js(r)),f}(i,r,t);return new cs(new ks(new Us("text"),I))}(t,w);return new Js(Bf().rd("Problems Report"),function(n,t){var r,i,e,u=n.description,o=null==u?null:gr(vf(u));return r=null==o?gr(Bf().qd((i=t,e=n,function(n){n.ed(i.length+" problems have been reported during the execution");var t=e.buildName;null==t||(n.ed(" of build "),n.fd(t));var r=e.requestedTasks;return null==r||(n.ed(" for the following tasks:"),n.fd(r),lr()),lr()}))):o,r}(n,t),new bf("reporting problems",n.documentationLink),d,g,p,t.length,function(n,t,r){return lo(r)>0?Gs():lo(n)>0?Hs():lo(t)>0?$s():Hs()}(d,g,p))}(t,n.diagnostics))}}(),n}(void 0===this["configuration-cache-report"]?{}:this["configuration-cache-report"])}}[70](),{}))));
//# sourceMappingURL=configuration-cache-report.js.map
                </script>

</body>
</html>
````

## File: android/gradle/wrapper/gradle-wrapper.properties
````
#Sun Jun 29 20:53:08 EDT 2025
distributionBase=GRADLE_USER_HOME
distributionPath=wrapper/dists
distributionUrl=https\://services.gradle.org/distributions/gradle-8.13-bin.zip
zipStoreBase=GRADLE_USER_HOME
zipStorePath=wrapper/dists
````

## File: lib/features/assignments/presentation/screens/teacher/assignments_list_screen.dart
````dart
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'package:go_router/go_router.dart';
import '../../../../../shared/widgets/common/adaptive_layout.dart';
import '../../../../../shared/widgets/common/responsive_layout.dart';
import '../../../domain/models/assignment.dart';
import '../../../../../shared/models/user_model.dart';
import '../../../../../features/auth/presentation/providers/auth_provider.dart';
import '../../providers/assignment_provider.dart';

class TeacherAssignmentsScreen extends StatefulWidget {
  const TeacherAssignmentsScreen({super.key});

  @override
  State<TeacherAssignmentsScreen> createState() => _TeacherAssignmentsScreenState();
}

class _TeacherAssignmentsScreenState extends State<TeacherAssignmentsScreen> {
  String _selectedClass = 'All Classes';
  String _selectedStatus = 'All';
  final _searchController = TextEditingController();

  @override
  void initState() {
    super.initState();
    // Load assignments when screen loads
    WidgetsBinding.instance.addPostFrameCallback((_) {
      final authProvider = context.read<AuthProvider>();
      final assignmentProvider = context.read<AssignmentProvider>();
      final user = authProvider.userModel;
      
      if (user != null && user.role == UserRole.teacher) {
        assignmentProvider.loadAssignmentsForTeacher(user.uid);
      }
    });
  }

  @override
  void dispose() {
    _searchController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return AdaptiveLayout(
      title: 'Assignments',
      floatingActionButton: FloatingActionButton.extended(
        onPressed: () {
          _showCreateAssignmentSheet(context);
        },
        icon: const Icon(Icons.add),
        label: const Text('New Assignment'),
      ),
      body: ResponsiveContainer(
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            // Filters and Search
            Card(
              child: Padding(
                padding: const EdgeInsets.all(16),
                child: Column(
                  children: [
                    // Search Bar
                    TextField(
                      controller: _searchController,
                      decoration: InputDecoration(
                        hintText: 'Search assignments...',
                        prefixIcon: const Icon(Icons.search),
                        suffixIcon: _searchController.text.isNotEmpty
                            ? IconButton(
                                icon: const Icon(Icons.clear),
                                onPressed: () {
                                  setState(() {
                                    _searchController.clear();
                                  });
                                },
                              )
                            : null,
                        border: const OutlineInputBorder(),
                        contentPadding: const EdgeInsets.symmetric(
                          horizontal: 16,
                          vertical: 12,
                        ),
                      ),
                      onChanged: (value) => setState(() {}),
                    ),
                    const SizedBox(height: 16),
                    // Filter Chips
                    Wrap(
                      spacing: 8,
                      runSpacing: 8,
                      children: [
                        // Class Filter
                        ChoiceChip(
                          label: Row(
                            mainAxisSize: MainAxisSize.min,
                            children: [
                              const Icon(Icons.class_, size: 18),
                              const SizedBox(width: 8),
                              Text(_selectedClass),
                            ],
                          ),
                          selected: true,
                          onSelected: (_) {
                            _showClassFilterDialog();
                          },
                        ),
                        // Status Filter
                        ..._buildStatusChips(),
                      ],
                    ),
                  ],
                ),
              ),
            ),
            const SizedBox(height: 16),

            // Assignments List
            Expanded(
              child: _buildAssignmentsList(),
            ),
          ],
        ),
      ),
    );
  }

  List<Widget> _buildStatusChips() {
    final statuses = ['All', 'Active', 'Draft', 'Closed'];
    return statuses.map((status) {
      return FilterChip(
        label: Text(status),
        selected: _selectedStatus == status,
        onSelected: (selected) {
          setState(() {
            _selectedStatus = selected ? status : 'All';
          });
        },
      );
    }).toList();
  }

  Widget _buildAssignmentsList() {
    final authProvider = context.watch<AuthProvider>();
    final assignmentProvider = context.watch<AssignmentProvider>();
    final user = authProvider.userModel;
    
    if (user == null) {
      return const Center(
        child: Text('Please log in to view assignments'),
      );
    }

    if (assignmentProvider.isLoading) {
      return const Center(child: CircularProgressIndicator());
    }

    if (assignmentProvider.error != null) {
      return Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            const Icon(Icons.error_outline, size: 64, color: Colors.red),
            const SizedBox(height: 16),
            Text('Error: ${assignmentProvider.error}'),
            const SizedBox(height: 16),
            ElevatedButton(
              onPressed: () {
                assignmentProvider.clearError();
                assignmentProvider.loadAssignmentsForTeacher(user.uid);
              },
              child: const Text('Retry'),
            ),
          ],
        ),
      );
    }

    final assignments = assignmentProvider.teacherAssignments;
        
        // Filter assignments based on selected filters
        final filteredAssignments = assignments.where((assignment) {
          // Status filter
          if (_selectedStatus != 'All') {
            if (_selectedStatus == 'Active' && assignment.status != AssignmentStatus.active) return false;
            if (_selectedStatus == 'Draft' && (assignment.status != AssignmentStatus.draft || assignment.isPublished)) return false;
            if (_selectedStatus == 'Closed' && assignment.status != AssignmentStatus.completed) return false;
          }
          
          // Search filter
          if (_searchController.text.isNotEmpty) {
            final searchLower = _searchController.text.toLowerCase();
            return assignment.title.toLowerCase().contains(searchLower) ||
                   assignment.description.toLowerCase().contains(searchLower);
          }
          
          return true;
        }).toList();

        if (filteredAssignments.isEmpty) {
          return Center(
            child: Column(
              mainAxisAlignment: MainAxisAlignment.center,
              children: [
                Icon(
                  Icons.assignment_outlined,
                  size: 64,
                  color: Theme.of(context).colorScheme.onSurfaceVariant,
                ),
                const SizedBox(height: 16),
                Text(
                  'No assignments found',
                  style: Theme.of(context).textTheme.bodyLarge,
                ),
                if (_searchController.text.isNotEmpty || _selectedStatus != 'All')
                  TextButton(
                    onPressed: () {
                      setState(() {
                        _searchController.clear();
                        _selectedStatus = 'All';
                      });
                    },
                    child: const Text('Clear filters'),
                  ),
              ],
            ),
          );
        }

    return ListView.builder(
      itemCount: filteredAssignments.length,
      itemBuilder: (context, index) {
        return _buildAssignmentCard(filteredAssignments[index]);
      },
    );
  }

  Widget _buildAssignmentCard(Assignment assignment) {
    final theme = Theme.of(context);
    final dueDate = assignment.dueDate;
    final isOverdue = dueDate.isBefore(DateTime.now()) && assignment.status == AssignmentStatus.active;
    
    Color statusColor;
    IconData statusIcon;
    switch (assignment.status) {
      case AssignmentStatus.active:
        statusColor = Colors.green;
        statusIcon = Icons.play_circle_outline;
        break;
      case AssignmentStatus.draft:
        statusColor = Colors.orange;
        statusIcon = Icons.edit_outlined;
        break;
      case AssignmentStatus.completed:
        statusColor = Colors.grey;
        statusIcon = Icons.check_circle_outline;
        break;
      case AssignmentStatus.archived:
        statusColor = Colors.grey;
        statusIcon = Icons.archive_outlined;
        break;
    }

    if (!assignment.isPublished) {
      if (assignment.publishAt != null) {
        statusColor = Colors.blue;
        statusIcon = Icons.schedule;
      } else {
        statusColor = Colors.orange;
        statusIcon = Icons.visibility_off;
      }
    }

    return Card(
      margin: const EdgeInsets.only(bottom: 12),
      child: InkWell(
        onTap: () => context.go('/teacher/assignments/${assignment.id}'),
        borderRadius: BorderRadius.circular(12),
        child: Padding(
          padding: const EdgeInsets.all(16),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              // Header Row
              Row(
                children: [
                  // Assignment Type Icon
                  Container(
                    padding: const EdgeInsets.all(8),
                    decoration: BoxDecoration(
                      color: theme.colorScheme.primaryContainer,
                      borderRadius: BorderRadius.circular(8),
                    ),
                    child: Icon(
                      _getAssignmentTypeIcon(assignment.type),
                      color: theme.colorScheme.onPrimaryContainer,
                    ),
                  ),
                  const SizedBox(width: 12),
                  // Title and Category
                  Expanded(
                    child: Column(
                      crossAxisAlignment: CrossAxisAlignment.start,
                      children: [
                        Text(
                          assignment.title,
                          style: theme.textTheme.titleMedium?.copyWith(
                            fontWeight: FontWeight.bold,
                          ),
                        ),
                        Text(
                          assignment.category,
                          style: theme.textTheme.bodyMedium?.copyWith(
                            color: theme.colorScheme.onSurfaceVariant,
                          ),
                        ),
                      ],
                    ),
                  ),
                  // Status Badge
                  Container(
                    padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 6),
                    decoration: BoxDecoration(
                      color: statusColor.withValues(alpha: 0.1),
                      borderRadius: BorderRadius.circular(20),
                    ),
                    child: Row(
                      mainAxisSize: MainAxisSize.min,
                      children: [
                        Icon(statusIcon, size: 16, color: statusColor),
                        const SizedBox(width: 4),
                        Text(
                          assignment.isPublished 
                              ? assignment.status.name.toUpperCase()
                              : assignment.publishAt != null
                                  ? 'SCHEDULED'
                                  : 'UNPUBLISHED',
                          style: TextStyle(
                            color: statusColor,
                            fontWeight: FontWeight.w600,
                            fontSize: 12,
                          ),
                        ),
                      ],
                    ),
                  ),
                ],
              ),
              const SizedBox(height: 16),

              // Info Grid
              Row(
                children: [
                  // Due Date
                  Expanded(
                    child: _buildInfoItem(
                      icon: Icons.calendar_today,
                      label: 'Due Date',
                      value: _formatDate(dueDate),
                      color: isOverdue ? Colors.red : null,
                    ),
                  ),
                  // Points
                  Expanded(
                    child: _buildInfoItem(
                      icon: Icons.star_outline,
                      label: 'Points',
                      value: '${assignment.maxPoints.toInt()}',
                    ),
                  ),
                  // Type or Publish Date
                  Expanded(
                    child: assignment.publishAt != null && !assignment.isPublished
                      ? _buildInfoItem(
                          icon: Icons.schedule,
                          label: 'Publishes',
                          value: _formatDate(assignment.publishAt!),
                          color: Colors.blue,
                        )
                      : _buildInfoItem(
                          icon: Icons.assignment_outlined,
                          label: 'Type',
                          value: assignment.type.name.toUpperCase(),
                        ),
                  ),
                ],
              ),

              // Action Buttons
              const SizedBox(height: 12),
              Row(
                mainAxisAlignment: MainAxisAlignment.end,
                children: [
                  if (assignment.status == AssignmentStatus.active)
                    TextButton.icon(
                      onPressed: () {
                        context.go('/teacher/gradebook?assignmentId=${assignment.id}');
                      },
                      icon: const Icon(Icons.grading, size: 18),
                      label: const Text('Grade'),
                    ),
                  if (!assignment.isPublished)
                    TextButton.icon(
                      onPressed: () async {
                        final assignmentProvider = context.read<AssignmentProvider>();
                        await assignmentProvider.togglePublishStatus(assignment.id, true);
                      },
                      icon: const Icon(Icons.publish, size: 18),
                      label: const Text('Publish'),
                    ),
                  TextButton.icon(
                    onPressed: () {
                      context.go('/teacher/assignments/${assignment.id}');
                    },
                    icon: const Icon(Icons.visibility, size: 18),
                    label: const Text('View'),
                  ),
                ],
              ),
            ],
          ),
        ),
      ),
    );
  }

  Widget _buildInfoItem({
    required IconData icon,
    required String label,
    required String value,
    Color? color,
  }) {
    final theme = Theme.of(context);
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Row(
          children: [
            Icon(icon, size: 16, color: color ?? theme.colorScheme.onSurfaceVariant),
            const SizedBox(width: 4),
            Text(
              label,
              style: theme.textTheme.bodySmall?.copyWith(
                color: theme.colorScheme.onSurfaceVariant,
              ),
            ),
          ],
        ),
        const SizedBox(height: 2),
        Text(
          value,
          style: theme.textTheme.bodyMedium?.copyWith(
            fontWeight: FontWeight.w600,
            color: color,
          ),
        ),
      ],
    );
  }

  IconData _getAssignmentTypeIcon(AssignmentType type) {
    switch (type) {
      case AssignmentType.homework:
        return Icons.home_work_outlined;
      case AssignmentType.essay:
        return Icons.article_outlined;
      case AssignmentType.exam:
        return Icons.quiz_outlined;
      case AssignmentType.test:
        return Icons.quiz_outlined;
      case AssignmentType.lab:
        return Icons.science_outlined;
      case AssignmentType.project:
        return Icons.folder_special_outlined;
      case AssignmentType.quiz:
        return Icons.quiz_outlined;
      case AssignmentType.presentation:
        return Icons.present_to_all_outlined;
      case AssignmentType.classwork:
        return Icons.work_outlined;
      case AssignmentType.other:
        return Icons.assignment_outlined;
    }
  }

  String _formatDate(DateTime date) {
    final now = DateTime.now();
    final difference = date.difference(now);

    if (difference.inDays == 0) {
      return 'Today';
    } else if (difference.inDays == 1) {
      return 'Tomorrow';
    } else if (difference.inDays == -1) {
      return 'Yesterday';
    } else if (difference.inDays > 0 && difference.inDays < 7) {
      return 'In ${difference.inDays} days';
    } else if (difference.inDays < 0 && difference.inDays > -7) {
      return '${-difference.inDays} days ago';
    } else {
      return '${date.day}/${date.month}/${date.year}';
    }
  }

  void _showClassFilterDialog() {
    showDialog(
      context: context,
      builder: (context) {
        return AlertDialog(
          title: const Text('Select Class'),
          content: Column(
            mainAxisSize: MainAxisSize.min,
            children: [
              RadioListTile(
                title: const Text('All Classes'),
                value: 'All Classes',
                groupValue: _selectedClass,
                onChanged: (value) {
                  setState(() {
                    _selectedClass = value!;
                  });
                  Navigator.pop(context);
                },
              ),
              RadioListTile(
                title: const Text('Math 101 - Section A'),
                value: 'Math 101 - Section A',
                groupValue: _selectedClass,
                onChanged: (value) {
                  setState(() {
                    _selectedClass = value!;
                  });
                  Navigator.pop(context);
                },
              ),
              RadioListTile(
                title: const Text('Environmental Science'),
                value: 'Environmental Science',
                groupValue: _selectedClass,
                onChanged: (value) {
                  setState(() {
                    _selectedClass = value!;
                  });
                  Navigator.pop(context);
                },
              ),
              RadioListTile(
                title: const Text('Physics Honors'),
                value: 'Physics Honors',
                groupValue: _selectedClass,
                onChanged: (value) {
                  setState(() {
                    _selectedClass = value!;
                  });
                  Navigator.pop(context);
                },
              ),
            ],
          ),
        );
      },
    );
  }

  void _showCreateAssignmentSheet(BuildContext context) {
    context.go('/teacher/assignments/create');
  }
}

// Assignment Detail Sheet
class AssignmentDetailSheet extends StatelessWidget {
  final Map<String, dynamic> assignment;

  const AssignmentDetailSheet({
    super.key,
    required this.assignment,
  });

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);

    return Container(
      decoration: BoxDecoration(
        color: theme.colorScheme.surface,
        borderRadius: const BorderRadius.vertical(top: Radius.circular(20)),
      ),
      child: DraggableScrollableSheet(
        initialChildSize: 0.7,
        minChildSize: 0.5,
        maxChildSize: 0.95,
        expand: false,
        builder: (context, scrollController) {
          return CustomScrollView(
            controller: scrollController,
            slivers: [
              // Handle Bar
              SliverToBoxAdapter(
                child: Center(
                  child: Container(
                    margin: const EdgeInsets.only(top: 12, bottom: 20),
                    width: 40,
                    height: 4,
                    decoration: BoxDecoration(
                      color: theme.colorScheme.onSurfaceVariant.withValues(alpha: 0.3),
                      borderRadius: BorderRadius.circular(2),
                    ),
                  ),
                ),
              ),
              // Content
              SliverPadding(
                padding: const EdgeInsets.symmetric(horizontal: 24),
                sliver: SliverList(
                  delegate: SliverChildListDelegate([
                    // Title
                    Text(
                      assignment['title'],
                      style: theme.textTheme.headlineSmall?.copyWith(
                        fontWeight: FontWeight.bold,
                      ),
                    ),
                    const SizedBox(height: 8),
                    // Class and Subject
                    Row(
                      children: [
                        Icon(
                          Icons.class_,
                          size: 16,
                          color: theme.colorScheme.onSurfaceVariant,
                        ),
                        const SizedBox(width: 4),
                        Text(
                          '${assignment['class']} • ${assignment['subject']}',
                          style: theme.textTheme.bodyLarge?.copyWith(
                            color: theme.colorScheme.onSurfaceVariant,
                          ),
                        ),
                      ],
                    ),
                    const SizedBox(height: 24),

                    // Instructions
                    Text(
                      'Instructions',
                      style: theme.textTheme.titleMedium?.copyWith(
                        fontWeight: FontWeight.bold,
                      ),
                    ),
                    const SizedBox(height: 8),
                    Text(
                      'Complete all problems from Chapter 5, pages 142-145. Show all your work and explain your reasoning for word problems. Submit your work as a PDF file.',
                      style: theme.textTheme.bodyMedium,
                    ),
                    const SizedBox(height: 24),

                    // Assignment Details
                    Text(
                      'Assignment Details',
                      style: theme.textTheme.titleMedium?.copyWith(
                        fontWeight: FontWeight.bold,
                      ),
                    ),
                    const SizedBox(height: 12),
                    _buildDetailRow('Type', assignment['type']),
                    _buildDetailRow('Points', '${assignment['points']}'),
                    _buildDetailRow('Due Date', _formatDetailDate(assignment['dueDate'])),
                    _buildDetailRow('Status', assignment['status']),
                    const SizedBox(height: 24),

                    // Submission Statistics
                    Text(
                      'Submission Statistics',
                      style: theme.textTheme.titleMedium?.copyWith(
                        fontWeight: FontWeight.bold,
                      ),
                    ),
                    const SizedBox(height: 12),
                    _buildStatCard(
                      'Submitted',
                      '${assignment['submissions']}',
                      Colors.green,
                      Icons.check_circle,
                    ),
                    _buildStatCard(
                      'Pending',
                      '${assignment['total'] - assignment['submissions']}',
                      Colors.orange,
                      Icons.pending,
                    ),
                    _buildStatCard(
                      'Total Students',
                      '${assignment['total']}',
                      Colors.blue,
                      Icons.groups,
                    ),

                    const SizedBox(height: 32),
                  ]),
                ),
              ),
            ],
          );
        },
      ),
    );
  }

  Widget _buildDetailRow(String label, String value) {
    return Padding(
      padding: const EdgeInsets.symmetric(vertical: 4),
      child: Row(
        mainAxisAlignment: MainAxisAlignment.spaceBetween,
        children: [
          Text(
            label,
            style: const TextStyle(color: Colors.grey),
          ),
          Text(
            value,
            style: const TextStyle(fontWeight: FontWeight.w600),
          ),
        ],
      ),
    );
  }

  Widget _buildStatCard(String label, String value, Color color, IconData icon) {
    return Card(
      margin: const EdgeInsets.only(bottom: 8),
      child: ListTile(
        leading: CircleAvatar(
          backgroundColor: color.withValues(alpha: 0.1),
          child: Icon(icon, color: color),
        ),
        title: Text(label),
        trailing: Text(
          value,
          style: TextStyle(
            fontSize: 20,
            fontWeight: FontWeight.bold,
            color: color,
          ),
        ),
      ),
    );
  }

  String _formatDetailDate(DateTime date) {
    final months = [
      'January', 'February', 'March', 'April', 'May', 'June',
      'July', 'August', 'September', 'October', 'November', 'December'
    ];
    return '${months[date.month - 1]} ${date.day}, ${date.year}';
  }
}

// Create Assignment Sheet
class CreateAssignmentSheet extends StatefulWidget {
  const CreateAssignmentSheet({super.key});

  @override
  State<CreateAssignmentSheet> createState() => _CreateAssignmentSheetState();
}

class _CreateAssignmentSheetState extends State<CreateAssignmentSheet> {
  final _titleController = TextEditingController();
  final _instructionsController = TextEditingController();
  final _pointsController = TextEditingController();
  String _selectedType = 'Homework';
  String _selectedClass = 'Math 101 - Section A';
  DateTime _dueDate = DateTime.now().add(const Duration(days: 7));

  @override
  void dispose() {
    _titleController.dispose();
    _instructionsController.dispose();
    _pointsController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);

    return Container(
      height: MediaQuery.of(context).size.height * 0.9,
      decoration: BoxDecoration(
        color: theme.colorScheme.surface,
        borderRadius: const BorderRadius.vertical(top: Radius.circular(20)),
      ),
      child: Column(
        children: [
          // Handle Bar
          Center(
            child: Container(
              margin: const EdgeInsets.only(top: 12, bottom: 8),
              width: 40,
              height: 4,
              decoration: BoxDecoration(
                color: theme.colorScheme.onSurfaceVariant.withValues(alpha: 0.3),
                borderRadius: BorderRadius.circular(2),
              ),
            ),
          ),
          // Header
          Padding(
            padding: const EdgeInsets.symmetric(horizontal: 24, vertical: 16),
            child: Row(
              mainAxisAlignment: MainAxisAlignment.spaceBetween,
              children: [
                Text(
                  'Create Assignment',
                  style: theme.textTheme.headlineSmall?.copyWith(
                    fontWeight: FontWeight.bold,
                  ),
                ),
                IconButton(
                  onPressed: () => Navigator.pop(context),
                  icon: const Icon(Icons.close),
                ),
              ],
            ),
          ),
          // Form
          Expanded(
            child: SingleChildScrollView(
              padding: const EdgeInsets.symmetric(horizontal: 24),
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  // Title Field
                  TextField(
                    controller: _titleController,
                    decoration: const InputDecoration(
                      labelText: 'Assignment Title',
                      hintText: 'Enter assignment title',
                      border: OutlineInputBorder(),
                    ),
                  ),
                  const SizedBox(height: 16),

                  // Type Dropdown
                  DropdownButtonFormField<String>(
                    value: _selectedType,
                    decoration: const InputDecoration(
                      labelText: 'Assignment Type',
                      border: OutlineInputBorder(),
                    ),
                    items: [
                      'Homework', 'Essay', 'Exam', 'Lab Report', 'Project', 'Quiz'
                    ].map((type) {
                      return DropdownMenuItem(
                        value: type,
                        child: Text(type),
                      );
                    }).toList(),
                    onChanged: (value) {
                      setState(() {
                        _selectedType = value!;
                      });
                    },
                  ),
                  const SizedBox(height: 16),

                  // Class Dropdown
                  DropdownButtonFormField<String>(
                    value: _selectedClass,
                    decoration: const InputDecoration(
                      labelText: 'Class',
                      border: OutlineInputBorder(),
                    ),
                    items: [
                      'Math 101 - Section A',
                      'Environmental Science',
                      'Physics Honors',
                      'Chemistry 101',
                    ].map((className) {
                      return DropdownMenuItem(
                        value: className,
                        child: Text(className),
                      );
                    }).toList(),
                    onChanged: (value) {
                      setState(() {
                        _selectedClass = value!;
                      });
                    },
                  ),
                  const SizedBox(height: 16),

                  // Points Field
                  TextField(
                    controller: _pointsController,
                    keyboardType: TextInputType.number,
                    decoration: const InputDecoration(
                      labelText: 'Points',
                      hintText: 'Enter total points',
                      border: OutlineInputBorder(),
                      suffixText: 'pts',
                    ),
                  ),
                  const SizedBox(height: 16),

                  // Due Date
                  InkWell(
                    onTap: () async {
                      final picked = await showDatePicker(
                        context: context,
                        initialDate: _dueDate,
                        firstDate: DateTime.now(),
                        lastDate: DateTime.now().add(const Duration(days: 365)),
                      );
                      if (picked != null) {
                        setState(() {
                          _dueDate = picked;
                        });
                      }
                    },
                    child: InputDecorator(
                      decoration: const InputDecoration(
                        labelText: 'Due Date',
                        border: OutlineInputBorder(),
                        suffixIcon: Icon(Icons.calendar_today),
                      ),
                      child: Text(
                        '${_dueDate.day}/${_dueDate.month}/${_dueDate.year}',
                      ),
                    ),
                  ),
                  const SizedBox(height: 16),

                  // Instructions Field
                  TextField(
                    controller: _instructionsController,
                    maxLines: 5,
                    decoration: const InputDecoration(
                      labelText: 'Instructions',
                      hintText: 'Enter assignment instructions',
                      border: OutlineInputBorder(),
                      alignLabelWithHint: true,
                    ),
                  ),
                  const SizedBox(height: 32),
                ],
              ),
            ),
          ),
          // Action Buttons
          Container(
            padding: const EdgeInsets.all(24),
            decoration: BoxDecoration(
              color: theme.colorScheme.surface,
              boxShadow: [
                BoxShadow(
                  color: Colors.black.withValues(alpha: 0.1),
                  blurRadius: 10,
                  offset: const Offset(0, -5),
                ),
              ],
            ),
            child: Row(
              children: [
                Expanded(
                  child: OutlinedButton(
                    onPressed: () => Navigator.pop(context),
                    style: OutlinedButton.styleFrom(
                      padding: const EdgeInsets.symmetric(vertical: 16),
                    ),
                    child: const Text('Cancel'),
                  ),
                ),
                const SizedBox(width: 16),
                Expanded(
                  child: FilledButton(
                    onPressed: () {
                      // Create assignment logic
                      Navigator.pop(context);
                      ScaffoldMessenger.of(context).showSnackBar(
                        const SnackBar(
                          content: Text('Assignment created successfully'),
                        ),
                      );
                    },
                    style: FilledButton.styleFrom(
                      padding: const EdgeInsets.symmetric(vertical: 16),
                    ),
                    child: const Text('Create Assignment'),
                  ),
                ),
              ],
            ),
          ),
        ],
      ),
    );
  }
}
````

## File: lib/features/calendar/data/services/calendar_service.dart
````dart
/// Service layer for calendar business logic.
/// 
/// This module provides high-level calendar operations,
/// coordinating between repositories and handling complex
/// business rules for educational calendar management.
library;

import '../../domain/models/calendar_event.dart';
import '../../domain/repositories/calendar_repository.dart';
import '../../../auth/domain/repositories/user_repository.dart';
import '../../../classes/domain/repositories/class_repository.dart';
import '../../../notifications/data/services/notification_service.dart';
import 'device_calendar_service_factory.dart';

/// Service for managing calendar operations.
/// 
/// Provides business logic for:
/// - Event creation with validation
/// - Automatic event generation from assignments/classes
/// - Conflict detection
/// - Reminder scheduling
/// - Permission management
class CalendarService {
  final CalendarRepository _calendarRepository;
  final UserRepository _userRepository;
  final ClassRepository _classRepository;
  
  /// Creates service with required repositories.
  CalendarService(
    this._calendarRepository,
    this._userRepository,
    this._classRepository,
  );
  
  /// Creates a new calendar event with validation.
  Future<CalendarEvent> createEvent({
    required String title,
    required String createdBy,
    required EventType type,
    required DateTime startTime,
    DateTime? endTime,
    String? description,
    String? location,
    String? classId,
    String? assignmentId,
    List<String>? participantIds,
    bool isAllDay = false,
    RecurrenceType recurrence = RecurrenceType.none,
    DateTime? recurrenceEndDate,
    bool hasReminder = false,
    int? reminderMinutes,
    String? colorHex,
    bool syncToDeviceCalendar = false,
  }) async {
    // Get creator details
    final creator = await _userRepository.getUserById(createdBy);
    if (creator == null) {
      throw Exception('Creator not found');
    }
    
    // Validate class if provided
    if (classId != null) {
      final classExists = await _classRepository.getClass(classId);
      if (classExists == null) {
        throw Exception('Class not found');
      }
    }
    
    // Validate end time
    if (endTime != null && endTime.isBefore(startTime)) {
      throw Exception('End time cannot be before start time');
    }
    
    // Create event
    final event = CalendarEvent(
      id: '', // Will be set by repository
      title: title,
      description: description,
      type: type,
      startTime: startTime,
      endTime: endTime,
      isAllDay: isAllDay,
      location: location,
      createdBy: createdBy,
      createdByName: creator.displayName,
      classId: classId,
      assignmentId: assignmentId,
      participantIds: participantIds,
      colorHex: colorHex,
      recurrence: recurrence,
      recurrenceEndDate: recurrenceEndDate,
      hasReminder: hasReminder,
      reminderMinutes: reminderMinutes,
      createdAt: DateTime.now(),
      updatedAt: DateTime.now(),
    );
    
    final createdEvent = await _calendarRepository.createEvent(event);
    
    // Schedule notification if reminder is enabled
    if (createdEvent.hasReminder) {
      final notificationService = NotificationService();
      await notificationService.scheduleEventReminder(createdEvent);
    }
    
    // Sync to device calendar if requested
    if (syncToDeviceCalendar) {
      final deviceCalendarService = DeviceCalendarServiceFactory.create();
      await deviceCalendarService.addCalendarEvent(event: createdEvent);
    }
    
    return createdEvent;
  }
  
  /// Updates an existing event with permission check.
  Future<CalendarEvent> updateEvent(
    String userId,
    CalendarEvent event,
  ) async {
    // Check permissions
    final canEdit = await _calendarRepository.canEditEvent(userId, event.id);
    if (!canEdit) {
      throw Exception('Insufficient permissions to edit this event');
    }
    
    final updatedEvent = await _calendarRepository.updateEvent(event);
    
    // Update notification if reminder settings changed
    final notificationService = NotificationService();
    // Cancel old notification
    await notificationService.cancelNotification(event.id.hashCode);
    
    // Schedule new one if reminder is enabled
    if (updatedEvent.hasReminder) {
      await notificationService.scheduleEventReminder(updatedEvent);
    }
    
    return updatedEvent;
  }
  
  /// Deletes an event with permission check.
  Future<void> deleteEvent(String userId, String eventId) async {
    // Check permissions
    final canEdit = await _calendarRepository.canEditEvent(userId, eventId);
    if (!canEdit) {
      throw Exception('Insufficient permissions to delete this event');
    }
    
    await _calendarRepository.deleteEvent(eventId);
    
    // Cancel notification if scheduled
    final notificationService = NotificationService();
    await notificationService.cancelNotification(eventId.hashCode);
  }
  
  /// Creates a recurring class event.
  Future<CalendarEvent> createClassSchedule({
    required String classId,
    required String teacherId,
    required String className,
    required DateTime startDate,
    required DateTime classStartTime,
    required DateTime classEndTime,
    required List<int> weekdays, // 1-7 (Monday-Sunday)
    required DateTime semesterEndDate,
    String? location,
  }) async {
    // TODO: Implement custom recurrence details for weekly class schedule
    // final recurrenceDetails = {
    //   'type': 'weekly_class',
    //   'weekdays': weekdays,
    //   'originalStartTime': classStartTime.toIso8601String(),
    //   'originalEndTime': classEndTime.toIso8601String(),
    // };
    
    return await createEvent(
      title: className,
      createdBy: teacherId,
      type: EventType.class_,
      startTime: _combineDateAndTime(startDate, classStartTime),
      endTime: _combineDateAndTime(startDate, classEndTime),
      classId: classId,
      location: location,
      recurrence: RecurrenceType.custom,
      recurrenceEndDate: semesterEndDate,
      hasReminder: true,
      reminderMinutes: 15,
    );
  }
  
  /// Creates an event from an assignment due date.
  Future<CalendarEvent> createAssignmentEvent({
    required String assignmentId,
    required String title,
    required String teacherId,
    required String classId,
    required DateTime dueDate,
    String? description,
  }) async {
    return await createEvent(
      title: 'Due: $title',
      description: description,
      createdBy: teacherId,
      type: EventType.assignment,
      startTime: dueDate,
      isAllDay: true,
      classId: classId,
      assignmentId: assignmentId,
      hasReminder: true,
      reminderMinutes: 1440, // 24 hours
      colorHex: '#F44336', // Red for assignments
    );
  }
  
  /// Checks for event conflicts.
  Future<List<CalendarEvent>> checkConflicts(
    String userId,
    DateTime startTime,
    DateTime endTime,
  ) async {
    final events = await _calendarRepository.getEventsForDate(
      userId,
      startTime,
    );
    
    return events.where((event) {
      if (event.isAllDay) return false;
      
      final eventEnd = event.endTime ?? event.startTime.add(const Duration(hours: 1));
      
      // Check for overlap
      return (startTime.isBefore(eventEnd) && endTime.isAfter(event.startTime));
    }).toList();
  }
  
  /// Gets events grouped by date for agenda view.
  Stream<Map<DateTime, List<CalendarEvent>>> getEventsGroupedByDate(
    String userId,
    DateTime startDate,
    DateTime endDate,
  ) {
    return _calendarRepository
        .getEventsByDateRange(userId, startDate, endDate)
        .map((events) {
      final grouped = <DateTime, List<CalendarEvent>>{};
      
      // Process each day in the range
      for (var date = startDate;
          date.isBefore(endDate.add(const Duration(days: 1)));
          date = date.add(const Duration(days: 1))) {
        final dateOnly = DateTime(date.year, date.month, date.day);
        final dayEvents = events.where((event) => event.occursOn(date)).toList();
        
        if (dayEvents.isNotEmpty) {
          // Sort events by time
          dayEvents.sort((a, b) {
            if (a.isAllDay && !b.isAllDay) return -1;
            if (!a.isAllDay && b.isAllDay) return 1;
            return a.startTime.compareTo(b.startTime);
          });
          
          grouped[dateOnly] = dayEvents;
        }
      }
      
      return grouped;
    });
  }
  
  /// Adds a user to an event.
  Future<void> addParticipantToEvent(
    String eventId,
    String participantId,
  ) async {
    // Verify participant exists
    final participant = await _userRepository.getUserById(participantId);
    if (participant == null) {
      throw Exception('Participant not found');
    }
    
    await _calendarRepository.addParticipant(eventId, participantId);
  }
  
  /// Removes a user from an event.
  Future<void> removeParticipantFromEvent(
    String eventId,
    String participantId,
  ) async {
    await _calendarRepository.removeParticipant(eventId, participantId);
  }
  
  /// Gets suggested event colors based on type.
  String getSuggestedColor(EventType type) {
    switch (type) {
      case EventType.class_:
        return '#2196F3'; // Blue
      case EventType.assignment:
        return '#F44336'; // Red
      case EventType.meeting:
        return '#4CAF50'; // Green
      case EventType.exam:
        return '#FF9800'; // Orange
      case EventType.personal:
        return '#9C27B0'; // Purple
      case EventType.school:
        return '#00BCD4'; // Cyan
      case EventType.other:
        return '#607D8B'; // Blue Grey
    }
  }
  
  /// Helper to combine date and time.
  DateTime _combineDateAndTime(DateTime date, DateTime time) {
    return DateTime(
      date.year,
      date.month,
      date.day,
      time.hour,
      time.minute,
    );
  }
}
````

## File: lib/shared/core/app_initializer.dart
````dart
import 'dart:io';
import 'package:flutter/foundation.dart';
import 'package:flutter/material.dart';
import 'package:firebase_core/firebase_core.dart';
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:firebase_auth/firebase_auth.dart';
import 'package:firebase_storage/firebase_storage.dart';
import 'package:firebase_crashlytics/firebase_crashlytics.dart';
import 'package:flutter_dotenv/flutter_dotenv.dart';
import 'dart:async';
import '../../config/firebase_options.dart';
import '../services/logger_service.dart';
import '../../features/notifications/data/services/notification_service.dart';
import '../../features/notifications/data/services/firebase_messaging_service.dart';
import '../../features/notifications/data/services/voip_token_service.dart';
import '../services/performance_service.dart';
import '../../features/auth/data/services/google_sign_in_service.dart';
import '../../features/auth/data/services/web_auth_helper_interface.dart';
import 'service_locator.dart';

/// Handles all app initialization tasks
class AppInitializer {
  static bool _firebaseInitialized = false;
  
  static bool get isFirebaseInitialized => _firebaseInitialized;
  
  /// Initialize all app dependencies
  static Future<void> initialize() async {
    WidgetsFlutterBinding.ensureInitialized();
    
    // Load environment variables
    await _loadEnvironment();
    
    // Initialize Firebase
    await _initializeFirebase();
    
    // Initialize Google Sign In (early in the startup)
    await _initializeGoogleSignIn();
    
    // Initialize web auth helper for COOP warning fix
    if (kIsWeb) {
      _initializeWebAuthHelper();
    }
    
    // Initialize performance monitoring (after Firebase)
    if (_firebaseInitialized) {
      await _initializePerformanceMonitoring();
    }
    
    // Setup service locator
    await _setupServiceLocator();
    
    // Initialize notification service
    if (_firebaseInitialized) {
      await _initializeNotifications();
    }
    
    // Initialize Firebase Messaging for VoIP
    if (_firebaseInitialized) {
      await _initializeFirebaseMessaging();
    }
    
    // Initialize VoIP token service for iOS
    if (_firebaseInitialized && !kIsWeb && Platform.isIOS) {
      await _initializeVoIPTokenService();
    }
    
    // Setup crash reporting
    if (_firebaseInitialized && !kIsWeb) {
      _setupCrashlytics();
    }
  }
  
  /// Load environment variables
  static Future<void> _loadEnvironment() async {
    try {
      await dotenv.load(fileName: ".env");
    } catch (e) {
      LoggerService.info('Failed to load .env file', tag: 'AppInitializer');
    }
  }
  
  /// Initialize Firebase services
  static Future<void> _initializeFirebase() async {
    try {
      // On Linux desktop, Firebase is not supported natively
      // For development, we can either:
      // 1. Use Firebase emulators
      // 2. Run as a web app
      // 3. Skip Firebase for local testing
      if (defaultTargetPlatform == TargetPlatform.linux && !kIsWeb) {
        LoggerService.warning(
          'Firebase is not supported on Linux desktop. '
          'Consider running with: flutter run -d web-server',
          tag: 'AppInitializer'
        );
        _firebaseInitialized = false;
        return;
      }
      
      await Firebase.initializeApp(
        options: DefaultFirebaseOptions.currentPlatform,
      );
      _firebaseInitialized = true;
      
      // Skip emulator configuration for now
      // The Android emulator has issues with Google Play Services
      
      // Enable Firestore offline persistence
      if (!kIsWeb) {
        FirebaseFirestore.instance.settings = const Settings(
          persistenceEnabled: true,
          cacheSizeBytes: Settings.CACHE_SIZE_UNLIMITED,
        );
      }
    } catch (e) {
      _firebaseInitialized = false;
      LoggerService.error('Firebase initialization error', tag: 'AppInitializer', error: e);
    }
  }
  
  /// Setup dependency injection
  static Future<void> _setupServiceLocator() async {
    try {
      await setupServiceLocator();
    } catch (e) {
      LoggerService.error('Service locator setup error', tag: 'AppInitializer', error: e);
    }
  }
  
  /// Initialize performance monitoring
  static Future<void> _initializePerformanceMonitoring() async {
    try {
      // Initialize performance monitoring asynchronously to avoid blocking main thread
      unawaited(PerformanceService().initialize());
      LoggerService.debug('Performance monitoring initialized (async)', tag: 'AppInitializer');
    } catch (e) {
      LoggerService.error('Performance monitoring initialization error', tag: 'AppInitializer', error: e);
    }
  }
  
  /// Initialize notification service
  static Future<void> _initializeNotifications() async {
    try {
      final notificationService = NotificationService();
      await notificationService.initialize();
      await notificationService.requestPermissions();
      LoggerService.info('Notification service initialized', tag: 'AppInitializer');
    } catch (e) {
      LoggerService.error('Notification initialization error', tag: 'AppInitializer', error: e);
    }
  }
  
  /// Initialize Firebase Messaging for VoIP support
  static Future<void> _initializeFirebaseMessaging() async {
    try {
      final messagingService = FirebaseMessagingService();
      await messagingService.initialize();
      LoggerService.info('Firebase Messaging initialized for VoIP', tag: 'AppInitializer');
    } catch (e) {
      LoggerService.error('Firebase Messaging initialization error', tag: 'AppInitializer', error: e);
    }
  }
  
  /// Initialize VoIP token service for iOS
  static Future<void> _initializeVoIPTokenService() async {
    try {
      final voipTokenService = VoIPTokenService();
      await voipTokenService.initialize();
      LoggerService.info('VoIP token service initialized', tag: 'AppInitializer');
    } catch (e) {
      LoggerService.error('VoIP token service initialization error', tag: 'AppInitializer', error: e);
    }
  }
  
  /// Configure Crashlytics error reporting
  static void _setupCrashlytics() {
    // Pass all uncaught "fatal" errors from the framework to Crashlytics
    FlutterError.onError = FirebaseCrashlytics.instance.recordFlutterFatalError;
    
    // Pass all uncaught asynchronous errors to Crashlytics
    PlatformDispatcher.instance.onError = (error, stack) {
      FirebaseCrashlytics.instance.recordError(error, stack, fatal: true);
      return true;
    };
  }
  
  /// Initialize Google Sign In service
  static Future<void> _initializeGoogleSignIn() async {
    try {
      // Initialize with required scopes
      // In google_sign_in 7.x, this is async and calls GoogleSignIn.instance.initialize()
      await GoogleSignInService().initialize();
      LoggerService.info('Google Sign In initialized', tag: 'AppInitializer');
    } catch (e) {
      LoggerService.error('Google Sign In initialization error', tag: 'AppInitializer', error: e);
    }
  }
  
  /// Initialize web auth helper for COOP warning prevention
  static void _initializeWebAuthHelper() {
    try {
      WebAuthHelper().initialize();
      LoggerService.info('Web Auth Helper initialized', tag: 'AppInitializer');
    } catch (e) {
      LoggerService.error('Web Auth Helper initialization error', tag: 'AppInitializer', error: e);
    }
  }
  
  /// Configure Firebase emulators for development
  static Future<void> _configureFirebaseEmulators() async {
    try {
      const String host = '10.0.2.2'; // Android emulator localhost
      
      LoggerService.info('Starting Firebase emulator configuration...', tag: 'AppInitializer');
      
      // Note: There's no way to check if emulators are already configured
      // Calling useAuthEmulator multiple times will throw an error
      
      await FirebaseAuth.instance.useAuthEmulator(host, 9099);
      LoggerService.info('Auth emulator configured at $host:9099', tag: 'AppInitializer');
      
      FirebaseFirestore.instance.useFirestoreEmulator(host, 8080);
      LoggerService.info('Firestore emulator configured at $host:8080', tag: 'AppInitializer');
      
      await FirebaseStorage.instance.useStorageEmulator(host, 9199);
      LoggerService.info('Storage emulator configured at $host:9199', tag: 'AppInitializer');
      
      LoggerService.info('All Firebase emulators configured successfully', tag: 'AppInitializer');
      
    } catch (e) {
      LoggerService.error('Failed to configure Firebase emulators', tag: 'AppInitializer', error: e);
      rethrow; // Ensure we see the error
    }
  }
  
  /// Handle uncaught errors in the app
  static void handleError(Object error, StackTrace stack) {
    LoggerService.error('Uncaught error in app', tag: 'AppInitializer', error: error);
    if (!kIsWeb && _firebaseInitialized) {
      FirebaseCrashlytics.instance.recordError(error, stack);
    }
  }
}
````

## File: lib/shared/core/app_providers.dart
````dart
import 'package:provider/provider.dart';
import 'package:provider/single_child_widget.dart';
import '../../features/auth/presentation/providers/auth_provider.dart';
import '../../features/assignments/presentation/providers/assignment_provider.dart';
import '../../features/assignments/presentation/providers/student_assignment_provider.dart';
import '../providers/theme_provider.dart';
import '../../features/chat/presentation/providers/chat_provider.dart';
import '../../features/discussions/presentation/providers/discussion_provider.dart';
import '../../features/calendar/presentation/providers/calendar_provider.dart';
import '../../features/grades/presentation/providers/grade_analytics_provider.dart';
import '../providers/navigation_provider.dart';
import '../../features/chat/presentation/providers/call_provider.dart';
import '../../features/notifications/presentation/providers/notification_provider.dart';
import '../../features/classes/presentation/providers/class_provider.dart';
import '../../features/games/presentation/providers/jeopardy_provider.dart';

/// Centralized provider configuration
class AppProviders {
  /// Create all app providers
  static List<SingleChildWidget> getProviders() {
    return [
      ChangeNotifierProvider(create: (_) => ThemeProvider()),
      ChangeNotifierProvider(create: (_) => AuthProvider()),
      ChangeNotifierProvider(create: (_) => ClassProvider()),
      ChangeNotifierProvider(create: (_) => AssignmentProvider()),
      ChangeNotifierProvider(create: (_) => StudentAssignmentProvider()),
      ChangeNotifierProvider(create: (_) => ChatProvider()),
      ChangeNotifierProvider(create: (_) => DiscussionProvider()),
      ChangeNotifierProvider(create: (_) => CalendarProvider()),
      ChangeNotifierProvider(create: (_) => GradeAnalyticsProvider()),
      ChangeNotifierProvider(create: (_) => NavigationProvider()),
      ChangeNotifierProvider(create: (_) => CallProvider()),
      ChangeNotifierProvider(create: (_) => NotificationProvider()),
      ChangeNotifierProvider(create: (_) => JeopardyProvider()),
    ];
  }
}
````

## File: storage.rules
````
rules_version = '2';
service firebase.storage {
  match /b/{bucket}/o {
    // Temporary: Allow all authenticated users to read/write
    // TODO: Remove this after testing
    match /{allPaths=**} {
      allow read, write: if request.auth != null;
    }
    
    // User profile images - users can read/write their own
    match /users/{userId}/profile/{allPaths=**} {
      allow read: if true; // Profile images are public
      allow write: if request.auth != null && request.auth.uid == userId;
    }
    
    // Class materials - teachers can upload, students can read
    match /classes/{classId}/materials/{allPaths=**} {
      allow read: if request.auth != null && hasClassAccess(classId);
      allow write: if request.auth != null && isTeacherOfClass(classId);
    }
    
    // Student submissions - students can upload their own, teachers can read
    match /classes/{classId}/submissions/{studentId}/{allPaths=**} {
      allow read: if request.auth != null && 
        (request.auth.uid == studentId || isTeacherOfClass(classId));
      allow write: if request.auth != null && request.auth.uid == studentId;
    }
    
    // Shared files - based on file permissions in Firestore
    match /shared/{fileId}/{allPaths=**} {
      allow read: if request.auth != null && hasFilePermission(fileId, 'read');
      allow write: if request.auth != null && hasFilePermission(fileId, 'write');
    }
    
    // Chat attachments - conversation participants only
    match /conversations/{conversationId}/attachments/{allPaths=**} {
      allow read, write: if request.auth != null && 
        isConversationParticipant(conversationId);
    }
    
    // Chat media (images and videos) - organized by chat room
    match /chat_media/{chatRoomId}/{fileName} {
      allow read: if request.auth != null;
      allow write: if request.auth != null
        && request.resource.size < 100 * 1024 * 1024 // 100MB limit
        && (request.resource.contentType.matches('image/.*') || 
            request.resource.contentType.matches('video/.*'));
    }
    
    // Game assets - teachers can upload, all can read
    match /games/{gameId}/{allPaths=**} {
      allow read: if request.auth != null;
      allow write: if request.auth != null && hasRole('teacher');
    }
    
    // Helper functions
    function hasRole(role) {
      return firestore.get(/databases/(default)/documents/users/$(request.auth.uid)).data.role == role;
    }
    
    function hasClassAccess(classId) {
      let classData = firestore.get(/databases/(default)/documents/classes/$(classId)).data;
      return request.auth.uid == classData.teacherId || 
             request.auth.uid in classData.studentIds;
    }
    
    function isTeacherOfClass(classId) {
      return firestore.get(/databases/(default)/documents/classes/$(classId)).data.teacherId == request.auth.uid;
    }
    
    function hasFilePermission(fileId, permission) {
      let fileData = firestore.get(/databases/(default)/documents/files/$(fileId)).data;
      return request.auth.uid in fileData.permissions[permission];
    }
    
    function isConversationParticipant(conversationId) {
      return request.auth.uid in firestore.get(/databases/(default)/documents/conversations/$(conversationId)).data.participants;
    }
  }
}
````

## File: README.md
````markdown
# Teacher Dashboard Flutter/Firebase

A comprehensive teacher education management platform built with Flutter and Firebase, designed to streamline classroom management, student tracking, and educational workflows.

## 🚀 Project Overview

This is a migration project from SvelteKit + Supabase to Flutter + Firebase, providing a modern, cross-platform solution for educational management.

### Tech Stack Migration
- **FROM**: SvelteKit 5, TypeScript, Supabase, Tailwind CSS, Netlify
- **TO**: Flutter, Dart, Firebase (Firestore, Auth, Storage, Functions), Firebase Hosting

## ⚠️ Current Status (July 2, 2025)

**Development Stage**: Pre-MVP (~40% feature complete)

### 🔴 Platform Limitations
Firebase does not officially support Linux/Windows desktop platforms. The app will run on these platforms but Firebase services (auth, database) will not be available. For development on Linux/Windows, you can:
1. Use Flutter web (`flutter run -d chrome`)
2. Use an Android emulator
3. Mock Firebase services for local development

### ✅ Completed Features
- Authentication system (email/password, Google Sign-In)
- Role-based routing and navigation
- Basic dashboard structure for teachers/students
- Firestore security rules
- Theme system with Material 3 design
- State management with Provider pattern

### 🚧 In Progress
- Assignment creation and management system
- Grade tracking functionality
- Classes management

### ❌ Not Yet Implemented (Placeholder Screens)
- Student management
- Messaging system
- Calendar functionality
- Notifications
- Help & support
- Analytics dashboard
- Offline support

## ✨ Features

### Current Implementation (Phase 1-2)
- ✅ **Authentication System** - Email/password and Google Sign-In
- ✅ **Responsive Design** - Material 3 design system with adaptive layouts
- ✅ **Firebase Integration** - Firestore database, Authentication, Storage
- ✅ **Cross-Platform** - Web, Android, iOS support
- ✅ **Navigation** - Go Router with protected routes
- ✅ **State Management** - Provider pattern for app state

### Planned Features (Phase 3-4)
- 📚 **Gradebook Management** - Grade tracking and analytics
- 👥 **Student Management** - Enrollment, profiles, progress tracking
- 📝 **Assignment System** - Create, distribute, and grade assignments
- 💬 **Messaging** - Teacher-student-parent communication
- 📊 **Analytics Dashboard** - Performance insights and reports
- 🎮 **Educational Games** - Interactive learning activities
- 📱 **Push Notifications** - Assignment reminders and updates
- 📴 **Offline Support** - Work without internet connection

## 🛠️ Setup Instructions

### Prerequisites
- Flutter SDK (>=3.6.0)
- Firebase CLI
- Android Studio / VS Code
- Git

### Installation

1. **Clone the repository**
   ```bash
   git clone https://github.com/Sallvainian/teacher-dashboard-flutter-firebase.git
   cd teacher-dashboard-flutter-firebase
   ```

2. **Install dependencies**
   ```bash
   flutter pub get
   ```

3. **Firebase Setup**
   ```bash
   # Install Firebase CLI
   npm install -g firebase-tools
   firebase login
   
   # Install FlutterFire CLI
   dart pub global activate flutterfire_cli
   
   # Configure Firebase for your project
   flutterfire configure --project=teacher-dashboard-flutterfire
   ```

4. **Run the application**
   ```bash
   # Web
   flutter run -d chrome
   
   # Android (requires device/emulator)
   flutter run -d android
   
   # iOS (requires macOS and device/simulator)
   flutter run -d ios
   ```

## 🔥 Firebase Configuration

The project uses Firebase for:
- **Authentication** - Email/password and Google Sign-In
- **Firestore** - Real-time database for app data
- **Storage** - File uploads and media management
- **Analytics** - User behavior tracking
- **Crashlytics** - Error monitoring

### Security Rules
Firestore security rules are configured for:
- User document access (users can only access their own data)
- Class management (creators can manage their classes)
- Message/conversation access (participants only)
- File storage permissions

## 📱 Platform Support

| Platform | Status | Notes |
|----------|--------|-------|
| **Web** | ✅ Ready | Primary development platform |
| **Android** | ✅ Ready | Requires google-services.json |
| **iOS** | ✅ Ready | Requires GoogleService-Info.plist |
| **macOS** | 🚧 Planned | Future release |
| **Windows** | ❌ Not Supported | Firebase limitations |
| **Linux** | ❌ Not Supported | Firebase limitations |

## 🗂️ Project Structure

```
lib/
├── main.dart                 # App entry point
├── firebase_options.dart     # Firebase configuration
├── models/                   # Data models
│   ├── user_model.dart
│   ├── class_model.dart
│   └── assignment_model.dart
├── services/                 # Business logic
│   ├── auth_service.dart
│   ├── firestore_service.dart
│   └── storage_service.dart
├── providers/                # State management
│   ├── auth_provider.dart
│   └── data_provider.dart
├── screens/                  # UI screens
│   ├── auth/
│   ├── teacher/
│   └── student/
├── widgets/                  # Reusable components
├── theme/                    # App theming
└── utils/                    # Helper functions
```

## 🔐 Authentication

The app supports multiple authentication methods:

### Email/Password
- Create account with email and password
- Sign in with existing credentials
- Password reset functionality

### Google Sign-In
- One-tap Google authentication
- Automatic profile information sync
- Seamless cross-platform experience

## 💾 Database Schema

### Collections Structure
```
users/{userId}
├── email: string
├── displayName: string
├── createdAt: timestamp
└── lastActive: timestamp

classes/{classId}
├── name: string
├── teacherId: string
├── subject: string
├── createdAt: timestamp
├── students/{studentId}
├── assignments/{assignmentId}
└── grades/{gradeId}

conversations/{conversationId}
├── participants: array
├── lastMessage: timestamp
└── messages/{messageId}
```

## 🧪 Testing

### Database Testing
Use the built-in test utilities:

```bash
# Simple database test (no authentication required)
flutter run lib/test_db_simple.dart

# Full authentication test
flutter run lib/test_db_direct.dart

# Setup test data
flutter run lib/setup_test_data.dart
```

### Unit Tests
```bash
flutter test
```

## 🚀 Deployment

### Web Deployment (Firebase Hosting)
```bash
flutter build web
firebase deploy --only hosting
```

### Android Deployment
```bash
flutter build apk --release
# or
flutter build appbundle --release
```

### iOS Deployment
```bash
flutter build ios --release
```

## 🔧 Development Guidelines

### 🚨 Immediate Action Required
1. **Fix Firebase Initialization**: Remove dotenv approach for Firebase configuration
   - Run `flutterfire configure` to regenerate proper `firebase_options.dart`
   - Remove `flutter_dotenv` dependency and usage
   - Use platform-specific configuration files (google-services.json, GoogleService-Info.plist)

2. **Code Quality**: Fix 38 linting issues
   - Remove all `print` statements from production code
   - Fix unused variables and methods
   - Run `flutter analyze` and address all warnings

### Code Style
- Follow Dart conventions and linting rules
- Use meaningful variable and function names
- Implement proper error handling
- Add comments for complex logic

### Firebase Best Practices
- Use offline persistence for better UX
- Implement proper security rules
- Optimize queries with indexes
- Handle authentication states properly

### State Management
- Use Provider for global state
- Keep state as local as possible
- Implement proper loading states
- Handle errors gracefully

### Testing Strategy
- Write unit tests for all services and providers
- Add widget tests for UI components
- Implement integration tests for critical user flows
- Aim for >80% code coverage

## 📋 Migration Progress

### ✅ Completed Phases
- **Phase 1.1**: Flutter project initialization
- **Phase 1.2**: Firebase project setup
- **Phase 1.3**: Authentication system
- **Phase 1.4**: Navigation and routing
- **Phase 1.5**: Theme and UI foundation
- **Phase 2.1**: Database schema design
- **Phase 2.2**: Security rules implementation

### 🚧 Current Phase
- **Phase 2.3**: Real-time data synchronization
- **Phase 3.1**: Gradebook implementation

### 📅 Upcoming Phases
- **Phase 3.2**: Student management system
- **Phase 3.3**: Assignment creation and distribution
- **Phase 4.1**: Messaging system
- **Phase 4.2**: Analytics and reporting

## 🤝 Contributing

1. Fork the repository
2. Create a feature branch (`git checkout -b feature/amazing-feature`)
3. Commit your changes (`git commit -m 'Add amazing feature'`)
4. Push to the branch (`git push origin feature/amazing-feature`)
5. Open a Pull Request

## 📄 License

This project is licensed under the MIT License - see the [LICENSE](LICENSE) file for details.

## 🆘 Support

### Common Issues

**Firebase Configuration Issues**
- Ensure all platform apps are added to Firebase Console
- Verify google-services.json and GoogleService-Info.plist are in correct locations
- Check that bundle IDs match between Flutter and Firebase

**Authentication Problems**
- Enable Authentication providers in Firebase Console
- For Google Sign-In on Android, add SHA-1 fingerprints
- Verify domain authorization for web

**Database Permission Errors**
- Check Firestore security rules
- Ensure user is properly authenticated
- Verify document paths and permissions

### Getting Help
- 📧 Create an issue on GitHub
- 📖 Check the [Firebase Documentation](https://firebase.google.com/docs)
- 📱 Review [Flutter Documentation](https://flutter.dev/docs)

## 📈 Project Stats

- **Languages**: Dart, JavaScript (Firebase Functions)
- **Platforms**: Web, Android, iOS
- **Database**: Cloud Firestore
- **Authentication**: Firebase Auth
- **Storage**: Firebase Storage
- **Hosting**: Firebase Hosting

---

**Built with ❤️ using Flutter and Firebase**

*This project represents a modern approach to educational technology, focusing on user experience, scalability, and cross-platform compatibility.*
````

## File: web/index.html
````html
<!DOCTYPE html>
<html>
<head>
  <!--
    If you are serving your web app in a path other than the root, change the
    href value below to reflect the base path you are serving from.

    The path provided below has to start and end with a slash "/" in order for
    it to work correctly.

    For more details:
    * https://developer.mozilla.org/en-US/docs/Web/HTML/Element/base

    This is a placeholder for base href that will be replaced by the value of
    the `--base-href` argument provided to `flutter build`.
  -->
  <base href="$FLUTTER_BASE_HREF">

  <meta charset="UTF-8">
  <meta content="IE=Edge" http-equiv="X-UA-Compatible">
  <meta name="description" content="A new Flutter project.">

  <!-- iOS meta tags & icons -->
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <meta name="apple-mobile-web-app-title" content="teacher_dashboard_flutter_firebase">
  <link rel="apple-touch-icon" href="icons/Icon-192.png">

  <!-- Favicon -->
  <link rel="icon" type="image/png" href="favicon.png"/>

  <!-- Google Sign-In Client ID -->
  <meta name="google-signin-client_id" content="218352465432-g9u6sl8orf9f7iiv955241h7r5kb0qh5.apps.googleusercontent.com">

  <title>teacher_dashboard_flutter_firebase</title>
  <link rel="manifest" href="manifest.json">

  <!-- This script adds the flutter initialization JS code -->
</head>
<body>
  <script>
    {{flutter_bootstrap_js}}
  </script>
</body>
</html>
````

## File: firestore.indexes.json
````json
{
  "indexes": [
    {
      "collectionGroup": "grades",
      "queryScope": "COLLECTION_GROUP",
      "fields": [
        {
          "fieldPath": "studentId",
          "order": "ASCENDING"
        },
        {
          "fieldPath": "classId",
          "order": "ASCENDING"
        },
        {
          "fieldPath": "assignmentId",
          "order": "ASCENDING"
        }
      ]
    },
    {
      "collectionGroup": "grades",
      "queryScope": "COLLECTION_GROUP",
      "fields": [
        {
          "fieldPath": "classId",
          "order": "ASCENDING"
        },
        {
          "fieldPath": "gradedAt",
          "order": "ASCENDING"
        }
      ]
    },
    {
      "collectionGroup": "messages",
      "queryScope": "COLLECTION_GROUP",
      "fields": [
        {
          "fieldPath": "conversationId",
          "order": "ASCENDING"
        },
        {
          "fieldPath": "timestamp",
          "order": "DESCENDING"
        }
      ]
    },
    {
      "collectionGroup": "messages",
      "queryScope": "COLLECTION_GROUP",
      "fields": [
        {
          "fieldPath": "senderId",
          "order": "ASCENDING"
        },
        {
          "fieldPath": "timestamp",
          "order": "DESCENDING"
        }
      ]
    },
    {
      "collectionGroup": "assignments",
      "queryScope": "COLLECTION_GROUP",
      "fields": [
        {
          "fieldPath": "classId",
          "order": "ASCENDING"
        },
        {
          "fieldPath": "dueDate",
          "order": "ASCENDING"
        }
      ]
    },
    {
      "collectionGroup": "assignments",
      "queryScope": "COLLECTION_GROUP",
      "fields": [
        {
          "fieldPath": "teacherId",
          "order": "ASCENDING"
        },
        {
          "fieldPath": "createdAt",
          "order": "DESCENDING"
        }
      ]
    },
    {
      "collectionGroup": "files",
      "queryScope": "COLLECTION_GROUP",
      "fields": [
        {
          "fieldPath": "ownerId",
          "order": "ASCENDING"
        },
        {
          "fieldPath": "parentFolder",
          "order": "ASCENDING"
        },
        {
          "fieldPath": "createdAt",
          "order": "DESCENDING"
        }
      ]
    },
    {
      "collectionGroup": "students",
      "queryScope": "COLLECTION_GROUP",
      "fields": [
        {
          "fieldPath": "classIds",
          "arrayConfig": "CONTAINS"
        },
        {
          "fieldPath": "name",
          "order": "ASCENDING"
        }
      ]
    },
    {
      "collectionGroup": "games",
      "queryScope": "COLLECTION_GROUP",
      "fields": [
        {
          "fieldPath": "teacherId",
          "order": "ASCENDING"
        },
        {
          "fieldPath": "isPublic",
          "order": "ASCENDING"
        },
        {
          "fieldPath": "createdAt",
          "order": "DESCENDING"
        }
      ]
    },
    {
      "collectionGroup": "notifications",
      "queryScope": "COLLECTION_GROUP",
      "fields": [
        {
          "fieldPath": "userId",
          "order": "ASCENDING"
        },
        {
          "fieldPath": "createdAt",
          "order": "DESCENDING"
        }
      ]
    },
    {
      "collectionGroup": "notifications",
      "queryScope": "COLLECTION_GROUP",
      "fields": [
        {
          "fieldPath": "userId",
          "order": "ASCENDING"
        },
        {
          "fieldPath": "isRead",
          "order": "ASCENDING"
        },
        {
          "fieldPath": "createdAt",
          "order": "DESCENDING"
        }
      ]
    },
    {
      "collectionGroup": "chat_rooms",
      "queryScope": "COLLECTION",
      "fields": [
        {
          "fieldPath": "participantIds",
          "arrayConfig": "CONTAINS"
        },
        {
          "fieldPath": "lastMessageTime",
          "order": "DESCENDING"
        }
      ]
    },
    {
      "collectionGroup": "chat_rooms",
      "queryScope": "COLLECTION",
      "fields": [
        {
          "fieldPath": "participantIds",
          "arrayConfig": "CONTAINS"
        },
        {
          "fieldPath": "updatedAt",
          "order": "DESCENDING"
        }
      ]
    },
    {
      "collectionGroup": "discussion_boards",
      "queryScope": "COLLECTION",
      "fields": [
        {
          "fieldPath": "isPinned",
          "order": "DESCENDING"
        },
        {
          "fieldPath": "updatedAt",
          "order": "DESCENDING"
        }
      ]
    },
    {
      "collectionGroup": "threads",
      "queryScope": "COLLECTION_GROUP",
      "fields": [
        {
          "fieldPath": "isPinned",
          "order": "DESCENDING"
        },
        {
          "fieldPath": "updatedAt",
          "order": "DESCENDING"
        }
      ]
    },
    {
      "collectionGroup": "calendar_events",
      "queryScope": "COLLECTION",
      "fields": [
        {
          "fieldPath": "createdBy",
          "order": "ASCENDING"
        },
        {
          "fieldPath": "isActive",
          "order": "ASCENDING"
        },
        {
          "fieldPath": "startTime",
          "order": "ASCENDING"
        }
      ]
    },
    {
      "collectionGroup": "calendar_events",
      "queryScope": "COLLECTION",
      "fields": [
        {
          "fieldPath": "participantIds",
          "arrayConfig": "CONTAINS"
        },
        {
          "fieldPath": "isActive",
          "order": "ASCENDING"
        },
        {
          "fieldPath": "startTime",
          "order": "ASCENDING"
        }
      ]
    },
    {
      "collectionGroup": "students",
      "queryScope": "COLLECTION",
      "fields": [
        {
          "fieldPath": "isActive",
          "order": "ASCENDING"
        },
        {
          "fieldPath": "displayName",
          "order": "ASCENDING"
        }
      ]
    },
    {
      "collectionGroup": "students",
      "queryScope": "COLLECTION",
      "fields": [
        {
          "fieldPath": "gradeLevel",
          "order": "ASCENDING"
        },
        {
          "fieldPath": "displayName",
          "order": "ASCENDING"
        }
      ]
    },
    {
      "collectionGroup": "classes",
      "queryScope": "COLLECTION",
      "fields": [
        {
          "fieldPath": "enrollmentCode",
          "order": "ASCENDING"
        },
        {
          "fieldPath": "isActive",
          "order": "ASCENDING"
        }
      ]
    },
    {
      "collectionGroup": "classes",
      "queryScope": "COLLECTION",
      "fields": [
        {
          "fieldPath": "teacherId",
          "order": "ASCENDING"
        },
        {
          "fieldPath": "isActive",
          "order": "ASCENDING"
        },
        {
          "fieldPath": "createdAt",
          "order": "DESCENDING"
        }
      ]
    },
    {
      "collectionGroup": "classes",
      "queryScope": "COLLECTION",
      "fields": [
        {
          "fieldPath": "studentIds",
          "arrayConfig": "CONTAINS"
        },
        {
          "fieldPath": "isActive",
          "order": "ASCENDING"
        },
        {
          "fieldPath": "name",
          "order": "ASCENDING"
        }
      ]
    },
    {
      "collectionGroup": "classes",
      "queryScope": "COLLECTION",
      "fields": [
        {
          "fieldPath": "teacherId",
          "order": "ASCENDING"
        },
        {
          "fieldPath": "isActive",
          "order": "ASCENDING"
        }
      ]
    },
    {
      "collectionGroup": "classes",
      "queryScope": "COLLECTION",
      "fields": [
        {
          "fieldPath": "studentIds",
          "arrayConfig": "CONTAINS"
        },
        {
          "fieldPath": "name",
          "order": "ASCENDING"
        }
      ]
    }
  ],
  "fieldOverrides": []
}
````

## File: macos/Flutter/GeneratedPluginRegistrant.swift
````swift
//
//  Generated file. Do not edit.
//

import FlutterMacOS
import Foundation

import cloud_firestore
import file_picker
import file_selector_macos
import firebase_auth
import firebase_core
import firebase_crashlytics
import firebase_database
import firebase_messaging
import firebase_storage
import flutter_local_notifications
import flutter_webrtc
import google_sign_in_ios
import path_provider_foundation
import shared_preferences_foundation
import sqflite_darwin
import video_compress
import video_player_avfoundation

func RegisterGeneratedPlugins(registry: FlutterPluginRegistry) {
  FLTFirebaseFirestorePlugin.register(with: registry.registrar(forPlugin: "FLTFirebaseFirestorePlugin"))
  FilePickerPlugin.register(with: registry.registrar(forPlugin: "FilePickerPlugin"))
  FileSelectorPlugin.register(with: registry.registrar(forPlugin: "FileSelectorPlugin"))
  FLTFirebaseAuthPlugin.register(with: registry.registrar(forPlugin: "FLTFirebaseAuthPlugin"))
  FLTFirebaseCorePlugin.register(with: registry.registrar(forPlugin: "FLTFirebaseCorePlugin"))
  FLTFirebaseCrashlyticsPlugin.register(with: registry.registrar(forPlugin: "FLTFirebaseCrashlyticsPlugin"))
  FLTFirebaseDatabasePlugin.register(with: registry.registrar(forPlugin: "FLTFirebaseDatabasePlugin"))
  FLTFirebaseMessagingPlugin.register(with: registry.registrar(forPlugin: "FLTFirebaseMessagingPlugin"))
  FLTFirebaseStoragePlugin.register(with: registry.registrar(forPlugin: "FLTFirebaseStoragePlugin"))
  FlutterLocalNotificationsPlugin.register(with: registry.registrar(forPlugin: "FlutterLocalNotificationsPlugin"))
  FlutterWebRTCPlugin.register(with: registry.registrar(forPlugin: "FlutterWebRTCPlugin"))
  FLTGoogleSignInPlugin.register(with: registry.registrar(forPlugin: "FLTGoogleSignInPlugin"))
  PathProviderPlugin.register(with: registry.registrar(forPlugin: "PathProviderPlugin"))
  SharedPreferencesPlugin.register(with: registry.registrar(forPlugin: "SharedPreferencesPlugin"))
  SqflitePlugin.register(with: registry.registrar(forPlugin: "SqflitePlugin"))
  VideoCompressPlugin.register(with: registry.registrar(forPlugin: "VideoCompressPlugin"))
  FVPVideoPlayerPlugin.register(with: registry.registrar(forPlugin: "FVPVideoPlayerPlugin"))
}
````

## File: firestore.rules
````
rules_version = '2';
// DEVELOPMENT VERSION - More permissive rules for emulator testing
// TODO: Revert to production rules before deployment
service cloud.firestore {
  match /databases/{database}/documents {
    // Helper function to check if user is THE teacher (you)
    function isTheTeacher() {
      return request.auth != null && 
        get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role == 'teacher';
    }
    
    // Helper function to check if user is a student
    function isStudent() {
      return request.auth != null && 
        get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role == 'student';
    }
    // Users collection
    match /users/{userId} {
      // Any authenticated user can read user profiles (for chat user selection)
      allow read: if request.auth != null;
      // Users can only write their own document
      allow write: if request.auth != null && request.auth.uid == userId;
    }
    
    // Pending users - temporary data during signup
    match /pending_users/{userId} {
      allow read, write: if request.auth != null && request.auth.uid == userId;
    }
    
    // Classes - students can read their classes, only teacher can write
    match /classes/{classId} {
      // Students can read classes they're enrolled in, teacher can read all
      // Also allow students to read any class when searching by enrollment code
      allow read: if request.auth != null && 
        (isTheTeacher() || 
         (isStudent() && request.auth.uid in resource.data.studentIds) ||
         isStudent());
      
      // Only THE teacher can create classes
      allow create: if isTheTeacher();
      
      // Allow updates if teacher OR if student is enrolling (adding their ID to studentIds)
      allow update: if isTheTeacher() || 
        (isStudent() && 
         request.auth.uid in request.resource.data.studentIds &&
         request.resource.data.studentIds.hasAll(resource.data.studentIds));
         
      // Only THE teacher can delete classes
      allow delete: if isTheTeacher();
      
      // Nested collections in classes
      match /{document=**} {
        allow read: if request.auth != null && 
          (isTheTeacher() || 
           (isStudent() && request.auth.uid in get(/databases/$(database)/documents/classes/$(classId)).data.studentIds));
        allow write: if isTheTeacher();
      }
    }
    
    // Messages and conversations
    match /conversations/{conversationId} {
      allow read: if request.auth != null 
        && request.auth.uid in resource.data.participants;
      allow create: if request.auth != null 
        && request.auth.uid in request.resource.data.participants;
      allow update: if request.auth != null 
        && request.auth.uid in resource.data.participants;
      
      match /messages/{messageId} {
        allow read: if request.auth != null 
          && request.auth.uid in get(/databases/$(database)/documents/conversations/$(conversationId)).data.participants;
        allow create: if request.auth != null 
          && request.auth.uid == request.resource.data.senderId;
      }
    }
    
    // Chat rooms (new chat implementation)
    match /chat_rooms/{chatRoomId} {
      allow read: if request.auth != null 
        && request.auth.uid in resource.data.participantIds;
      allow create: if request.auth != null 
        && request.auth.uid in request.resource.data.participantIds;
      allow update: if request.auth != null 
        && request.auth.uid in resource.data.participantIds;
      allow delete: if false; // Don't allow deletion, only leaving
      
      match /messages/{messageId} {
        allow read: if request.auth != null 
          && request.auth.uid in get(/databases/$(database)/documents/chat_rooms/$(chatRoomId)).data.participantIds;
        allow create: if request.auth != null 
          && request.auth.uid == request.resource.data.senderId;
        allow update: if request.auth != null 
          && request.auth.uid == resource.data.senderId
          && request.resource.data.senderId == resource.data.senderId; // Can't change sender
        allow delete: if request.auth != null 
          && request.auth.uid == resource.data.senderId;
      }
    }
    
    // Assignments - students can read their class assignments, only teacher can write
    match /assignments/{assignmentId} {
      // Students can read assignments for classes they're enrolled in
      allow read: if request.auth != null && 
        (isTheTeacher() || 
         (isStudent() && request.auth.uid in get(/databases/$(database)/documents/classes/$(resource.data.classId)).data.studentIds));
      
      // Only THE teacher can create, update, or delete assignments
      allow create: if isTheTeacher();
      allow update, delete: if isTheTeacher();
    }
    
    // Grades - students can read their own, only THE teacher can write
    match /grades/{gradeId} {
      // Students can only read their own grades, teacher can read all
      allow read: if request.auth != null && 
        (isTheTeacher() || 
         (isStudent() && request.auth.uid == resource.data.studentId));
      
      // Only THE teacher can create, update, or delete grades
      allow create, update, delete: if isTheTeacher();
    }
    
    // Collection group queries for grades (needed for analytics)
    match /{path=**}/grades/{gradeId} {
      allow read: if request.auth != null && isTheTeacher();
    }
    
    // Submissions - students can read/write their own, teacher can read all
    match /submissions/{submissionId} {
      // Students can read their own submissions, teacher can read all
      allow read: if request.auth != null && 
        (isTheTeacher() || 
         (isStudent() && request.auth.uid == resource.data.studentId));
      
      // Students can create their own submissions
      allow create: if isStudent() && 
        request.auth.uid == request.resource.data.studentId;
      
      // Students can update their own submissions only if not yet submitted
      allow update: if isStudent() && 
        request.auth.uid == resource.data.studentId && 
        resource.data.submittedAt == null;
        
      // Only teacher can delete submissions
      allow delete: if isTheTeacher();
    }
    
    // Announcements - students can read, only teacher can write
    match /announcements/{announcementId} {
      allow read: if request.auth != null;
      allow create, update, delete: if isTheTeacher();
    }
    
    // Games - any authenticated user can read and create, only creator can update/delete
    match /games/{gameId} {
      allow read: if request.auth != null;
      allow create: if request.auth != null;
      allow update, delete: if request.auth != null 
        && resource.data.creatorId == request.auth.uid;
      
      // Scores - users can only create/update their own scores
      match /scores/{scoreId} {
        allow read: if request.auth != null;
        allow create: if request.auth != null 
          && request.auth.uid == request.resource.data.studentId;
        allow update: if request.auth != null 
          && request.auth.uid == resource.data.studentId;
      }
    }
    
    // Chat rooms - users can only access rooms they're participants in
    match /chat_rooms/{roomId} {
      allow read: if request.auth != null 
        && request.auth.uid in resource.data.participantIds;
      allow create: if request.auth != null 
        && request.auth.uid in request.resource.data.participantIds;
      allow update: if request.auth != null 
        && request.auth.uid in resource.data.participantIds;
      allow delete: if false; // Don't allow deletion of chat rooms
      
      // Messages within chat rooms
      match /messages/{messageId} {
        allow read: if request.auth != null 
          && request.auth.uid in get(/databases/$(database)/documents/chat_rooms/$(roomId)).data.participantIds;
        allow create: if request.auth != null 
          && request.auth.uid in get(/databases/$(database)/documents/chat_rooms/$(roomId)).data.participantIds
          && request.auth.uid == request.resource.data.senderId;
        allow update: if false; // Messages should not be edited
        allow delete: if request.auth != null 
          && request.auth.uid == resource.data.senderId;
      }
    }
    
    // Scheduled messages - users can only manage their own scheduled messages
    match /scheduled_messages/{messageId} {
      allow read: if request.auth != null 
        && request.auth.uid == resource.data.message.senderId;
      allow create: if request.auth != null 
        && request.auth.uid == request.resource.data.message.senderId;
      allow delete: if request.auth != null 
        && request.auth.uid == resource.data.message.senderId;
      allow update: if request.auth != null 
        && request.auth.uid == resource.data.message.senderId
        && request.auth.uid == request.resource.data.message.senderId; // Can't change sender
    }
    
    // Discussion boards - teacher creates boards, all users can read
    match /discussion_boards/{boardId} {
      allow read: if request.auth != null;
      allow create: if isTheTeacher();
      allow update: if request.auth != null 
        && resource.data.createdBy == request.auth.uid;
      allow delete: if false; // Don't allow deletion
      
      // Discussion threads
      match /threads/{threadId} {
        allow read: if request.auth != null;
        allow create: if request.auth != null;
        allow update: if request.auth != null 
          && resource.data.authorId == request.auth.uid;
        allow delete: if request.auth != null 
          && resource.data.authorId == request.auth.uid;
        
        // Thread replies
        match /replies/{replyId} {
          allow read: if request.auth != null;
          allow create: if request.auth != null;
          allow update: if request.auth != null 
            && resource.data.authorId == request.auth.uid;
          allow delete: if request.auth != null 
            && resource.data.authorId == request.auth.uid;
        }
      }
    }
    
    // Calendar events - users can create/manage their own events, view if participants
    match /calendar_events/{eventId} {
      allow read: if request.auth != null 
        && (resource.data.createdBy == request.auth.uid 
          || request.auth.uid in resource.data.participantIds);
      allow create: if request.auth != null 
        && request.auth.uid == request.resource.data.createdBy;
      allow update: if request.auth != null 
        && resource.data.createdBy == request.auth.uid;
      allow delete: if request.auth != null 
        && resource.data.createdBy == request.auth.uid;
    }
    
    // Students collection - for student-specific data
    match /students/{studentId} {
      // Students can read their own data (by userId field), teacher can read all
      allow read: if request.auth != null && 
        (isTheTeacher() || 
         (isStudent() && (request.auth.uid == studentId || 
          request.auth.uid == resource.data.userId)));
      
      // Students can update their own profile data
      allow update: if isStudent() && 
        (request.auth.uid == studentId || request.auth.uid == resource.data.userId);
      
      // Only teacher can create or delete student records
      allow create, delete: if isTheTeacher();
    }
    
    // Teachers collection - for teacher-specific data
    match /teachers/{teacherId} {
      // Only the teacher can read/write their own data
      allow read, write: if isTheTeacher() && request.auth.uid == teacherId;
    }
    
    // Calls collection - for video/voice calls
    match /calls/{callId} {
      // DEVELOPMENT: Allow any authenticated user to query calls (for WebRTC service cleanup)
      // This includes querying for calls with status == 'ringing'
      allow read: if request.auth != null;
      
      // Only authenticated users can create calls where they are the caller
      allow create: if request.auth != null &&
        request.auth.uid == request.resource.data.callerId;
      
      // Allow participants to update call status, including cleanup operations
      // This includes updating status, endedAt, duration, and endReason fields
      allow update: if request.auth != null && 
        (request.auth.uid == resource.data.callerId || 
         request.auth.uid == resource.data.receiverId) &&
        // Allow cleanup operations for stale calls
        (request.resource.data.status in ['ended', 'rejected', 'missed'] || 
         resource.data.status == 'ringing');
      
      // ICE candidates subcollection
      match /candidates/{userId}/candidates/{candidateId} {
        allow read, write: if request.auth != null && 
          (request.auth.uid == get(/databases/$(database)/documents/calls/$(callId)).data.callerId || 
           request.auth.uid == get(/databases/$(database)/documents/calls/$(callId)).data.receiverId);
      }
    }
    
    // Notifications collection
    match /notifications/{notificationId} {
      // Users can only read their own notifications
      allow read: if request.auth != null && 
        request.auth.uid == resource.data.userId;
      
      // System or teacher can create notifications
      allow create: if request.auth != null && 
        (isTheTeacher() || 
         request.auth.uid == request.resource.data.userId);
      
      // Users can update their own notifications (mark as read)
      allow update: if request.auth != null && 
        request.auth.uid == resource.data.userId;
      
      // Users can delete their own notifications
      allow delete: if request.auth != null && 
        request.auth.uid == resource.data.userId;
    }
    
    // FCM tokens - users can manage their own tokens
    match /fcm_tokens/{userId} {
      allow read, write: if request.auth != null && request.auth.uid == userId;
    }
    
    // Bug reports collection
    match /bug_reports/{reportId} {
      // Only teachers can read bug reports (for admin purposes)
      allow read: if isTheTeacher();
      
      // Any authenticated user can create a bug report
      allow create: if request.auth != null && 
        request.auth.uid == request.resource.data.userId;
      
      // Users cannot update or delete bug reports once submitted
      allow update, delete: if false;
    }
  }
}
````

## File: lib/shared/core/service_locator.dart
````dart
/// Service locator configuration for dependency injection.
/// 
/// This module sets up the application's dependency injection container
/// using the GetIt package. It provides a centralized location for
/// registering and resolving dependencies throughout the application.
/// 
/// The service locator pattern helps:
/// - Decouple classes from their dependencies
/// - Enable easy testing with mock implementations
/// - Provide a single source of truth for object creation
/// - Manage object lifecycles (singleton vs factory)
library;

import 'package:get_it/get_it.dart';
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:firebase_auth/firebase_auth.dart';
import 'package:firebase_storage/firebase_storage.dart';
import 'package:firebase_crashlytics/firebase_crashlytics.dart';
import '../../features/auth/data/services/auth_service.dart';
import '../../features/assignments/data/services/assignment_service.dart';
import '../../features/chat/data/services/chat_service.dart';
import '../../features/assignments/data/services/submission_service.dart';
import '../services/logger_service.dart';
import '../../features/auth/domain/repositories/auth_repository.dart';
import '../../features/auth/data/repositories/auth_repository_impl.dart';
import '../../features/assignments/domain/repositories/assignment_repository.dart';
import '../../features/assignments/data/repositories/assignment_repository_impl.dart';
import '../../features/classes/domain/repositories/class_repository.dart';
import '../../features/classes/data/repositories/class_repository_impl.dart';
import '../../features/grades/domain/repositories/grade_repository.dart';
import '../../features/grades/data/repositories/grade_repository_impl.dart';
import '../../features/student/domain/repositories/student_repository.dart';
import '../../features/student/data/repositories/student_repository_impl.dart';
import '../../features/assignments/domain/repositories/submission_repository.dart';
import '../../features/assignments/data/repositories/submission_repository_impl.dart';
import '../../features/chat/domain/repositories/chat_repository.dart';
import '../../features/chat/data/repositories/chat_repository_impl.dart';
import '../../features/discussions/domain/repositories/discussion_repository.dart';
import '../../features/discussions/data/repositories/discussion_repository_impl.dart';
import '../../features/calendar/domain/repositories/calendar_repository.dart';
import '../../features/calendar/data/repositories/calendar_repository_impl.dart';
import '../../features/auth/domain/repositories/user_repository.dart';
import '../../features/auth/data/repositories/user_repository_impl.dart';
import '../../features/calendar/data/services/calendar_service.dart';
import '../../features/games/domain/repositories/jeopardy_repository.dart';
import '../../features/games/data/repositories/firebase_jeopardy_repository.dart';

/// Global instance of the GetIt service locator.
/// This provides access to registered dependencies throughout the app.
final GetIt getIt = GetIt.instance;

/// Initializes and registers all application dependencies.
/// 
/// This function must be called during app initialization (in main.dart)
/// after Firebase has been initialized. It sets up:
/// 
/// 1. **Firebase Services** (as singletons):
///    - FirebaseAuth for authentication
///    - FirebaseFirestore for database operations
///    - FirebaseStorage for file storage
///    - FirebaseCrashlytics for error reporting
/// 
/// 2. **Core Services** (as singletons):
///    - AuthService for authentication logic
///    - LoggerService for centralized logging
/// 
/// 3. **Repository Layer** (as singletons):
///    - All repository implementations that abstract data access
/// 
/// 4. **Business Logic Services** (as factories):
///    - Services that contain business logic and use repositories
/// 
/// Registration types:
/// - `registerLazySingleton`: Creates instance only when first requested, then reuses
/// - `registerFactory`: Creates new instance each time it's requested
/// 
/// @throws Exception if Firebase is not initialized before calling this
Future<void> setupServiceLocator() async {
  // Setting up service locator...
  
  // Register Firebase instances
  getIt.registerLazySingleton<FirebaseAuth>(() => FirebaseAuth.instance);
  getIt.registerLazySingleton<FirebaseFirestore>(() => FirebaseFirestore.instance);
  getIt.registerLazySingleton<FirebaseStorage>(() => FirebaseStorage.instance);
  getIt.registerLazySingleton<FirebaseCrashlytics>(() => FirebaseCrashlytics.instance);

  // Register services
  getIt.registerLazySingleton<AuthService>(() => AuthService());
  getIt.registerLazySingleton<LoggerService>(() => LoggerService());
  
  // Register repositories
  getIt.registerLazySingleton<AuthRepository>(
    () => AuthRepositoryImpl(getIt<AuthService>()),
  );
  
  getIt.registerLazySingleton<AssignmentRepository>(
    () => AssignmentRepositoryImpl(getIt<FirebaseFirestore>()),
  );
  
  getIt.registerLazySingleton<ClassRepository>(
    () => ClassRepositoryImpl(getIt<FirebaseFirestore>()),
  );
  
  getIt.registerLazySingleton<GradeRepository>(
    () => GradeRepositoryImpl(getIt<FirebaseFirestore>()),
  );
  
  getIt.registerLazySingleton<StudentRepository>(
    () => StudentRepositoryImpl(getIt<FirebaseFirestore>()),
  );
  
  getIt.registerLazySingleton<SubmissionRepository>(
    () => SubmissionRepositoryImpl(getIt<FirebaseFirestore>()),
  );
  
  getIt.registerLazySingleton<ChatRepository>(
    () => ChatRepositoryImpl(getIt<FirebaseFirestore>(), getIt<FirebaseAuth>()),
  );
  
  getIt.registerLazySingleton<DiscussionRepository>(
    () => DiscussionRepositoryImpl(getIt<FirebaseFirestore>(), getIt<FirebaseAuth>()),
  );
  
  getIt.registerLazySingleton<CalendarRepository>(
    () => CalendarRepositoryImpl(getIt<FirebaseFirestore>()),
  );
  
  getIt.registerLazySingleton<UserRepository>(
    () => UserRepositoryImpl(getIt<FirebaseFirestore>()),
  );
  
  getIt.registerLazySingleton<JeopardyRepository>(
    () => FirebaseJeopardyRepository(firestore: getIt<FirebaseFirestore>()),
  );
  
  // Register services with dependencies
  getIt.registerFactory<AssignmentService>(
    () => AssignmentService(firestore: getIt<FirebaseFirestore>()),
  );
  
  getIt.registerFactory<ChatService>(() => ChatService());  
  getIt.registerFactory<SubmissionService>(
    () => SubmissionService(firestore: getIt<FirebaseFirestore>()),
  );
  
  getIt.registerFactory<CalendarService>(
    () => CalendarService(
      getIt<CalendarRepository>(),
      getIt<UserRepository>(),
      getIt<ClassRepository>(),
    ),
  );
  
  // CalendarService registered
  
  // Note: Providers will be refactored to use these services via dependency injection
  // rather than creating service instances directly
  // Service locator setup complete
}

/// Convenience extension for accessing registered services.
/// 
/// This extension provides type-safe getters for all registered services,
/// making it easier to retrieve dependencies without having to specify
/// the type parameter each time.
/// 
/// Usage example:
/// ```dart
/// final auth = getIt.auth; // Instead of getIt.get<FirebaseAuth>()
/// final userRepo = getIt.authRepository; // Instead of getIt.get<AuthRepository>()
/// ```
/// 
/// Benefits:
/// - Cleaner, more readable code
/// - Compile-time type safety
/// - IntelliSense support for available services
/// - Single point of maintenance for service names
extension ServiceLocatorExtension on GetIt {
  FirebaseAuth get auth => get<FirebaseAuth>();
  FirebaseFirestore get firestore => get<FirebaseFirestore>();
  FirebaseStorage get storage => get<FirebaseStorage>();
  FirebaseCrashlytics get crashlytics => get<FirebaseCrashlytics>();
  
  AuthService get authService => get<AuthService>();
  AuthRepository get authRepository => get<AuthRepository>();
  AssignmentRepository get assignmentRepository => get<AssignmentRepository>();
  ClassRepository get classRepository => get<ClassRepository>();
  GradeRepository get gradeRepository => get<GradeRepository>();
  StudentRepository get studentRepository => get<StudentRepository>();
  SubmissionRepository get submissionRepository => get<SubmissionRepository>();
  ChatRepository get chatRepository => get<ChatRepository>();
  DiscussionRepository get discussionRepository => get<DiscussionRepository>();
  CalendarRepository get calendarRepository => get<CalendarRepository>();
  UserRepository get userRepository => get<UserRepository>();
  AssignmentService get assignmentService => get<AssignmentService>();
  ChatService get chatService => get<ChatService>();
  SubmissionService get submissionService => get<SubmissionService>();
  CalendarService get calendarService => get<CalendarService>();
  LoggerService get loggerService => get<LoggerService>();
  JeopardyRepository get jeopardyRepository => get<JeopardyRepository>();
}
````

## File: lib/shared/routing/app_router.dart
````dart
import 'package:flutter/material.dart';
import 'package:go_router/go_router.dart';
import 'package:provider/provider.dart';
import '../models/user_model.dart';
import '../../features/chat/domain/models/call.dart';
import '../../features/auth/presentation/providers/auth_provider.dart';
import '../../features/auth/presentation/screens/login_screen.dart';
import '../../features/auth/presentation/screens/signup_screen.dart';
import '../../features/auth/presentation/screens/role_selection_screen.dart';
import '../../features/auth/presentation/screens/forgot_password_screen.dart';
import '../../features/teacher/presentation/screens/teacher_dashboard_screen.dart';
import '../../features/classes/presentation/screens/teacher/classes_screen.dart';
import '../../features/grades/presentation/screens/teacher/gradebook_screen.dart';
import '../../features/grades/presentation/screens/teacher/grade_analytics_screen.dart';
import '../../features/assignments/presentation/screens/teacher/assignments_list_screen.dart' as teacher_assignments;
import '../../features/assignments/presentation/screens/teacher/assignment_create_screen.dart';
import '../../features/assignments/presentation/screens/teacher/assignment_detail_screen.dart';
import '../../features/assignments/presentation/screens/teacher/assignment_edit_screen.dart';
import '../../features/student/presentation/screens/teacher/students_screen.dart';
import '../../features/student/presentation/screens/student_dashboard_screen.dart';
import '../../features/classes/presentation/screens/student/courses_screen.dart';
import '../../features/grades/presentation/screens/student/grades_screen.dart';
import '../../features/assignments/presentation/screens/student/assignments_list_screen.dart' as student_assignments;
import '../../features/assignments/presentation/screens/student/assignment_submission_screen.dart';
import '../../features/classes/presentation/screens/student/enrollment_screen.dart';
import '../../features/notifications/presentation/screens/student_notifications_screen.dart' as student_notifications;
import '../screens/settings_screen.dart';
import '../screens/debug/debug/update_display_name_screen.dart';
import '../../features/chat/presentation/screens/chat_list_screen.dart';
import '../../features/chat/presentation/screens/chat_detail_screen.dart';
import '../../features/chat/presentation/screens/user_selection_screen.dart';
import '../../features/chat/presentation/screens/group_creation_screen.dart';
import '../../features/chat/presentation/screens/class_selection_screen.dart';
import '../../features/chat/presentation/screens/call_screen.dart';
import '../../features/chat/presentation/screens/incoming_call_screen.dart';
import '../../features/discussions/presentation/screens/discussion_boards_screen.dart';
import '../../features/discussions/presentation/screens/discussion_board_detail_screen.dart';
import '../../features/calendar/presentation/screens/calendar_screen.dart';
import '../../features/notifications/presentation/screens/notifications_screen.dart';
import '../screens/common/common/dashboard_screen.dart';
import '../screens/contact_support_screen.dart';
import '../../features/games/presentation/screens/jeopardy_screen.dart';
import '../../features/games/presentation/screens/jeopardy_play_screen.dart';
import '../../features/games/presentation/screens/jeopardy_create_screen.dart';

/// App router configuration
class AppRouter {
  static GoRouter createRouter(AuthProvider authProvider) {
    return GoRouter(
      initialLocation: '/auth/login',
      refreshListenable: authProvider,
      redirect: (context, state) => _handleRedirect(authProvider, state),
      routes: [
        ..._authRoutes(),
        ..._teacherRoutes(),
        ..._studentRoutes(),
        ..._commonRoutes(),
        _rootRedirect(),
      ],
    );
  }
  
  /// Handle authentication redirects
  static String? _handleRedirect(AuthProvider authProvider, GoRouterState state) {
    final isAuthenticated = authProvider.isAuthenticated;
    final isAuthRoute = state.matchedLocation.startsWith('/auth');
    
    // If not authenticated and trying to access protected route
    if (!isAuthenticated && !isAuthRoute) {
      return '/auth/login';
    }
    
    // If authenticated and trying to access auth routes
    if (isAuthenticated && isAuthRoute) {
      return '/dashboard';
    }
    
    // If authenticated but needs role selection (Google sign-in)
    if (authProvider.status == AuthStatus.authenticating &&
        state.matchedLocation != '/auth/role-selection') {
      return '/auth/role-selection';
    }
    
    return null;
  }
  
  /// Authentication routes
  static List<GoRoute> _authRoutes() => [
    GoRoute(
      path: '/auth/login',
      builder: (context, state) => const LoginScreen(),
    ),
    GoRoute(
      path: '/auth/signup',
      builder: (context, state) => const SignupScreen(),
    ),
    GoRoute(
      path: '/auth/role-selection',
      builder: (context, state) => const RoleSelectionScreen(),
    ),
    GoRoute(
      path: '/auth/forgot-password',
      builder: (context, state) => const ForgotPasswordScreen(),
    ),
  ];
  
  /// Teacher-specific routes
  static List<GoRoute> _teacherRoutes() => [
    GoRoute(
      path: '/teacher/classes',
      builder: (context, state) => const ClassesScreen(),
    ),
    GoRoute(
      path: '/teacher/gradebook',
      builder: (context, state) => const GradebookScreen(),
    ),
    GoRoute(
      path: '/teacher/analytics',
      builder: (context, state) {
        final classId = state.uri.queryParameters['classId'];
        return GradeAnalyticsScreen(classId: classId);
      },
    ),
    GoRoute(
      path: '/teacher/assignments',
      builder: (context, state) => const teacher_assignments.TeacherAssignmentsScreen(),
      routes: [
        GoRoute(
          path: 'create',
          builder: (context, state) => const AssignmentCreateScreen(),
        ),
        GoRoute(
          path: ':assignmentId',
          builder: (context, state) {
            final assignmentId = state.pathParameters['assignmentId']!;
            return AssignmentDetailScreen(assignmentId: assignmentId);
          },
          routes: [
            GoRoute(
              path: 'edit',
              builder: (context, state) {
                final assignmentId = state.pathParameters['assignmentId']!;
                return AssignmentEditScreen(assignmentId: assignmentId);
              },
            ),
          ],
        ),
      ],
    ),
    GoRoute(
      path: '/teacher/students',
      builder: (context, state) => const TeacherStudentsScreen(),
    ),
    GoRoute(
      path: '/teacher/games/jeopardy',
      builder: (context, state) => const JeopardyScreen(),
      routes: [
        GoRoute(
          path: 'create',
          builder: (context, state) => const JeopardyCreateScreen(),
        ),
        GoRoute(
          path: ':gameId/edit',
          builder: (context, state) {
            final gameId = state.pathParameters['gameId']!;
            return JeopardyCreateScreen(gameId: gameId);
          },
        ),
        GoRoute(
          path: ':gameId/play',
          builder: (context, state) {
            final gameId = state.pathParameters['gameId']!;
            return JeopardyPlayScreen(gameId: gameId);
          },
        ),
      ],
    ),
  ];
  
  /// Student-specific routes
  static List<GoRoute> _studentRoutes() => [
    GoRoute(
      path: '/student/courses',
      builder: (context, state) => const StudentCoursesScreen(),
    ),
    GoRoute(
      path: '/student/assignments',
      builder: (context, state) => const student_assignments.StudentAssignmentsScreen(),
      routes: [
        GoRoute(
          path: ':assignmentId/submit',
          builder: (context, state) {
            final assignmentId = state.pathParameters['assignmentId']!;
            return AssignmentSubmissionScreen(assignmentId: assignmentId);
          },
        ),
      ],
    ),
    GoRoute(
      path: '/student/grades',
      builder: (context, state) => const StudentGradesScreen(),
    ),
    GoRoute(
      path: '/student/enroll',
      builder: (context, state) => const EnrollmentScreen(),
    ),
    GoRoute(
      path: '/student/notifications',
      builder: (context, state) => const student_notifications.StudentNotificationsScreen(),
    ),
  ];
  
  /// Common routes available to all users
  static List<GoRoute> _commonRoutes() => [
    GoRoute(
      path: '/dashboard',
      builder: (context, state) => _buildDashboard(context),
    ),
    GoRoute(
      path: '/messages',
      builder: (context, state) => const ChatListScreen(),
      routes: [
        GoRoute(
          path: ':chatRoomId',
          builder: (context, state) {
            final chatRoomId = state.pathParameters['chatRoomId']!;
            return ChatDetailScreen(chatRoomId: chatRoomId);
          },
        ),
      ],
    ),
    GoRoute(
      path: '/discussions',
      builder: (context, state) => const DiscussionBoardsScreen(),
    ),
    GoRoute(
      path: '/discussions/:boardId',
      builder: (context, state) {
        final boardId = state.pathParameters['boardId']!;
        final boardTitle = state.uri.queryParameters['title'] ?? 'Discussion Board';
        return DiscussionBoardDetailScreen(
          boardId: boardId,
          boardTitle: boardTitle,
        );
      },
    ),
    GoRoute(
      path: '/chat/user-selection',
      builder: (context, state) => const UserSelectionScreen(),
    ),
    GoRoute(
      path: '/chat/group-creation',
      builder: (context, state) => const GroupCreationScreen(),
    ),
    GoRoute(
      path: '/chat/class-selection',
      builder: (context, state) => const ClassSelectionScreen(),
    ),
    GoRoute(
      path: '/chat/:chatRoomId',
      builder: (context, state) {
        final chatRoomId = state.pathParameters['chatRoomId']!;
        return ChatDetailScreen(chatRoomId: chatRoomId);
      },
    ),
    GoRoute(
      path: '/call',
      builder: (context, state) {
        final extra = state.extra as Map<String, dynamic>;
        return CallScreen(
          callId: extra['callId'],
          receiverId: extra['receiverId'],
          receiverName: extra['receiverName'],
          receiverPhotoUrl: extra['receiverPhotoUrl'],
          isVideoCall: extra['isVideoCall'] ?? false,
          chatRoomId: extra['chatRoomId'],
        );
      },
    ),
    GoRoute(
      path: '/incoming-call',
      builder: (context, state) {
        final call = state.extra as Call;
        return IncomingCallScreen(call: call);
      },
    ),
    GoRoute(
      path: '/calendar',
      builder: (context, state) => const CalendarScreen(),
    ),
    GoRoute(
      path: '/notifications',
      builder: (context, state) => const NotificationsScreen(),
    ),
    GoRoute(
      path: '/settings',
      builder: (context, state) => const SettingsScreen(),
    ),
    GoRoute(
      path: '/contact-support',
      builder: (context, state) => const ContactSupportScreen(),
    ),
    GoRoute(
      path: '/debug/update-name',
      builder: (context, state) => const UpdateDisplayNameScreen(),
    ),
  ];
  
  /// Root redirect
  static GoRoute _rootRedirect() => GoRoute(
    path: '/',
    redirect: (_, __) => '/auth/login',
  );
  
  /// Build appropriate dashboard based on user role
  static Widget _buildDashboard(BuildContext context) {
    final authProvider = Provider.of<AuthProvider>(context, listen: false);
    final user = authProvider.userModel;
    
    if (user?.role == UserRole.teacher) {
      return const TeacherDashboardScreen();
    } else if (user?.role == UserRole.student) {
      return const StudentDashboardScreen();
    } else {
      return const DashboardScreen(); // Admin or fallback
    }
  }
}
````

## File: .gitignore
````
# Flutter/Dart specific
.dart_tool/
.pub/
.pub-cache/
.flutter-plugins
.flutter-plugins-dependencies
**/build/  # Consolidated all build ignores

# General build artifacts
app.*.symbols
app.*.map.json
*.hprof

# IDE/Editor specific (trim if you don't use these)
.idea/
.vscode/
*.iml
*.ipr
*.iws
.DS_Store
.atom/
.history
.svn/
.sonarlint/

# Platform-specific ephemerals/generated (consolidated)
**/flutter/ephemeral
**/Pods/
**/.symlinks/
**/Flutter/App.framework
**/Flutter/Flutter.framework
**/Flutter/Generated.xcconfig
**/Flutter/flutter_export_environment.sh
**/Flutter/.last_build_id
**/Runner.xcworkspace/xcshareddata/
**/Runner.xcodeproj/xcshareddata/
**/Runner.xcodeproj/project.xcworkspace/
*.mode1v3
*.mode2v3
*.moved-aside
*.pbxuser
*.perspectivev3
*.xcscmblueprint
*.xccheckout
*.xcscheme
xcuserdata/  # Made global

# Android specific
/android/app/debug.keystore
/android/local.properties
/android/.gradle/
*.jks
android/init.gradle
android/gradle.properties

# iOS specific
/ios/Runner/GoogleService-Info.plist

# General artifacts
*.class
*.log
*.pyc
*.swp
*.lock
*.snapshot
*~
.buildlog/
migrate_working_dir/
*.tmp
*.temp
*.bak
*.backup
.~*

# Sensitive/Environment files (critical for public repo—keep these!)
.env*
*.env
secrets.json
google-services.json
GoogleService-Info.plist
.firebaserc
**/firebase.json  # Added for Firebase CLI configs
firebase-debug.log
firestore-debug.log
ui-debug.log
emulator-debug.log
firebase-export-*

# Test/Coverage
coverage/
*.lcov

# Personal/project-specific (keep for your workflow; safe in personal repo)
PROJECT_TODOS.md
CLAUDE.md
launch_app.sh
.mcp.json
.claude/
.cursor/
.gemini/
devtools_options.yaml

# Windows-specific (keep if on Windows)
nul
*/nul
web/nul
````

## File: lib/main.dart
````dart
/// Main entry point for the Teacher Dashboard Flutter application.
/// 
/// This application provides a comprehensive education management platform
/// for teachers and students, built with Flutter and Firebase.
library;

import 'dart:async';
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'shared/core/app_initializer.dart';
import 'features/auth/presentation/providers/auth_provider.dart';
import 'shared/providers/theme_provider.dart';
import 'shared/core/app_providers.dart';
import 'shared/routing/app_router.dart';
import 'shared/theme/app_theme.dart';
import 'shared/theme/app_typography.dart';
import 'shared/widgets/splash_screen.dart';

/// Public getter for Firebase initialization status.
bool get isFirebaseInitialized => AppInitializer.isFirebaseInitialized;

/// Application entry point - shows splash screen immediately
Future<void> main() async {
  await runZonedGuarded<Future<void>>(
    () async {
      WidgetsFlutterBinding.ensureInitialized();
      runApp(const InitializationWrapper());
    },
    AppInitializer.handleError,
  );
}

/// Root widget of the Teacher Dashboard application - simplified and modular
class TeacherDashboardApp extends StatelessWidget {
  const TeacherDashboardApp({super.key});

  @override
  Widget build(BuildContext context) {
    return MultiProvider(
      providers: AppProviders.getProviders(),
      child: Builder(
        builder: (context) {
          final authProvider = context.watch<AuthProvider>();
          final themeProvider = context.watch<ThemeProvider>();

          return MaterialApp.router(
            title: 'Teacher Dashboard',
            theme: AppTheme.lightTheme().copyWith(
              textTheme: AppTypography.createTextTheme(
                AppTheme.lightTheme().colorScheme,
              ),
            ),
            darkTheme: AppTheme.darkTheme().copyWith(
              textTheme: AppTypography.createTextTheme(
                AppTheme.darkTheme().colorScheme,
              ),
            ),
            themeMode: themeProvider.themeMode,
            debugShowCheckedModeBanner: false,
            routerConfig: AppRouter.createRouter(authProvider),
          );
        },
      ),
    );
  }
}

/// Wrapper widget that handles async initialization with splash screen
class InitializationWrapper extends StatefulWidget {
  const InitializationWrapper({super.key});

  @override
  State<InitializationWrapper> createState() => _InitializationWrapperState();
}

class _InitializationWrapperState extends State<InitializationWrapper> {
  bool _isInitialized = false;
  String _currentStatus = 'Starting app...';
  double? _progress;

  @override
  void initState() {
    super.initState();
    _initializeApp();
  }

  Future<void> _initializeApp() async {
    try {
      // Show initial status
      setState(() {
        _currentStatus = 'Loading environment...';
        _progress = 0.1;
      });

      // Initialize services with progress updates
      await Future.delayed(const Duration(milliseconds: 100)); // Allow UI to update

      setState(() {
        _currentStatus = 'Initializing Firebase...';
        _progress = 0.3;
      });

      // Perform actual initialization
      await AppInitializer.initialize();

      setState(() {
        _currentStatus = 'Setting up providers...';
        _progress = 0.8;
      });

      // Small delay to show final progress
      await Future.delayed(const Duration(milliseconds: 300));

      // Mark as initialized
      setState(() {
        _isInitialized = true;
        _progress = 1.0;
      });
    } catch (e) {
      // Show error state
      setState(() {
        _currentStatus = 'Initialization failed. Please restart the app.';
        _progress = null;
      });
    }
  }

  @override
  Widget build(BuildContext context) {
    if (_isInitialized) {
      return const TeacherDashboardApp();
    }

    return SplashScreen(
      message: _currentStatus,
      progress: _progress,
    );
  }
}
````

## File: pubspec.yaml
````yaml
name: teacher_dashboard_flutter
description: "A new Flutter project."
# The following line prevents the package from being accidentally published to
# pub.dev using `flutter pub publish`. This is preferred for private packages.
publish_to: 'none' # Remove this line if you wish to publish to pub.dev

# The following defines the version and build number for your application.
# A version number is three numbers separated by dots, like 1.2.43
# followed by an optional build number separated by a +.
# Both the version and the builder number may be overridden in flutter
# build by specifying --build-name and --build-number, respectively.
# In Android, build-name is used as versionName while build-number used as versionCode.
# Read more about Android versioning at https://developer.android.com/studio/publish/versioning
# In iOS, build-name is used as CFBundleShortVersionString while build-number is used as CFBundleVersion.
# Read more about iOS versioning at
# https://developer.apple.com/library/archive/documentation/General/Reference/InfoPlistKeyReference/Articles/CoreFoundationKeys.html
# In Windows, build-name is used as the major, minor, and patch parts
# of the product and file versions while build-number is used as the build suffix.
version: 1.0.0+1

environment:
  sdk: ^3.6.0

# Dependencies specify other packages that your package needs in order to work.
# To automatically upgrade your package dependencies to the latest versions
# consider running `flutter pub upgrade --major-versions`. Alternatively,
# dependencies can be manually updated by changing the version numbers below to
# the latest version available on pub.dev. To see which dependencies have newer
# versions available, run `flutter pub outdated`.
dependencies:
  flutter:
    sdk: flutter

  # Firebase Core - Required for all Firebase services
  firebase_core: ^3.15.1 
  
  # Firebase Services
  firebase_auth: ^5.6.2
  cloud_firestore: ^5.6.11
  firebase_storage: ^12.4.9
  firebase_crashlytics: ^4.3.9
  firebase_database: ^11.3.9
  firebase_messaging: ^15.2.9
  
  # Authentication
  google_sign_in: ^7.1.1
  google_sign_in_web: ^1.0.0
  google_identity_services_web: ^0.3.1+1 
  
  # Web support
  web: 1.1.1
  
  # State Management
  provider: ^6.1.2
  
  # Charts and Data Visualization
  fl_chart: ^1.0.0
  
  # UI & Navigation
  go_router: ^16.0.0
  
  # Utilities
  intl: ^0.20.0
  image_picker: ^1.1.2
  shared_preferences: ^2.5.3
  flutter_dotenv: ^5.2.1
  get_it: ^8.0.2
  
  # File handling
  file_picker: ^10.2.0
  
  # Image caching for performance
  cached_network_image: ^3.3.1
  
  # Video support
  video_player: ^2.8.2
  video_compress: ^3.1.4
  
  # WebRTC for video/voice calling
  flutter_webrtc: ^0.14.2
  permission_handler: ^12.0.1
  
  # Notifications - Re-enabled with desktop support
  flutter_local_notifications: ^18.0.0
  timezone: ^0.9.4
  
  # Call UI for mobile platforms (iOS CallKit, Android ConnectionService)
  flutter_callkit_incoming: ^2.0.3
  
  # Calendar sync
  device_calendar: ^4.3.2
  
  # The following adds the Cupertino Icons font to your application.
  # Use with the CupertinoIcons class for iOS style icons.
  rxdart: ^0.28.0

# Dependency overrides to resolve version conflicts
# dependency_overrides:
#   timezone: ^0.10.0

dev_dependencies:
  flutter_test:
    sdk: flutter
  flutter_lints: ^6.0.0

  # The "flutter_lints" package below contains a set of recommended lints to
  # encourage good coding practices. The lint set provided by the package is
  # activated in the `analysis_options.yaml` file located at the root of your
  # package. See that file for information about deactivating specific lint
  # rules and activating additional ones.

# For information on the generic Dart part of this file, see the
# following page: https://dart.dev/tools/pub/pubspec

# The following section is specific to Flutter packages.
flutter:

  # The following line ensures that the Material Icons font is
  # included with your application, so that you can use the icons in
  # the material Icons class.
  uses-material-design: true

  # To add assets to your application, add an assets section, like this:
  assets:
    - assets/images/
    - .env

  # An image asset can refer to one or more resolution-specific "variants", see
  # https://flutter.dev/to/resolution-aware-images

  # For details regarding adding assets from package dependencies, see
  # https://flutter.dev/to/asset-from-package

  # To add custom fonts to your application, add a fonts section here,
  # in this "flutter" section. Each entry in this list should have a
  # "family" key with the font family name, and a "fonts" key with a
  # list giving the asset and other descriptors for the font. For
  # example:
  # fonts:
  #   - family: Schyler
  #     fonts:
  #       - asset: fonts/Schyler-Regular.ttf
  #       - asset: fonts/Schyler-Italic.ttf
  #         style: italic
  #   - family: Trajan Pro
  #     fonts:
  #       - asset: fonts/TrajanPro.ttf
  #       - asset: fonts/TrajanPro_Bold.ttf
  #         weight: 700
  #
  # For details regarding fonts from package dependencies,
  # see https://flutter.dev/to/font-from-package
````
